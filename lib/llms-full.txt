
# Getting Started
Your First Steps {.subtitle}

Welcome to CAP, and to *capire*, its one-stop documentation.

[**CAP** [ˈkap(m)] — (unofficial) abbreviation for the *"SAP Cloud Application Programming Model"*](https://translate.google.com/details?sl=en&text=cap){.learn-more .dict}

[**capire** [ca·pì·re] — Italian for _"understand"_](https://translate.google.com/details?sl=it&tl=en&text=capire){.learn-more .dict}






## Initial Setup {#setup}

Follow the steps after this for a minimalistic local setup. Alternatively, you can use CAP in [SAP Build Code](https://pages.community.sap.com/topics/build-code), or other cloud-based setups, such as GitHub codespaces.



### Prerequisites

- [Node.js](https://nodejs.org) — required for installing the `cds` command line interface
- [SQLite](https://sqlite.org) — included in macOS and Linux → [install it](https://sqlite.org/download.html) on Windows
- **A Terminal**{} — for using the `cds` command line interface (CLI)
- **A Text Editor**{} → we recommend [VS Code](https://code.visualstudio.com) with [CDS plugin](../tools/cds-editors#vscode)


### Installation

- With the prerequisites met, install the [`cds` toolkit](../tools/cds-cli) *globally*:

    ```sh
    npm add -g @sap/cds-dk
    ```

    [Visit the _Troubleshooting_ guide](troubleshooting.md) if you encounter any errors. {.learn-more}

- Run `cds` to check whether installation was successful:

  ```sh
  cds
  ```

  You see some output like that:

  ```sh
  USAGE

      cds <command> [<args>]
      cds <src>  =  cds compile <src>
      cds        =  cds help

  COMMANDS

      i | init        jump-start cds-based projects
      a | add         add a feature to an existing project
      c | compile     compile cds models to different outputs
      s | serve       run your services in local server
      w | watch       run and restart on file changes
      r | repl        read-eval-event loop
      e | env         inspect effective configuration
      b | build       prepare for deployment
      d | deploy      deploy to databases or cloud
      v | version     get detailed version information
      ? | help        get detailed usage information

    Learn more about each command using:
    cds help <command> or
    cds <command> --help

  ```



### Optional

- [Java](https://sapmachine.io) & [Maven](https://maven.apache.org/download.cgi) — if you're going for Java development → [see instructions](../java/getting-started#local).
- [git](https://git-scm.com) — if you go for more than just some quick trials.



## Starting Projects

- Use `cds init` to start a CAP project, and then open it in VS Code:

   ```sh
   cds init bookshop
   ```

   ```sh
   code bookshop
   ```
   [Assumes you activated the `code` command on macOS as documented](../tools/cds-editors#vscode) {.learn-more}



## Project Structure

The default file structure of CAP projects is as follows:

```zsh
bookshop/        # Your project's root folder
├─ app/          # UI-related content
├─ srv/          # Service-related content
├─ db/           # Domain models and database-related content
├─ package.json  # Configuration for cds + cds-dk
└─ readme.md     # A readme placeholder
```

CAP has defaults for many things that you'd have to configure in other frameworks. The goal is that things should just work out of the box, with zero configuration, whenever possible. You can override these defaults by a specific configuration if you need to do so.

::: details See an example for configuring custom project layouts...

::: code-group

```json [package.json]
{ ...
  "cds": {
    "folders": {
       "db": "database/",
       "srv": "services/",
       "app": "uis/"
    }
  }
}
```

```sh [Explore the defaults in your project]
cds env ls defaults
```

[Learn more about project-specific configuration.](../node.js/cds-env){.learn-more}
:::

::: tip Convention over configuration
We recommend sticking to CAP's way of [Convention over Configuration](https://en.wikipedia.org/wiki/Convention_over_configuration) to benefit from things just working out of the  box. Only override the defaults if you really need to do so.
:::




## Learning More
{#next-steps}

After the [initial setup](#setup), we recommend continuing as follows while you grow as you go...:

| # | Guide                                     | Description                                            |
|---|-------------------------------------------|--------------------------------------------------------|
| 1 | [Introduction – What is CAP?](../about/)  | Learn about key benefits and value propositions.       |
| 2 | [Bookshop by capire](in-a-nutshell)       | Build your first CAP application within 4-44 minutes.  |
| 3 | [Best Practices](../about/best-practices) | Key concepts & rationales to understand → *must read*. |
| 4 | [Anti Patterns](../about/bad-practices)   | Misconceptions & bad practices to avoid → *must read*. |
| 5 | [Learn More](learning-sources)            | Find samples, videos, blogs, tutorials, and so on.     |



## Grow as you go...

After these getting started-level introductions, you would continuously revisit these guides to deepen your understanding and as reference docs:

|  # | Guides & References                                                                   | Description                                    |
|---:|---------------------------------------------------------------------------------------|------------------------------------------------|
|  6 | [Cookbook](../guides/)                                                                | Walkthroughs for the most common tasks.        |
|  7 | [CDS](../cds/)<br/>[Java](../java/)<br/>[Node.js](../node.js/)<br/>[Tools](../tools/) | The reference docs for these respective areas. |
|  8 | [Plugins](../plugins/)                                                                | Curated list of recommended Calesi plugins.    |
|  9 | [Releases](../releases/)                                                              | Your primary source to stay up to date.        |
| 10 | [Resources](../resources/)                                                            | About support channels, community, ...         |


This also reflects the overall structure of [this documentation](./learning-sources.md#this-documentation).



# Introduction to CAP

Value Propositions {.subtitle}

## What is CAP?

The _Cloud Application Programming Model_ (CAP) is a framework of languages, libraries, and tools for building *enterprise-grade* cloud applications. It guides developers along a *golden path* of **proven best practices**, which are **served out of the box** by generic providers cloud-natively, thereby relieving application developers from tedious recurring tasks.

In effect, CAP-based projects benefit from a primary **focus on domain**, with close collaboration of developers and domain experts, **rapid development** at **minimized costs**, as well as **avoiding technical debts** by eliminating exposure to, and lock-ins to volatile low-level technologies.

Someone once said:

"CAP is like ABAP for the non-ABAP world" {.quote}

... which is not completely true, of course
<br/>... ABAP is much older \:-)

## Jumpstart & Grow As You Go...
###### grow-as-you-go



### Jumpstarting Projects

To get started with CAP, there's only a [minimalistic initial setup](../get-started/index.md) required. Starting a project is a matter of seconds. No tedious long lasting platform onboarding ceremonies are required; instead you can (and should):

- Start new CAP projects within seconds.
- Create functional apps with full-fledged servers within minutes.
- Without prior onboarding to, or being connected to, the cloud.

```sh
cds init
cds watch
```

> [!tip]
>
> Following the principle of *convention over configuration*, CAP uses built-in configuration presets and defaults for different profiles. For the development profile, there's all set up for jumpstart development. In parallel, ops teams could set up the cloud, to be ready for first deployments later in time.



### Growing as You Go...

Add things only when you need them or when you know more. Avoid any premature decisions or up-front overhead. For example, typical CAP projects adopt an *iterative* and *evolutionary* workflow like that:

1. **jumpstart a project** → no premature decisions made at that stage, just the name.
2. **rapidly create** fully functional first prototypes or proof-of-concept versions.
3. work in **fast inner loops** in airplane mode, and only occasionally go hybrid.
4. anytime **add new features** like Fiori UIs, message queues, different databases, etc.
5. do a first **ad-hoc deployment** to the cloud some days later
6. set up your **CI/CD pipelines** some weeks later
7. switch on **multitenancy** and **extensibility** for SaaS apps before going live
8. optionally cut out some **micro services** only if necessary and months later earliest

```sh
cds add hana,redis,mta,helm,mtx,multitenancy,extensibility...
```

> [!tip]
>
> Avoid futile up-front setups and overhead and rather **get started rapidly**, having a first prototype up and running as fast as possible... by doing so, you might even find out soon that this product idea you or somebody else had doesn't work out anyways, so rather stop early ...



### Fast Inner Loops

Most of your development happens in inner loops, where developers would **code**, **run**, and **test** in **fast iteration**. However, at least in mediocre cloud-based development approaches, this is slowed down drastically, for example, by the need to always be connected to platform services, up to the need to always deploy to the cloud to see and test the effects of recent changes.

![inner-loop](assets/inner-loop.png){.zoom75}

CAP applications are [**agnostic by design**](best-practices#agnostic-by-design), which allows to stay in fast inner loops by using local mock variants as stand-ins for many platform services and features, thereby eliminating the need to always connect to or deploy to the cloud; developers can stay in fast inner loops, without connection to cloud – aka. ***airplane*** mode development. Only when necessary, they can test in ***hybrid*** mode or do ad-hoc deployments to the cloud.

CAP provides mocked variants for several platform services out of the box, which are used automatically through default configuration presets in ***development*** profile, while the real services are automatically used in ***production*** profile. Examples are:

| Platform Service | Development          | Production                       |
| ---------------- | -------------------- | -------------------------------- |
| Database         | SQLite, H2 in-memory | SAP HANA, PostgreSQL             |
| Authentication   | Mocked Auth          | SAP Identity Services            |
| App Gateway      | None                 | SAP App Router                   |
| Messaging        | File-based Queues    | SAP Cloud Appl. Event Hub, Kafka, Redis, ... |

> [!tip]
>
>  CAP's agnostic design, in combination with the local mock variants provided out of the box, not only retains **fast turnarounds** in inner loops, it also **reduces complexity**, and makes development **resilient** against unavailable platform services → thus promoting **maximized speed** at **minimized costs**.





### Agnostic Microservices

CAP's thorough [agnostic design](best-practices#agnostic-by-design) not only allows to swap local mock variants as stand-ins for productive platform services, it also allows to do the same for your application services.

Assumed you plan for a microservices architecture, the team developing microservice `A` would always have a dependency to the availability of microservice `B`, which they need to connect to, at least in a hybrid setup, worst case even ending up in the need to always have both deployed to the cloud.

With CAP, you can (and should) instead just run both services in the same local process at development, basically by using `B` as a plain old library in `A`, and only deploy them to separate microservices in production, **without having to touch your models or code** (given `A` uses `B` through public APIs, which should always be the case anyways).

![modulith](assets/modulith.png){.zoom66}

![late-cut-microservices](assets/late-cut-microservices.png){.zoom66}

If service `A` and `B` are developed in different runtimes, for example, Node.js and Java, you can't run them in the same process. But even then you can (and should) leverage CAP's ability to easily serve a service generically based on a service definition in CDS. So during development, `A`  would use a mocked variant of `B` served automatically by CAP's generic providers.



### Late-cut Microservices

You can (and should) also leverage the offered options to have CAP services co-deployed in a single *modulithic* process to delay the decision of whether and how to cut your application into microservices to a later phase of your project, when you know more about where to actually do the right cuts in the right way.

In general, we always propose that approach:

1. **Avoid** premature cuts into microservices → ends up in lots of pain without gains
2. **Go for** a *modulith* approach instead → with CAP services for modularization
3. Cut into separate microservices **later on** → only when you really need to

>  [!tip]
>
>  - **CAP services** are your primary means for modularization
>  - **Microservices** are **deployment units**.
>  - **Valid** reasons for microservices are:
>   1. need to scale things differently
>   2. different runtimes, for example, Node.js vs Java
>   3. loosely coupled, coarse-grained subsystems with separate lifecycles
>  - **False** reasons are: distributed development, modularization, isolation, ... → there are well established and proven better ways to address these things, without the pain which comes with microservices.

[See also the anti pattern of *Microservices Mania*](bad-practices#microservices-mania) {.learn-more}



### Parallelized Workflows



As shown in the [*Bookshop by capire*](../get-started/in-a-nutshell) walkthrough, a simple service definition in CDS is all we need to run a full-fledged REST, or OData, or GraphQL server

There are more options to parallelize workflows. Fueled by service definition is all that is required to get a full-fledged REST or OData service **served out of the box** by generic providers.

So, projects could spawn two teams in parallel: one working on the frontend using automatically served backends, while the other one works on the actual implementations of the backend part.



## Proven Best Practices



### Served Out Of The Box



The CAP runtimes in Node.js and Java provide many generic implementations for recurring tasks and best practices, distilled from proven SAP applications. This is a list of the most common tasks covered by the core frameworks:

- [Serving CRUD Requests](../guides/providing-services#generic-providers)
- [Serving Nested Documents](../guides/providing-services#deep-reads-and-writes)
- [Serving Variable Data](../releases/archive/2024/oct24#basic-support-for-cds-map) <Alpha/>
- [Serving (Fiori) Drafts](../advanced/fiori#draft-support)
- [Serving Media Data](../guides/providing-services#serving-media-data)
- [Searching Data](../guides/providing-services#searching-data)
- [Pagination](../guides/providing-services#implicit-pagination)
- [Sorting](../guides/providing-services#implicit-sorting)
- [Authentication](../node.js/authentication)
- [Authorization](../guides/security/authorization)
- [Localization / i18n](../guides/i18n)
- [Basic Input Validation](../guides/providing-services#input-validation)
- [Auto-generated Keys](../guides/providing-services#auto-generated-keys)
- [Concurrency Control](../guides/providing-services#concurrency-control)

<br/>

> [!tip]
>
> This set of automatically served requests and covered related requirements, means that CAP's generic providers automatically serve the vast majority, if not all of the requests showing up in your applications, without you having to code anything for that, except for true custom domain logic.

[See also the *Features Overview*](./features) {.learn-more}



### Enterprise Best Practices



On top of the common request-serving related things handled by CAP's generic providers, we provide out of the box solutions for these higher-level topic fields:

- [Common Reuse Types & Aspects](../cds/common)
- [Managed Data](../guides/domain-modeling#managed-data)
- [Localized Data](../guides/localized-data)
- [Temporal Data](../guides/temporal-data)
- [Data Federation](https://github.com/SAP-samples/teched2022-AD265/wiki) → hands-on tutorial; capire guide in the making...
- [Verticalization & Extensibility](../guides/extensibility/)

<br/>

> [!tip]
>
> These best practice solutions mostly stem from close collaborations with as well as contributions by real, successful projects and SAP products, and from ABAP. Which means they've been proven in many years of adoption and real business use.



### The 'Calesi' Effect



'**Calesi**' stands for "**CA**P-**le**vel **S**ervice **I**ntegrations" as well as for an initiative we started late 2023 by rolling out the *CAP Plugins* technique, which promotes plugins and add-ons contributions not only by the CAP team, but also by

- **SAP BTP technology units** and service teams (beyond CAP team)
- **SAP application teams**
- **Partners** & **Customers**, as well as
- **Contributors** from the CAP community

That initiative happened to be successful, and gave a boost to a steadily **growing ecosystem** around CAP with an active **inner source** and **open source** community on the one hand side. On the other hand, it resulted into an impressive collection of production-level add-ons. Here are some highlights **maintained by SAP teams**:

- [GraphQL Adapter](../plugins/#graphql-adapter)
- [OData V2 Adapter](../plugins/#odata-v2-proxy)
- [WebSockets Adapter](../plugins/#websocket)
- [UI5 Dev Server](../plugins/#ui5-dev-server)
- [Open Telemetry → SAP Cloud Logging, Dynatrace, ...](../plugins/#telemetry)
- [Attachments → SAP Object Store /S3](../plugins/#attachments)
- [Attachments → SAP Document Management Service](../plugins/#@cap-js/sdm)
- [Messaging → SAP Cloud Application Event Hub](../plugins/#event-hub)
- [Change Tracking](../plugins/#change-tracking)
- [Notifications](../plugins/#notifications)
- [Audit Logging → SAP Audit Logging](../plugins/#audit-logging)
- [Personal Data Management → SAP DPI Services](../guides/data-privacy/)
- [Open Resource Discovery (ORD)](../plugins/#ord-open-resource-discovery)

>  [!tip]
>
> This is just a subset and a snapshot of the growing number of plugins <br/>→ find more in the [***CAP Plugins***](../plugins/) page, as well in the [***CAP Commmunity***](../resources/community-sap) spaces.



### Intrinsic Extensibility <UnderConstruction/>

SaaS customers, verticalization partners, or your teams can...

- Add/override annotations, translations, initial data
- Add extension fields, entities, relationships
- Add custom logic → in-app + side-by-side
- Bundle and share that as reuse extension packages
- Feature-toggle such pre-built extension packages per tenant

All of these tasks are done in [the same way as you do in your own projects](best-practices.md#intrinsic-extensibility):

- Using the same techniques of CDS Aspects and Event Handlers
- Including adaption and extensions of reuse types/models
- Including extensions to framework-provided services

And all of that is available out of the box, that is, without you having to create extension points. You would want to restrict who can extend what, though.





### Cloud-Native by Design



CAP's [service-centric paradigm](best-practices#services) is designed from the ground up for cloud-scale enterprise applications. Its core design principles of flyweight, stateless services processing passive, immutable data, complemented by an intrinsic, ubiquitous [events-based](best-practices#events) processing model greatly promote scalability and resilience.

On top of that, several built-in facilities address many things to care about in cloud-based apps out of the box, such as:

- **Multitenancy** → tenant *isolation* at runtime; *deploy*, *subscribe*, *update* handled by MTX
- **Extensibility** → for customers to tailor SaaS apps to their needs →  [see Intrinsic...](#intrinsic-extensibility)
- **Security** → CAP+plugins do authentications, certificates, mTLS, ...
- **Scalability** → by stateless services, passive data, messaging, ...
- **Resilience** → by messaging, tx outbox, outboxed audit logging, ...
- **Observability** → by logging + telemetry integrated to BTP services

<br/>

> [!tip]
>
> Application developers don't have to and **should not have to care** about these complex non-functional requirements. Instead they should [focus on domain](#focus-on-domain), that is, their functional requirements, as much as possible.

> [!caution]
>
> Many of these crucial cloud qualities are of complex and critical nature, for example, **multitenancy**, **isolation** and **security**, but also scalability and resilience isn't that easy to do right → it's a **high risk** to assume each application developer in each project is doing everything in the right ways



### Open _and_ Opinionated


That might sound like a contradiction, but it isn't: While CAP certainly gives *opinionated* guidance, we do so without sacrificing openness and flexibility.  At the end of the day, you stay in control of which tools or technologies to choose, or which architecture patterns to follow as depicted in the following table.

| CAP is *Opinionated* in...                                   | CAP is *Open* as...                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **Platform-agnostic APIs** to avoid lock-ins to low-level stuff. | All abstractions follow a glass-box pattern that allows unrestricted access to lower-level things, if necessary |
| **Best practices**, served out of the box by generic providers | You're free to do things your way in [custom handlers](../guides/providing-services#custom-logic), ... while CAP simply tries to get the tedious tasks out of your way. |
| **Out-of-the-box support** for <br> **[SAP Fiori](https://developers.sap.com/topics/ui-development.html)** and **[SAP HANA](https://developers.sap.com/topics/hana.html)** | You can also choose other UI technologies, like [Vue.js](../get-started/in-a-nutshell#vue). Other databases are supported as well. |
| **Tools support** in [SAP Build Code](../tools/cds-editors#bas) or [VS Code](../tools/cds-editors#vscode). | Everything in CAP can be done using the [`@sap/cds-dk`](../tools/cds-cli) CLI and any editor or IDE of your choice. |

<br/>

> [!tip]
>
> And most important: As CAP itself is designed as an open framework, everything what's not covered by CAP today can be solved in application projects, in specific custom code, or by [generic handlers](best-practices.md#extensible-framework) ... or by [plugins](../plugins/index.md) that you could build and contribute. <br/>⇒  **Contributions *are* welcome!**



## Focus on Domain

CAP places **primary focus on domain**, by capturing _domain knowledge_ and _intent_ instead of imperative coding — that means, _What, not How_ — which promotes the following:

- Close collaboration of _developers_ and _domain experts_ in domain modeling.
- _Out-of-the-box_ implementations for _best practices_ and recurring tasks.
- _Platform-agnostic_ approach to _avoid lock-ins_, hence _protecting investments_.

### Conceptual Modeling by CDS <UnderConstruction/>

### Domain-Driven Design <UnderConstruction/>

### Rapid Development <UnderConstruction/>

### Minimal Distraction <UnderConstruction/>



## Avoid Technical Debt

There are several definitions of technical debt found in media which all boil down to:

Technical debt arises when speed of delivery is prioritized over quality. <br>The results must later be revised, thoroughly refactored, or completely rebuilt. {.quote}

So, how could CAP help to avoid, or reduce the risks of piling up technical debt?

### Less Code → Less Mistakes

Every line of code not written is free of errors. {.quote}

Moreover:

- Relieving app dev teams from overly technical disciplines not only saves efforts and time, it also avoids **severe mistakes** which can be made in these fields, for example, in tenant isolation and security.
- **Best practices** reproduce proven solution patterns to recurring tasks, found and refined in successful application projects; your peers.
- Having them **served out of the box** paves the path for their adoption, and hence reduces the likelihood of picking anti patterns instead.

### Single Points to Fix

Of course, we also make mistakes and errors in CAP, but ...

- We can fix them centrally and all CAP users benefit from that immediately.
- Those bugs are frequently found and fixed by your peers in crime, before you even encounter them yourselves.
- And this effect increases with steadily growing adoption of CAP that we see, ...
- And with the open culture we established successfully, for example, **open issue reports** in GitHub, that is, the standard out there, instead of private support tickets — a relict of the past.

> Note that all of this is in contrast to code generators, where you can't fix code generated in the past → see also [*Avoid Code Generators*](bad-practices#code-generators) in the anti patterns guide.

### Minimized Lock-Ins

Keeping pace with a rapidly changing world of volatile cloud technologies and platforms is a major challenge, as today's technologies that might soon become obsolete. CAP avoids such lock-ins and shields application developers from low-level things like:

- **Authentication** and **Authorization**, incl. things like Certificates, mTLS, OAuth, ...
- **Service Bindings** like K8s secrets, VCAP_SERVICES, ...
- **Multitenancy**-related things, especially w.r.t. tenant isolation
- **Messaging** protocols or brokers such as AMQP, MQTT, Webhooks, Kafka, Redis, ...
- **Networking** protocols such as HTTP, gRCP, OData, GraphQL, SOAP, RFC, ...
- **Audit Logging** → use the *Calesi* variant, which provides ultimate resilience
- **Logs**, **Traces**, **Metrics** → CAP does that behind the scenes + provides *Calesi* variants
- **Transaction Management** → CAP manages all transactions → don't mess with that!

> [!tip]
>
> CAP not only abstracts these things at scale, but also does most things automatically in the background. In addition, it allows us to provide various implementations that encourage *Evolution w/o Disruption*, as well as fully functional mocks used in development.

> [!caution]
>
> Things get dangerous when application developers have to deal with low-level security-related things like authentication, certificates, tenant isolation, and so on. Whenever this happens, it's a clear sign that something is seriously wrong.



## What about AI? <UnderConstruction/>

- AI provides tremendous boosts to productivity → for example:
  - **Coding Assists** → for example, by [Copilot](https://en.wikipedia.org/wiki/Microsoft_Copilot) in `.cds`, `.js`, even `.md` sources
  - **Code Analysis** → detecting [bad practices](bad-practices) → guiding to [best practices](best-practices)
  - **Code Generation** → for example, for tests, test data, ...
  - **Project Scaffolding** → for quick head starts
  - **Search & Learning Assists** → like Maui, ...
- But this doesn't replace the need for **Human Intelligence**!
  - There's a different between a GPT-generated one-off thesis and long-lived enterprise software, which needs to adapt and scale to new requirements.
- **CAP itself** is a major contribution to AI → its simple, clear concepts, uniform ways to implement and consume services, capire, its openness and visibility in the public world, ...




# Getting Started in a Nutshell
Build Your First App with CAP {.subtitle}





## Jumpstart a Project {#jumpstart}



After you completed the [*Initial Setup*](./), you jumpstart a project as follows:

- Create a new project using `cds init`

   <span class="impl node">

   ```sh [Node.js]
   cds init bookshop
   ```

   </span>

   <span class="impl java">

   ```sh [Java]
   cds init bookshop --java --java:mvn -DgroupId=com.sap.capire
   ```

   </span>

- Open the project in VS Code

   ```sh
   code bookshop
   ```
   [Assumes you activated the `code` command on macOS as documented](/tools/cds-editors#vscode) {.learn-more}

   For Java development in VS Code you need to [install extensions](https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack). {.learn-more .java}


- Run the following command in an [*Integrated Terminal*](https://code.visualstudio.com/docs/terminal/basics)

   <span class="impl node">

   ```sh [Node.js]
   cds watch
   ```

   </span>

   <span class="impl java">

   ```sh [Java]
   cd srv && mvn cds:watch
   ```

   </span>

   ::: details `cds watch` is waiting for things to come...

   ```log
   [dev] cds w

   cds serve all --with-mocks --in-memory?
   live reload enabled for browsers

         ___________________________

   No models found in db/,srv/,app/,schema,services. // [!code focus]
   Waiting for some to arrive... // [!code focus]

   ```

   So, let's go on feeding it...

   :::


::: details Optionally clone sample from GitHub ...

The sections below describe a hands-on walkthrough, in which you'd create a new project and fill it with content step by step. Alternatively, you can get the final sample content from GitHub as follows:

::: code-group

```sh [Node.js]
git clone https://github.com/sap-samples/cloud-cap-samples samples
cd samples
npm install
```

```sh [Java]
git clone https://github.com/sap-samples/cloud-cap-samples-java bookshop
```

Note: When comparing the code from the *cap/samples* on GitHub to the snippets given in the sections below you will recognise additions showcasing enhanced features. So, what you find in there is a superset of what we describe in this getting started guide.

:::



## Capture Domain Models


Let's feed our project by adding a simple domain model. Start by creating a file named _db/schema.cds_ and copy the following definitions into it:

::: code-group

```cds [db/schema.cds]
using { Currency, managed, sap } from '@sap/cds/common';
namespace sap.capire.bookshop; // [!code focus]

entity Books : managed { // [!code focus]
  key ID : Integer;
  title  : localized String(111);
  descr  : localized String(1111);
  author : Association to Authors;
  genre  : Association to Genres;
  stock  : Integer;
  price  : Decimal(9,2);
  currency : Currency;
}

entity Authors : managed { // [!code focus]
  key ID : Integer;
  name   : String(111);
  books  : Association to many Books on books.author = $self;
}

/** Hierarchically organized Code List for Genres */
entity Genres : sap.common.CodeList { // [!code focus]
  key ID   : Integer;
  parent   : Association to Genres;
  children : Composition of many Genres on children.parent = $self;
}

```
:::

_Find this source also in `cap/samples` [for Node.js](https://github.com/sap-samples/cloud-cap-samples/tree/main/bookshop/db/schema.cds), and [for Java](https://github.com/SAP-samples/cloud-cap-samples-java/blob/main/db/books.cds)_{ .learn-more}
[Learn more about **Domain Modeling**.](../guides/domain-modeling){ .learn-more}
[Learn more about **CDS Modeling Languages**.](../cds/){ .learn-more}


### Deployed to Databases {#deployed-in-memory}

<span class="impl node">

As soon as you save the *schema.cds* file, the still running `cds watch` reacts immediately with new output like this:

```log
[cds] - connect to db > sqlite { database: ':memory:' }
/> successfully deployed to in-memory database.
```

This means that `cds watch` detected the changes in _db/schema.cds_ and automatically bootstrapped an in-memory _SQLite_ database when restarting the server process.

</span>

<span class="impl java">

As soon as you save your CDS file, the still running `mvn cds:watch` command reacts immediately with a CDS
compilation and reload of the CAP Java application. The embedded database of the started application will reflect the schema defined in your CDS file.

</span>

### Compiling Models {#cli}

We can optionally test-compile models individually to check for validity and produce a parsed output in [CSN format](../cds/csn). For example, run this command in a new terminal:

```sh
cds db/schema.cds
```

This dumps the compiled CSN model as a plain JavaScript object to stdout. <br>
Add `--to <target>` (shortcut `-2`) to produce other outputs, for example:

```sh
cds db/schema.cds -2 json
cds db/schema.cds -2 yml
cds db/schema.cds -2 sql
```

[Learn more about the command line interface by executing `cds help`.](../tools/cds-cli#cds-help){.learn-more}



## Providing Services {#services}


<span class="impl node">

After the recent changes, `cds watch` also prints this message:

```log
No service definitions found in loaded models.
Waiting for some to arrive...
```

</span>

<span class="impl java">

After the recent changes, the running CAP Java application is still not exposing any service endpoints.

</span>

So, let's go on feeding it with two service definitions for different use cases:

An `AdminService` for administrators to maintain `Books` and `Authors`.

A `CatalogService` for end users to browse and order `Books` under path `/browse`.

To do so, create the following two files in folder _./srv_ and fill them with this content:

::: code-group
```cds [srv/admin-service.cds]
using { sap.capire.bookshop as my } from '../db/schema';
service AdminService @(requires:'authenticated-user') { // [!code focus]
  entity Books as projection on my.Books;
  entity Authors as projection on my.Authors;
}
```
```cds [srv/cat-service.cds]
using { sap.capire.bookshop as my } from '../db/schema';
service CatalogService @(path:'/browse') { // [!code focus]

  @readonly entity Books as select from my.Books {*,
    author.name as author
  } excluding { createdBy, modifiedBy };

  @requires: 'authenticated-user'
  action submitOrder (book: Books:ID, quantity: Integer);
}
```
:::

*Find this source also on GitHub [for Node.js](https://github.com/sap-samples/cloud-cap-samples/tree/main/bookshop/srv), and [for Java](https://github.com/SAP-samples/cloud-cap-samples-java/blob/main/srv)*{.learn-more}

[Learn more about **Defining Services**.](../guides/providing-services){ .learn-more}



### Served via OData

<span class="impl node">

This time `cds watch` reacted with additional output like this:

```log
[cds] - serving AdminService { at: '/odata/v4/admin' }
[cds] - serving CatalogService { at: '/browse' }

[cds] - server listening on { url: 'http://localhost:4004' }
```

As you can see, the two service definitions have been compiled and generic service providers have been constructed to serve requests on the listed endpoints _/odata/v4/admin_ and _/browse_.

</span>

<span class="impl java">

In case the CDS service definitions were compiled correctly the Spring Boot runtime is reloaded automatically and should output a log line like this:

```log
c.s.c.services.impl.ServiceCatalogImpl : Registered service AdminService
c.s.c.services.impl.ServiceCatalogImpl : Registered service CatalogService
```

As you can see in the log output, the two service definitions have been compiled and generic service providers have been constructed to serve requests on the listed endpoints _/odata/v4/AdminService_ and _/odata/v4/browse_.

::: warning Add the dependency to spring-boot-security-starter
Both services defined above contain security annotations that restrict access to certain endpoints. Please add the dependency to spring-boot-security-starter to the _srv/pom.xml_ in order to activate mock user and authentication support:

```sh
mvn com.sap.cds:cds-maven-plugin:add -Dfeature=SECURITY
```

:::

</span>


> [!tip]
>
>  CAP-based services are full-fledged OData services out of the box. Without adding any provider implementation code, they translate OData request into corresponding database requests, and return the results as OData responses.

[Learn more about **Generic Providers**.](../guides/providing-services){.learn-more}



### Generating APIs

We can optionally also compile service definitions explicitly, for example to [OData EDMX metadata documents](https://docs.oasis-open.org/odata/odata/v4.0/odata-v4.0-part3-csdl.html):

```sh
cds srv/cat-service.cds -2 edmx
```

Essentially, using a CLI, this invokes what happened automatically behind the scenes in the previous steps.
While we don't really need such explicit compile steps, you can do this to test correctness on the model level, for example.


### Generic *index.html*

<span class="impl node">

Open _<http://localhost:4004>_ in your browser and see the generic _index.html_ page:

![Generic welcome page generated by CAP that list all endpoints. Eases jumpstarting development and is not meant for productive use.](assets/welcome.png){}

> Note: User `alice` is a [default user with admin privileges](../node.js/authentication#mocked). Use it to access the _/admin_ service. You don't need to enter a password.

</span>

<span class="impl java">

Open _<http://localhost:8080>_ in your browser and see the generic _index.html_ page:

![Generic welcome page generated by CAP that list all endpoints. Eases jumpstarting development and is not meant for productive use.](./assets/welcome-java.png)

> Note: User `authenticated` is a [prepared mock user](../java/security#mock-users) which will be authenticated by default. Use it to access the _/admin_ service. You don't need to enter a password.

</span>





## Using Databases {#databases}

### SQLite In-Memory {.impl .node}

As [previously shown](#deployed-in-memory), `cds watch` automatically bootstraps an SQLite in-process and in-memory database by default — that is, unless told otherwise. While this **isn't meant for productive use**, it drastically speeds up development turn-around times, essentially by mocking your target database, for example, SAP HANA. {.impl .node}


### H2 In-Memory {.impl .java}

As [previously shown](#deployed-in-memory), `mvn cds:watch` automatically bootstraps an H2 in-process and in-memory database by default — that is, unless told otherwise. While this **isn't meant for productive use**, it drastically speeds up turn-around times in local development and furthermore allows self-contained testing. {.impl .java}

### Adding Initial Data

Now, let's fill your database with initial data by adding a few plain CSV files under _db/data_ like this:

::: code-group

```csvc [db/data/sap.capire.bookshop-Books.csv]
ID,title,author_ID,stock
201,Wuthering Heights,101,12
207,Jane Eyre,107,11
251,The Raven,150,333
252,Eleonora,150,555
271,Catweazle,170,22
```
```csvc [db/data/sap.capire.bookshop-Authors.csv]
ID,name
101,Emily Brontë
107,Charlotte Brontë
150,Edgar Allen Poe
170,Richard Carpenter
```
:::



::: details `cds add data` can help you with the file and record generation
Create empty CSV files with header lines only:

```sh 
cds add data
```

Create CSV files that already include some sample data:

```sh
cds add data --records 10
```
[Find the full set of options here.](../tools/cds-cli.md#data){.learn-more}
:::

[Find a full set of `.csv` files in **cap/samples**.](https://github.com/sap-samples/cloud-cap-samples/tree/main/bookshop/db/data){ .learn-more target="_blank"}

<span class="impl node">

After you've added these files, `cds watch` restarts the server with output, telling us that the files have been detected and their content has been loaded into the database automatically:

```log
[cds] - connect to db { database: ':memory:' }
 > filling sap.capire.bookshop.Authors from bookshop/db/data/sap.capire.bookshop-Authors.csv
 > filling sap.capire.bookshop.Books from bookshop/db/data/sap.capire.bookshop-Books.csv
 > filling sap.capire.bookshop.Books_texts from bookshop/db/data/sap.capire.bookshop-Books_texts.csv
 > filling sap.capire.bookshop.Genres from bookshop/db/data/sap.capire.bookshop-Genres.csv
 > filling sap.common.Currencies from common/data/sap.common-Currencies.csv
 > filling sap.common.Currencies_texts from common/data/sap.common-Currencies_texts.csv
/> successfully deployed to in-memory database.
```

> Note: This is the output when you're using the [samples](https://github.com/sap-samples/cloud-cap-samples). It's less if you've followed the manual steps here.

</span>

<span class="impl java">

After you've added these files, `mvn cds:watch` restarts the server with output, telling us that the files have been detected and their content has been loaded into the database automatically:

```log
c.s.c.s.impl.persistence.CsvDataLoader   : Filling sap.capire.bookshop.Books from db/data/sap.capire.bookshop-Authors.csv
c.s.c.s.impl.persistence.CsvDataLoader   : Filling sap.capire.bookshop.Books from db/data/sap.capire.bookshop-Books.csv
```

</span>

[Learn more about **Using Databases**.](../guides/databases){.learn-more}


### Querying via OData

Now that we have a connected, fully capable SQL database, filled with some initial data, we can send complex OData queries, served by the built-in generic providers:

- _[…/Books?$select=ID,title](http://localhost:4004/browse/Books?$select=ID,title)_ {.impl .node}
- _[…/Authors?$search=Bro](http://localhost:4004/odata/v4/admin/Authors?$search=Bro)_ {.impl .node}
- _[…/Authors?$expand=books($select=ID,title)](http://localhost:4004/odata/v4/admin/Authors?$expand=books($select=ID,title))_ {.impl .node}
- _[…/Books?$select=ID,title](http://localhost:8080/odata/v4/browse/Books?$select=ID,title)_ {.impl .java}
- _[…/Authors?$search=Bro](http://localhost:8080/odata/v4/AdminService/Authors?$search=Bro)_ {.impl .java}
- _[…/Authors?$expand=books($select=ID,title)](http://localhost:8080/odata/v4/AdminService/Authors?$expand=books($select=ID,title))_ {.impl .java}

> Note: Use [_alice_](../node.js/authentication#mocked) as user to query the `admin` service. You don't need to enter a password. {.impl .node}

> Note: Use [_authenticated_](../java/security#mock-users) to query the `admin` service. You don't need to enter a password. {.impl .java}

[Learn more about **Generic Providers**.](../guides/providing-services){.learn-more}
[Learn more about **OData's Query Options**.](../advanced/odata){.learn-more}



### Persistent Databases {.impl .node}

Instead of in-memory databases we can also use persistent ones. For example, still with SQLite, add the following configuration:


::: code-group

```json [package.json]
{
  "cds": {
    "requires": {
      "db": {
          "kind": "sqlite",
          "credentials": { "url": "db.sqlite" } // [!code focus]
      }
    }
  }
}
```

:::

Then deploy:

```sh
cds deploy
```

The difference from the automatically provided in-memory database is that we now get a persistent database stored in the local file _./db.sqlite_. This is also recorded in the _package.json_.

::: details To see what that did, use the `sqlite3` CLI with the newly created database.
```sh
sqlite3 db.sqlite .dump
sqlite3 db.sqlite .tables
```
:::

[Learn how to install SQLite on Windows.](troubleshooting#how-do-i-install-sqlite-on-windows){.learn-more}

:::details You could also deploy to a provisioned SAP HANA database using this variant.
```sh
cds deploy --to hana
```
:::

[Learn more about deploying to SAP HANA.](../guides/databases){.learn-more .impl .node}



## Serving UIs {#uis}


You can consume the provided services, for example, from UI frontends, using standard AJAX requests.
Simply add an _index.html_ file into the _app/_ folder, to replace the generic index page.


### SAP Fiori UIs {#fiori}

CAP provides out-of-the-box support for SAP Fiori UIs, for example, with respect to SAP Fiori annotations and advanced features such as search, value helps and SAP Fiori Draft.

![Shows the famous bookshop catalog service in an SAP Fiori UI.](assets/fiori-app.png)

[Learn more about **Serving Fiori UIs**.](../advanced/fiori){.learn-more}


### Vue.js UIs {#vue .impl .node}

Besides Fiori UIs, CAP services can be consumed from any UI frontends using standard AJAX requests.
For example, you can [find a simple Vue.js app in **cap/samples**](https://github.com/sap-samples/cloud-cap-samples/tree/main/bookshop/app/vue), which demonstrates browsing and ordering books using OData requests to [the `CatalogService` API we defined above](#services). {.impl .node}

![Shows the famous bookshop catalog service in a simple Vue.js UI.](assets/vue-app.png){ .impl .node .adapt}



## Adding Custom Logic



While the generic providers serve most CRUD requests out of the box, you can add custom code to deal with the specific domain logic of your application.



### Service Implementations

In Node.js, the easiest way to provide implementations for services is through equally named _.js_ files placed next to a service definition's _.cds_ file: {.impl .node}

<span class="impl node">

```zsh
bookshop/
├─ srv/
│ ├─ ...
│ ├─ cat-service.cds # [!code focus]
│ └─ cat-service.js # [!code focus]
└─ ...
```

[See these files also in **cap/samples**/bookshop/srv folder.](https://github.com/sap-samples/cloud-cap-samples/tree/main/bookshop/srv){.learn-more}
[Learn more about providing service implementations **in Node.js**.](../node.js/core-services#implementing-services){.learn-more .impl .node}
[Learn also **how to do that in Java** using Event Handler Classes.](../java/event-handlers/#handlerclasses){.learn-more .impl .java}

You can have this _.js_ file created automatically with [`cds add handler`](../tools/cds-cli#handler). {.learn-more}

</span>

<span class="impl java">

In CAP Java, you can add custom handlers for your service as so called EventHandlers. As CAP Java integrates with Spring Boot, you need to provide your custom code in classes, annotated with `@Component`, for example. Use your favorite Java IDE to add a class like the following to the `srv/src/main/java/` folder of your application. {.impl .java}

::: code-group
```java [srv/src/main/java/com/sap/capire/bookshop/handlers/CatalogServiceHandler.java]
@Component
@ServiceName(CatalogService_.CDS_NAME)
public class CatalogServiceHandler implements EventHandler {
  // your custom code will go here
}
```
:::

::: tip
Place the code in your package of choice and use your IDE to generate the needed `import` statements.
:::

</span>



### Adding Event Handlers

Service implementations essentially consist of one or more event handlers.

<span class="impl node">

Copy this into _srv/cat-service.js_ to add custom event handlers:

::: code-group
```js [srv/cat-service.js]
const cds = require('@sap/cds')
class CatalogService extends cds.ApplicationService { init() {
  const { Books } = cds.entities('CatalogService')

  // Register your event handlers in here, for example:  // [!code focus]
  this.after ('each', Books, book => { // [!code focus]
    if (book.stock > 111) { // [!code focus]
      book.title += ` -- 11% discount!` // [!code focus]
    } // [!code focus]
  }) // [!code focus]

  return super.init()
}}
module.exports = CatalogService
```
:::

[Learn more about adding **event handlers** using `<srv>.on/before/after`.](../node.js/core-services#srv-on-before-after){.learn-more}

</span>

<span class="impl java">

Now that you have created the classes for your custom handlers it's time to add the actual logic. You can achieve this by adding methods annotated with CAP's `@Before`,  `@On`, or `@After` to your new class. The annotation takes two arguments: the event that shall be handled and the entity name for which the event is handled.

::: code-group
```java [srv/src/main/java/com/sap/capire/bookshop/handlers/CatalogServiceHandler.java]
  @After(event = CqnService.EVENT_READ, entity = Books_.CDS_NAME)
  public void addDiscountIfApplicable(List<Books> books) {
    for (Books book : books) {
      if (book.getStock() != null && book.getStock() > 111) {
        book.setTitle(book.getTitle() + " -- 11% discount!");
      }
    }
  }
```
:::

:::details Code including imports
::: code-group
```java [srv/src/main/java/com/sap/capire/bookshop/handlers/CatalogServiceHandler.java]
package com.sap.capire.bookshop.handlers;

import java.util.List;
import org.springframework.stereotype.Component;
import com.sap.cds.services.cds.CqnService;
import com.sap.cds.services.handler.EventHandler;
import com.sap.cds.services.handler.annotations.After;
import com.sap.cds.services.handler.annotations.ServiceName;
import cds.gen.catalogservice.Books;
import cds.gen.catalogservice.Books_;
import cds.gen.catalogservice.CatalogService_;

@Component
@ServiceName(CatalogService_.CDS_NAME)
public class CatalogServiceHandler implements EventHandler {
  @After(event = CqnService.EVENT_READ, entity = Books_.CDS_NAME)
  public void addDiscountIfApplicable(List<Books> books) {
    for (Books book : books) {
      if (book.getStock() != null && book.getStock() > 111) {
        book.setTitle(book.getTitle() + " -- 11% discount!");
      }
    }
  }
}
```
:::


[Learn more about **event handlers** in the  CAP Java documentation.](../java/event-handlers/#handlerclasses){.learn-more}

</span>



### Consuming Other Services

Quite frequently, event handler implementations consume other services, sending requests and queries, as in the completed example below.

<span class="impl node">

::: code-group
```js [srv/cat-service.js]
const cds = require('@sap/cds')
class CatalogService extends cds.ApplicationService { async init() {

  const db = await cds.connect.to('db') // connect to database service
  const { Books } = db.entities         // get reflected definitions

  // Reduce stock of ordered books if available stock suffices
  this.on ('submitOrder', async req => {
    const {book,quantity} = req.data
    const n = await UPDATE (Books, book)
      .with ({ stock: {'-=': quantity }})
      .where ({ stock: {'>=': quantity }})
    n > 0 || req.error (409,`${quantity} exceeds stock for book #${book}`)
  })

  // Add some discount for overstocked books
  this.after ('each','Books', book => {
    if (book.stock > 111) book.title += ` -- 11% discount!`
  })

  return super.init()
}}
module.exports = CatalogService
```
:::
</span>

<span class="impl java">

::: code-group
```java [srv/src/main/java/com/sap/capire/bookshop/handlers/SubmitOrderHandler.java]
@Component
@ServiceName(CatalogService_.CDS_NAME)
public class SubmitOrderHandler implements EventHandler {

  private final PersistenceService persistenceService;

  public SubmitOrderHandler(PersistenceService persistenceService) {
    this.persistenceService = persistenceService;
  }

  @On
  public void onSubmitOrder(SubmitOrderContext context) {
    Select<Books_> byId = Select.from(cds.gen.catalogservice.Books_.class).byId(context.getBook());
    Books book = persistenceService.run(byId).single().as(Books.class);
    if (context.getQuantity() > book.getStock())
      throw new IllegalArgumentException(context.getQuantity() + " exceeds stock for book #" + book.getTitle());
    book.setStock(book.getStock() - context.getQuantity());
    persistenceService.run(Update.entity(Books_.CDS_NAME).data(book));
    context.setCompleted();
  }
}
```
:::

:::details Code including imports
::: code-group
```java [srv/src/main/java/com/sap/capire/bookshop/handlers/CatalogService.java]
package com.sap.capire.bookshop.handlers;

import org.springframework.stereotype.Component;
import com.sap.cds.ql.Select;
import com.sap.cds.ql.Update;
import com.sap.cds.services.handler.EventHandler;
import com.sap.cds.services.handler.annotations.On;
import com.sap.cds.services.handler.annotations.ServiceName;
import com.sap.cds.services.persistence.PersistenceService;
import cds.gen.catalogservice.Books;
import cds.gen.catalogservice.Books_;
import cds.gen.catalogservice.CatalogService_;
import cds.gen.catalogservice.SubmitOrderContext;

@Component
@ServiceName(CatalogService_.CDS_NAME)
public class SubmitOrderHandler implements EventHandler {

  private final PersistenceService persistenceService;

  public SubmitOrderHandler(PersistenceService persistenceService) {
    this.persistenceService = persistenceService;
  }

  @On
  public void onSubmitOrder(SubmitOrderContext context) {
    Select<Books_> byId = Select.from(cds.gen.catalogservice.Books_.class).byId(context.getBook());
    Books book = persistenceService.run(byId).single().as(Books.class);
    if (context.getQuantity() > book.getStock())
      throw new IllegalArgumentException(context.getQuantity() + " exceeds stock for book #" + book.getTitle());
    book.setStock(book.getStock() - context.getQuantity());

    persistenceService.run(Update.entity(Books_.CDS_NAME).data(book));

    context.setCompleted();
  }
}


```
:::

</span>

[Find this source also in **cap/samples**.](https://github.com/sap-samples/cloud-cap-samples/tree/main/bookshop/srv/cat-service.js){ .learn-more .impl .node target="_blank"}
[Find this source also in **cap/samples**.](https://github.com/SAP-samples/cloud-cap-samples-java/blob/main/srv/src/main/java/my/bookshop/handlers/CatalogServiceHandler.java#L166){ .impl .java .learn-more target="_blank"}
[Learn more about **connecting to services** using `cds.connect`.](../node.js/cds-connect){ .learn-more .impl .node}
[Learn more about **connecting to services** using `@Autowired`, `com.sap.cds.ql`, etc.](../java/services){.learn-more .impl .java}
[Learn more about **reading and writing data** using `cds.ql`.](../node.js/cds-ql){ .learn-more .impl .node}
[Learn more about **reading and writing data** using `cds.ql`.](../java/working-with-cql/query-api){ .learn-more .impl .java}
[Learn more about **using reflection APIs** using `<srv>.entities`.](../node.js/core-services#entities){ .learn-more .impl .node}
[Learn more about **typed access to data** using the CAP Java SDK.](../java/cds-data#typed-access){ .learn-more .impl .java}

**Test this implementation**, [for example using the Vue.js app](#vue), and see how discounts are displayed in some book titles. {.impl .node}

### Sample HTTP Requests

Test the implementation by submitting orders until you see the error messages. Create a file called _test.http_ and copy the request into it.

<span class="impl node">

::: code-group

```http [test.http]
### Submit Order
POST http://localhost:4004/browse/submitOrder
Content-Type: application/json
Authorization: Basic alice:

{
  "book": 201,
  "quantity": 2
}
```

:::

</span>

<span class="impl java">

::: code-group

```http [test.http]
### Submit Order
POST http://localhost:8080/odata/v4/browse/submitOrder
Content-Type: application/json
Authorization: Basic authenticated:

{
  "book": 201,
  "quantity": 2
}
```

:::

</span>


## Summary

With this getting started guide we introduced many of the basics of CAP, such as:

- [Domain Modeling](../guides/domain-modeling)
- [Providing Services](../guides/providing-services)
- [Consuming Services](../guides/using-services)
- [Using Databases](../guides/databases)
- [Serving UIs](../advanced/fiori)

Visit the [***Cookbook***](../guides/) for deep dive guides on these topics and more. Also see the reference documentations for [***CDS***](../cds/), as well as [***Node.js***](../node.js/) and [***Java***](../java/) Service SDKs and runtimes.



# Best Practices by CAP

Key Concepts & Rationales
{.subtitle}

## Introduction

### Primary Building Blocks

The CAP framework features a mix of proven and broadly adopted open-source and SAP technologies. The following figure depicts CAP's place and focus in a stack architecture.

![Vertically CAP services are placed between database and UI. Horizontally, CDS fuels CAP services and is closer to the core than, for example, toolkits and IDEs. Also shown horizontally is the integration into various platform services.](assets/architecture.drawio.svg){}

The major building blocks are as follows:

- [**Core Data Services** (CDS)](../cds/) — CAP's universal modeling language, and the very backbone of everything; used to capture domain knowledge, generating database schemas, translating to and from various API languages, and most important: fueling generic runtimes to automatically serve request out of the box.

- [**Service Runtimes**](../guides/providing-services.md) for [Node.js](../node.js/) and [Java](../java/) — providing the core frameworks for services, generic providers to serve requests automatically, database support for SAP HANA, SQLite, and PostgreSQL, and protocol adaptors for REST, OData, GraphQL, ...

- [**Platform Integrations**](../plugins/) — providing CAP-level service interfaces (*'[Calesi](#the-calesi-pattern)'*) to cloud platform services in platform-agnostic ways, as much as possible. Some of these are provided out of the box, others as plugins.

- [**Command-Line Interface** (CLI)](../tools/) — the Swiss army knife on the tools and development kit front, complemented by integrations and support in [*SAP Build Code*](https://www.sap.com/germany/products/technology-platform/developer-tools.html), *Visual Studio Code*, *IntelliJ*, and *Eclipse*.

In addition, there's a fast-growing number of [plugins](../plugins/) contributed by open-source and inner-source [communities](/resources/#public-resources) that enhance CAP in various ways, and integrate with additional tools and environments; the [*Calesi* plugins](./index.md#the-calesi-effect) are among them.



### Models fuel Runtimes

CDS models play a prevalent role in CAP applications. They're ultimately used to fuel generic runtimes to automatically serve requests, without any coding for custom implementations required.

![Models fuel Generic Services](assets/fueling-services.drawio.svg){}

CAP runtimes bootstrap *Generic Service Providers* for services defined in service models. They use the information at runtime to translate incoming requests from a querying protocol, such as OData, into SQL queries sent to the database.

:::tip Models fuel Runtimes
CAP uses the captured declarative information about data and services to **automatically serve requests**, including complex deep queries, with expands, where clauses and order by, aggregations, and so forth...
:::




### Concepts Overview

The following sections provide an overview of the core concepts and design principles of CAP. The following illustration is an attempt to show all concepts, how they relate to each other, and to introduce the terminology.

![Service models declare service interfaces, events, facades, and services. Service interfaces are published as APIs and are consumed by clients. Clients send requests which trigger events. Services are implemented in service providers, react on events, and act as facades. Facades are inferred to service interfaces and are views on domain models. Service providers are implemented through event handlers which handle events. Also, service providers read/write data which has been declared in domain models.](assets/key-concepts.drawio.svg){}

Start reading the diagram from the _Service Models_ bubble in the middle, then follow the arrows to the other concepts.
We dive into each of these concepts in the following sections, starting with _Domain Models_, the other grey bubble in the previous illustration.



## Domain Models

[CDS](../cds/) is CAP's universal modeling language to declaratively capture knowledge about an application's domain. Data models capture the *static* aspects of a domain, using the widely used technique of [*entity-relationship modeling*](https://en.wikipedia.org/wiki/Entity–relationship_model#:~:text=An%20entity–relationship%20model%20(or,instances%20of%20those%20entity%20types).). For example, a simple domain model as illustrated in this ER diagram:

![bookshop-erm.drawio](assets/bookshop-erm.drawio.svg)

In a first iteration, it would look like this in CDS, with some fields added:

::: code-group

```cds [Domain Data Model]
using { Country, cuid, managed } from '@sap/cds/common';

entity Books : cuid, managed {
  title  : localized String;
  author : Association to Authors;
}

entity Authors : cuid, managed {
  name    : String;
  books   : Association to many Books on books.author = $self;
  country : Country;
}
```

:::

[Type `Country` is declared to be an association to `sap.common.Countries`.](../cds/common#type-country) {.learn-more}


### Definition Language (CDL)

We use CDS's [*Conceptual Definition Language (CDL)*](../cds/cdl) as a *human-readable* way to express CDS models. Think of it as a *concise*, and more *expressive* derivate of [SQL DDL](https://wikipedia.org/wiki/Data_definition_language).

For processing at runtime CDS models are compiled into a *machine-readable* plain object notation, called *CSN*, which stands for [*Core Schema Notation (CSN)*](../cds/csn). For deployment to databases, CSN models are translated into native SQL DDL. Supported databases are [*SQLite*](../guides/databases-sqlite.md) and *[H2](../guides/databases-h2.md)* for development, and [_SAP HANA_](../guides/databases-hana.md) and [_PostgreSQL_](../guides/databases-postgres.md) for production.

![cdl-csn.drawio](assets/cdl-csn.drawio.svg)

See also *[On the Nature of Models](../cds/models)* in the CDS reference docs. {.learn-more}



### Associations

Approached from an SQL angle, CDS adds the concepts of (managed) *[Associations](../cds/cdl#associations)*, and [path expressions](../cds/cql#path-expressions) linked to that, which greatly increases the expressiveness of domain data models. For example, we can write queries, and hence declare views like that:

```cds [Using Associations]
entity EnglishBooks as select from Books
where author.country.code = 'GB';
```

This is an even more compact version, using *[infix filters](../cds/cql#with-infix-filters)* and *navigation*.

```cds
entity EnglishBooks as select from Authors[country.code='GB']:books;
```

::: details See how that would look like in SQL...

From a plain SQL perspective, think of *Associations* as the like of 'forward-declared joins', as becomes apparent in the following SQL equivalents of the preceding view definitions.

Path expressions in `where` clauses become *INNER JOINs*:

```sql
CREATE VIEW EnglishBooks AS SELECT * FROM Books
-- for Association Books:author:
INNER JOIN Authors as author ON author.ID = Books.author_ID
-- for Association Authors:country:
INNER JOIN Countries as country ON country.code = author.country_code
-- the actual filter condition:
WHERE country.code = 'GB';
```
Path expressions in *infix filters*  become *SEMI JOINs*, e.g.using `IN`:
```sql
CREATE VIEW EnglishBooks AS SELECT * FROM Books
-- for Association Books:author:
WHERE Books.author_ID IN (SELECT ID from Authors as author
  -- for Association Authors:country:
  WHERE author.country_code IN (SELECT code from Countries as country
    -- the actual filter condition:
    WHERE country.code = 'GB';
  )
)
```

... same with `EXISTS`, which is faster with some databases:

```sql
CREATE VIEW EnglishBooks AS SELECT * FROM Books
-- for Association Books:author:
WHERE EXISTS (SELECT 1 from Authors as author WHERE author.ID = Books.author_ID
  -- for Association Authors:country:
  AND EXISTS (SELECT 1 from Countries as country WHERE country.code = author.country_code
    -- the actual filter condition:
    AND country.code = 'GB';
  )
)
```

:::



### Aspects

A distinctive feature of CDS is its intrinsic support for [_Aspect-oriented Modeling_](../cds/aspects), which allows to factor out separate concerns into separate files. It also allows everyone to adapt and extend everything anytime, including reuse definitions you don't own, but have imported to your models.

::: code-group
```cds [Separation of Concerns]
// All authorization rules go in here, the domain models are kept clean
using { Books } from './my/clean/schema.cds';
annotate Books with @restrict: [{ grant:'WRITE', to:'admin' }];
```
```cds [Verticalization]
// Everyone can extend any definitions, also ones they don't own:
using { sap.common.Countries } from '@sap/cds/common';
extend Countries with { county: String } // for UK, ...
```
```cds [Customization]
// SaaS customers can do the same for their private usage:
using { Books } from '@capire/bookshop';
extend Books with { ISBN: String }
```
:::

<br/>

:::tip Key features & qualities
CDS greatly promotes **Focus on Domain** by a *concise* and *comprehensible* language. Intrinsic support for *aspect-oriented modeling* fosters **Separation of Concerns**, as well as **Extensibility** in customization, verticalization, and composition scenarios.
:::





## Services

Services are the most central concept in CAP when it comes to an application's behavior. They're  declared in CDS, frequently as views on underlying data, and implemented by services providers in the CAP runtimes. This ultimately establishes a **Service-centric Paradigm** which manifests in these **key design principles**:

- **Every** active thing is a **service** → _yours, and framework-provided ones_{.grey}
- Services establish **interfaces** → *declared in service models*{.grey}
- Services react to **events** → *in sync and async ones*{.grey}
- Services run **queries** → *pushed down to database*{.grey}
- Services are **agnostic** → *platforms and protocols*{.grey}
- Services are **stateless** → *process passive data*{.grey}

![Key Design Principles](assets/paradigm.drawio.svg)

:::tip Design principles and benefits
The design principles - and adherence to them - are crucial for the key features & benefits.
:::

### Services as Interfaces

Service models capture the *behavioral* aspects of an application. In its simplest form a service definition, focusing on the *interface* only, could look like that:

::: code-group

```cds [Service Definition in CDS]
service BookshopService {
  entity Books : cuid { title: String; author: Association to Authors }
  entity Authors :cuid { name: String; }
  action submitOrder ( book: UUID, quantity: Integer );
}
```

:::

### Services as Facades

Most frequently, services expose denormalized views of underlying domain models. They act as facades to an application's core domain data. The service interface results from the _inferred_ element structures of the given projections.

For example, if we take the [*bookshop* domain model](../get-started/in-a-nutshell#capture-domain-models) as a basis, we could define a service that exposes a flattened view on books with authors names as follows (note and click on the *⇒ Inferred Interface* tab):

::: code-group

```cds [Service as Facade]
using { sap.capire.bookshop as underlying } from '../db/schema';
service CatalogService {
  @readonly entity ListOfBooks as projection on underlying.Books {
    ID, title, author.name as author // flattened
  }
}
```

```cds [⇒ &nbsp; Inferred Interface]
service CatalogService {
  @readonly entity ListOfBooks {
    key ID : UUID;
    title  : String;
    author : String, // flattened authors.name
  }
}
```

[Learn more about `as projection on` in the **Querying** section below](#querying). {.learn-more}

:::

::: tip **Single-purposed Services**
The previous example follows the recommended best practice of a *[single-purposed service](../guides/providing-services#single-purposed-services)* which is specialized on *one* specific use case and group of users. Learn more about that in the [Providing Services](../guides/providing-services) guide.
:::

### Service Providers

As we'll learn in the next chapter after this, service providers, that is the implementations of services, react to events, such as a request from a client, by registering respective event handlers. At the end of the day, a service implementation is **the sum of all event handlers** registered with this service.

[More about service implementations through *Event Handlers* in the next chapter](#events) {.learn-more}



### Not Microservices

Don't confuse CAP services with Microservices:

- **CAP services** are modular software components, while ...
- **Microservices** are deployment units.

CAP services are important for how you *design* and *implement* your applications in clean and modularized ways on a fine-granular use case-oriented level. The primary focus of Microservices is on how to cut your whole application into independent coarse-grained(!) deployment units, to release and scale them independently.

[Learn more about that in the *Anti Patterns* section on Microservices](bad-practices#microservices-mania) {.learn-more}

## Events

While services are the most important concept for models and runtime, events are equally, if not more, important to the runtime. CAP has a *ubiquitous* notion of events: they show up everywhere, and everything is an event, and everything happening at runtime is in reaction to events.
We complement our [*Service-centric Paradigm*](#services) by these additional **design principles**:

- **Everything** happening at runtime is triggered by / in reaction to **events**
- **Providers** subscribe to, and *handle* events, as their implementations
- **Observers** subscribe to, and *listen* to events 'from the outside'
- Events can be of ***local*** or ***remote*** origin, and be...
- Delivered via ***synchronous*** or ***asynchronous*** channels



### Event Handlers

Services react to events by registering *event handlers*.

![event-handlers.drawio](assets/event-handlers.drawio.svg)

This is an example of that in Node.js:

```js
class BookshopService extends cds.ApplicationService { init() {
  const { Books } = this.entities
  this.before ('UPDATE', Books, req => validate (req.data))
  this.after ('READ', Books, books => ... )
  this.on ('SubmitOrder', req => this.emit ('BookOrdered',req.data))
}}
```

You can also register *generic* handlers, acting on classes of similar events:

```js
this.before ('READ','*', ...)   // for READ requests to all entities
this.before ('*','Books', ...)  // for all requests to Books
this.before ('*', ...)          // for all requests served by this srv
```

::: info What constitutes a service implementation?
The service's implementation consists of all event handlers registered with it.
:::



### Event Listeners

The way we register event handlers that *implement* a service looks similar to how we register similar handlers for the purpose of just *listening* to what happens with other services. At the end of the day, the difference is only to *whom* we register event listeners.

::: code-group

```js [Service Provider]
class SomeServiceProvider { async init() {
  this.on ('SomeEvent', req => { ... })
}}
```

```js [Observer]
class Observer { async init() {
  const that = await cds.connect.to ('SomeService')
  that.on ('SomeEvent', req => { ... })
}}
```

:::

::: info Service provider and observer
Everyone/everything can register event handlers with a given service. This is not limited to the service itself, as its implementation, but also includes *observers* or *interceptors* listening to events 'from the outside'.
:::





### Sync / Async

From an event handler's perspective, there's close to no difference between *synchronous requests* received from client like UIs, and *asynchronous event messages* coming in from respective message queues. The arrival of both, or either of which, at the service's interface is an event, to which we can subscribe to and react in the same uniform way, thus blurring the lines between the synchronous and the asynchronous world.

![events.drawio](assets/events.drawio.svg)

Handling synchronous requests vs asynchronous event messages:

::: code-group

```js [Handling sync Requests]
class CatalogService { async init() {
  this.on ('SubmitOrder', req => {        // sync action request
    const { book, quantity } = req.data  // process it...
  })
}}
```

```js [Handling async Events]
class AnotherService { async init() {
  const cats = await cds.connect.to ('CatalogService')
  cats.on ('BookOrdered', msg => {        // async event message
    const { book, quantity } = msg.data  // process it...
  })
}}
```

:::

Same applies to whether we *send* a request or *emit* an asynchronous event:

```js
await cats.send ('SubmitOrder', { book:201, quantity:1 })
await this.emit ('BookOrdered', { book:201, quantity:1 })
```



### Local / Remote

Services cannot only be used and called remotely, but also locally, within the same process. The way we connect to and interact with *local* services is the same as for *remote* ones, via whatever protocol:

```js
const local_or_remote = await cds.connect.to('SomeService')
await local_or_remote.send ('SomeRequest', {...data})
await local_or_remote.read ('SomeEntity').where({ID:4711})
```

Same applies to the way we subscribe to and react to incoming events:

```js
this.on ('SomeRequest', req => {/* process req.data */})
this.on ('READ','SomeEntity', req => {/* process req.query */})
```

> [!note]
>
> The way we *connect* to and *consume* services, as well as the way we *listen* and *react* to events, and hence *implement* services, are *agnostic* to whether we deal with *local* or *remote* services, as well as to whatever *protocols* are used. <br/>→ see also [*Agnostic by Design*](#agnostic-by-design)



## Data

All data processed and served by CAP services is *passive*, and represented by *plain simple* data structures as much as possible. In Node.js it's plain JavaScript record objects, in Java it's hash maps.  This is of utmost importance for the reasons set out in the following sections.

![passive-data.drawio](assets/passive-data.drawio.svg)

### Extensible Data

Extensibility, in particular in a SaaS context, allows customers to tailor a SaaS application to their needs by adding extension fields. These fields are not known at design time but need to be served by your services, potentially through all interfaces. CAP's combination of dynamic querying and passive data this is intrinsically covered and extension fields look and feel no different than pre-defined fields.

For example, an extension like that can automatically be served by CAP:

```cds
extend Books with {
   some_extension_field : String;
}
```

> [!warning]
>
> In contrast to that, common *DAOs*, *DTOs*, *Repositories*, or *Active Records* approaches which use static classes can't transport such extension data, not known at the time these classes are defined. Additional means would be required, which is not the case for CAP.

### Queried Data

As detailed out in the next chapter, querying allows service clients to ask exactly for the data they need, instead of always reading full data records, only to display a list of books titles. For example, querying allows that:

```js
let books = await GET `Books { ID, title, author.name as author }`
```

While a static DAO/DTO-based approach would look like that:

```js
let books = await GET `Books` // always read in a SELECT * fashion
```

In effect, when querying is used the shape of records in result sets vary very much, even in denormalized ways, which is hardly possible to achieve with static access or transfer objects.

### Passive Data

As, for the previously mentioned reasons, we can't use static classes to represent data at runtime, there's also no reasonable way to add any behavior to data objects. So in consequence, all data has to be passive, and hence all logic, such as for validation or field control 'determinations' has to go somewhere else → into event handlers.

> [!tip]
>
> Adhering to the principle of passive data also has other positive effects. For example:
>
> **(1)** Passive data can be easily cached in content delivery networks. &nbsp; **(2)** Passive data is more lightweight than active objects. &nbsp; **(3)** Passive data is *immutable* → which allows to apply parallelization as known from functional programming.



## Querying

As a matter of fact, business applications tend to be *data-centric*. That is, the majority of operations deal with the discipline of reading and writing data in various ways. Over the decades, querying, as known from SQL, as well as from web protocols like OData or GraphQL, became the prevalent and most successful way for this discipline.

### Query Language (CQL)

As already introduced in the [*Domain Models*](#domain-models) section, CAP uses queries in CDS models, for example to declare service interfaces by projections on underlying entities, here's an excerpt of what was mentioned earlier:

```cds
entity ListOfBooks as projection on underlying.Books {
  ID, title, author.name as author
}
```

We use [CDS's *Conceptual Query Language (CQL)*](../cds/cql) to write queries in a human-readable way. For reasons of familiarity, CQL is designed as a derivate of SQL, but used in CAP independent of SQL and databases. For example to derive new types as projections on others, or sending OData or GraphQL queries to remote services.

Here's a rough comparison of [CQL](../cds/cql.md) with [GraphQL](http://graphql.org), [OData](https://www.odata.org), and [SQL](https://en.wikipedia.org/wiki/SQL):

<span class="centered">

| Feature            |   CQL   |  GraphQL  |  OData  |   SQL   |
| ------------------ | :-----: | :-------: | :-----: | :-----: |
| CRUD               | &check; |  &check;  | &check; | &check; |
| Flat Projections   | &check; |  &check;  | &check; | &check; |
| Nested Projections | &check; |  &check;  | &check; |         |
| Navigation         | &check; | (&check;) | &check; |         |
| Filtering          | &check; |           | &check; | &check; |
| Sorting            | &check; |           | &check; | &check; |
| Pagination         | &check; |           | &check; | &check; |
| Aggregation        | &check; |           | &check; | &check; |
| Denormalization    | &check; |           |         | &check; |
| Native SQL         | &check; |           |         | &check; |

</span>

As apparent from this comparison, we can regard CQL as a superset of the other query languages, which enables us to translate from and to all of them.

### Queries at Runtime

CAP also uses queries at runtime: an OData or GraphQL request is essentially a query which arrives at a service interface. Respective protocol adapters translate these into *machine-readable* runtime representations of CAP queries (→ see [*Core Query Notation, CQN*](../cds/cqn)), which are then forwarded to and processed by target services. Here's an example, including CQL over http:

::: code-group

```sql [CQL]
SELECT from Books { ID, title, author { name }}
```

```graphql [CQL /http]
GET Books { ID, title, author { name }}
```
```graphql [GraphQL]
POST query {
  Books {
    ID, title, author {
      name
    }
  }
}
```
```http [OData]
GET Books?$select=ID,title&$expand=author($select=name)
```
```js [⇒  CAP Query (in CQN)]
{ SELECT: { from: {ref:['Books']},
    columns: [ 'ID', 'title', {ref:['author']},
      expand:[ 'name' ]
    }]
}}
```

:::

Queries can also be created programmatically at runtime, for example to send queries to a database. For that we're using *human-readable* language bindings, which in turn create CQN objects behind the scenes. For example, like that in Node.js (both creating the same CQN object as described earlier):

::: code-group

```js [Using TTL]
let books = await SELECT `from Books {
  ID, title, author { name }
}`
```

```js [Using Fluent API]
let books = await SELECT.from (Books, b => {
  b.ID, b.title, b.author (a => a.name)
})
```

:::

### Push-Down to Databases

The CAP runtimes automatically translate incoming queries from the protocol-specific query language to CQN and then to native SQL, which is finally sent to underlying databases. The idea is to push down queries to where the data is, and execute them there with best query optimization and late materialization.

![cql-cqn.drawio](assets/cql-cqn.drawio.svg)

CAP queries are **first-class** objects with **late materialization**. They're captured in CQN, kept in standard program variables, passed along as method arguments, are transformed and combined with other queries, translated to other target query languages, and finally sent to their targets for execution. This process is similar to the role of functions as first-class objects in functional programming languages.



## Agnostic by Design



In [Introduction - What is CAP](../about/index) we learned that your domain models, as well as the services, and their implementations are **agnostic to protocols**, as well whether they're connected to and consume other services **locally or remotely**. In this chapter, we complement this by CAP-level integration of platform services and vendor-independent database support.

So, in total, and in effect, we learn:

> [!tip] Your domain models and application logic stays...
>
> - Agnostic to *Local vs Remote*
> - Agnostic to *Protocols*
> - Agnostic to *Databases*
> - Agnostic to *Platform Services* and low-level *Technologies*
>
> **This is *the* key enabling quality** for several major benefits and value propositions of CAP, such as [*Fast Inner Loops*](./index#fast-inner-loops), [*Agnostic Services*](./index#agnostic-microservices), [*Late-cut Microservices*](./index.md#late-cut-microservices), and several more...





### Hexagonal Architecture



The *[Hexagonal Architecture](https://alistair.cockburn.us/hexagonal-architecture/)* (aka *Ports and Adapters Architecture/Pattern*) as first proposed by Alistair Cockburn in 2005, is quite famous and fancied these days (rightly so). As he introduces it, its intent is to:

*"Allow an application to equally be driven by users, programs, automated test or batch scripts, and to be developed and tested in isolation from its eventual run-time devices and databases"* {.indent}

... and he illustrated that like this:

![Hexagonal architecture basic.gif](https://alistair.cockburn.us/hexFig1.png)

In a nutshell, this introduction to the objectives of hexagonal architecture translates to that in our world of cloud-based business applications:

> [!tip] Objectives of Hexagonal Architecture
>
> - Your *Application* (→ the inner hexagon) should stay ***agnostic*** to *"the outside"*
> - Thereby allowing to replace *"the outside"* met in production by *mocked* variants
> - To reduce complexity and speed up turnaround times at *development*, and in *tests*
>   <br/>→ [*'Airplane Mode' Development & Tests*](index.md#fast-inner-loops)
>
> **In contrast to that**, if you (think you) are doing Hexagonal Architecture, but still find yourself trapped in a slow and expensive always-connected development experience, you might have missed a point... → the *Why* and *What*, not *How*.



#### CAP as an implementation of Hexagonal Architecture

CAP's [agnostic design principles](#agnostic-by-design) are very much in line with the goals of Hexagonal Architecture, and actually give you exactly what these are aiming for: as your applications greatly stay *agnostic* to protocols, and other low-level details, which could lock them in to one specific execution environment, they can be "*developed and tested in isolation*", which in fact is one of CAP's [key value propositions](./index#fast-inner-loops). Moreover, they become [*resilient* to disrupting changes](./index#minimized-lock-ins) in "the outside".

Not only do we address the very same goals, we can also identify several symmetries in the way we address and achieve these goals as follows:

<span class="centered">

| Hexagonal Architecture | CAP                                                          |
| ---------------------- | ------------------------------------------------------------ |
| "The Outside"          | Remote *Clients* of Services (inbound) <br/>Databases, Platform Services (outbound) |
| Adapters               | Protocol ***Adapters*** (inbound + outbound), <br/>Framework Services (outbound) |
| Ports                  | Service ***Interfaces*** + Events (inbound + outbound)       |
| Application Model      | Use-case ***Services*** + Event Handlers                     |
| Domain Model           | Domain ***Entities*** (w/ essential invariants)              |

</span>



> [!tip]
>
> CAP is very much in line with both, the intent and goals of Hexagonal Architecture, as well as with the fundamental concepts. Actually, CAP *is an implementation* of Hexagonal Architecture, in particular with respect to the [*Adapters*](#protocol-adapters) in the outer hexagon, but also regarding [*Application Models*](#application-domain) and [*(Core) Domain Models*](#application-domain) in the inner hexagon.

[Also take notice of the *Squared Hexagons* section in the Anti Patterns guide](bad-practices#squared-hexagons) {.learn-more}



### Application Domain



Looking at the things in the inner hexagon, many protagonists distinct between *application model* and *domain model* living in there. In his initial post about [*Hexagonal Architecture*](https://wiki.c2.com/?HexagonalArchitecture) in the in [*c2 wiki*](https://wiki.c2.com) Cockburn already highlighted that as follows in plain text:

​	*OUTSIDE <-> transformer <--> ( **application**  <->  **domain** )* {}

::: details Background from MVC and *Four Layers Architecture* ...

That distinction didn't come by surprise to the patterns community in c2, as Cockburn introduced his proposal as a *"symmetric"* evolution of the [*Four Layers Architecture*](https://wiki.c2.com/?FourLayerArchitecture) by Kyle Brown, which in turn is an evolution of the [*Model View Controller*](https://wiki.c2.com/?ModelViewController) pattern, invented by Trygve Reenskaug et al. at Xerox PARC.

The first MVC implementations in [*Smalltalk-80*](https://en.wikipedia.org/wiki/Smalltalk) already introduced the notion of an *[Application Model](https://wiki.c2.com/?ApplicationModel)* which acts as a *mediator* between use case-oriented application logic, and the core [*Domain Model*](https://wiki.c2.com/?DomainModel) classes, which primarily represent an application's data objects, with only the most central invariants carved in stone.

Yet, **both are agnostic** to wire protocols or ['UI widgetry'](https://wiki.c2.com/?FourLayerArchitecture) → the latter being covered and abstracted from by *Views* and *Controllers* in MVC.

:::

#### See Also...

- The [*Model Model View Controller*](https://wiki.c2.com/?ModelModelViewController) pattern in c2 wiki, in which Randy Stafford points out the need for such twofold models:

  *"... there have always been two kinds of model: [DomainModel](https://wiki.c2.com/?DomainModel), and [ApplicationModel](https://wiki.c2.com/?ApplicationModel)."* {.indent}

- [*Hexagonal Architecture and DDD (Domain Driven Design)*](https://www.happycoders.eu/software-craftsmanship/hexagonal-architecture/#hexagonal-architecture-and-ddd-domain-driven-design) by Sven Woltmann, a great end-to-end introduction to the topic, which probably has the best, and most correct illustrations, like this one:

![Hexagonal architecture and DDD (Domain Driven Design)](https://www.happycoders.eu/wp-content/uploads/2023/01/hexagonal-architecture-ddd-domain-driven-design-600x484.png){.zoom75}

#### Entities ⇒ Core Domain Model
{#core-domain-model}

Your core domain model is largely covered by CDS-declared entities, enriched with invariant assertions, which are deployed to databases and automatically served by generic service providers out of the box. Even enterprise aspects like common code lists, localized data, or temporal data are simple to add and served out of the box as well.

#### Services ⇒ Application Model

Your application models are your services, also served automatically by generic providers, complemented with your domain-specific application logic you added in custom event handlers. The services are completely agnostic to inbound and outbound protocols: they react on events in agnostic ways, and use other services in equally agnostic ways — including framework-provided ones, like database services or messaging services.

> [!tip]
>
> Your ***Core Domain Model*** is largely captured in respective [CDS data models](#domain-models), including annotations for invariants, and served automatically by CAP's generic providers.
>
> Your ***Application Model*** are CAP services, which are [also declared in CDS](#services) and served by generic providers, complemented with your domain-specific [**custom event handlers**](#event-handlers).



### Protocol Adapters

Behind the scenes, i.e., in the **outer hexagon** containing stuff, you as an application developer should not see, the CAP runtime employs Protocol Adapters, which translate requests from (and to) low-level protocols like HTTP, REST, OData, GraphQL, ... to protocol-agnostic CAP requests and queries.

- for ***inbound*** communication → i.e., requests your application *receives*, as well as as...
- for ***outbound*** communication → i.e., requests your application *sends* to other services.

In effect your service implementations stay agnostic to (wire) protocols, which allows us to exchange protocols, replace targets by mocks, do fast inner loop development in airplane mode, ... even change topologies from a monolith to micro services and vice versa late in time.

![protocol-adapters.drawio](assets/protocol-adapters.drawio.svg)

The inbound and outbound adapters (and the framework services) effectively provide your inner core with the ***ports*** to the outside world, which always provide the same, hence *agnostic* style of API (indicated by the green arrows used in the previous graphic), as already introduced in [Local  /Remote](#local-remote).

Inbound:

```js
this.on ('SomeEvent', msg => {/* process msg.data */})
this.on ('SomeRequest', req => {/* process req.data */})
this.on ('READ','SomeEntity', req => {/* process req.query */})
```

Outbound:

```js
const any = await cds.connect.to('SomeService')
await any.emit ('SomeEvent', {...data})
await any.send ('SomeRequest', {...data})
await any.read ('SomeEntity').where({ID:4711})
```

> In the latter, `any` can be any service your application needs to talk to. Local application services, remote services, CAP-based and non-CAP-based ones, as well as framework-provided services, such as database services, or messaging services → more on that in the next section...



### Framework Services



In the figure above we see boxes for *Framework Services* and *Database Services*. Both are CAP framework-provided services, which — following our [guiding principle](#services) of *"Every active thing in CAP is a CAP service"* — are implemented as CAP services itself, and hence are also consumed via the same agnostic API style, as any other CAP service.

Overall, this is the class hierarchy implemented in the CAP runtimes:

![service-classes.drawio](assets/service-classes.drawio.svg)



The *RemoteService* box at the bottom is a CAP service proxy for remote services, which in turn used the outbound *Protocol Adapters* behind the scenes to translate outgoing requests to the target wire protocols.

The *DatabaseService* subclasses provide implementations for the different databases, thereby trying to provide a consistent, portable usage, without falling into a common denominator syndrome pit. Same for the *MessagingServices*.



## Intrinsic Extensibility



SaaS customers of CAP applications use the very same techniques than any developer can use to adapt given models or service implementations to their needs. That applies to both, models and service implementations.

### Extending Models

Everyone can extend every model definition: SaaS customers can add extension fields or new entities to respective definitions of as SaaS application's models.

In the same way, you can extend any reuse definition that you might consume from reuse packages, including the reuse models shipped with CAP itself. For example:

```cds
using { User, managed } from '@sap/cds/common';
extend managed with {
  ChangeNotes : Composition of many {
    key timestamp : DateTime;
    author : User;
    note : String(1000);
  }
}
```

This would extend the common reuse type `managed` obtained from `@sap/cds/common` to not only capture latest modifications, but a history of commented changes, with all entities inheriting from that aspect, own or reused ones, receiving this enhancement automatically.

> [!tip]
>
> Not only can your SaaS customers extend *your* definitions, but also you can extend any definitions that you *reuse* to adapt it to your needs. Adapting widely used reuse definitions, as in this example, has the advantage that you reach many existing usages.

[Learn more about these options in the CDS guide about *Aspect-oriented Modeling*](../cds/aspects). {.learn-more}



### Extension Logic

As introduced in the section on [*Event Listeners*](#event-listeners) above, everyone can add event handlers to every service. Similar to aspect-oriented modeling, this allows to extend reuse services.

For example, assumed you're using a reuse package that provides a service to manage reviews, as show-cased in the [*cap/samples* *reviews*](https://github.com/sap-samples/cloud-cap-samples/tree/main/reviews) package. And whenever a new review is added you want to do something in addition. To accomplish this, simply add a respective event handler to the reuse service like so:

```js
const ReviewsService = await cds.connect.to('ReviewsService')
ReviewsService.after ('CREATE', 'Reviews', req => {
   // do something in addition...
})
```



As a service provider you can also introduce explicitly defined business-level extension points, instead of allowing your clients to hook in to your technical event. For example as the owner of the reviews service, you could add and event like that to your service definition:

```cds
service ReviewsService { ...
   event ReviewAdded {
      subject  : ReviewedSubject;
      title    : String;
      message  : String;
      reviewer : User;
   }
}
```

And in your implementation you would emit such events like so:

```js
class ReviewsService { init() {
   this.after ('CREATE','Reviews', req => this.emit('ReviewAdded', req.data))
}}
```



With that your clients can hook in to that extension point like that:

```js
const ReviewsService = await cds.connect.to('ReviewsService')
ReviewsService.on ('ReviewAdded', msg => {
   // do something in addition...
})
```





### Extensible Framework



As stated in the introduction: "*Every active thing is a Service*". This also applies to all framework features and services, like databases, messaging, remote proxies, MTX services, and so on.

And as everyone can add event handlers to every service, you can also add event handlers to framework services, and thereby extend the core framework.

For example, you could extend CAP's primary **database service** like this:

```js
cds.db .before ('*', req => {
  console.log (req.event, req.target.name)
})
```

In the same way you could add handlers to **remote service proxies**:

```js
const proxy = await cds.connect.to ('SomeRemoteService')
proxy.on ('READ', 'Something', req => {
  // handle that remote call yourself
})
proxy.before ('READ', '*', req => {
  // modify requests before they go out
})
proxy.after ('READ', '*', result => {
  // post-process recieved responses
})
```





## The Calesi Pattern



'Calesi' stands for CAP-level Service Interfaces, and refers to the increasing numbers of BTP platform services which offer a CAP-level client library. These drastically reduce the boilerplate code applications would have to write.

For example, adding attachments required thousands of lines of code, caring for the UI, streaming of large data, size limiting, malware scanning, multitenancy, and so forth... after we provided the [Attachments plugin](../plugins/#attachments), all an application needs to do now is to add that line to an entity:

```cds
entity Foo { //...
   attachments : Composition of many Attachments; // [!code focus]
}
```



Whenever you have to integrate external services, you should follow the Calesi patterns. For example, let's take an audit logging use case: Data privacy regulations require to write audit logs whenever personal data is modified.

1. **Declare the service interface** — provide a CAP service that encapsulates outbound communication with the audit log service. Start by defining the respective service interface in CDS:

   ```cds
   service AuditLogService {

     event PersonalDataModified : LogEntry {
       subject   : DataSubject;
       changes   : many {
         field : String;
         old   : String;
         new   : String;
       };
       tenant    : Tenant;
       user      : User;
       timestamp : DateTime:
     }

   }
   ```



2. **Implement a mock variant** — Add a first service implementation: one for mocked usage during development:

   ```js
   class AuditLogService {init(){
     this.on('PersonalDataModified', msg => {
       console.log('Received audit log message', red.data)
     })
   }}
   ```

   >  [!tip]
   >
   > With that, you already fulfilled a few goals and guidelines from Hexagonal Architecture: The interface offered to your clients is agnostic and follows CAP's uniform service API style. Your consumers can use this mock implementation at development to speed up their [inner loop development](./#fast-inner-loops) phases.



3. **Provide the real impl** — Start working on the 'real' implementation that translates received audit log messages into outbound calls to the real audit log service.

   > [!note]
   >
   > You bought yourself some time for doing that, as your clients already got a working mock solution, which they can use for their development.



4. **Plug and play** —Add profile-aware configuration presets, so your consumers don't need to do any configuration at all:

   ```js
   {
     cds: {
       requires: {
         'audit-log': {
           "[development]": { impl: ".../audit-log-mock.js" },
           "[production]":  { impl: ".../the-real-audit-log-srv.js" },
         }
       }
     }
   }
   ```



5. **Served automatically?** — Check if you could automate things even more instead of having your use your service programmatically. For example, we could introduce an annotation *@PersonalData*, and write audit log entries automatically whenever an entity or element is tagged with that:

   ```js :line-numbers
   cds.on('served', async services => {
     const auditlog = await cds.connect.to('AuditLog')
     for (let each of services) {
       for (let e of each.entities) if (e['@PersonalData']) {
         each.on('UPDATE',e, auditlog.emit('PersonalDataModified', {...}))
       }
     }
   })
   ```



That example was an *outbound* communication use case. Basically, we encapsulate outbound channels with CAP Services, as done in CAP for messaging service interfaces and database services.

For *inbound* integrations, we would create an adapter, that is, a service endpoint which translates incoming messages into CAP event messages which it forwards to CAP services. With that, the actual service provider implementation is again a protocol-agnostic CAP service, which could as well be called locally, for example in development and tests.

> [!tip]
>
> Essentially, the 'Calesi' pattern is about encapsulating any external communication within a CAP-service-based interface, so that the actual consumption and/or implementation benefits from the related advantages, such as an agnostic consumption, intrinsic extensibility, automatic mocking, and so on.



# Bad Practices

## Questionable Prior Arts <UnderConstruction/>

### DAOs, DTOs, Active Records <UnderConstruction/>

- → see [Best Practices / Passive Data](best-practices#data)

### Object-Relational Mappers <UnderConstruction/>

- → see [Best Practices / Querying](best-practices#querying)

### BO-centric Frameworks <UnderConstruction/>

... which bypass or are in conflict with CAP's [key design principles](bad-practices.md), for example:

- ORM techniques like Spring repositories
- Active Records, DAOs

These would be in conflict with CAP's focus on stateless services processing passive data, as well as with the querying-based approach to read and write data.

### Determinations & Validations <UnderConstruction/>

- This might be a special thing if you come from a background where these terms were prominently positioned, accompanied by corresponding frameworks.
- Quite likely that is an SAP background, as we didn't find the term "determination" used outside of these SAP circles in that context.
- CAP is actually an offspring of a performance firefighting taskforce project, which identified such frameworks and their overly fragmented and fine-granular element level approach as one of a few root causes for framework-induced performance overheads.
- Hence CAP intentionally does not offer element-level call-level validation or determination framework, and strongly discourages combining your use of CAP with such.
- CAP does provide declarative element-level validations though → these are advisable, as we can optimize the implementations behind the scenes, which is just not possible in the imperative call-level frameworks.
-

### Sticking to DIY (or NIH) <UnderConstruction/>

Such as...

- Low-level http or OData requests
- Low-level integration with message brokers
- Database-specific things without need
- Non-CAP client libraries for BTP services

Doing so would spoil the party, for example regarding rapid local development at minimized costs, fast test pipelines, and late-cut µ services.
It would also expose your projects to risks of disruptions by changes in those rather volatile technologies.

### Always done it this way <UnderConstruction/>

- and CAP is different... for a reason, or more... ;-)



## Abstracting from CAP <UnderConstruction/>

- CAP already provides abstractions from the underlying database, the protocols, the deployment target, the client technology, and more.
- CAP is also an implementation of Hexagonal Architecture, which is an abstraction of the same kind.
- So, abstracting from CAP would be abstracting from an abstraction, which is a bad idea in general, and certainly will ensure that you won't benefit from the full power of CAP, any longer.

### Squared Hexagons <UnderConstruction/>

- As documented in the best practices guide, CAP is not only very much in line with Hexagonal Architecture, it actually *is an implementation* of it.
- So there's little need to invest into the outer hexagon → focus on the inner one
- Yet, we saw projects insisting on doing Hexagonal Architecture their own way, or maybe the very way that was discussed in some other paper, done with some other framework ...
- ... Hexagonal Arch ** 2 = ?

### Same for DDD... <UnderConstruction/>

- Focus on Domain is exactly what domain-driven design is also striving for... and there are some many commonalities in concepts and approaches.
- Yet, we saw projects insisting on doing DDD a very specific way, for example using Active Records, Spring repositories, etc.... → things [we list as bad practices above](#daos-dtos-active-records)




## Code Generators

### The Swagger Textbook

Alternative frameworks or toolsets follow code generation approaches. Swagger does so for example: One write OpenAPI documents in YAML in the [Swagger Editor](https://editor.swagger.io), and have a server package generated, for example for Node.js, which, as the included readme tells us *"... leverages the mega-awesome [swagger-tools](https://github.com/apigee-127/swagger-tools) middleware which does most all the work."* → it does so as follows:

<span class="centered">

| Feature                              |       Swagger        |          CAP          |
|--------------------------------------|:--------------------:|:---------------------:|
| Lines of code for service definition | **~555**{.h3}{.red}  | **~11**{.h3} {.green} |
| Lines of code for implementation     | **~500**{.h3} {.red} |  **0**{.h3} {.green}  |
| Size of framework library            |     16 MB {.red}     |    10 MB {.green}     |
| CRUDQ served on DB, including...     |                      |        &check;        |
| Deep Reads & Writes                  |                      |        &check;        |
| Deep Hierarchies                     |                      |        &check;        |
| Aggregations                         |                      |        &check;        |
| Pagination                           |                      |        &check;        |
| Sorting                              |                      |        &check;        |
| Search                               |                      |        &check;        |
| Filtering                            |                      |        &check;        |
| Primary Keys                         |                      |        &check;        |
| Access Control                       |                      |        &check;        |
| Localized Data                       |                      |        &check;        |
| Managed Data                         |                      |        &check;        |
| Media Data                           |                      |        &check;        |
| Temporal Data                        |                      |        &check;        |
| Fiori Draft Handling                 |                      |        &check;        |
| Exclusive Locking                    |                      |        &check;        |
| Conflict Detection (via ETags)       |                      |        &check;        |
| Data Replication (upcoming)         |                      |        &check;        |
| Data Privacy                         |                      |        &check;        |
| ...                                  |                      |        &check;        |

</span>

While code generators also have you writing less code yourself, the code is still there (to cover all that CAP covers, we could extrapolate the 500 lines of code to end up in ~5,000, maybe 50,000 ...?). To mention only the most critical consequence out of this: **No single points to fix**, as you simply can't fix code generated in the past.

::: details CDS-based service definitions vs OpenAPI documents ...

Even if we'd ignore all the other things, there still remains the difference between writing ~11 lines of concise and comprehensible CDS declarations, or ~333 lines of YAML. While the former allows to involve and closely collaborate with domain experts, the latter certainly doesn't. (And technocratic approaches like Hexagonal Architecture or Domain-Driven Design the way it's frequently done by developers don't really help either.)

:::

### Code-Generating AI <UnderConstruction/>

- Don't confuse "[*Generative AI*](https://en.wikipedia.org/wiki/Generative_artificial_intelligence)" with '*Code-generating AI*' ...
- Even though it's AI-generated the usual drawbacks for generated code apply:
  - **No single points to fix** all that code that was generated last year
  - One off approach → doesn't help much in evolutionary, iterative development
  - ...

- There's a different between a GPT-generated one-off thesis and long-lived enterprise software, which needs to adapt and scale to new requirements.

## Overly Generic Approaches <UnderConstruction/>

### The 'ODatabase' Anti Pattern <UnderConstruction/>

- Assume you have a domain model with 123 entities
- Then the easiest thing is to add a single service with 123 1:1 projections...?
- As all the rest can be done by CAP's and OData's powerful query languages, right?
- → that service is the exact opposite of a use case-oriented facade
- if you want that, don't use CAP, don't use any layered architecture at all ...s
- just connect your client directly to a SQL database in a two tier model ;-)



### Tons of Glue Code <UnderConstruction/>

- as stated, while CAP cares about the vast majority of non-functional requirements, qualities, wire protocols, low-level stuff... so that you, as an application developer should be able to put primary focus on domain.
- if you still find yourself lost in a high ratio of glue code, something has certainly gone wrong




## Microservices Mania <UnderConstruction/>

Avoid eager fragmentation into microservices. Instead, start with a monolith and cut out microservices later, when you really need them. This is what we call "late-cut microservices".

See also...

- [Microservices Mania: Are Moduliths the Saner Path to Scalable Architecture?](https://blog.payara.fish/microservices-mania-are-moduliths-the-saner-path-to-scalable-architecture)
- [Mainstream Microservices Mania Challenges Increasing with Adoption](https://www.f5.com/de_de/company/blog/mainstream-microservices-mania-challenges-increasing-with-adoption)
- [What is Better: Modular Monolith vs. Microservices](https://medium.com/codex/what-is-better-modular-monolith-vs-microservices-994e1ec70994)
- [Architecture Style: Modulith vs. Microservices](https://dzone.com/articles/architecture-style-modulith-vs-microservices)
- [Death by a Thousand Microservices](https://www.reddit.com/r/programming/comments/18crnmz/death_by_a_thousand_microservices/).



## Ignorance

When writing these guides we frequently wonder whether it is worth the effort, because we likely have to understand and to accept that we're living in times of ...

- Too long; didn't read (TL;DR)
- Too busy (→ an [anti pattern on it's own](assets/too-busy) \;-)
- Not required, as we've AI now
- I don't need to read that, as I already know (better) ...

If against all odds you are indeed just reading these lines, please leave a trace about that in [blue sky](https://bsky.app) with this content (including link):

*[I read it! ☺️](#ignorance) <br/>
#sapcap*
{.indent}

... to let the others out there know that there's hope, and some hi, left... \:-)

And in case you are just reading these lines, because of these posts, we strongly encourage you to read these new guides, even if (you think) you already know CAP:

- *[Introduction – What is CAP?](./index) → Value Propositions*
- *[Best Practices](best-practices) → Key Concepts & Rationales*
- *[Anti Patterns](bad-practices) → Do's and **don'ts***

And after you did that, would be great if you'd leave another trace about that in [blue sky](https://bsky.app) with this content (including link):

*[I really read it! 🤓](#ignorance) <br/>
#sapcap*
{.indent}

... as a motivation for us to keep on writing, and that it is worth the effort.



# Learning Sources



## This Documentation

This documentation — named _'capire'_, italian for understand — is the primary source of information for the SAP Cloud Application Programming Model.

It's organized as follows:

| Section                                                                                  | Description                                                                                                        |
|------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------|
| [Getting&nbsp;Started](./) <br/> [Cookbook](../guides/) <br/> [Advanced](../advanced/)   | **Task-oriented guides** that walk you through the most common tasks and advanced topics in CAP-based development. |
| [CDS](../cds/) <br/> [Java](../java/) <br/> [Node](../node.js/) <br/> [Tools](../tools/) | **Reference docs** for respective areas.                                                                           |
| [Plugins](../plugins/)                                                                   | **Curated list of plugins** that extend the capabilities of the CAP framework.                                     |
| [Releases](../releases/)                                                                 | The place where you can stay up to date with the most recent information about new features and changes in CAP.        |


### Node/Java Toggles


### Feature Status Badges

Within the docs, you find badges that indicate the status of a feature, or API.
Here's a list of the badges and their meanings:

| Badge                                   | Description                                                                                                                                                        |
|-----------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <Since version="1.2.3" of="@sap/..." /> | The marked feature is available with the given version or higher                                                                                                   |
| <Alpha />                               | Alpha features are experimental. They may never be generally available. If released subsequently, the APIs and behavior might change                               |
| <Beta />                                | Beta features are planned to be generally available in subsequent releases, however, APIs and their behavior are not final and may change in the general release   |
| <Concept />                             | Concept features are ideas for potential future enhancements and an opportunity for you to give feedback. This is not a commitment to implement the feature though |
| <Internal />                            | SAP specific features, processes, or infrastructure. Examples are _Deploy with Confidence_, _SAP product standards_, or _xMake_                                    |


### CAP Notebooks Integration





## Sample Projects

In here, we collected several interesting sample projects for you. Not all of them are maintained by the CAP team, not all of them cover CAP in its entirety, but they are well-prepared sources we can recommend for your learning. From the short description we provide for every resource, you're hopefully able to tell if that fits to the need you're currently having.




### Bookshop by capire {.github}

> [![]()](https://github.com/sap-samples/cloud-cap-samples-java){.java}
> [![]()](https://github.com/sap-samples/cloud-cap-samples){.node}

The bookshop sample is our original sample provided by the CAP team and featured in the [getting started guides](../get-started/in-a-nutshell).
It's available in both Node.js and Java. The Node.js variant contains additional samples besides bookshop that demonstrate various features of CAP.


### Incidents Mgmt {.github}

> [![]()](https://github.com/cap-java/incidents-app){.java}
> [![]()](https://github.com/cap-js/incidents-app){.node}

A reference sample application for CAP and the SAP BTP Developer Guide.


### CAP SFlight {.github}

> [![]()](https://github.com/sap-samples/cap-sflight){.java}
> [![]()](https://github.com/sap-samples/cap-sflight){.node}

This sample is a CAP adaptation of the popular [SFLIGHT](https://blog.sap-press.com/what-is-sflight-and-the-flight-and-booking-data-model-for-abap) sample app in ABAP. It's a great source for how to add SAP **Fiori** applications to a CAP project, including adding UI test suites on various stacks.


### Star Wars App {.github}

> [![]()](https://github.com/SAP-samples/cloud-cap-hana-swapi){.node}

SWAPI - the Star Wars API. This sample is based upon the sample at [swapi.dev](https://swapi.dev) which in turn was based upon [swapi.co](https://swapi.dev/about). The original source can be found at https://github.com/Juriy/swapi.

The projects described previously have fallen out of maintenance but still offered the opportunity for a fun yet challenging learning experience from a non-trivial data model. The many bi-directional, many-to-many relationships with the data provide a good basis for an SAP Cloud Application Programming Model and Fiori Draft UI sample. {.indent}


### BTP SusaaS App {.github}

> [![]()](https://github.com/SAP-samples/btp-cap-multitenant-saas){.node}

The Sustainable SaaS (SusaaS) sample application has been built in a partner collaboration to help interested developers, partners, and customers in developing multitenant Software as a Service applications using CAP and deploying them to the SAP Business Technology Platform (SAP BTP).



### Partner Reference App {.github}

> [![]()](https://github.com/SAP-samples/partner-reference-application){.node}

The Partner Reference Application repository provides you with a “golden path” to becoming a SaaS provider of multitenant applications based on the SAP Business Technology Platform (SAP BTP).
The guidance covers building, running, and integrating scalable full-stack cloud applications. It includes an ERP-agnostic design that lets you deliver your application as a side-by-side extension to consumers using any SAP solution, such as SAP S/4HANA Cloud, SAP Business One, and SAP Business ByDesign.

By using BTP services and the SAP Cloud Application Programming Model (CAP), your application meets SAP standards for enterprise-class business solutions. It offers a harmonized user experience and seamless integration, including:
- centralized identity and access management,
- a common launchpad,
- cross-application front-end navigation,
- and secure back-channel integration.

The repository includes the “Poetry Slam Manager” application as a ready-to-run example. It also provides tutorials on how to build the application from scratch using an incremental development approach.
Based on this sample application, you find the bill of materials and a sizing example. This addresses the question "Which BTP resources do I need to subscribe to and in what quantities?" and serves as a basis for cost calculation.

<span id="prdstdcap" />
<Fragment target="#prdstdcap" type="">

### Product Standard Boilerplate {.github}

> [![]()](https://github.tools.sap/PRDSTDCAP/PRDSTDCAP_MAIN_2){.github}

This repository is a sample CAP application, based on the bookstore example on capire. We intend to fulfill as many product standards as possible. You can use it as a boilerplate for new applications, and as a reference for how to fulfill product standards. We [documented](https://github.tools.sap/PRDSTDCAP/PRDSTDCAP_MAIN_2/blob/main/README.Standards.md) how we fulfill each requirement. You can also contribute your best practices on how to fulfill certain product standard requirements to this repository as a pull request.

<iframe id="kmsembed-1_e8icoxas" height="288" src="https://video.sap.com/embed/secure/iframe/entryId/1_e8icoxas/uiConfId/54310412/st/0" class="kmsembed" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" referrerPolicy="no-referrer-when-downgrade" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Boilerplate for CAP Pitch - Hyperthon 2025"></iframe>


</Fragment>

## Open Source Projects

- Plugins by SAP + CAP Teams
- Plugins by Community
- ...


## Learning Journeys

- [Getting started with SAP Cloud Application Programming Model](https://learning.sap.com/learning-journeys/getting-started-with-sap-cloud-application-programming-model) (Beginner)
- [Building side-by-side extensions on SAP BTP](https://learning.sap.com/learning-journeys/build-side-by-side-extensions-on-sap-btp) (Intermediate)

## SAP Discovery Center Missions
- [Develop a Full-Stack CAP Application Following the SAP BTP Developer's Guide](https://discovery-center.cloud.sap/missiondetail/4327/4608/)
- [Develop a Side-by-Side CAP-Based Extension Application Following the SAP BTP Developer's Guide](https://discovery-center.cloud.sap/missiondetail/4426/4712/)
- [Implement Observability in a Full-Stack CAP Application Following SAP BTP Developer's Guide](https://discovery-center.cloud.sap/missiondetail/4432/4718/)


## Tutorials

- [TechEd 2023 Hands-On Session AD264 – Build Extensions with CAP](https://github.com/SAP-samples/teched2023-AD264/)
- [TechEd 2022 Hands-On Session AD264 – Verticalization, Customization, Composition](https://github.com/SAP-archive/teched2022-AD264)
- [Build a Business Application Using CAP for Node.js](https://developers.sap.com/mission.cp-starter-extensions-cap.html)
- [Build a Business Application Using CAP for Java](https://developers.sap.com/mission.cap-java-app.html)
- [CAP Service Integration CodeJam](https://github.com/sap-samples/cap-service-integration-codejam) by DJ Adams



## Videos

- [The Art and Science of CAP](https://www.youtube.com/playlist?list=PL6RpkC85SLQAe45xlhIfhTYB9G0mdRVjI) <br> by DJ Adams and Daniel Hutzel
- [Back to basics: CAP Node.js](https://www.youtube.com/playlist?list=PL6RpkC85SLQBHPdfHQ0Ry2TMdsT-muECx) <br> by DJ Adams
- [Hybrid Testing and Alternative DBs](https://youtu.be/vqub4vJbZX8?si=j5ZkPR6vPb59iBBy) <br> by Thomas Jung
- [Consume External Services](https://youtu.be/rWQFbXFEr1M) <br> by Thomas Jung
- [Building a CAP app in 60 min](https://youtu.be/zoJ7umKZKB4) <br> by Martin Stenzig
- [Integrating an external API into a CAP service](https://youtu.be/T_rjax3VY2E) <br> by DJ Adams



## Blogs

- [Surviving and Thriving with the SAP Cloud Application Programming Model](https://community.sap.com/t5/tag/CAPTricks/tg-p/board-id/technology-blog-sap)  <br> by Max Streifeneder (2023)
- [Multitenant SaaS applications on SAP BTP using CAP? Tried-and-True!](https://community.sap.com/t5/technology-blogs-by-sap/multitenant-saas-applications-on-sap-btp-using-cap-tried-and-true/ba-p/13541907) <br> by Martin Frick (2022)

<div id="secondary-file">get-started/learning-sources.fragment.md</div>







# Features Overview

Following is an index of the features currently covered by CAP, with status and availability information. In addition, we also list features, which are planned or already in development, but not yet generally available, to give you an idea about our roadmap.


#### Legend

|  Tag  | Explanation                                       |
|:-----:|---------------------------------------------------|
| <X/>  | generally and publicly available today            |
| <Na/> | not applicable for this combination               |
| <D/>  | in progress; likely to become available near-term |
| <O/>  | we might pick that up for development soon        |
| <C/>  | not scheduled for development by us so far        |
| <Ac/> | already active contribution                       |

### CLI & Tools Support

| CLI commands                                                               |                            |
|----------------------------------------------------------------------------|----------------------------|
| [Jump-start cds-based projects](../get-started/)                           | `cds init <project>`       |
| [Add a feature to an existing project](../tools/cds-cli#cds-add)           | `cds add <facets>`         |
| [Add models from external sources](../guides/using-services#local-mocking) | `cds import <api>`         |
| [Compile cds models to different outputs](../node.js/cds-compile)          | `cds compile <models>`     |
| [Run your services in local server](../node.js/cds-serve)                  | `cds serve <services>`     |
| [Run and restart on file changes](../get-started/in-a-nutshell)            | `cds watch`                |
| [Read-eval-event loop](../node.js/cds-env#cli)                | `cds repl`                 |
| Inspect effective configuration                                            | `cds env`                  |
| Prepare for deployment                                                     | `cds build`                |
| Deploy to databases or cloud                                               | `cds deploy`               |
| Login to multitenant SaaS application                                      | `cds login <app-url>`      |
| Upgrade SaaS tenant(s) to latest versions                                  | `cds upgrade`              |
| Logout from multitenant SaaS application                                   | `cds logout`               |
| Subscribe a tenant to a SaaS application                                   | `cds subscribe <tenant>`   |
| Unsubscribe a tenant from a SaaS application                               | `cds unsubscribe <tenant>` |
| Pull the base model for a SaaS extension                                   | `cds pull`                 |
| Push a SaaS extension                                                      | `cds push`                 |


> Run `cds help <command>` to find details about an individual command. Use `cds version` to check the version that you've installed. To know what is the latest version, see the [Release Notes](../releases/) for CAP.

<br>

| Editors/IDE Support      | Application Studio | VS Code |
|--------------------------|:------------------:|:-------:|
| CDS Syntax Highlighting  |        <X/>        |  <X/>   |
| CDS Code Completion      |        <X/>        |  <X/>   |
| CDS Prettifier           |        <X/>        |  <X/>   |
| Advanced Debug/Run Tools |        <X/>        |         |
| Project Explorer         |        <X/>        |         |
| ...                      |                    |         |


### CDS Language & Compiler

|                                                                                                                   | CDS  |
|-------------------------------------------------------------------------------------------------------------------|:----:|
| [Entity-Relationship Modeling](../cds/cdl#entities)                                                               | <X/> |
| [Custom-defined Types](../cds/cdl#types)                                                                          | <X/> |
| [Views / Projections ](../cds/cdl#views)                                                                          | <X/> |
| [Associations & Compositions](../cds/cdl#associations)                                                            | <X/> |
| [Annotations](../cds/cdl#annotations) &rarr; [Common](../cds/annotations), [OData](../advanced/odata#annotations) | <X/> |
| [Aspects](../guides/domain-modeling#aspects)                                                                      | <X/> |
| [Services...](../cds/cdl#services)                                                                                | <X/> |
| [&mdash; w/ Redirected Associations](../cds/cdl#auto-redirect)                                                    | <X/> |
| [&mdash; w/ Auto-exposed Targets](../cds/cdl#auto-expose)                                                         | <X/> |
| [&mdash; w/ Actions & Functions](../cds/cdl#actions)                                                              | <X/> |
| [&mdash; w/ Events](../cds/cdl#events)                                                                            | <X/> |
| [Managed Compositions of Aspects](../cds/cdl#managed-compositions)                                                | <X/> |
| [Structured Elements](../cds/cdl#structured-types)                                                                | <X/> |
| Nested Projections                                                                                                | <D/> |
| [Calculated Elements](../cds/cdl#calculated-elements)                                                             | <X/> |
| Managed _n:m_ Associations                                                                                        | <O/> |
| Pluggable CDS Linter                                                                                              | <D/> |
| [CDS Linter](../tools/cds-lint/)                                                                                  | <X/> |

### Providing Services

| Core Framework Features                                                                    |  CDS  | Node.js | Java |
|--------------------------------------------------------------------------------------------|:-----:|:-------:|:----:|
| [Automatically Serving CRUD Requests](../guides/providing-services#generic-providers)      | <Na/> |  <X/>   | <X/> |
| [Deep-Read/Write Structured Documents](../guides/providing-services#deep-reads-and-writes) | <X/>  |  <X/>   | <X/> |
| [Automatic Input Validation](../guides/providing-services#input-validation)                | <X/>  |  <X/>   | <X/> |
| [Auto-filled Primary Keys](../guides/domain-modeling#prefer-uuids-for-keys)                | <X/>  |  <X/>   | <X/> |
| [Implicit Paging](../guides/providing-services#implicit-pagination)                        | <X/>  |  <X/>   | <X/> |
| [Implicit Sorting](../guides/providing-services#implicit-sorting)                          | <X/>  |  <X/>   | <X/> |
| [Access Control](../guides/security/authorization)                                         | <X/>  |  <X/>   | <X/> |
| [Arrayed Elements](../cds/cdl#arrayed-types)                                               | <X/>  |  <X/>   | <X/> |
| [Streaming & Media Types](../guides/providing-services#serving-media-data)                 | <X/>  |  <X/>   | <X/> |
| [Conflict Detection through _ETags_](../guides/providing-services#etag)                    | <X/>  |  <X/>   | <X/> |
| [Authentication via JWT](../guides/security/authorization#prerequisite-authentication)     | <Na/> |  <X/>   | <X/> |
| [Basic Authentication](../guides/security/authorization#prerequisite-authentication)       | <Na/> |  <X/>   | <X/> |


<br>

| Enterprise Features                                                                                                |  CDS  | Node.js | Java |
|--------------------------------------------------------------------------------------------------------------------|:-----:|:-------:|:----:|
| [Authorization](../guides/security/authorization)                                                                  | <X/>  |  <X/>   | <X/> |
| [Analytics in Fiori](../advanced/odata#data-aggregation)                                                           | <X/>  |  <D/>   | <X/> |
| [Localization/i18n](../guides/i18n)                                                                                | <X/>  |  <X/>   | <X/> |
| [Localized Data](../guides/localized-data)                                                                         | <X/>  |  <X/>   | <X/> |
| [Temporal Data](../guides/temporal-data)                                                                           | <X/>  |  <X/>   | <X/> |
| [Managed Data](../guides/domain-modeling#managed-data)                                                             | <X/>  |  <X/>   | <X/> |
| [Dynamic Extensibility](../guides/extensibility/)                                                                  | <X/>  |  <X/>   | <X/> |
| Monitoring / Logging [[Node.js](../node.js/cds-log)\|[Java](../java/operating-applications/observability#logging)] | <Na/> |  <X/>   | <X/> |
| Audit Logging [[Node.js](../guides/data-privacy/audit-logging)\|[Java](../java/auditlog)]                          | <Na/> |  <X/>   | <X/> |


<br>

| Inbound Protocol Support                              | CDS <sup>1</sup> |      Node.js      |       Java        |
|-------------------------------------------------------|:----------------:|:-----------------:|:-----------------:|
| [REST/OpenAPI](/advanced/publishing-apis/openapi)     |       <X/>       |       <X/>        |       <X/>        |
| [OData V2](../advanced/odata#v2-support) <sup>2</sup> |       <X/>       | <X/> <sup>3</sup> |       <X/>        |
| OData V4                                              |       <X/>       |       <X/>        |       <X/>        |
| OData V4 for APIs                                     |       <D/>       |       <D/>        |       <D/>        |
| GraphQL<sup>4</sup>                                   |       <C/>       | <X/><sup>5</sup>  | <C/> <sup>6</sup> |


<br>

> <sup>1</sup> Export CDS models to ... <br>
> <sup>2</sup> To support customers with existing OData V2 UIs<br>
> <sup>3</sup> Through [V2 proxy](../advanced/odata#odata-v2-adapter-node)  <br>
> <sup>4</sup> Could be a good case for 3rd-party contribution <br>
> <sup>5</sup> For Node.js try out the [GraphQL Adapter](/plugins/#graphql-adapter) <br>
> <sup>6</sup> For Java try out the provided [sample code](https://github.com/SAP-samples/cloud-cap-samples-java/commit/16dc5d9a1f103eb1336405ee601dc7004f70538f). <br>


### Consuming Services

| [Service Consumption APIs](../guides/using-services) | Node.js | Java |
|------------------------------------------------------|:-------:|:----:|
| Uniform Consumption APIs → Hexagonal Architecture    |  <X/>   | <X/> |
| Dynamic Querying                                     |  <X/>   | <X/> |
| Programmatic Delegation                              |  <X/>   | <X/> |
| Generic Delegation                                   |  <O/>   | <O/> |
| Resilience (retry, circuit breaking, ...)            |  <C/>   | <X/> |


<br>

| Outbound Protocol Support                                        | CDS <sup>1</sup> | Node.js | Java |
|------------------------------------------------------------------|:----------------:|:-------:|:----:|
| [REST/OpenAPI](../tools/apis/cds-import#cds-import-from-openapi) |       <X/>       |  <X/>   | <X/> |
| OData V2                                                         |       <X/>       |  <X/>   | <X/> |
| OData V4                                                         |       <X/>       |  <X/>   | <X/> |
| GraphQL<sup>2</sup>                                              |       <C/>       |  <C/>   | <C/> |

> <sup>1</sup> Import API to CSN <br>
> <sup>2</sup> Could be a good case for 3rd-party contribution <br>

[Learn more about supported features for consuming services.](../guides/using-services){.learn-more}

### Events / Messaging

|                                                                                                                                                             | CDS   | Node.js                   | Java                      |
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|:-----:|:-------------------------:|:-------------------------:|
| [Declared Events in CDS](../cds/cdl#events)                                                                                                                 | <X/>  | <X/>                      | <X/>                      |
| Mock Broker (to speed up local dev) [[Node.js](../node.js/messaging#file-based)\|[Java](../java/messaging#local-testing)]                                   | <Na/> | <X/>                      | <X/>                      |
| [SAP Cloud Application Event Hub](../guides/messaging/event-broker)                                                                                            | <Na/> | <X/><br><sup>plugin</sup> | <X/><br><sup>plugin</sup> |
| [SAP Event Mesh](../guides/messaging/event-mesh)                                                                                                            | <Na/> | <X/>                      | <X/>                      |
| Composite Messaging (routing by configuration) [[Node.js](../node.js/messaging#composite-messaging)\|[Java](../java/messaging#composite-messaging-service)] | <Na/> | <X/>                      | <X/>                      |
| Import AsyncAPI                                                                                                                                             | <O/>  |                           |                           |
| Export AsyncAPI                                                                                                                                             | <X/>  |                           |                           |

<span id="events-messaging-more" />
<Fragment target="#events-messaging-more">

##### Internal Features <Internal />

The following additional features are available SAP-internally:

|                                                                                                                                          |  CDS  |         Node.js           |          Java             |
|------------------------------------------------------------------------------------------------------------------------------------------|:-----:|:-------------------------:|:-------------------------:|
| [SAP Cloud Application Event Hub (Multitenancy)](../guides/messaging/event-broker#multitenancy)                                             | <Na/> | <X/><br><sup>plugin</sup> | <X/><br><sup>plugin</sup> |
| [SAP Event Mesh (Multitenancy)](../guides/messaging/event-mesh#multitenancy)                                                             | <Na/> |           <X/>            |          <X/>             |
| SAP Message Queuing [[Node.js](../node.js/messaging#sap-message-queuing)\|[Java](../java/messaging#configuring-message-queuing-support)] | <Na/> |           <X/>            |          <X/>             |
| [Event Logs (Kafka)](../java/messaging#configuring-apache-kafka-support)                                                                 | <Na/> | <X/><br><sup>beta</sup>   | <X/><br><sup>beta</sup>   |

</Fragment>

### Database Support

|                                                                 | CDS/deploy | Node.js | Java |
|-----------------------------------------------------------------|:----------:|:-------:|:----:|
| [SAP HANA](../guides/databases)                                 |    <X/>    |  <X/>   | <X/> |
| [SAP HANA Cloud](../guides/databases-hana)                      |    <X/>    |  <X/>   | <X/> |
| [PostgreSQL](../guides/databases-postgres)                      |    <X/>    |  <X/>   | <X/> |
| [SQLite](../guides/databases-sqlite) <sup>1</sup>               |    <X/>    |  <X/>   | <X/> |
| [H2](../java/cqn-services/persistence-services#h2) <sup>1</sup> |    <X/>    |  <Na/>  | <X/> |
| [MongoDB](../guides/databases) out of the box                   |   <Na/>    |  <Na/>  | <D/> |
| Pluggable drivers architecture                                  |    <D/>    |  <D/>   | <X/> |
| Out-of-the-box support for other databases?                     |    <C/>    |  <C/>   | <C/> |


> <sup>1</sup> To speed up development. Not for productive use! <br>

> Note: You can already integrate your database of choice in a project or a contribution level. The last two are meant to further facilitate this by out-of-the-box features in CAP.






### UIs/Frontend Support

|                                                                                                         | CDS  | Node.js | Java |
|---------------------------------------------------------------------------------------------------------|:----:|:-------:|:----:|
| [Serving Fiori UIs](../advanced/fiori)                                                                  | <X/> |  <X/>   | <X/> |
| [Fiori Annotations in CDS](../advanced/fiori#fiori-annotations)                                         | <X/> |  <X/>   | <X/> |
| [Advanced Value Help](../advanced/fiori#value-helps)                                                    | <X/> |  <X/>   | <X/> |
| [Draft Support](../advanced/fiori#draft-support)                                                        | <X/> |  <X/>   | <X/> |
| [Draft for Localized Data](../advanced/fiori#draft-for-localized-data)                                  | <X/> |  <X/>   | <X/> |
| [Support for Fiori Analytics](../advanced/analytics)                                                    | <X/> |  <D/>   | <X/> |
| [Support for other UI technologies, for example Vue.js](../get-started/in-a-nutshell#vue)  <sup>1</sup> | <X/> |  <X/>   | <X/> |

>  <sup>1</sup> through standard REST/AJAX


### Platform Support & Integration

|                                                                                | Node.js | Java |
|--------------------------------------------------------------------------------|:-------:|:----:|
| [Deploy to/run on _SAP BTP, Cloud Foundry environment_](../guides/deployment/) |  <X/>   | <X/> |
| Deploy to/run on _Kubernetes_<sup>1</sup>                                      |  <D/>   | <D/> |
| [Deploy to/run on _Kyma_](../guides/deployment/to-kyma)                        |  <X/>   | <X/> |
| [SaaS on-/offboarding](../guides/multitenancy/)                                |  <X/>   | <X/> |
| [Multitenancy](../guides/multitenancy/)                                        |  <X/>   | <X/> |
| [Health checks](/guides/deployment/health-checks)                              |  <X/>   | <X/> |

> <sup>1</sup> Available on plain Kubernetes level &rarr; see [blog post by Thomas Jung](https://blogs.sap.com/2019/07/16/running-sap-cloud-application-programming-model-with-connection-to-hana-on-kubernetes/) <br>


### Extensibility

|                                                                                          |      |
|------------------------------------------------------------------------------------------|:----:|
| [Tenant-Specific Extensions](../guides/extensibility/)                                   | <X/> |
| [Adding Extension Fields](../guides/extensibility/customization#about-extension-models)  | <X/> |
| [Adding new Entities](../guides/extensibility/customization#about-extension-models)      | <X/> |
| [Adding new Relationships](../guides/extensibility/customization#about-extension-models) | <X/> |
| [Adding/Overriding Annotations](../guides/extensibility/customization)                   | <X/> |
| Adding Events                                                                            | <O/> |
| [Extension Namespaces](../guides/extensibility/customization)                            | <X/> |
| [Extension Templates](../guides/extensibility/customization#templates)                   | <X/> |
| Custom Governance Checks                                                                 | <D/> |
| [Generic Input Validations](../guides/providing-services#input-validation)               | <X/> |
| Declarative Constraints                                                                  | <O/> |
| Execute Sandboxed Code                                                                   | <O/> |
| Runtime API for In-App Extensibility                                                     | <D/> |
| Propagating Extensions across (µ) Services                                               | <O/> |

<div id="secondary-file">about/features.fragment.md</div>


# Troubleshooting

Find here common solutions to frequently occurring issues.

## Setup {#setup}


### Can't start VS Code from Command Line on macOS {#vscode-macos}

In order to start VS Code via the `code` CLI, users on macOS must first run a command (*Shell Command: Install 'code' command in PATH*) to add the VS Code executable to the `PATH` environment variable. Read VS Code's [macOS setup guide](https://code.visualstudio.com/docs/setup/mac) for help.



### Check the Node.js version { #node-version}

Make sure you run the latest long-term support (LTS) version of Node.js with an even number like `20`. Refrain from using odd versions, for which some modules with native parts will have no support and thus might even fail to install. Check version with:

```sh
node -v
```

Should you see an error like "_Node.js v1... or higher is required for `@sap/cds ...`._" on server startup, upgrade to the indicated version at the minimum, or even better, the most recent LTS version.
For [Cloud Foundry](https://docs.cloudfoundry.org/buildpacks/node/index.html#runtime), use the `engines` field in _package.json_.

[Learn more about the release schedule of **Node.js**.](https://github.com/nodejs/release#release-schedule/){.learn-more}
[Learn about ways to install **Node.js**.](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm){.learn-more}

### Check access permissions on macOS or Linux

In case you get error messages like `Error: EACCES: permission denied, mkdir '/usr/local/...'` when installing a global module like `@sap/cds-dk`, configure `npm` to use a different directory for global modules:

```sh
mkdir ~/.npm-global ; npm set prefix '~/.npm-global'
export PATH=~/.npm-global/bin:$PATH
```

Also add the last line to your user profile, for example, `~/.profile`, so that future shell sessions have changed `PATH` as well.

[Learn more about other ways to handle this **error**.](https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally){.learn-more}

### Check if your environment variables are properly set on Windows

Global npm installations are stored in a user-specific directory on your machine. On Windows, this directory usually is:

```sh
C:\Users\<your-username>\AppData\Roaming\npm
```

Make sure that your `PATH`-environment variable contains this path.

In addition, set the variable `NODE_PATH` to: <br /> ``C:\Users\<your-username>\AppData\Roaming\npm\node_modules``.


### How Do I Consume a New Version of CDS? { #cds-versions}

* Design time tools like `cds init`:

    Install and update `@sap/cds-dk` globally using `npm i -g @sap/cds-dk`.

* Node.js runtime:

    Maintain the version of `@sap/cds` in the top-level _package.json_ of your application in the `dependencies` section.

    [Learn more about recommendations on how to manage **Node.js dependencies**.](../node.js/best-practices#dependencies){.learn-more}


* CAP Java SDK:

    Maintain the version in the _pom.xml_ of your Java module, which is located in the root folder. In this file, modify the property `cds.services.version`.

<span id="announcements" />
<Fragment target="#announcements">

* Announcements

   Subscribe to [CAP news](https://github.wdf.sap.corp/cap/news/issues/19) to receive email notifications once we have [released](../releases/) CAP with new versions of the components.

</Fragment>

## Node.js

### How can I start Node.js apps on different ports?

By default, Node.js apps started with `cds run` or `cds watch` use port 4004, which might be occupied if other app instances are still running. In this case, `cds watch` now asks you if it should pick a different port.

```log
$ cds watch
...
[cds] - serving CatalogService ...

EADDRINUSE - port 4004 is already in use. Restart with new port? (Y/n) // [!code highlight]
> y
restart
...
[cds] - server listening on { url: 'http://localhost:4005' }
```

Ports can be explicitly set with the `PORT` environment variable or the `--port` argument.  See `cds help run` for more.


### Why do I lose registered event handlers?

Node.js allows extending existing services, for example in mashup scenarios. This is commonly done on bootstrap time in `cds.on('served', ...)` handlers like so:

#### DO:{.good}

```js
cds.on('served', ()=>{
  const { db } = cds.services
  db.on('before',(req)=> console.log(req.event, req.path))
})
```

It is important to note that by Node.js `emit` are synchronous operations, so, **avoid _any_ `await` operations** in there, as that might lead to race conditions. In particular, when registering additional event handlers with a service, as shown in the snippet above, this could lead to very hard to detect and resolve issues with handler registrations. So, for example, don't do this:

#### DON'T:{.bad}

```js
cds.on('served', async ()=>{
  const db = await cds.connect.to('db') // DANGER: will cause race condition !!!
  db.on('before',(req)=> console.log(req.event, req.path))
})
```

### My app isn't showing up in Dynatrace

Make sure that:
- Your app's start script is `cds-serve` instead of `npx cds run`.
- You have the dependency `@dynatrace/oneagent-sdk` in your _package.json_.

### Why are requests occasionally rejected with "Acquiring client from pool timed out" or "ResourceRequest timed out"?

**First of all**, make sure the SAP HANA database is accessible in your application's environment.
This includes making sure the SAP HANA is either part of or mapped to your Cloud Foundry space or Kyma cluster and the IP addresses are [in an allowed range](https://help.sap.com/docs/HANA_SERVICE_CF/cc53ad464a57404b8d453bbadbc81ceb/71eb651f84274a0cb2f2b4380df91724.html). Connectivity issues are likely the root cause if you experience this error during application startup.

[Learn how to set up SAP HANA instance mappings](https://help.sap.com/docs/hana-cloud/sap-hana-cloud-administration-guide/map-sap-hana-database-to-another-environment-context){.learn-more}

If you frequently get this error during normal runtime operation your database client pool settings likely don't match the application's requirements. There are two possible root causes:

|  | Explanation |
| --- | ---- |
| _Root Cause 1_ | The maximum number of database clients in the pool is reached and additional requests wait too long for the next client.
| _Root Cause 2_ | The creation of a new connection to the database takes too long.
| _Solution_ | Adapt `max` or `acquireTimeoutMillis` with more appropriate values, according to the [documentation](../node.js/databases#databaseservice-configuration).

Always make sure that database transactions are either committed or rolled back. This can work in two ways:
1. Couple it to your request (this happens automatically): Once the request is succeeded, the database service commits the transaction. If there was an error in one of the handlers, the database service performs a rollback.
2. For manual transactions (for example, by writing `const tx = cds.tx()`), you need to perform the commit/rollback yourself: `await tx.commit()`/`await tx.rollback()`.

If you're using [@sap/hana-client](https://www.npmjs.com/package/@sap/hana-client), make sure to adjust the environment variable [`HDB_NODEJS_THREADPOOL_SIZE`](https://help.sap.com/docs/SAP_HANA_CLIENT/f1b440ded6144a54ada97ff95dac7adf/31a8c93a574b4f8fb6a8366d2c758f21.html?version=2.11) which specifies the amount of workers that concurrently execute asynchronous method calls for different connections.


### Why are requests rejected with status `502` and do not seem to reach the application?

If you have long running requests, you may experience intermittent `502` errors that are characterized by being logged by the platform's router, but not by your CAP application.
In most cases, this behavior is caused by the server having just closed the TCP connection without waiting for acknowledgement, so that the platform's load balancer still considers it open and uses it to forward the request.
The issue is discussed in detail in this [blog post](https://adamcrowder.net/posts/node-express-api-and-aws-alb-502/#the-502-problem) by Adam Crowder.
One solution is to increase the server's `keepAliveTimeout` to above that of the respective load balancer.

The following example shows how to set `keepAliveTimeout` on the [http.Server](https://nodejs.org/api/http.html#class-httpserver) created by CAP.

```js
const cds = require('@sap/cds')
cds.once('listening', ({ server }) => {
  server.keepAliveTimeout = 3 * 60 * 1000 // > 3 mins
})
module.exports = cds.server
```

[Watch the video to learn more about **Best Practices for CAP Node.js Apps**.](https://www.youtube.com/watch?v=WTOOse-Flj8&t=87s){.learn-more}

### Why are long running requests rejected with status `504` after 30 seconds even though the application continues processing the request?

|  | Explanation |
| --- | ---- |
| _Root Cause_ | Most probably, this error is caused by the destination timeout of the App Router.
| _Solution_ | Set your own `timeout` configuration of [@sap/approuter](https://www.npmjs.com/package/@sap/approuter#destinations).

### Why does the server crash with `No service definition found for <srv-name>`?

|  | Explanation |
| --- | ---- |
| _Root Cause_ | Most probably, the service name in the `requires` section does not match the served service definition.
| _Solution_ | Set the `.service` property in the respective `requires` entry. See [cds.connect()](../node.js/cds-connect#cds-requires-srv-service) for more details.

### Why is the destination of a remote service not correctly retrieved by SAP Cloud SDK and returns a status code 404?

|  | Explanation |
| --- | ---- |
| _Root Cause_ | In case the application has a service binding with the same name as the requested destination, the SAP Cloud SDK prioritized the service binding. This service of course does have different endpoints than the originally targeted remote service. For more information, please refer to the [SAP Cloud SDK documentation](https://sap.github.io/cloud-sdk/docs/js/features/connectivity/destinations#referencing-destinations-by-name).
| _Solution_ | Use different names for the service binding and the destination.

### Why does my remote service call not work?

|  | Explanation |
| --- | ---- |
| _Root Cause_ | The destination, the remote system or the request details are not configured correctly.
| _Solution_ | To further troubleshoot the root cause, you can enable logging with environment variables `SAP_CLOUD_SDK_LOG_LEVEL=silly` and `DEBUG=remote`.

## TypeScript

### Type definitions for `@sap/cds` not found or incomplete

|                | Explanation                                                           |
|----------------|-----------------------------------------------------------------------|
| _Root Cause 1_ | The package `@cap-js/cds-typer` is not installed.                     |
| _Solution 1_   | Install the package as a dev dependency.                              |
| _Root Cause 2_ | Symlink is missing.                                                   |
| _Solution 2_   | Try `npm rebuild` or add `@cap-js/cds-types` in your _tsconfig.json_. |


#### Install package as dev dependency
The type definitions for `@sap/cds` are maintained in a separate package `@cap-js/cds-types` and have to be explicitly installed as a dev dependency. This can be done by adding the `typescript` facet:

::: code-group
```sh [facet]
cds add typescript
```
```sh [manually]
npm i -D @cap-js/cds-types
```
:::

#### Fix missing symlink

Installing `@cap-js/cds-types` leverages VS Code's automatic type resolution mechanism by symlinking the package in `node_modules/@types/sap__cds` in a postinstall script. If you find that this symlink is missing, try `npm rebuild` to trigger the postinstall script again.

If the symlink still does not persist, you can explicitly point the type resolution mechanism to `@cap-js/cds-types` in your _tsconfig.json_:

::: code-group
```json [tsconfig.json]
{
  "compilerOptions": {
    "types": ["@cap-js/cds-types"],
  }
}
```
:::

If you find that the types are still incomplete, open a bug report in [the `@cap-js/cds-types` repository](https://github.com/cap-js/cds-types/issues/new/choose).

## Java

### How can I make sure that a user passes all authorization checks?

A new option `privilegedUser()` can be leveraged when [defining](../java/event-handlers/request-contexts#defining-requestcontext) your own `RequestContext`. Adding this introduces a user, which passes all authorization restrictions. This is useful for scenarios, where a restricted service should be called through the [local service consumption API](../java/services) either in a request thread regardless of the original user's authorizations or in a background thread.

### Why do I get a "User should not exist" error during build time?

|  | Explanation |
| --- | ---- |
| _Root Cause_ | You've [explicitly configured a mock](../java/security#explicitly-defined-mock-users) user with a name that is already used by a [preconfigured mock user](../java/security#preconfigured-mock-users).
| _Solution_ | Rename the mock user and build your project again.

### Why do I get an "Error on server start"?

There could be a mismatch between your locally installed Node.js version and the version that is used by the `cds-maven-plugin`. The result is an error similar to the following:

```sh
❗️ ERROR on server start: ❗️
Error: The module '/home/user/....node'
was compiled against a different Node.js version using
```

To fix this, either switch the Node.js version using a Node version manager, or add the Node version to your _pom.xml_ as follows:

```xml
<properties>
		
		<cds.install-node.nodeVersion>v20.11.0</cds.install-node.nodeVersion>
		
	</properties>

```

[Learn more about the install-node goal.](../java/assets/cds-maven-plugin-site/install-node-mojo.html){.learn-more target="_blank"}

### How can I expose custom REST APIs with CAP?

From time to time you might want to expose additional REST APIs in your CAP application, that aren't covered through CAPs existing protocol adapters (for example, OData V4). A common example for this might be a CSV file upload or another type of custom REST endpoint.
In that case, you can leverage the powerful capabilities of Spring Web MVC, by implementing your own RestController. From within your RestController implementation, you can fully leverage all CAP Java APIs. Most commonly you'll be interacting with your services and the database through the [local service consumption API](../java/services). To learn more about Spring Web MVC, see the [Spring docs](https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc), [Spring Boot docs](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc), and this [tutorial](https://spring.io/guides/gs/serving-web-content/).

### How can I build a CAP Java application without SQL database?

The project skeleton generated by the CAP Java archetype adds the relevant Spring Boot and CAP Java dependencies, so that SQL database is supported by default.
However, using an SQL database in CAP Java is fully optional. You can also develop CAP applications that don't use persistence at all.
To remove the SQL database support, you need to exclude the JDBC-related dependencies of Spring Boot and CAP Java. This means that CAP Java won't create a Persistence Service instance.

::: tip Default Application Service event handlers delegate to Persistence Service
You need to implement your own custom handlers in case you remove the SQL database support.
:::

You can exclude those dependencies from the `cds-starter-spring-boot` dependency in the `srv/pom.xml`:

```xml
<dependency>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-starter-spring-boot</artifactId>
  <exclusions>
    <exclusion>
      <groupId>com.sap.cds</groupId>
      <artifactId>cds-feature-jdbc</artifactId>
    </exclusion>
    <exclusion>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-jdbc</artifactId>
    </exclusion>
  </exclusions>
</dependency>
```

In addition you might want to remove the H2 dependency, which is included in the `srv/pom.xml` by default as well.

If you don't want to exclude dependencies completely, but make sure that an in-memory H2 database **isn't** used, you can disable Spring Boot's `DataSource` auto-configuration, by annotating the `Application.java` class with `@SpringBootApplication(exclude = org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration.class)`. In that mode CAP Java however can still react on explicit data source configurations or database bindings.

### What to Do About Maven-Related Errors in Eclipse's Problems View?

- In _Problems_ view, execute _Quick fix_ from the context menu if available. If Eclipse asks you to install additional Maven Eclipse plug-ins to overcome the error, do so.
- Errors like _'Plugin execution not covered by lifecycle configuration: org.codehaus.mojo:exec-maven-plugin)_ can be ignored. Do so in _Problems_ view > _Quick fix_ context menu > _Mark goal as ignored in Eclipse preferences_.
- In case, there are still errors in the project, use _Maven > Update Project..._ from the project's context menu.

## OData

### How Do I Generate an OData Response in Node.js for Error 404?

If your application(s) endpoints are served with OData and you want to change the standard HTML response to an OData response, adapt the following snippet to your needs and add it in your [custom _server.js_ file](../node.js/cds-serve#custom-server-js).

```js
let app
cds.on('bootstrap', a => {
  app = a
})
cds.on('served', () => {
  app.use((req, res, next) => {
    // > unhandled request
    res.status(404).json({ message: 'Not Found' })
  })
})
```

### Why do some requests fail if I set `@odata.draft.enabled` on my entity?

The annotation `@odata.draft.enabled` is very specific to SAP Fiori elements, only some requests are allowed.
For example it's forbidden to freely add `IsActiveEntity` to `$filter`, `$orderby` and other query options.
The technical reason for that is that active instances and drafts are stored in two different database tables.
Mixing them together is not trivial, therefore only some special cases are supported.


## SQLite { #sqlite}

### How Do I Install SQLite on Windows?

* From the [SQLite page](https://sqlite.org/download.html), download the precompiled binaries for Windows `sqlite-tools-win*.zip`.

* Create a folder _C:\sqlite_ and unzip the downloaded file in this folder to get the file `sqlite3.exe`.

* Start using SQLite directly by opening `sqlite3.exe` from the folder _sqlite_ or from the command line window opened in _C:\sqlite_.

* _Optional_: Add _C:\sqlite_ in your PATH environment variable. As soon as the configuration is active, you can start using SQLite from every location on your Windows installation.

* Use the command _sqlite3_ to connect to the in-memory database:

```sh
C:\sqlite>sqlite3
SQLite version ...
Enter ".help" for instructions
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite>
```

If you want to test further, use _.help_ command to see all available commands in _sqlite3_.

In case you want a visual interface tool to work with SQLite, you can use [SQLite Viewer](https://marketplace.visualstudio.com/items?itemName=qwtel.sqlite-viewer). It's available as an extension for VS Code and integrated in SAP Business Application Studio.


## SAP HANA { #hana}

### How to Get an SAP HANA Cloud Instance for SAP BTP, Cloud Foundry environment? { #get-hana}

To configure this service in the SAP BPT cockpit on trial, refer to the [SAP HANA Cloud Onboarding Guide](https://www.sap.com/documents/2021/09/7476f8c4-f77d-0010-bca6-c68f7e60039b.html). See [SAP HANA Cloud](https://help.sap.com/docs/HANA_CLOUD) documentation or visit the [SAP HANA Cloud community](https://pages.community.sap.com/topics/hana/cloud) for more details.

::: warning HANA needs to be restarted on trial accounts
On trial, your SAP HANA Cloud instance will be automatically stopped overnight, according to the server region time zone. That means you need to restart your instance every day before you start working with your trial.
:::

[Learn more about SAP HANA Cloud trying out tutorials in the Tutorial Navigator.](https://developers.sap.com/mission.hana-cloud-database-get-started.html){.learn-more}


### I removed sample data (_.csv_ file) from my project. Still, the data is deployed and overwrites existing data. { #hana-csv}

|  | Explanation |
| --- | ---- |
| _Root Cause_ | SAP HANA still claims exclusive ownership of the data that was once deployed through `hdbtabledata` artifacts, even though the CSV files are now deleted in your project.
| _Solution_ | Add an _undeploy.json_ file to the root of your database module (the _db_ folder by default). This file defines the files **and data** to be deleted. See section [HDI Delta Deployment and Undeploy Allow List](https://help.sap.com/docs/HANA_CLOUD_DATABASE/c2b99f19e9264c4d9ae9221b22f6f589/ebb0a1d1d41e4ab0a06ea951717e7d3d.html) for more details.


#### How do I keep existing data?
If you want to keep the data from _.csv_ files and data you've already added, apply [SAP Note 2922271](https://me.sap.com/notes/2922271).
Depending on whether you have a single-tenant or multi-tenant application, see the following details for how to set the `path_parameter` and `undeploy` parameters:

:::details Single-tenant applications {open}

Use the _db/undeploy.json_ file as given in the SAP note.
The _package.json_ file that is mentioned in the SAP note is located in the _db/_ folder.
- If you don't find a _db/package.json_ file, use _gen/db/package.json_ (created by `cds build`) as a template and copy it to _db/package.json_.
- After the modification, run `cds build --production` and verify your changes have been copied to _gen/db/package.json_.
- Don't modify _gen/db/package.json_ as it is overwritten on every build.

:::

:::details Multi-tenant applications

Instead of configuring the static deployer application in _db/package.json_, use environment variable [`HDI_DEPLOY_OPTIONS`](https://help.sap.com/docs/SAP_HANA_PLATFORM/4505d0bdaf4948449b7f7379d24d0f0d/a4bbc2dd8a20442387dc7b706e8d3070.html), the `cds` configuration in _package.json_, or add the options to the model update request as `hdi` parameter:

CDS configuration for [Deployment Service](../guides/multitenancy/mtxs#deployment-config)
```json
"cds.xt.DeploymentService": {
  "hdi": {
    "deploy": {
      "undeploy": [
        "src/gen/data/my.bookshop-Books.hdbtabledata"
      ],
      "path_parameter": {
        "src/gen/data/my.bookshop-Books.hdbtabledata:skip_data_deletion": "true"
      }
    },
    ...
  }
}
```

Options in [Saas Provisioning Service upgrade API](../guides/multitenancy/mtxs#example-usage-1) call payload
```json
{
  "tenants": ["*"],
  "_": {
      "hdi": {
        "deploy": {
          "undeploy": [
            "src/gen/data/my.bookshop-Books.hdbtabledata"
          ],
          "path_parameter": {
            "src/gen/data/my.bookshop-Books.hdbtabledata:skip_data_deletion": "true"
          }
        }
      }
  }
}
```

:::

After you have successfully deployed these changes to all affected HDI (tenant) containers (in all spaces, accounts etc.), you can remove the configuration again.


### How Do I Resolve Deployment Errors?

#### Deployment fails — _Cyclic dependencies found_ or _Cycle between files_

|  | Explanation |
| --- | ---- |
| _Root Cause_ | This is a known issue with older HDI/HANA versions, which are offered on trial landscapes.
| _Solution_ | Apply the workaround of adding `--treat-unmodified-as-modified` as argument to the `hdi-deploy` command in _db/package.json_. This option redeploys files, even if they haven't changed. If you're the owner of the SAP HANA installation, ask for an upgrade of the SAP HANA instance.

#### Deployment fails — _Version incompatibility_

|  | Explanation |
| --- | ---- |
| _Root Cause_ | An error like `Version incompatibility for the ... build plugin: "2.0.x" (installed) is incompatible with "2.0.y" (requested)` indicates that your project demands a higher version of SAP HANA than what is available in your org/space on SAP BTP, Cloud Foundry environment. The error might not occur on other landscapes for the same project.
| _Solution_ | Lower the version in file `db/src/.hdiconfig` to the one given in the error message. If you're the owner of the SAP HANA installation, ask for an upgrade of the SAP HANA instance.

#### Deployment fails — _Cannot create certificate store_ {#cannot-create-certificate-store}

|  | Explanation |
| --- | ---- |
| _Root Cause_ | If you deploy to SAP HANA from a local Windows machine, this error might occur if the SAP CommonCryptoLib isn't installed on this machine. |
| _Solution_ | To install it, follow these [instructions](https://help.sap.com/docs/SAP_DATA_SERVICES/e54136ab6a4a43e6a370265bf0a2d744/c049e28431ee4e8280cd6f5d1a8937d8.html). If this doesn't solve the problem, also set the environment variables as [described here](https://help.sap.com/docs/SAP_HANA_PLATFORM/e7e79e15f5284474b965872bf0fa3d63/463d3ceeb7404eca8762dfe74e9cff62.html).


#### Deployment fails —
+ _Failed to get connection for database_
+ _Connection failed (RTE:[300015] SSL certificate validation failed_
+ _Cannot create SSL engine: Received invalid SSL Record Header_

|  | Explanation |
| --- | ---- |
| _Root Cause_ | Your SAP HANA Cloud instance is stopped. |
| _Solution_ | [Start your SAP HANA Cloud instance.](https://help.sap.com/docs/HANA_CLOUD/9ae9104a46f74a6583ce5182e7fb20cb/fe8cbc3a13b4425990880bac3a5d50d9.html)

#### Deployment fails — SSL certificate validation failed: error code: 337047686

|  | Explanation |
| --- | ---- |
| _Root Cause_ | The `@sap/hana-client` can't verify the certificate because of missing system toolchain dependencies. |
| _Solution_ | Make sure [`ca-certificates`](https://packages.ubuntu.com/focal/ca-certificates) is installed on your Docker container.

#### Deployment fails — _Cannot create SSL engine: Received invalid SSL Record Header_

|  | Explanation |
| --- | ---- |
| _Root Cause_ | Your SAP HANA Cloud instance is stopped. |
| _Solution_ | [Start your SAP HANA Cloud instance.](https://help.sap.com/docs/HANA_CLOUD/9ae9104a46f74a6583ce5182e7fb20cb/fe8cbc3a13b4425990880bac3a5d50d9.html)

#### Deployment fails — _Error: HDI make failed_

|  | Explanation |
| --- | ---- |
| _Root Cause_ | Your configuration isn't properly set. |
| _Solution_ | Configure your project as described in [Using Databases](../guides/databases).


#### Deployment fails — _Connection failed (RTE:[89008] Socket closed by peer_ {#connection-failed-89008}

#### Hybrid testing connectivity issue — _ResourceRequest timed out_ {}

|  | Explanation |
| --- | ---- |
| _Root Cause_ | Your IP isn't part of the filtering you configured when you created an SAP HANA Cloud instance. This error can also happen if you exceed the [maximum number of simultaneous connections to SAP HANA Cloud (1000)](https://help.sap.com/docs/HANA_CLOUD_DATABASE/c1d3f60099654ecfb3fe36ac93c121bb/20a760537519101497e3cfe07b348f3c.html). |
| _Solution_ | Configure your SAP HANA Cloud instance [to accept your IP](https://help.sap.com/docs/HANA_SERVICE_CF/cc53ad464a57404b8d453bbadbc81ceb/71eb651f84274a0cb2f2b4380df91724.html). If configured correctly, check if the number of database connections are exceeded. Make sure your [pool configuration](../node.js/databases#pool) does not allow more than 1000 connections.

<div id="hana-ips" />
<Fragment target="#hana-ips">

::: tip
To configure your SAP HANA Cloud on SAP offices IP addresses/ranges, see this [list of all IP addresses for SAP offices](https://nip.wdf.sap.corp/nip2/faces/networking/wan/PublicAddresses.xhtml).
:::

</Fragment>

#### Deployment fails — _... build plugin for file suffix "hdbmigrationtable" [8210015]_
{#missingPlugin}

|  | Explanation |
| --- | ---- |
| _Root Cause_ | Your project configuration is missing some configuration in your _.hdiconfig_ file. |
| _Solution_ | Use `cds add hana` to add the needed configuration to your project. Or maintain the _hdbmigrationtable_ plugin in your _.hdiconfig_ file manually: `"hdbmigrationtable": { "plugin_name": "com.sap.hana.di.table.migration" }`


#### Deployment fails — _In USING declarations only main artifacts can be accessed, not sub artifacts of \<name\>_
This error occurs if all of the following applies:
+ You [added native SAP HANA objects](../advanced/hana#add-native-objects) to your CAP model.
+ You used deploy format `hdbcds`.
+ You didn't use the default naming mode `plain`.

|  | Explanation |
| --- | ---- |
| _Root Cause_ | The name/prefix of the native SAP HANA object collides with a name/prefix in the CAP CDS model.
| _Solution_ | Change the name of the native SAP HANA object so that it doesn't start with the name given in the error message and doesn't start with any other prefix that occurs in the CAP CDS model. If you can't change the name of the SAP HANA object, because it already exists, define a synonym for the object. The name of the synonym must follow the naming rule to avoid collisions (root cause).

### How do I pass additional HDI deployment options to the multitenancy tenant deployment of the `cds-mtx` library

You can add a subset of the [HDI deploy options](https://help.sap.com/docs/SAP_HANA_PLATFORM/4505d0bdaf4948449b7f7379d24d0f0d/a4bbc2dd8a20442387dc7b706e8d3070.html) using the environment variable `HDI_DEPLOY_OPTIONS`.\

When making use of these parameters, for example `exclude_filter`, please always check if the parameters are consistent with your CDS build configuration to
avoid deployment problems. For example, make sure to not exclude generated SAP HANA tables that are needed by generated views.

### How can a table function access the logged in user?

The _cds runtime_ sets the session variable `APPLICATIONUSER`. This should always reflect the logged in user.

Do not use a `XS_` prefix.

## MTXS

### I get a 401 error when logging in to MTXS through App Router { #mtxs-sidecar-approuter-401}

See [How to configure your App Router](../guides/extensibility/customization#app-router) to verify your setup.
Also check the [documentation about `cds login`](../guides/extensibility/customization#cds-login).

### When running a tenant upgrade, I get the message 'Extensions exist, but extensibility is disabled.'

This message indicates that extensions exist, but the application is not configured for extensibility. To avoid accidental data loss by removing existing extensions from the database, the upgrade is blocked in that case.
Please check the [configuration for extensibility](../guides/extensibility/customization#_1-enable-extensibility).

::: danger
If data loss is intended, you can disable the check by adding <Config>cds.requires.cds.xt.DeploymentService.upgrade.skipExtensionCheck = true</Config> to the configuration.
:::

## MTA { #mta}

### Why Does My MTA Build Fail?

- Make sure to use the latest version of the [Cloud MTA Build Tool (MBT)](https://sap.github.io/cloud-mta-build-tool/).
- Consult the [Cloud MTA Build Tool documentation](https://sap.github.io/cloud-mta-build-tool/usage/) for further information, for example, on the available tool options.

### How Can I Define the Build Order Between MTA Modules?

By default the Cloud MTA Build Tool executes module builds in parallel. If you want to enforce a specific build order, for example, because one module build relies on the outcome of another one, check the [Configuring build order](https://sap.github.io/cloud-mta-build-tool/configuration/) section in the tool documentation.

### How Do I Undeploy an MTA?

`cf undeploy <mta-id>` deletes an MTA (use `cf mtas` to find the MTA ID).

Use the optional `--delete-services` parameter to also wipe service instances. <br />
**Caution:** This deletes the HDI containers with the application data.

### MTA Build Complains About _package-lock.json_

If the MTA build fails with `The 'npm ci' command can only install with an existing package-lock.json`, this means that such a file is missing in your project.
- Check with `cds --version` to have `@sap/cds` >= 5.7.0.
- Create the _package-lock.json_ file with a regular [`npm update`](https://docs.npmjs.com/cli/v8/commands/npm-update) command.
- If the file was not created, make sure to enable it with `npm config set package-lock true` and repeat the previous command.
- _package-lock.json_ should also be added to version control, so make sure that _.gitignore_ does __not__ contain it.

The purpose of _package-lock.json_ is to pin your project's dependencies to allow for reproducible builds.

[Learn more about dependency management in Node.js.](../node.js/best-practices#dependencies){.learn-more}

### How Can I Reduce the MTA Archive Size During Development? { #reduce-mta-size}

You can reduce MTA archive sizes, and thereby speedup deployments, by omitting `node_module` folders.

First, add a file `less.mtaext` with the following content:

::: code-group
```yaml [less.mtaext]
_schema-version: '3.1'
ID: bookshop-small
extends: capire.bookshop
modules:
 - name: bookshop-srv
   build-parameters:
     ignore: ["node_modules/"]
```
:::

Now you can build the archive with:

```sh
mbt build -t gen --mtar mta.tar -e less.mtaext
```

::: warning
This approach is only recommended
- For test deployments during _development_.  For _production_ deployments,  self-contained archives are preferrable.
- If all your dependencies are available in _public_ registries like npmjs.org or Maven Central.  Dependencies from _corporate_ registries are not resolvable in this mode.
:::

<div id="sap-make" />
<Fragment target="#sap-make">

## xMake <Internal /> { #xmake }

### Supported Node.js versions

For Node.js builds, ensure that the [Node.js version](https://github.wdf.sap.corp/pages/xmake-ci/User-Guide/Setting_up_a_Build/Build_Plugins/Node/#about-node-version) is supported by the Node Build Plugin.
See the [Artifactory Milestones repository](https://int.repositories.cloud.sap/artifactory/build-milestones/com/sap/prd/distributions/org/nodejs/linuxx86_64/nodejs/) for a list of all available versions.

### Builds fail because of SQLite binaries

xMake builds might fail in, for example `npm install` operations with an error message like
  - `binaries not installable for better-sqlite3` or
  - `FetchError: request to https://nodejs.org/download/release/...-headers.tar.gz failed, reason: connect ECONNREFUSED`

This is most likely caused by a blocked Internet connectivity on the xMake build servers, so that `npm` can't download the `better-sqlite3` binaries from the Internet. `better-sqlite3` is used through [`@cap-js/sqlite`](../guides/databases-sqlite#setup-configuration).

To fix the error, add an entry like this in your `.xmake.cfg` file to make `npm` fetch the `better-sqlite3` binaries from SAP's Artifactory:

::: code-group

```ini [.xmake.cfg]
[env_all]
npm_config_better_sqlite3_binary_host_mirror=https://int.repositories.cloud.sap/artifactory/build-releases/com/sap/cds/better-sqlite3-binaries/{version}/better-sqlite3-binaries-{version}-bin.zip!
```

:::


::: tip Notes on the URL:

- It does not work in browsers, but _does_ work in other http clients like in `npm install`.
- It must end with `!` which allows for paths _inside_ the archive. In your local shell, you might need to escape `!` with `\!`
- The `{version}` placeholder is replaced by npm with the current SQLite version.  This way, you don't have to bump it regularly.  Alternatively, consider configuring [Renovate](https://github.tools.sap/OSPO/renovate-controller/blob/main/docs/xmake-sqlite3-mirror.md#readme) to update the version.
:::

Likewise for the `sqlite3` package, you need to configure this:

::: code-group

```ini [.xmake.cfg]
[env_all]
npm_config_sqlite3_binary_host_mirror=https://int.repositories.cloud.sap/artifactory/build-releases/com/sap/cds/node-sqlite3-binary/{version}/node-sqlite3-binary-{version}.zip!
```

:::

### Builds fail with `Connection refused`

  If the build fails with "Connect to proxy:8080 failed: Connection refused", disable the proxy:

  ::: code-group

  ```ini [.xmake.cfg]
  [buildplugin]
  noproxy=true
  ```

  :::

### How can I specify the Maven version in xMake?

By default xMake provides Maven in version 3.3.x, but the minimum required version of newly created CAP Java projects is version 3.5.0.

  Set this:

  ::: code-group

  ```ini [.xmake.cfg]
  [buildplugin]
  maven-version=3.6.0
  ```

  :::


### Installation of @sap/cds-dk Fails

The `cds-maven-plugin` provides a goal to install `@sap/cds-dk` during a Maven build. The Node.js module `@sap/cds-dk` has a dependency on `sqlite3` and `npm` tries to download this module from the Internet. This download fails during a Maven build on xMake because of a blocked Internet connection.

Follow this [troubleshooting](#builds-fail-because-of-sqlite-binaries) to overcome these limitations.


### Installation of Node.js Fails

The `cds-maven-plugin` can also be used to install a Node.js distribution, which is a prerequisite for the `@sap/cds-dk`. By default the goal [install-node](../java/assets/cds-maven-plugin-site/install-node-mojo.html){target="_blank"} uses the public Node.js [download URL](https://nodejs.org/dist/) to get the distribution, but xMake blocks access to this public URL. Therefore, it's required to [configure the `downloadUrl`](../java/assets/cds-maven-plugin-site/install-node-mojo){target="_blank"} with `https://int.repositories.cloud.sap/artifactory/proxy-3rd-party-nodejs-dist`

The following sample shows the configuration with the internal download URL by defining a property `node.url`, which points to the correct location. If executed in xMake environment, the property is set to the artifactory location:

```xml
<properties>
	<node.url>https://nodejs.org/dist/</node.url>
</properties>

<profiles>
	<profile>
		<id>xmake-node-path</id>
		<activation>
			<property>
				<name>env.XMAKE_IMPORT_APT_0</name>
			</property>
		</activation>
		<properties>
			<node.url>${env.XMAKE_IMPORT_APT_0}</node.url>
		</properties>
	</profile>
</profiles>

<plugin>
    <groupId>com.sap.cds</groupId>
    <artifactId>cds-maven-plugin</artifactId>
    <version>${cds.services.version}</version>
    <executions>
        
        <execution>
            <id>install-node</id>
            <goals>
                <goal>install-node</goal>
            </goals>
            <configuration>
                <downloadUrl>${node.url}</downloadUrl>
            </configuration>
        </execution>
    </executions>
</plugin>
```

::: tip
On xMake the environment variable `XMAKE_IMPORT_APT_0` points to the internal Node.js download URL.
:::

See [xMake Build Lifecycle](https://github.wdf.sap.corp/pages/xmake-ci/User-Guide/Setting_up_a_Build/About_Build_Properties/xmake_Build_Lifecycle/#default-values-in-environmentcfg-and-environmentjson) for more details about valid URLs on xMake.

</Fragment>



## CAP on Cloud Foundry


### How Do I Get Started with SAP Business Technology Platform, Cloud Foundry environment?

For a start, create your [Trial Account](https://account.hanatrial.ondemand.com/).

<div id="sap-in-house" />
<Fragment target="#sap-in-house">

#### SAP-In-House Development <Internal />

For SAP-in-house development uses the _Canary_ landscape:
- API endpoint: `https://api.cf.sap.hana.ondemand.com`
- User ID: your D/I user
- Password: your GLOBAL password

On Canary, you can use the provided [Try Out CF space](https://wiki.one.int.sap/wiki/display/webapptoolkit/Using+tryout+Cloud+Foundry+space+for+full+stack+development) if you don't have an own.  This space includes an SAP HANA service, but all apps are wiped daily.

To get an own org and space on SAP BTP, Cloud Foundry environment, see [**Request a Cloud Foundry org** for your projects](https://jam4.sapjam.com/groups/ApFhQ0NCGAzAtXQWsdqB3B/overview_page/p8JIXj2pstIcY7TegLyOp8). Then, you need to have an SAP HANA service connected to your Cloud Foundry space. See this [process](https://jam4.sapjam.com/groups/1gnolvQd9meN7B9VnqYCeM/overview_page/sRGnj4p2tK4pkjhw44lqeD) for getting a HaaS instance on Canary.

</Fragment>

### How Do I Resolve Errors with `cf` Executable? { #cf-cli}

#### Installation fails — _mkdir ... The system cannot find the path specified_

This is a known [issue](https://github.com/cloudfoundry/docs-cf-cli/issues/57) on Windows. The fix is to set the `HOMEDRIVE` environment variable to `C:`. In any `cmd` shell session, you can do so with `SET HOMEDRIVE=C:`<br />
Also, make sure to persist the variable for future sessions in the system preferences. See [How do I set my system variables in Windows](https://superuser.com/questions/949560/how-do-i-set-system-environment-variables-in-windows-10) for more details.

#### `cf` commands fail — _Error writing config_

This is the same issue as with the installation error above.

### Why Can't My _xs-security.json_ File Be Used to Create an XSUAA Service Instance? { #pws-encoding}

|  | Explanation |
| --- | ---- |
| _Root Cause_ | Your file isn't UTF-8 encoded. If you executed `cds compile` with Windows PowerShell, the encoding of your _xs-security.json_ file is wrong.
| _Solution_ | Make sure, you execute `cds compile` in a command prompt that encodes in UTF-8 when piping output into a file.

[You can find related information on **Stack Overflow**.](https://stackoverflow.com/questions/40098771/changing-powershells-default-output-encoding-to-utf-8){.learn-more}


### How Can I Connect to a Backing Service Container like SAP HANA from My Local Machine? { #cf-connect}

Depending on, whether the container host is reachable and whether there's a proxy between your machine and the cloud, one of the following options applies:

<span id="direct-access" />
<Fragment target="#direct-access">

* Direct access

    Requires no further actions, if these prerequisites are met:
    - The target **host is reachable** network-wise. You can try to `ping` the host (using its name or IP address) to find out.
    - In addition, if you use protocols like JDBC (for database services) or SSH, **no HTTP proxy** is allowed, as those only let HTTP traffic through.

    ::: tip
    This option is best if you're located in an SAP office, as most buildings don't require proxy usage anymore. If you're connected from home through VPN, look at the following options.
    :::

</Fragment>

* CF SSH

    The second most convenient way is the `cf ssh` capability of Cloud Foundry CLI. You can open an SSH tunnel to the target Cloud Foundry container, if these prerequisites are met:
    - There's **no HTTP proxy** in the way.  Those only let HTTP traffic through.
    - SSH access is enabled for the CF landscape and your space (in _Canary_ this is true, otherwise check with `cf ssh-enabled`).

    Use it like this:

    ```sh
    cf ssh <app> -L localhost:<LocalPort>:<RemoteIP>:<RemotePort>
    ```
    where `<app>` has to be a running application that is bound to the service.

    Example:

    Connect to a SAP HANA service running on remote host 10.10.10.10, port 30010.

    ```sh
    cf ssh <app> -L localhost:30010:10.10.10.10:30010
    ```

    From then on, use `localhost:30010` instead of the remote address.

    [Learn more about **cf ssh**.](https://docs.cloudfoundry.org/devguide/deploy-apps/ssh-apps.html){ .learn-more}

* Chisel

    In all other cases, for example, if there's an HTTP proxy between you and the cloud, you can resort to a TCP proxy tool, called _Chisel_. This also applies if the target host isn't reachable on a network level. You need to install _Chisel_ in your target space and that will tunnel TCP traffic over HTTP from your local host to the target (and vice versa).

    Find [step-by-step instructions here](https://github.com/jpillora/chisel). For example, to connect to an SAP HANA service running on remote host 10.10.10.10, port 30010:

    ```sh
    bin/chisel_... client --auth secrets https://<url_to_chisel_server_app> localhost:30010:10.10.10.10:30010
    ```
    From then on, use `localhost:30010` instead of the remote address.

    [Learn more about **Chisel**.](https://github.com/jpillora/chisel){ .learn-more}

### Aborted Deployment With the _Create-Service-Push_ Plugin

If you're using _manifest.yml_ features that are part of the new Cloud Foundry API, for example, the `buildpacks` property, the `cf create-service-push` command will abort after service creation without pushing the applications to Cloud Foundry.

Use `cf create-service-push --push-as-subprocess` to execute `cf push` in a sub-process.

[See `cf create-service-push --help` for further CLI details or visit the Create-Service-Push GitHub repository.](https://github.com/dawu415/CF-CLI-Create-Service-Push-Plugin){.learn-more}

### Deployment Crashes With "No space left on device" Error

If on deployment to Cloud Foundry, a module crashes with the error message `Cannot mkdir: No space left on device` then the solution is to adjust the space available to that module in the `mta.yaml` file. Adjust the `disk-quota` parameter.

```sh
    parameters:
      disk-quota: 512M
      memory: 256M
```
[Learn more about this error in KBA 3310683](https://userapps.support.sap.com/sap/support/knowledge/en/3310683){.learn-more}

### How Can I Get Logs From My Application in Cloud Foundry? { #cflogs-recent}

The SAP BTP cockpit is not meant to analyze a huge amount of logs. You should use the Cloud Foundry CLI.

```sh
cf logs <appname> --recent
```

::: tip
If you omit the option `--recent`, you can run this command in parallel to your deployment and see the logs as they come in.
:::

### Why do I get "404 Not Found: Requested route does not exist"?

In order to send a request to an app, it must be associated with a route.
Please see [Cloud Foundry Documentation -> Routes](https://docs.cloudfoundry.org/devguide/deploy-apps/routes-domains.html#routes) for details.
As this is done automatically by default, the process is mostly transparent for developers.

If you receive an error response `404 Not Found: Requested route ('<route>') does not exist`, this can have two reasons:
1. The route really does not exist or is not bound to an app.
  You can check this in SAP BTP cockpit either in the app details view or in the list of routes in the Cloud Foundry space.
2. The app (or all app instances, in case of horizontal scale-out) failed the readiness check.
  Please see [Health Checks](../guides/deployment/health-checks.md) and [Using Cloud Foundry health checks](https://docs.cloudfoundry.org/devguide/deploy-apps/healthchecks.html) for details on how to set up the check.

    ::: details Troubleshoot using the Cloud Foundry CLI

    ```sh
    cf apps # -> list all apps
    cf app <your app name> # -> get details on your app, incl. state and routes
    cf app <your app name> --guid # -> get your app's guid
    cf curl "/v3/processes/<your app guid>/stats"
      # -> list of processes (one per app instance) with property "routable"
      #    indicating whether the most recent readiness check was successful
    ```

    See [cf curl](https://cli.cloudfoundry.org/en-US/v7/curl.html) and [The process stats object](https://v3-apidocs.cloudfoundry.org/version/3.184.0/index.html#the-process-stats-object) for details on how to use the CLI.

    :::



## CAP on Kyma

### Pack Command Fails with Error `package.json and package-lock.json aren't in sync`

To fix this error, run `npm i --package-lock-only` to update your `package-lock.json` file and run the pack command again.

> Note: After updating the package-lock.json the specific dependency versions would change, go through the changes and verify them.

::: tip
For SAP HANA deployment errors see [The HANA section](#how-do-i-resolve-deployment-errors).
:::


## CAP on Windows

Please note that Git Bash on Windows, despite offering a Unix-like environment, may encounter interoperability issues with specific scripts or tools due to its hybrid nature between Windows and Unix systems.
When using Windows, we recommend testing and verifying all functionalities in the native Windows Command Prompt (cmd.exe) or PowerShell for optimal interoperability. Otherwise, problems can occur when building the mtxs extension on Windows, locally, or in the cloud.

<div id="end" />

<div id="secondary-file">get-started/troubleshooting.fragment.md</div>


# The CAP Cookbook
Guides and Recipes for Common Tasks
{ .subtitle}


The following figure illustrates a walkthrough of the most prominent tasks within CAP's universe of discourse (aka scope). The guides contained in this section provide details and instructions about each.

![The graphic groups topics into three phases: Development, Deploy, Use. The development phase covers topics like domain modeling, sing and providing services, databases and frontends. The deploy phase covers the deployment as well as CI/CD, monitoring and publishing APIs and packages for reuse. The use phase is about the subscription flow of multitenant applications and about customizing and extending those applications. ](assets/cookbook-overview.drawio.svg)



<br>
<IndexList :pages='pages' />




# Providing Services

This guide introduces how to define and implement services, leveraging generic implementations provided by the CAP runtimes, complemented by domain-specific custom logic.

## Intro: Core Concepts
{#introduction}

The following sections give a brief overview of CAP's core concepts.

### Service-Centric Paradigm

A CAP application commonly provides services defined in CDS models and served by the CAP runtimes. Every active thing in CAP is a service. They embody the behavioral aspects of a domain in terms of exposed entities, actions, and events.

![This graphic is explained in the accompanying text.](assets/providing-services/service-centric-paradigm.drawio.svg)

### Ubiquitous Events

At runtime, everything happening is in response to events. CAP features a ubiquitous notion of events, which represent both, *requests* coming in through **synchronous** APIs, as well as **asynchronous** *event messages*, blurring the line between both worlds.

![This graphic shows that consumers send events to services and that there are hooks, so that event handlers can react on those events.](assets/providing-services/services-events.drawio.svg)

### Event Handlers

Service providers basically react on events in event handlers, plugged in to respective hooks provided by the core service runtimes.






## Service Definitions


### Services as APIs

In its most basic form, a service definition simply declares the data entities and operations it serves. For example:

```cds
service BookshopService {

  entity Books {
    key ID : UUID;
    title  : String;
    author : Association to Authors;
  }

  entity Authors {
    key ID : UUID;
    name   : String;
    books  : Association to many Books on books.author = $self;
  }

  action submitOrder (book : Books:ID, quantity : Integer);

}
```

This definition effectively defines the API served by `BookshopService`.

![This graphic is explained in the accompanying text.](assets/providing-services/service-apis.drawio.svg)

Simple service definitions like that are all we need to run full-fledged servers out of the box, served by CAP's generic runtimes, without any implementation coding required.

### Services as Facades

In contrast to the all-in-one definition above, services usually expose views, aka projections, on underlying domain model entities:

```cds
using { sap.capire.bookshop as my } from '../db/schema';
service BookshopService {
  entity Books as projection on my.Books;
  entity Authors as projection on my.Authors;
  action submitOrder (book : Books:ID, quantity : Integer);
}
```

This way, services become facades to encapsulated domain data, exposing different aspects tailored to respective use cases.

![This graphic is explained in the accompanying text.](assets/providing-services/service-as-facades.drawio.svg)


### Denormalized Views

Instead of exposing access to underlying data in a 1:1 fashion, services frequently expose denormalized views, tailored to specific use cases.

For example, the following service definition, undiscloses information about maintainers from end users and also [marks the entities as `@readonly`](#readonly):

```cds
using { sap.capire.bookshop as my } from '../db/schema';

/** For serving end users */
service CatalogService @(path:'/browse') {

  /** For displaying lists of Books */
  @readonly entity ListOfBooks as projection on Books
  excluding { descr };

  /** For display in details pages */
  @readonly entity Books as projection on my.Books { *,
    author.name as author
  } excluding { createdBy, modifiedBy };

}
```

[Learn more about **CQL** the language used for `projections`.](../cds/cql){.learn-more}
[See also: Prefer Single-Purposed Services!](#single-purposed-services){.learn-more}
 [Find above sources in **cap/samples**.](https://github.com/sap-samples/cloud-cap-samples/tree/main/bookshop/srv/cat-service.cds){ .learn-more}


### Auto-Exposed Entities

Annotate entities with `@cds.autoexpose` to automatically include them in services containing entities with Association referencing to them.
For example, this is commonly done for code list entities in order to serve Value Lists dropdowns on UIs:

```cds
service Zoo {
  entity Foo { //...
    code : Association to SomeCodeList;
  }
}
@cds.autoexpose entity SomeCodeList {...}
```

[Learn more about Auto-Exposed Entities in the CDS reference docs.](../cds/cdl#auto-expose){.learn-more}


### Redirected Associations

When exposing related entities, associations are automatically redirected. This ensures that clients can navigate between projected entities as expected. For example:

```cds
service AdminService {
  entity Books as projection on my.Books;
  entity Authors as projection on my.Authors;
  //> AdminService.Authors.books refers to AdminService.Books
}
```

[Learn more about Redirected Associations in the CDS reference docs.](../cds/cdl#auto-redirect){.learn-more}



## Generic Providers

The CAP runtimes for [Node.js](../node.js/) and [Java](../java/) provide a wealth of generic implementations, which serve most requests automatically, with out-of-the-box solutions to recurring tasks such as search, pagination, or input validation — the majority of this guide focuses on these generic features.

In effect, a service definition [as introduced above](#service-definitions) is all we need to run a full-fledged server out of the box. The need for coding reduces to real custom logic specific to a project's domain &rarr; section [Custom Logic](#custom-logic) picks that up.


### Serving CRUD Requests
{#serving-crud}

The CAP runtimes for [Node.js](../node.js/) and [Java](../java/) provide generic handlers, which automatically serve all CRUD requests to entities for CDS-modelled services on top of a default [primary database](databases).

This comprises read and write operations like that:

* `GET /Books/201` → reading single data entities
* `GET /Books?...` → reading data entity sets with advanced query options
* `POST /Books {....}` → creating new data entities
* `PUT/PATCH /Books/201 {...}` → updating data entities
* `DELETE /Books/201` → deleting data entities

<br>

::: warning No filtering and sorting for virtual elements
CAP runtimes delegate filtering and sorting to the database. Therefore
filtering and sorting is not available for `virtual` elements.
:::


### Deep Reads and Writes

CDS and the runtimes have advanced support for modeling and serving document-oriented data.
The runtimes provide generic handlers for serving deeply nested document structures out of the box as documented in here.


#### Deep `READ`

You can read deeply nested documents by *expanding* along associations or compositions.
For example, like this in OData:

:::code-group
```http
GET .../Orders?$expand=header($expand=items)
```
```js[cds.ql]
SELECT.from ('Orders', o => {
  o.ID, o.title, o.header (h => {
    h.ID, h.status, h.items('*')
  })
})
```
[Learn more about `cds.ql`](../node.js/cds-ql){.learn-more}
:::

Both would return an array of nested structures as follows:

```js
[{
    ID:1, title: 'first order', header: { // to-one
      ID:2, status: 'open', items: [{     // to-many
        ID:3, description: 'first order item'
      },{
        ID:4, description: 'second order item'
      }]
    }
  },
  ...
]
```



#### Deep `INSERT`

Create a parent entity along with child entities in a single operation, for example, like that:

:::code-group
```http
POST .../Orders {
  ID:1, title: 'new order', header: { // to-one
    ID:2, status: 'open', items: [{   // to-many
      ID:3, description: 'child of child entity'
    },{
      ID:4, description: 'another child of child entity'
    }]
  }
}
```
:::

Note that Associations and Compositions are handled differently in (deep) inserts and updates:

- Compositions → runtime **deeply creates or updates** entries in target entities
- Associations → runtime **fills in foreign keys** to *existing* target entries

For example, the following request would create a new `Book` with a *reference* to an existing `Author`, with `{ID:12}` being the foreign key value filled in for association `author`:

```http
POST .../Books {
  ID:121, title: 'Jane Eyre', author: {ID:12}
}
```



#### Deep `UPDATE`

Deep `UPDATE` of the deeply nested documents look very similar to deep `INSERT`:

:::code-group
```http
PUT .../Orders/1 {
  title: 'changed title of existing order', header: {
    ID:2, items: [{
      ID:3, description: 'modified child of child entity'
    },{
      ID:5, description: 'new child of child entity'
    }]
  }]
}
```
:::

Depending on existing data, child entities will be created, updated, or deleted as follows:

- entries existing on the database, but not in the payload, are deleted → for example, `ID:4`
- entries existing on the database, and in the payload are updated → for example, `ID:3`
- entries not existing on the database are created → for example, `ID:5`

**`PUT` vs `PATCH`** — Omitted fields get reset to `default` values or `null` in case of `PUT` requests; they are left untouched for `PATCH` requests.

Omitted compositions have no effect, whether during `PATCH` or during `PUT`. That is, to delete all children, the payload must specify `null` or `[]`, respectively, for the to-one or to-many composition.



#### Deep `DELETE`

Deleting a root of a composition hierarchy results in a cascaded delete of all nested children.

:::code-group
```sql
DELETE .../Orders/1  -- would also delete all headers and items
```
:::

#### Limitations

Note that deep `WRITE` operations are only supported out of the box if the following conditions are met:

1. The on-condition of the composition only uses comparison predicates with an `=` operator.
2. The predicates are only connected with the logical operator `AND`.
3. The operands are references or `$self`. CAP Java also supports pseudo variables like `$user.locale`.

```cds
entity Orders {
  key ID : UUID;
  title  : String;
  Items  : Composition of many OrderItems on substring(title, 0, 1) <= 'F' or Items.pos > 12; // [!code --]
  Items  : Composition of many OrderItems on Items.order = $self; // [!code ++]
}
entity OrderItems {
  key order : Association to Orders;
  key pos  : Integer;
  descr: String;
}
```

### Auto-Generated Keys


On `CREATE` operations, `key` elements of type `UUID` are filled in automatically. In addition, on deep inserts and upserts, respective foreign keys of newly created nested objects are filled in accordingly.

For example, given a model like that:

```cds
entity Orders {
  key ID : UUID;
  title  : String;
  Items  : Composition of many OrderItems on Items.order = $self;
}
entity OrderItems {
  key order : Association to Orders;
  key pos  : Integer;
  descr: String;
}
```

When creating a new `Order` with nested `OrderItems` like that:

```js
POST .../Orders {
  title: 'Order #1', Items: [
    { pos:1, descr: 'Item #1' },
    { pos:2, descr: 'Item #2' }
  ]
}
```

CAP runtimes will automatically fill in `Orders.ID` with a new uuid, as well as the nested `OrderItems.order.ID` referring to the parent.



### Searching Data


CAP runtimes provide out-of-the-box support for advanced search of a given text in all textual elements of an entity including nested entities along composition hierarchies.

A typical search request looks like that:

```js
GET .../Books?$search=Heights
```

That would basically search for occurrences of `"Heights"` in all text fields of Books, that is, in `title` and `descr` using database-specific `contains` operations (for example, using `like '%Heights%'` in standard SQL).

#### The `@cds.search` Annotation {#cds-search}

By default search is limited to the elements of type `String` of an entity that aren't [calculated](../cds/cdl#calculated-elements) or [virtual](../cds/cdl#virtual-elements). Yet, sometimes you may want to deviate from this default and specify a different set of searchable elements, or to extend the search to associated entities. Use the `@cds.search` annotation to do so. The general usage is:

```cds
@cds.search: {
    element1,         // included
    element2 : true,  // included
    element3 : false, // excluded
    assoc1,           // extend to searchable elements in target entity
    assoc2.elementA   // extend to a specific element in target entity
}
entity E { }
```

[Learn more about the syntax of annotations.](../cds/cdl#annotations){.learn-more}

#### Including Fields

```cds
@cds.search: { title }
entity Books { ... }
```

Searches the `title` element only.

##### Extend Search to *Associated* Entities

::: warning Node.js: Only w/ streamlined database services
For Node.js projects, this feature is only available with the [streamlined `@cap-js/` database services](../releases/archive/2024/jun24#new-database-services-ga) (default with `@sap/cds` >= 8)
:::

```cds
@cds.search: { author }
entity Books { ... }

@cds.search: { biography: false }
entity Authors { ... }
```

Searches all elements of the `Books` entity, as well as all searchable elements of the associated `Authors` entity. Which elements of the associated entity are searchable is determined by the `@cds.search` annotation on the associated entity. So, from `Authors`, all elements of type `String` are searched but `biography` is excluded.

##### Extend to Individual Elements in Associated Entities

```cds
@cds.search: { author.name }
entity Books { ... }
```

Searches only in the element `name` of the associated `Authors` entity.

#### Excluding Fields

```cds
@cds.search: { isbn: false }
entity Books { ... }
```

Searches all elements of type `String` excluding the element `isbn`, which leaves the `title` and `descr` elements to be searched.

::: tip
You can explicitly annotate calculated elements to make them searchable, even though they aren't searchable by default. The virtual elements won't be searchable even if they're explicitly annotated.
:::

#### Fuzzy Search on SAP HANA Cloud <Beta /> {#fuzzy-search}

> Prerequisite: For CAP Java, you need to run in [`HEX` optimization mode](../java/cqn-services/persistence-services#sql-optimization-mode) on SAP HANA Cloud and enable <Config java keyOnly>cds.sql.hana.search.fuzzy = true</Config>

Fuzzy search is a fault-tolerant search feature of SAP HANA Cloud, which returns records even if the search term contains additional characters, is missing characters, or has typographical errors.

You can configure the fuzziness in the range [0.0, 1.0]. The value 1.0 enforces exact search.

- Java: <Config java keyOnly>cds.sql.hana.search.fuzzinessThreshold = 0.8</Config>
- Node.js:<Config keyOnly>cds.hana.fuzzy = 0.7</Config><sup>(1)</sup> 

<sup>(1)</sup> If set to `false`, fuzzy search is disabled and falls back to a case insensitive substring search.

Override the fuzziness for elements, using the `@Search.fuzzinessThreshold` annotation:

```cds
entity Books {
   @Search.fuzzinessThreshold: 0.7
   title : String;
}
```

The relevance of a search match depends on the weight of the element causing the match. By default, all [searchable elements](#cds-search) have equal weight. To adjust the weight of an element, use the `@Search.ranking` annotation. Allowed values are HIGH, MEDIUM (default), and LOW:

```cds
entity Books {
   @Search.ranking: HIGH
   title         : String;

   @Search.ranking: LOW
   publisherName : String;
}
```

::: tip Wildcards in search terms
When using wildcards in search terms, an *exact pattern search* is performed.
Supported wildcards are '*' matching zero or more characters and '?' matching a single character. You can escape wildcards using '\\'.
:::



### Pagination & Sorting


#### Implicit Pagination

By default, the generic handlers for READ requests automatically **truncate** result sets to a size of 1,000 records max.
If there are more entries available, a link is added to the response allowing clients to fetch the next page of records.

The OData response body for truncated result sets contains a `nextLink` as follows:

```http
GET .../Books
>{
  value: [
    {... first record ...},
    {... second record ...},
    ...
  ],
  @odata.nextLink: "Books?$skiptoken=1000"
}
```

To retrieve the next page of records from the server, the client would use this `nextLink` in a follow-up request, like so:

```http
GET .../Books?$skiptoken=1000
```

On firing this query, you get the second set of 1,000 records with a link to the next page, and so on, until the last page is returned, with the response not containing a `nextLink`.
::: warning
Per OData specification for [Server Side Paging](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ServerDrivenPaging), the value of the `nextLink` returned by the server must not be interpreted or changed by the clients.
:::

#### Reliable Pagination

> Note: This feature is available only for OData V4 endpoints.

Using a numeric skip token based on the values of `$skip` and `$top` can result in duplicate or missing rows if the entity set is modified between the calls. _Reliable Pagination_ avoids this inconsistency by generating a skip token based on the values of the last row of a page.

The reliable pagination is available with following limitations:

- Results of functions or arithmetic expressions can't be used in the `$orderby` option (explicit ordering).
- The elements used in the `$orderby` of the request must be of simple type.
- All elements used in `$orderby` must also be included in the `$select` option, if it's set.
- Complex [concatenations](../advanced/odata#concat) of result sets aren't supported.
::: warning
Don't use reliable pagination if an entity set is sorted by elements that contain sensitive information, the skip token could reveal the values of these elements.
:::

The feature can be enabled with the following [configuration options](../node.js/cds-env#project-settings) set to `true`:
- Java: <Config java keyOnly>cds.query.limit.reliablePaging.enabled: true</Config>
- Node.js: <Config keyOnly>cds.query.limit.reliablePaging: true</Config>


#### Paging Limits


You can configure default and maximum page size limits in your [project configuration](../node.js/cds-env#project-settings) as follows:

```json
"cds": {
  "query": {
    "limit": {
      "default": 20, //> no default
      "max": 100     //> default 1000
    }
  }
}
```

- The **maximum limit** defines the maximum number of items that can get retrieved, regardless of `$top`.
- The **default limit** defines the number of items that are retrieved if no `$top` was specified.


##### Annotation `@cds.query.limit` {#annotation-cds-query-limit}

You can override the defaults by applying the `@cds.query.limit` annotation on the service or entity level, as follows:


```cds
@cds.query.limit: { default?, max? } | Number
```

The limit definitions for `CatalogService` and `AdminService` in the following example are equivalent.

```cds
@cds.query.limit.default: 20
@cds.query.limit.max: 100
service CatalogService {
  // ...
}
@cds.query.limit: { default: 20, max: 100 }
service AdminService {
  // ...
}
```

`@cds.query.limit` can be used as shorthand if no default limit needs to be specified at the same level.

```cds
@cds.query.limit: 100
service CatalogService {
  entity Books as projection on my.Books;     //> pages at 100
  @cds.query.limit: 20
  entity Authors as projection on my.Authors; //> pages at 20
}
service AdminService {
  entity Books as projection on my.Books;     //> pages at 1000 (default)
}
```

##### Precedence

The closest limit applies, that means, an entity-level limit overrides that of its service, and a service-level limit overrides the global setting. The value `0` disables the respective limit at the respective level.

```cds
@cds.query.limit.default: 20
service CatalogService {
  @cds.query.limit.max: 100
  entity Books as projection on my.Books;     //> default = 20 (from CatalogService), max = 100
  @cds.query.limit: 0
  entity Authors as projection on my.Authors; //> no default, max = 1,000 (from environment)
}
```


#### Implicit Sorting


Paging requires implied sorting, otherwise records might be skipped accidentally when reading follow-up pages.
By default the entity's primary key is used as a sort criterion.

For example, given a service definition like this:

```cds
service CatalogService {
  entity Books as projection on my.Books;
}
```

The SQL query executed in response to incoming requests to Books will be enhanced with an additional order-by clause as follows:

```sql
SELECT ... from my_Books
ORDER BY ID; -- default: order by the entity's primary key
```

If the request specifies a sort order, for example, `GET .../Books?$orderby=author`, both are applied as follows:

```sql
SELECT ... from my_Books ORDER BY
  author,     -- request-specific order has precedence
  ID;         -- default order still applied in addition
```

We can also define a default order when serving books as follows:

```cds
service CatalogService {
  entity Books as projection on my.Books order by title asc;
}
```

Now, the resulting order by clauses are as follows for `GET .../Books`:

```sql
SELECT ... from my_Books ORDER BY
  title asc,  -- from entity definition
  ID;         -- default order still applied in addition
```

... and for `GET .../Books?$orderby=author`:

```sql
SELECT ... from my_Books ORDER BY
  author,     -- request-specific order has precedence
  title asc,  -- from entity definition
  ID;         -- default order still applied in addition
```





### Concurrency Control

CAP runtimes support different ways to avoid lost-update situations as documented in the following.

Use _optimistic locking_ to _detect_ concurrent modification of data _across requests_. The implementation relies on [ETags](#etag).

Use _pessimistic locking_ to _protect_ data from concurrent modification by concurrent _transactions_. CAP leverages database locks for [pessimistic locking](#select-for-update).

#### Conflict Detection Using ETags {#etag}

The CAP runtimes support optimistic concurrency control and caching techniques using ETags.
An ETag identifies a specific version of a resource found at a URL.

Enable ETags by adding the `@odata.etag` annotation to an element to be used to calculate an ETag value as follows:

```cds
using { managed } from '@sap/cds/common';
entity Foo : managed {...}
annotate Foo with { modifiedAt @odata.etag }
```

> The value of an ETag element should uniquely change with each update per row.
> The `modifiedAt` element from the [pre-defined `managed` aspect](../cds/common#aspect-managed) is a good candidate, as this is automatically updated.
> You could also use update counters or UUIDs, which are recalculated on each update.

You use ETags when updating, deleting, or invoking the action bound to an entity by using the ETag value in an `If-Match` or `If-None-Match` header.
The following examples represent typical requests and responses:

```http
POST Employees { ID:111, name:'Name' }
> 201 Created {'@odata.etag': 'W/"2000-01-01T01:10:10.100Z"',...}
//> Got new ETag to be used for subsequent requests...
```

```http
GET Employees/111
If-None-Match: "2000-01-01T01:10:10.100Z"
> 304 Not Modified // Record was not changed
```

```http
GET Employees/111
If-Match: "2000-01-01T01:10:10.100Z"
> 412 Precondition Failed // Record was changed by another user
```

```http
UPDATE Employees/111
If-Match: "2000-01-01T01:10:10.100Z"
> 200 Ok {'@odata.etag': 'W/"2000-02-02T02:20:20.200Z"',...}
//> Got new ETag to be used for subsequent requests...
```

```http
UPDATE Employees/111
If-Match: "2000-02-02T02:20:20.200Z"
> 412 Precondition Failed // Record was modified by another user
```

```http
DELETE Employees/111
If-Match: "2000-02-02T02:20:20.200Z"
> 412 Precondition Failed // Record was modified by another user
```

If the ETag validation detects a conflict, the request typically needs to be retried by the client. Hence, optimistic concurrency should be used if conflicts occur rarely.

#### Pessimistic Locking {#select-for-update}

_Pessimistic locking_ allows you to lock the selected records so that other transactions are blocked from changing the records in any way.

Use _exclusive_ locks when reading entity data with the _intention to update_ it in the same transaction and you want to prevent the data to be locked or updated in a concurrent transaction.

Use _shared_ locks if you only need to prevent the entity data to be locked exclusively by an update in a concurrent transaction or by a read operation with lock mode _exclusive_. Non-locking read operations or read operations with lock mode _shared_ are not prevented.

The records are locked until the end of the transaction by commit or rollback statement.

Here's an overview table:

| State              | Select Without Lock   | Select With Shared Lock |  Select With Exclusive Lock/Update |
| --------------- | ----------------------- | -------------------------- |  ------------------------------------- |
| not locked      | passes | passes  | passes |
| shared lock     | passes | passes  | waits |
| exclusive lock | passes | waits  | waits |


[Learn more about using the `SELECT ... FOR UPDATE` statement in the Node.js runtime.](../node.js/cds-ql#forupdate){.learn-more}

[Learn more about using the `Select.lock()` method in the Java runtime.](../java/working-with-cql/query-api#write-lock){.learn-more}


::: warning Restrictions
-  Pessimistic locking is supported for domain entities (DB table rows). The locking is not possible for projections and views.
-  Pessimistic locking is not supported by SQLite. H2 supports exclusive locks only.
:::

## Input Validation

CAP runtimes automatically validate user input, controlled by the following annotations.


### `@readonly`

Elements annotated with `@readonly`, as well as [_calculated elements_](../cds/cdl#calculated-elements), are protected against write operations. That is, if a CREATE or UPDATE operation specifies values for such fields, these values are **silently ignored**.

By default [`virtual` elements](../cds/cdl#virtual-elements) are also _calculated_.
::: tip
The same applies for fields with the [OData Annotations](../advanced/odata#annotations) `@FieldControl.ReadOnly` (static), `@Core.Computed`, or `@Core.Immutable` (the latter only on UPDATEs).
:::

::: warning Not allowed on keys
Do not use the `@readonly` annotation on keys in all variants.
:::

<div id="readonlywithexpressions"/>
<Fragment target="#readonlywithexpressions">

#### ... with expressions <Internal/> <Alpha/> { .java}

It is possible to define an expression for the `@readonly` annotation. The expression ensures that the annotated field is protected against write operations only when it evaluates to `true`.

```cds
entity Foo {
  bar : Boolean;
  boo : String @readonly: (not bar);
}
```

Refer to [Expressions as Annotation Values](../cds/cdl.md#expressions-as-annotation-values) for detailed rules on expression syntax.

::: info Expression Evaluation
The expressions provided with the `@readonly` annotation will be evaluated against the before-image of the affected entities. The before-image is the state of the given entity *before* the given
request is applied to the underlying datastore. For `CREATE` events this means that elements are not considered readonly and are writable. The affected entities are the entities being part of the request and identified by their primary keys. The evaluating runtime then constructs and executes
statements with the annotation-provided expressions and the respective primary key values for the given entities. Depending on the structure and cardinality of the request data it can be one or more statements being executed.
:::

::: warning Limitations
- Constraints will only be enforced in `CREATE` and `UPDATE` statements that contain all key fields (including deep insert and deep update)
- Subqueries and aggregations are not supported in the condition
- Only elements with simple types (like, `String`, `Integer`, `Boolean`) can be annotated with `@readonly` with expressions. Elements typed with structured or arrayed types are not supported.
:::
</Fragment>


### `@mandatory`

Elements marked with `@mandatory` are checked for nonempty input: `null` and (trimmed) empty strings are rejected.

```cds
service Sue {
  entity Books {
    key ID : UUID;
    title  : String @mandatory;
  }
}
```

In addition to server-side input validation as introduced above, this adds a corresponding `@FieldControl` annotation to the EDMX so that OData / Fiori clients would enforce a valid entry, thereby avoiding unnecessary request roundtrips:

```xml
<Annotations Target="Sue.Books/title">
  <Annotation Term="Common.FieldControl" EnumMember="Common.FieldControlType/Mandatory"/>
</Annotations>
```

<div id="mandatorywithexpressions"/>
<Fragment target="#mandatorywithexpressions">

#### ... with expressions <Internal/> <Alpha/> { .java}

It is possible to define an expression for the `@mandatory` annotation. The expression ensures that the described mandatory validations are applied only if the expression evaluates to `true`.

```cds
entity Foo {
  bar : Boolean;
  boo : String @mandatory: (bar);
}
```

Refer to [Expressions as Annotation Values](../cds/cdl.md#expressions-as-annotation-values) for detailed rules on expression syntax.

::: warning Limitations
- Constraints will only be enforced in `CREATE` and `UPDATE` statements that contain all key fields (including deep insert and deep update)
- Subqueries and aggregations are not supported in the condition
- Only elements with simple types (like, `String`, `Integer`, `Boolean`) can be annotated with `@mandatory` with expressions. Elements typed with structured or arrayed types are not supported.
:::
</Fragment>


### `@assert .format`

Allows you to specify a regular expression string (in ECMA 262 format in CAP Node.js and java.util.regex.Pattern format in CAP Java) that all string input must match.

```cds
entity Foo {
  bar : String @assert.format: '[a-z]ear';
}
```


### `@assert .range`

Allows you to specify `[ min, max ]` ranges for elements with ordinal types &mdash; that is, numeric or date/time types. For `enum` elements, `true` can be specified to restrict all input to the defined enum values.

```cds
entity Foo {
  bar : Integer  @assert.range: [ 0, 3 ];
  boo : Decimal  @assert.range: [ 2.1, 10.25 ];
  car : DateTime @assert.range: ['2018-10-31', '2019-01-15'];
  zoo : String   @assert.range enum { high; medium; low; };
}
```
#### ... with open intervals

By default, specified `[min,max]` ranges are interpreted as closed intervals, that means, the performed checks are `min ≤ input ≤ max`. You can also specify open intervals by wrapping the *min* and/or *max* values into parenthesis like that:


```cds
@assert.range: [(0),100]    // 0 < input ≤ 100
@assert.range: [0,(100)]    // 0 ≤ input < 100
@assert.range: [(0),(100)]  // 0 < input < 100
```
In addition, you can use an underscore `_` to represent *Infinity* like that:

```cds
@assert.range: [(0),_]  // positive numbers only, _ means +Infinity here
@assert.range: [_,(0)]  // negative number only, _ means -Infinity here
```
>  Basically values wrapped in parentheses _`(x)`_ can be read as _excluding `x`_ for *min* or *max*. Note that the underscore `_` doesn't have to be wrapped into parenthesis, as by definition no number can be equal to *Infinity* .

Support for open intervals and infinity is available for CAP Node.js since `@sap/cds` version **8.5** and in CAP Java since version **3.5.0**.



### `@assert .target`

Annotate a [managed to-one association](../cds/cdl#managed-associations) of a CDS model entity definition with the
`@assert.target` annotation to check whether the target entity referenced by the association (the reference's target)
exists. In other words, use this annotation to check whether a non-null foreign key input in a table has a corresponding
primary key in the associated/referenced target table.

You can check whether multiple targets exist in the same transaction. For example, in the `Books` entity, you could
annotate one or more managed to-one associations with the `@assert.target` annotation. However, it is assumed that
dependent values were inserted before the current transaction. For example, in a deep create scenario, when creating a
book, checking whether an associated author exists that was created as part of the same deep create transaction isn't
supported, in this case, you will get an error.

The `@assert.target` check constraint is meant to **validate user input** and not to ensure referential integrity.
Therefore only `CREATE`, and `UPDATE` events are supported (`DELETE` events are not supported). To ensure that every
non-null foreign key in a table has a corresponding primary key in the associated/referenced target table
(ensure referential integrity), the [`@assert.integrity`](databases#database-constraints) constraint must be used instead.

If the reference's target doesn't exist, an HTTP response
(error message) is provided to HTTP client applications and logged to stdout in debug mode. The HTTP response body's
content adheres to the standard OData specification for an error
[response body](https://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_ErrorResponse).

#### Example

Add `@assert.target` annotation to the service definition as previously mentioned:

```cds
entity Books {
  key ID : UUID;
  title  : String;
  author : Association to Authors @assert.target;
}

entity Authors {
  key ID : UUID;
  name   : String;
  books  : Association to many Books on books.author = $self;
}
```

**HTTP Request** — *assume that an author with the ID `"796e274a-c3de-4584-9de2-3ffd7d42d646"` doesn't exist in the database*

```http
POST Books HTTP/1.1
Accept: application/json;odata.metadata=minimal
Prefer: return=minimal
Content-Type: application/json;charset=UTF-8

{"author_ID": "796e274a-c3de-4584-9de2-3ffd7d42d646"}
```

**HTTP Response**

```http
HTTP/1.1 400 Bad Request
odata-version: 4.0
content-type: application/json;odata.metadata=minimal

{"error": {
  "@Common.numericSeverity": 4,
  "code": "400",
  "message": "Value doesn't exist",
  "target": "author_ID"
}}
```
::: tip
In contrast to the `@assert.integrity` constraint, whose check is performed on the underlying database layer,
the `@assert.target` check constraint is performed on the application service layer before the custom application handlers are called.
:::
::: warning
Cross-service checks are not supported. It is expected that the associated entities are defined in the same service.
:::
::: warning
The `@assert.target` check constraint relies on database locks to ensure accurate results in concurrent scenarios. However, locking is a database-specific feature, and some databases don't permit to lock certain kinds of objects. On SAP HANA, for example, views with joins or unions can't be locked. Do not use `@assert.target` on such artifacts/entities.
:::


<div id="assertconstraints" />
<Fragment target="#assertconstraints">

### `@assert .constraint` <Internal/> <Alpha/> { .java}

Annotate an entity or element with `@assert.constraint` to define an expression for more complex constraints that need to be fulfilled before data gets persisted. The constraint is defined by an expression in the `condition` property. If the expression evaluates to `false`, the operation is rejected and the message defined in the `message` property is returned.

The `message` property can be a static message or a message key. If a message key is used, the message is looked up in the message bundle of the service. In both cases, the message can be defined with parameters, which get replaced with the values of the elements defined in the `parameters` property. The `parameters` property is optional; if not provided, the message will be used as-is without parameter substitution.

[Learn more about localized messages](./i18n){.learn-more}

Specify the `targets` property to define the affected elements. For annotations on element level where no `targets` property is defined, the element itself is implicitly used as the target.

```cds
@assert.constraint.lengthExpression: {
	condition: (length(bar) > length(boo)),
	message: 'foo.bar.length',
	targets: [(bar), (boo)]
}
entity Foo {
  @assert.constraint.notInvalid: {
	condition: (bar != 'invalid'),
	message: 'foo.bar.invalid',
    parameters: [(bar)]
  }
  bar : String;
  boo : String;
}
```

Refer to [Expressions as Annotation Values](../cds/cdl.md#expressions-as-annotation-values) for detailed rules on expression syntax.

::: info Expression Evaluation
Expressions defined in the `condition` property are evaluated against the after-image of the affected entity. The after-image is the state of the given entity *after* the given request is applied to the underlying datastore. For example, think of the after-image as a snapshot of the entity's state after an update or insert operation has been processed. The affected entities are the entities being part of the request and identified by their primary keys. The evaluating runtime constructs and executes statements with the annotation-provided expressions and the respective primary key values for the given entities. Depending on the structure and cardinality of the request data it can be one or more statements being executed.
:::

::: warning Limitations
- Constraints will only be enforced in `CREATE` and `UPDATE` statements that contain all key fields (including deep insert and deep update)
- Subqueries and aggregations are not supported in the condition
- Only elements with simple types (like, `String`, `Integer`, `Boolean`) can be annotated with `@assert.constraint`. Elements typed with structured or arrayed types are not supported
:::
</Fragment>


### Database Constraints

Next to input validation, you can add [database constraints](databases#database-constraints) to prevent invalid data from being persisted.

<div id="assertconstraints" />
<Fragment target="#assertconstraints">

### `@assert .constraint` <Internal/> <Alpha/> { .java}

Annotate an entity or element with `@assert.constraint` to define an expression for more complex constraints that need to be fulfilled before data gets persisted. The constraint is defined by an expression in the `condition` property. If the expression evaluates to `false`, the operation is rejected and the message defined in the `message` property is returned.

The `message` property can be a static message or a message key. If a message key is used, the message is looked up in the message bundle of the service. In both cases, the message can be defined with parameters, which get replaced with the values of the elements defined in the `parameters` property. The `parameters` property is optional; if not provided, the message will be used as-is without parameter substitution.

[Learn more about localized messages](./i18n){.learn-more}

Specify the `targets` property to define the affected elements. For annotations on element level where no `targets` property is defined, the element itself is implicitly used as the target.

```cds
@assert.constraint.lengthExpression: {
	condition: (length(bar) > length(boo)),
	message: 'foo.bar.length',
	targets: [(bar), (boo)]
}
entity Foo {
  @assert.constraint.notInvalid: {
	condition: (bar != 'invalid'),
	message: 'foo.bar.invalid',
    parameters: [(bar)]
  }
  bar : String;
  boo : String;
}
```

Refer to [Expressions as Annotation Values](../cds/cdl.md#expressions-as-annotation-values) for detailed rules on expression syntax.

::: info Expression Evaluation
Expressions defined in the `condition` property are evaluated against the after-image of the affected entity. The after-image is the state of the given entity *after* the given request is applied to the underlying datastore. For example, think of the after-image as a snapshot of the entity's state after an update or insert operation has been processed. The affected entities are the entities being part of the request and identified by their primary keys. The evaluating runtime constructs and executes statements with the annotation-provided expressions and the respective primary key values for the given entities. Depending on the structure and cardinality of the request data it can be one or more statements being executed.
:::

::: warning Limitations
- Constraints will only be enforced in `CREATE` and `UPDATE` statements that contain all key fields (including deep insert and deep update)
- Subqueries and aggregations are not supported in the condition
- Only elements with simple types (like, `String`, `Integer`, `Boolean`) can be annotated with `@assert.constraint`. Elements typed with structured or arrayed types are not supported
:::
</Fragment>

## Custom Logic



As most standard tasks and use cases are covered by [generic service providers](#generic-providers), the need to add service implementation code is greatly reduced and minified, and hence the quantity of individual boilerplate coding.

The remaining cases that need custom handlers, reduce to real custom logic, specific to your domain and application, such as:

- Domain-specific programmatic [Validations](#input-validation)
- Augmenting result sets, for example to add computed fields for frontends
- Programmatic [Authorization Enforcements](/guides/security/authorization#enforcement)
- Triggering follow-up actions, for example calling other services or emitting outbound events in response to inbound events
- And more... In general, all the things not (yet) covered by generic handlers



**In Node.js**, the easiest way to add custom implementations for services is through equally named _.js_ files placed next to a service definition's _.cds_ file:

```sh
./srv
  - cat-service.cds  # service definitions
  - cat-service.js   # service implementation
...
```

[Learn more about providing service implementations in Node.js.](../node.js/core-services#implementing-services){.learn-more}

**In Java**, you'd assign `EventHandler` classes using dependency injection as follows:

```Java
@Component
@ServiceName("org.acme.Foo")
public class FooServiceImpl implements EventHandler {...}
```

[Learn more about Event Handler classes in Java.](../java/event-handlers/#handlerclasses){.learn-more}



### Custom Event Handlers

Within your custom implementations, you can register event handlers like that:

::: code-group

```js [Node.js]
module.exports = function (){
  this.on ('submitOrder', (req)=>{...}) //> custom actions
  this.on ('CREATE',`Books`, (req)=>{...})
  this.before ('UPDATE',`*`, (req)=>{...})
  this.after ('READ',`Books`, (books)=>{...})
}
```
```Java
@Component
@ServiceName("BookshopService")
public class BookshopServiceImpl implements EventHandler {
  @On(event="submitOrder") public void onSubmitOrder (EventContext req) {...}
  @On(event="CREATE", entity="Books") public void onCreateBooks (EventContext req) {...}
  @Before(event="UPDATE", entity="*") public void onUpdate (EventContext req) {...}
  @After(event="READ", entity="Books") public void onReadBooks (EventContext req) {...}
}
```

:::

[Learn more about **adding event handlers in Node.js**.](../node.js/core-services#srv-on-before-after){.learn-more}

[Learn more about **adding event handlers in Java**.](../java/event-handlers/#handlerclasses){.learn-more}



### Hooks: `on`, `before`, `after`

In essence, event handlers are functions/method registered to be called when a certain event occurs, with the event being a custom operation, like `submitOrder`, or a CRUD operation on a certain entity, like `READ Books`; in general following this scheme:

- `<hook:on|before|after>` , `<event>` , `[<entity>]` &rarr; handler function

CAP allows to plug in event handlers to these different hooks, that is phases during processing a certain event:

- `on` handlers run _instead of_ the generic/default handlers.
- `before` handlers run _before_ the `on` handlers
- `after` handlers run _after_ the `on` handlers, and get the result set as input

`on` handlers form an *interceptor* stack: the topmost handler getting called by the framework. The implementation of this handler   is in control whether to delegate to default handlers down the stack or not.

`before` and `after` handlers are *listeners*: all registered listeners are invoked in parallel. If one vetoes / throws an error the request fails.



### Within Event Handlers {#handler-impls}

Event handlers all get a uniform _Request_/_Event Message_ context object as their primary argument, which, among others, provides access to the following information:

- The `event` name — that is, a CRUD method name, or a custom-defined one
- The `target` entity, if any
- The `query` in [CQN](../cds/cqn) format, for CRUD requests
- The `data` payload
- The `user`, if identified/authenticated
- The `tenant` using your SaaS application, if enabled

[Learn more about **implementing event handlers in Node.js**.](../node.js/events#cds-request){.learn-more}
[Learn more about **implementing event handlers in Java**.](../java/event-handlers/#eventcontext){.learn-more}



## Actions & Functions

In addition to common CRUD operations, you can declare domain-specific custom operations as shown below. These custom operations always need custom implementations in corresponding events handlers.

You can define actions and functions in CDS models like that:
```cds
service Sue {
  // unbound actions & functions
  function sum (x:Integer, y:Integer) returns Integer;
  function stock (id : Foo:ID) returns Integer;
  action add (x:Integer, to: Integer) returns Integer;

  // bound actions & functions
  entity Foo { key ID:Integer } actions {
    function getStock() returns Integer;
    action order (x:Integer) returns Integer;
    //bound to the collection and not a specific instance of Foo
    action customCreate (in: many $self, x: String) returns Foo;
    // All parameters are optional by default, unless marked with `not null`:
    action discard (reason: String not null);
  }
}
```

[Learn more about modeling actions and functions in CDS.](../cds/cdl#actions){.learn-more}



The differentiation between *Actions* and *Functions* as well as *bound* and *unbound* stems from the OData specifications, and in essence is as follows:

- **Actions** modify data in the server
- **Functions** retrieve data
- **Unbound** actions/functions are like plain unbound functions in JavaScript.
- **Bound** actions/functions always receive the bound entity's primary key as implicit first argument, similar to `this` pointers in Java or JavaScript. The exception are bound actions to collections, which are bound against the collection and not a specific instance of the entity. An example use case are custom create actions for the SAP Fiori elements UI.


### Implementing Actions / Functions

In general, implement actions or functions like that:

```js
module.exports = function Sue(){
  this.on('sum', ({data:{x,y}}) => x+y)
  this.on('add', ({data:{x,to}}) => stocks[to] += x)
  this.on('stock', ({data:{id}}) => stocks[id])
  this.on('getStock','Foo', ({params:[id]}) => stocks[id])
  this.on('order','Foo', ({params:[id],data:{x}}) => stocks[id] -= x)
}
```

Event handlers for actions or functions are very similar to those for CRUD events, with the name of the action/function replacing the name of the CRUD operations. No entity is specific for unbound actions/functions.

**Method-style Implementations** in Node.js, you can alternatively implement actions and functions using conventional JavaScript methods with subclasses of `cds.Service`:

```js
module.exports = class Sue extends cds.Service {
  sum(x,y) { return x+y }
  add(x,to) { return stocks[to] += x }
  stock(id) { return stocks[id] }
  getStock(Foo,id) { return stocks[id] }
  order(Foo,id,x) { return stocks[id] -= x }
}
```



### Calling Actions / Functions

**HTTP Requests** to call the actions/function declared above look like that:

```js
GET .../sue/sum(x=1,y=2)              // unbound function
GET .../sue/stock(id=2)               // unbound function
POST .../sue/add {"x":11,"to":2}      // unbound action
GET .../sue/Foo(2)/Sue.getStock()     // bound function
POST .../sue/Foo(2)/Sue.order {"x":3} // bound action
```

> Note: You always need to add the `()` for functions, even if no arguments are required. The OData standard specifies that bound actions/functions need to be prefixed with the service's name. In the previous example, entity `Foo` has a bound action `order`. That action must be called via `/Foo(2)/Sue.order` instead of simply `/Foo(2)/order`.
> For convenience, the CAP Node.js runtime also allows the following:
> - Call bound actions/functions without prefixing them with the service name.
> - Omit the `()` if no parameter is required.
> - Use query options to provide function parameters like `sue/sum?x=1&y=2`

<br>


**Programmatic** usage via **generic APIs** for Node.js:

For unbound actions and functions:

```ts
async function srv.send (
  event   : string | { event, data?, headers?: object },  
  data?   : object | any
)
return : result of this.dispatch(req)
```

For bound actions and functions:

```ts
async function srv.send (
 event   : string | { event, entity, data?, params?: array of object, headers?: object },
 entity  : string,
 data?   : object | any
)
return : result of this.dispatch(req)
```

-  `event` is a name of a custom action or function
-  `entity` is a name of an entity
-  `params` are keys of the entity instance

Programmatic usage would look like this for Node.js:

```js
  const srv = await cds.connect.to('Sue')
  // unbound actions/functions
  await srv.send('sum',{x:1,y:2})
  await srv.send('stock',{id:2})
  await srv.send('add',{x:11,to:2})
  // actions/functions bound to collection
  await srv.send('getStock','Foo',{id:2})
  // for actions/functions bound to entity instance, use this syntax
  await srv.send({ event: 'order', entity: 'Foo', data: {x:3}, params: [{id:2}]})
```

> Note: Always pass the target entity name as second argument for bound actions/functions.

<br>

**Programmatic** usage via **typed API** — Node.js automatically equips generated service instances with specific methods matching the definitions of actions/functions found in the services' model. This allows convenient usage like that:

```js
  const srv = await cds.connect.to(Sue)
  // unbound actions/functions
  srv.sum(1,2)
  srv.stock(2)
  srv.add(11,2)
  // bound actions/functions
  srv.getStock('Foo',2)
  srv.order('Foo',2,3)
```

> Note: Even with that typed APIs, always pass the target entity name as second argument for bound actions/functions.



<br><br>



## Serving Media Data

CAP provides out-of-the-box support for serving media and other binary data.


### Annotating Media Elements

You can use the following annotations in the service model to indicate that an element in an entity contains media data.

`@Core.MediaType`
: Indicates that the element contains media data (directly or using a redirect). The value of this annotation is either a string with the contained MIME type (as shown in the first example), or is a path to the element that contains the MIME type (as shown in the second example).

`@Core.IsMediaType`
: Indicates that the element contains a MIME type. The `@Core.MediaType` annotation of another element can reference this element.

`@Core.IsURL @Core.MediaType`
: Indicates that the element contains a URL pointing to the media data (redirect scenario).

`@Core.ContentDisposition.Filename`
: Indicates that the element is expected to be displayed as an attachment, that is downloaded and saved locally. The value of this annotation is a path to the element that contains the Filename (as shown in the fourth example ).

`@Core.ContentDisposition.Type`
: Can be used to instruct the browser to display the element inline, even if `@Core.ContentDisposition.Filename` is specified, by setting to `inline` (see the fifth example). If omitted, the behavior is `@Core.ContentDisposition.Type: 'attachment'`.

[Learn more how to enable stream support in SAP Fiori elements.](https://ui5.sap.com/#/topic/b236d32d48b74304887b3dd5163548c1){.learn-more}

The following examples show these annotations in action:

1. Media data is stored in a database with a fixed media type `image/png`:

```cds
entity Books { //...
  image : LargeBinary @Core.MediaType: 'image/png';
}
```

2. Media data is stored in a database with a _variable_ media type:

```cds
entity Books { //...
  image : LargeBinary @Core.MediaType: imageType;
  imageType : String  @Core.IsMediaType;
}
```

3. Media data is stored in an external repository:

```cds
entity Books { //...
  imageUrl  : String @Core.IsURL @Core.MediaType: imageType;
  imageType : String @Core.IsMediaType;
}
```

4. Content disposition data is stored in a database with a _variable_ disposition:
```cds
entity Authors { //...
  image : LargeBinary @Core.MediaType: imageType @Core.ContentDisposition.Filename: fileName;
  fileName : String;
}
```

5. The image shall have the suggested file name but be displayed inline nevertheless:

```cds
entity Authors { //...
  image : LargeBinary @Core.MediaType: imageType @Core.ContentDisposition.Filename: fileName @Core.ContentDisposition.Type: 'inline';
  fileName : String;
}
```

[Learn more about the syntax of annotations.](../cds/cdl#annotations){.learn-more}

::: warning
In case you rename the properties holding the media type or content disposition information in a projection, you need to update the annotation's value as well.
:::

### Reading Media Resources

Read media data using `GET` requests of the form `/Entity(<ID>)/mediaProperty`:

```cds
GET ../Books(201)/image
> Content-Type: application/octet-stream
```

> The response's `Content-Type` header is typically `application/octet-stream`.

> Although allowed by [RFC 2231](https://datatracker.ietf.org/doc/html/rfc2231), Node.js does not support line breaks in HTTP headers. Hence, make sure you remove any line breaks from your `@Core.IsMediaType` content.

Read media data with `@Core.ContentDisposition.Filename` in the model:

```cds
GET ../Authors(201)/image
> Content-Disposition: 'attachment; filename="foo.jpg"'
```

> The media data is streamed automatically.

[Learn more about returning a custom streaming object (Node.js - beta).](../node.js/best-practices#custom-streaming-beta){.learn-more}

### Creating a Media Resource

As a first step, create an entity without media data using a POST request to the entity. After creating the entity, you can insert a media property using the PUT method. The MIME type is passed in the `Content-Type` header. Here are some sample requests:

```cds
POST ../Books
Content-Type: application/json
{ <JSON> }
```

```cds
PUT ../Books(201)/image
Content-Type: image/png
<MEDIA>
```

> The media data is streamed automatically.

### Updating Media Resources

The media data for an entity can be updated using the PUT method:

```cds
PUT ../Books(201)/image
Content-Type: image/png
<MEDIA>
```

> The media data is streamed automatically.

### Deleting Media Resources

One option is to delete the complete entity, including all media data:

```cds
DELETE ../Books(201)
```

Alternatively, you can delete a media data element individually:

```cds
DELETE ../Books(201)/image
```

### Using External Resources

The following are requests and responses for the entity containing redirected media data from the third example, "Media data is stored in an external repository".
> This format is used by OData-Version: 4.0. To be changed in OData-Version: 4.01.

```cds
GET: ../Books(201)
>{ ...
    image@odata.mediaReadLink: "http://other-server/image.jpeg",
    image@odata.mediaContentType: "image/jpeg",
    imageType: "image/jpeg"
}
```

### Conventions & Limitations

#### General Conventions

- Binary data in payloads must be a Base64 encoded string.
- Binary data in URLs must have the format `binary'<url-safe base64 encoded>'`. For example:

```http
GET $filter=ID eq binary'Q0FQIE5vZGUuanM='
```

#### Node.js Runtime Conventions and Limitations

- The usage of binary data in some advanced constructs like the `$apply` query option and `/any()` might be limited.
- On SQLite, binary strings are stored as plain strings, whereas a buffer is stored as binary data. As a result, if in
a CDS query, a binary string is used to query data stored as binary, this wouldn't work.
- Please note, that SQLite doesn't support streaming. That means, that LargeBinary fields are read as a whole (not in chunks) and stored in memory, which can impact performance.
- SAP HANA Database Client for Node.js (HDB) and SAP HANA Client for Node.js (`@sap/hana-client`) packages handle
binary data differently. For example, HDB automatically converts binary strings into binary data, whereas SAP HANA
Client doesn't.
- In the Node.js Runtime, all binary strings are converted into binary data according to SAP HANA property types.
To disable this default behavior, you can set the environment variable <Config>cds.hana.base64_to_buffer: false</Config>.

# Best Practices



## Single-Purposed Services
{.best-practice}


We strongly recommend designing your services for single use cases.
Services in CAP are cheap, so there's no need to save on them.


#### **DON'T:**{.bad} Single Services Exposing All Entities 1:1

The anti-pattern to that are single services exposing all underlying entities in your app in a 1:1 fashion. While that may save you some thoughts in the beginning, it's likely that it will result in lots of headaches in the long run:

* They open huge entry doors to your clients with only few restrictions
* Individual use-cases aren't reflected in your API design
* You have to add numerous checks on a per-request basis...
* Which have to reflect on the actual use cases in complex and expensive evaluations


#### **DO:**{.good} One Service Per Use Case

For example, let's assume that we have a domain model defining *Books* and *Authors* more or less as above, and then we add *Orders*. We could define the following services:

```cds
using { my.domain as my } from './db/schema';
```

```cds
/** Serves end users browsing books and place orders */
service CatalogService {
  @readonly entity Books as select from my.Books {
    ID, title, author.name as author
  };
  @requires: 'authenticated-user'
  @insertonly entity Orders as projection on my.Orders;
}
```

```cds
/** Serves registered users managing their account and their orders */
@requires: 'authenticated-user'
service UsersService {
  @restrict: [{ grant: 'READ', where: 'buyer = $user' }] // limit to own ones
  @readonly entity Orders as projection on my.Orders;
  action cancelOrder ( ID:Orders.ID, reason:String );
}
```

```cds
/** Serves administrators managing everything */
@requires: 'authenticated-user'
service AdminService {
  entity Books   as projection on my.Books;
  entity Authors as projection on my.Authors;
  entity Orders  as projection on my.Orders;
}
```

These services serve different use cases and are tailored for each.
Note, for example, that we intentionally don't expose the `Authors` entity
to end users.

## Late-Cut Microservices {.best-practice}

Compared to Microservices, CAP services are 'Nano'. As shown in the previous sections, you should design your application as a set of loosely coupled, single-purposed services, which can all be served embedded in a single-server process at first (that is, a monolith).

Yet, given such loosely coupled services, and enabled by CAP's uniform way to define and consume services, you can decide later on to separate, deploy, and run your services as separate microservices, even without changing your models or code.

This flexibility allows you to, again, focus on solving your domain problem first, and avoid the efforts and costs of premature microservice design and DevOps overhead, at least in the early phases of development.

<div id="secondary-file">guides/providing-services.fragment.md</div>





# Consuming Services

<ImplVariantsHint />

## Introduction

If you want to use data from other services or you want to split your application into multiple microservices, you need a connection between those services. We call them **remote services**. As everything in CAP is a service, remote services are modeled the same way as internal services — using CDS.

CAP supports service consumption with dedicated APIs to [import](#import-api) service definitions, [query](#execute-queries) remote services, [mash up](#building-mashups) services, and [work locally](#local-mocking) as much as possible.





### Feature Overview

For outbound remote service consumption, the following features are supported:
+ OData V4
+ OData V2 (Deprecated)
+ [Querying API](#querying-api-features)
+ [Projections on remote services](#supported-projection-features)

### Tutorials and Examples
| Example                                                                                                                            | Description                                                                               |
| ---------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| [Capire Bookshop (Fiori)](https://github.com/sap-samples/cloud-cap-samples/tree/main/fiori)                                                                                           | Example, Node.js, CAP-to-CAP                                                              |
| [Example Application (Node.js)](https://github.com/SAP-samples/cloud-cap-risk-management/tree/ext-service-s4hc-suppliers-ui)       | Complete application from the end-to-end Tutorial                                         |
| [Example Application (Java)](https://github.com/SAP-samples/cloud-cap-risk-management/tree/ext-service-s4hc-suppliers-ui-java)     | Complete application from the end-to-end Tutorial                                         |
| [Incident Management (Node.js)](https://github.com/SAP-samples/btp-developer-guide-cap/tree/main/documentation/remote-service)    | Using a mock server or S/4 on Cloud Foundry or Kyma

### Define Scenario

Before you start your implementation, you should define your scenario. Answering the following questions gets you started:
+ What services (remote/CAP) are involved?
+ How do they interact?
+ What needs to be displayed on the UI?

You have all your answers and know your scenario, go on reading about [external service APIs](#external-service-api), getting an API definition from [the SAP Business Accelerator Hub](#from-api-hub) or [from a CAP project](#from-cap-service), and [importing an API definition](#import-api) to your project.

#### Sample Scenario from End-to-End Tutorial



![A graphic showing the flow for one possible scenario. A user can either view risks or view the suppliers. The suppliers master data is already available from a system and is consumed in an application that enables the user to add the risks. From the maintained risks the user can get information about the supplier connected to a risk. From the supplier view, it's also possible to get details about a risk that is associated with a supplier. The user can block/unblock suppliers from the risk view.](./assets/using-services/risk-mgmt.drawio.svg){}

::: info _User Story_
A company wants to ensure that goods are only sourced from suppliers with acceptable risks. There shall be a software system, that allows a clerk to maintain risks for suppliers and their mitigations. The system shall block the supplier used if risks can't be mitigated.
:::

The application is an extension for SAP S/4HANA. It deals with _risks_ and _mitigations_ that are local entities in the application and _suppliers_ that are stored in SAP S/4HANA Cloud. The application helps to reduce risks associated with suppliers by automatically blocking suppliers with a high risk using a [remote API Call](#execute-queries).

##### Integrate

The user picks a supplier from the list. That list is coming [from the remote system and is exposed by the CAP application](#expose-remote-services). Then the user does a risk assessment. Additional supplier data, like name and blocked status, should be displayed on the UI as well, by [integrating the remote supplier service into the local risk service](#integrate-remote-into-local-services).

##### Extend

It should be also possible to search for suppliers and show the associated risks by extending the remote supplier service [with the local risk service](#extend-a-remote-by-a-local-service) and its risks.

:::info New scenario: Incident Management
If you want to learn about this topic based on the [Incident Management](https://github.com/cap-js/incidents-app) sample, you can follow the [BTP Developer's Guide repository](https://github.com/SAP-samples/btp-developer-guide-cap/tree/main/documentation/remote-service).
:::

## Install Dependencies { .node }

```sh
npm add @sap-cloud-sdk/http-client@4.x @sap-cloud-sdk/connectivity@4.x @sap-cloud-sdk/resilience@4.x
```

## Get and Import an External Service API { #external-service-api }

To communicate to remote services, CAP needs to know their definitions. Having the definitions in your project allows you to mock them during design time.

These definitions are usually made available by the service provider. As they aren't defined within your application but imported from outside, they're called *external* service APIs in CAP. Service APIs can be provided in different formats. Currently, *EDMX* files for OData V2 and V4 are supported.

### From SAP Business Accelerator Hub { #from-api-hub}

The [SAP Business Accelerator Hub](https://api.sap.com/) provides many relevant APIs from SAP. You can download API specifications in different formats. If available, use the EDMX format. The EDMX format describes OData interfaces.

To download the [Business Partner API (A2X) from SAP S/4HANA Cloud](https://api.sap.com/api/API_BUSINESS_PARTNER/overview), go to section **API Resources**, select **API Specification**, and download the **EDMX** file.

### For a Remote CAP Service { #from-cap-service}

We recommend using EDMX as exchange format. Export a service API to EDMX:




::: code-group

```sh [Mac/Linux]
cds compile srv -s OrdersService -2 edmx > OrdersService.edmx
```

```cmd [Windows]
cds compile srv -s OrdersService -2 edmx > OrdersService.edmx
```

```powershell  [Powershell]
cds compile srv -s OrdersService -2 edmx -o dest/
```
:::


[You can try it with the orders sample in cap/samples.](https://github.com/SAP-samples/cloud-cap-samples/tree/master/orders){.learn-more}

By default, CAP works with OData V4 and the EDMX export is in this protocol version as well. The `cds compile` command offers options for other OData versions and flavors, call `cds help compile` for more information.
::: warning Don't just copy the CDS file for a remote CAP service
Simply copying CDS files from a different application comes with the following issues:
- The effective service API depends on the used protocol.
- CDS files often use includes, which can't be resolved anymore.
- CAP creates unneeded database tables and views for all entities in the file.
:::

### Import API Definition { #import-api}

Import the API to your project using `cds import`.

```sh
cds import <input_file> --as cds
```

> `<input_file>` can be an EDMX (OData V2, OData V4), OpenAPI or AsyncAPI file.

| Option             | Description                                                                                                                                                                                                       |
| ------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `--as cds`         | The import creates a CDS file (for example _API_BUSINESS_PARTNER.cds_) instead of a CSN file.                                                                                                                     |


This adds the API in CDS format to the _srv/external_ folder and also copies the input file into that folder.

<div class="impl node">

Further, it adds the API as an external service to your _package.json_. You use this declaration later to connect to the remote service [using a destination](#use-destinations-with-node-js).

```json
"cds": {
    "requires": {
        "API_BUSINESS_PARTNER": {
            "kind": "odata-v2",
            "model": "srv/external/API_BUSINESS_PARTNER"
        }
    }
}
```

</div>

::: details Options and flags in _.cdsrc.json_
Alternatively, you can set the options and flags for `cds import` in your _.cdsrc.json_:

```json
{
    "import": {
        "as": "cds",
        "force": true,
        "include_namespaces": "sap,c4c"
    }
}
```

Now run `cds import <filename>`

- `--as` only supports these formats: "csn","cds", and "json"
- `--force` is applicable only in combination with `--as` option. By default the `--force` flag is set to false.
  > If set to true, existing CSN/CDS files from previous imports are overwritten.
:::

When importing the specification files, the `kind` is set according to the following mapping:

| Imported Format | Used `kind`                    |
|-----------------|--------------------------------|
| OData V2        | `odata-v2`                     |
| OData V4        | `odata` (alias for `odata-v4`) |
| OpenAPI         | `rest`                         |
| AsyncAPI        | `odata`                        |

[Learn more about type mappings from OData to CDS and vice versa.](../tools/apis/cds-import#odata-type-mappings){.learn-more}

::: tip
Always use OData V4 (`odata`) when calling another CAP service.
:::

::: warning Limitations
Not all features of OData, OpenAPI, or AsyncAPI are supported in CAP which may lead to the rejection of the imported model by the CDS compiler or may result in a different API when rendered by CAP.
Known limitations are cyclic type references and inheritance.
:::

<div class="impl java">

You need to configure remote services in Spring Boot's _application.yaml_:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
spring:
  config.activate.on-profile: cloud
cds:
  remote.services:
    API_BUSINESS_PARTNER:
      type: "odata-v2"
```
:::
To work with remote services, add the following dependency to your Maven project:

```xml
<dependency>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-feature-remote-odata</artifactId>
  <scope>runtime</scope>
</dependency>
```

[Learn about all `cds.remote.services` configuration possibilities.](../java/developing-applications/properties#cds-remote-services){.learn-more}

</div>

## Local Mocking

When developing your application, you can mock the remote service.

### Add Mock Data

As for any other CAP service, you can add mocking data.

The CSV file needs to be added to the _srv/external/data_ folder. {.node}

The CSV file needs to be added to the _db/data_ folder. {.java}

::: code-group
```csv [API_BUSINESS_PARTNER-A_BusinessPartner.csv]
BusinessPartner;BusinessPartnerFullName;BusinessPartnerIsBlocked
1004155;Williams Electric Drives;false
1004161;Smith Batteries Ltd;false
1004100;Johnson Automotive Supplies;true
```
:::

For Java, make sure to add the `--with-mocks` option to the `cds deploy` command used to generate the `schema.sql` in `srv/pom.xml`. This ensures that tables for the mocked remote entities are created in the database.{.java}

[Find this source in the end-to-end tutorial](https://github.com/SAP-samples/cloud-cap-risk-management/blob/ext-service-s4hc-suppliers-ui-java/srv/external/data/API_BUSINESS_PARTNER-A_BusinessPartner.csv){.learn-more}


### Run Local with Mocks

Start your project with the imported service definition.

<div class="impl node">

```sh
cds watch
```

The service is automatically mocked, as you can see in the log output on server start.

```log
...

[cds] - model loaded from 8 file(s):

  ...
  ./srv/external/API_BUSINESS_PARTNER.cds
  ...

[cds] - connect using bindings from: { registry: '~/.cds-services.json' }
[cds] - connect to db > sqlite { database: ':memory:' }
 > filling sap.ui.riskmanagement.Mitigations from ./db/data/sap.ui.riskmanagement-Mitigations.csv
 > filling sap.ui.riskmanagement.Risks from ./db/data/sap.ui.riskmanagement-Risks.csv
 > filling API_BUSINESS_PARTNER.A_BusinessPartner from ./srv/external/data/API_BUSINESS_PARTNER-A_BusinessPartner.csv
/> successfully deployed to sqlite in-memory db

[cds] - serving RiskService { at: '/service/risk', impl: './srv/risk-service.js' }
[cds] - mocking API_BUSINESS_PARTNER { at: '/api-business-partner' }  // [!code focus] [!code highlight]

[cds] - launched in: 1.104s
[cds] - server listening on { url: 'http://localhost:4004' }
[ terminate with ^C ]
```

[If you want to run with a mock server in the cloud, try the BTP Developer's Guide.](https://github.com/SAP-samples/btp-developer-guide-cap/blob/main/documentation/remote-service/remote-service-mock-cf.md){.learn-more}

</div>

<div class="impl java">

```sh
mvn spring-boot:run
```

</div>

### Mock Associations

You can't get data from associations of a mocked service out of the box.

The associations of imported services lack information how to look up the associated records. This missing relation is expressed with an empty key definition at the end of the association declaration in the CDS model (`{ }`).

::: code-group
```cds{9} [srv/external/API_BUSINESS_PARTNER.cds]
entity API_BUSINESS_PARTNER.A_BusinessPartner {
  key BusinessPartner : LargeString;
  BusinessPartnerFullName : LargeString;
  BusinessPartnerType : LargeString;

  ...

  to_BusinessPartnerAddress :
    Association to many API_BUSINESS_PARTNER.A_BusinessPartnerAddress {  };  // [!code focus]
};

entity API_BUSINESS_PARTNER.A_BusinessPartnerAddress {
  key BusinessPartner : String(10);
  key AddressID : String(10);

  ...
};
```
:::

To mock an association, you have to modify [the imported file](#import-api). Before doing any modifications, create a local copy and add it to your source code management system.


```sh
cp srv/external/API_BUSINESS_PARTNER.cds srv/external/API_BUSINESS_PARTNER-orig.cds
git add srv/external/API_BUSINESS_PARTNER-orig.cds
...
```

Import the CDS file again, just using a different name:

```sh
cds import ~/Downloads/API_BUSINESS_PARTNER.edmx --keep-namespace \
    --as cds --out srv/external/API_BUSINESS_PARTNER-new.cds
```

Add an `on` condition to express the relation:

::: code-group
```cds [srv/external/API_BUSINESS_PARTNER-new.cds]
entity API_BUSINESS_PARTNER.A_BusinessPartner {
  // ...
  to_BusinessPartnerAddress :
      Association to many API_BUSINESS_PARTNER.A_BusinessPartnerAddress
      on to_BusinessPartnerAddress.BusinessPartner = BusinessPartner;
};
```
:::

Don't add any keys or remove empty keys, which would change it to a managed association. Added fields aren't known in the service and lead to runtime errors.


Use a 3-way merge tool to take over your modifications, check it and overwrite the previous unmodified file with the newly imported file:

```sh
git merge-file API_BUSINESS_PARTNER.cds \
               API_BUSINESS_PARTNER-orig.cds \
               API_BUSINESS_PARTNER-new.cds
mv API_BUSINESS_PARTNER-new.cds API_BUSINESS_PARTNER-orig.cds
```

To prevent accidental loss of modifications, the `cds import --as cds` command refuses to overwrite modified files based on a "checksum" that is included in the file.

### Mock Remote Service as OData Service (Node.js) {.node}

As shown previously you can run one process including a mocked external service. However, this mock doesn't behave like a real external service. The communication happens in-process and doesn't use HTTP or OData. For a more realistic testing, let the mocked service run in a separate process.

Start the CAP application with the mocked remote service only:

```sh
cds mock API_BUSINESS_PARTNER
```

If the startup is completed, run `cds watch` in the same project from a **different** terminal:

```sh
cds watch
```

CAP tracks locally running services. The mocked service `API_BUSINESS_PARTNER` is registered in file _~/.cds-services.json_. `cds watch` searches for running services in that file and connects to them.

Node.js only supports *OData V4* protocol and so does the mocked service. There might still be some differences to the real remote service if it uses a different protocol, but it's much closer to it than using only one instance. In the console output, you can also easily see how the communication between the two processes happens.

### Mock Remote Service as OData Service (Java) {.java}

You configure CAP to do OData and HTTP requests for a mocked service instead of doing it in-process. Configure a new Spring Boot profile (for example `mocked`):
::: code-group
```yaml [srv/src/main/resources/application.yaml]
spring:
  config.activate.on-profile: mocked
cds:
  application.services:
  - name: API_BUSINESS_PARTNER-mocked
    model: API_BUSINESS_PARTNER
    serve.path: API_BUSINESS_PARTNER
  remote.services:
    API_BUSINESS_PARTNER:
      destination:
        name: "s4-business-partner-api-mocked"
```
:::
The profile exposes the mocked service as OData service and defines a destination to access the service. The destination just points to the CAP application itself. You need to implement some Java code for this:

::: code-group
```java [DestinationConfiguration.java]
@EventListener
void applicationReady(ApplicationReadyEvent ready) {
  int port = Integer.valueOf(environment.getProperty("local.server.port"));
  DefaultHttpDestination mockDestination = DefaultHttpDestination
      .builder("http://localhost:" + port)
      .name("s4-business-partner-api-mocked").build();

  DefaultDestinationLoader loader = new DefaultDestinationLoader();
  loader.registerDestination(mockDestination);
  DestinationAccessor.prependDestinationLoader(loader);
}
```
:::

Now, you just need to run the application with the new profile:

```sh
mvn spring-boot:run -Dspring-boot.run.profiles=default,mocked
```

When sending a request to your CAP application, for example the `Suppliers` entity, it is transformed to the request for the mocked remote service and requested from itself as a OData request. Therefore, you'll see two HTTP requests in your CAP application's log.

For example:

[http://localhost:8080/service/risk/Suppliers](http://localhost:8080/service/risk/Suppliers)

```log
2021-09-21 15:18:44.870 DEBUG 34645 — [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : GET "/service/risk/Suppliers", parameters={}
...
2021-09-21 15:18:45.292 DEBUG 34645 — [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : GET "/API_BUSINESS_PARTNER/A_BusinessPartner?$select=BusinessPartner,BusinessPartnerFullName,BusinessPartnerIsBlocked&$top=1000&$skip=0&$orderby=BusinessPartner%20asc&sap-language=de&sap-valid-at=2021-09-21T13:18:45.211722Z", parameters={masked}
...
2021-09-21 15:18:45.474 DEBUG 34645 — [nio-8080-exec-2] o.s.web.servlet.DispatcherServlet        : Completed 200 OK
2021-09-21 15:18:45.519 DEBUG 34645 — [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet        : Completed 200 OK
```

[Try out the example application.](https://github.com/SAP-samples/cloud-cap-risk-management/tree/ext-service-s4hc-suppliers-ui-java){.learn-more}

## Execute Queries {#execute-queries}

You can send requests to remote services using CAP's powerful querying API.

### Execute Queries with Node.js{.node}

Connect to the service before sending a request, as usual in CAP:

```js
const bupa = await cds.connect.to('API_BUSINESS_PARTNER');
```

Then execute your queries using the [Querying API](../node.js/core-services#srv-run-query):

```js
const { A_BusinessPartner } = bupa.entities;
const result = await bupa.run(SELECT(A_BusinessPartner).limit(100));
```

We recommend limiting the result set and avoid the download of large data sets in a single request. You can `limit` the result as in the example: `.limit(100)`.

Many features of the querying API are supported for OData services. For example, you can resolve associations like this:

```js
const { A_BusinessPartner } = bupa.entities;
const result = await bupa.run(SELECT.from(A_BusinessPartner, bp => {
    bp('BusinessPartner'),
    bp.to_BusinessPartnerAddress(addresses => {
      addresses('*')
    })
  }).limit(100));
```

[Learn more about querying API examples.](https://github.com/SAP-samples/cloud-cap-risk-management/blob/ext-service-s4hc-suppliers-ui/test/odata-examples.js){.learn-more}

[Learn more about supported querying API features.](#querying-api-features){.learn-more}

### Execute Queries with Java {.java}

You can use dependency injection to get access to the remote service:

```java
@Autowired
@Qualifier(ApiBusinessPartner_.CDS_NAME)
CqnService bupa;
```

Then execute your queries using the [Querying API](../java/working-with-cql/query-execution):

```java
CqnSelect select = Select.from(ABusinessPartner_.class).limit(100);
List<ABusinessPartner> businessPartner = bupa.run(select).listOf(ABusinessPartner.class);
```

[Learn more about querying API examples.](https://github.com/SAP-samples/cloud-cap-risk-management/blob/ext-service-s4hc-suppliers-ui/test/odata-examples.js){.learn-more}

[Learn more about supported querying API features.](#querying-api-features){.learn-more}

### Model Projections

External service definitions, like [generated CDS or CSN files during import](#import-api), can be used as any other CDS definition, but they **don't** generate database tables and views unless they are mocked.

It's best practice to use your own "interface" to the external service and define the relevant fields in a projection in your namespace. Your implementation is then independent of the remote service implementation and you request only the information that you require.

```cds
using {  API_BUSINESS_PARTNER as bupa } from '../srv/external/API_BUSINESS_PARTNER';

entity Suppliers as projection on bupa.A_BusinessPartner {
  key BusinessPartner as ID,
  BusinessPartnerFullName as fullName,
  BusinessPartnerIsBlocked as isBlocked,
}
```

As the example shows, you can use field aliases as well.

[Learn more about supported features for projections.](#supported-projection-features){.learn-more}

### Execute Queries on Projections to a Remote Service{.node}

Connect to the service before sending a request, as usual in CAP:

```js
const bupa = await cds.connect.to('API_BUSINESS_PARTNER');
```

Then execute your queries:

```js
const suppliers = await bupa.run(SELECT(Suppliers).where({ID}));
```

CAP resolves projections and does the required mapping, similar to databases.

A brief explanation, based on the previous query, what CAP does:
+ Resolves the `Suppliers` projection to the external service interface `API_BUSINESS_PARTNER.A_Business_Partner`.
+ The **where** condition for field `ID` will be mapped to the `BusinessPartner` field of `A_BusinessPartner`.
+ The result is mapped back to the `Suppliers` projection, so that values for the `BusinessPartner` field are mapped back to `ID`.

This makes it convenient to work with external services.

### Building Custom Requests with Node.js{.node}

If you can't use the querying API, you can craft your own HTTP requests using `send`:


```js
bupa.send({
  method: 'PATCH',
  path: A_BusinessPartner,
  data: {
    BusinessPartner: 1004155,
    BusinessPartnerIsBlocked: true
  }
})
```

[Learn more about the `send` API.](../node.js/core-services#srv-send-request){.learn-more}

### Building Custom Requests with Java {.java}

For Java, you can use the `HttpClient` API to implement your custom requests. The API is enhanced by the SAP Cloud SDK to support destinations.

[Learn more about using the HttpClient Accessor.](https://sap.github.io/cloud-sdk/docs/java/features/connectivity/sdk-connectivity-http-client){.learn-more}

[Learn more about using destinations.](#use-destinations-with-java){.learn-more}

## Integrate and Extend {#integrate-and-extend}

By creating projections on remote service entities and using associations, you can create services that combine data from your local service and remote services.

What you need to do depends on [the scenarios](#sample-scenario-from-end-to-end-tutorial) and how your remote services should be integrated into, as well as extended by your local services.

### Expose Remote Services

To expose a remote service entity, you add a projection on it to your CAP service:

```cds
using {  API_BUSINESS_PARTNER as bupa } from '../srv/external/API_BUSINESS_PARTNER';

extend service RiskService with {
  entity BusinessPartners as projection on bupa.A_BusinessPartner;
}
```

CAP automatically tries to delegate queries to database entities, which don't exist as you're pointing to an external service. That behavior would produce an error like this:

```xml
<error xmlns="https://docs.oasis-open.org/odata/ns/metadata">
<code>500</code>
<message>SQLITE_ERROR: no such table: RiskService_BusinessPartners in: SELECT BusinessPartner, Customer, Supplier, AcademicTitle, AuthorizationGroup, BusinessPartnerCategory, BusinessPartnerFullName, BusinessPartnerGrouping, BusinessPartnerName, BusinessPartnerUUID, CorrespondenceLanguage, CreatedByUser, CreationDate, (...)  FROM RiskService_BusinessPartner ALIAS_1 ORDER BY BusinessPartner COLLATE NOCASE ASC LIMIT 11</message>
</error>
```

To avoid this error, you need to handle projections. Write a handler function to delegate a query to the remote service and run the incoming query on the external service.

::: code-group
```js [Node.js]
module.exports = cds.service.impl(async function() {
  const bupa = await cds.connect.to('API_BUSINESS_PARTNER');

  this.on('READ', 'BusinessPartners', req => {
      return bupa.run(req.query);
  });
});
```

```java [Java]
@Component
@ServiceName(RiskService_.CDS_NAME)
public class RiskServiceHandler implements EventHandler {
  @Autowired
  @Qualifier(ApiBusinessPartner_.CDS_NAME)
  CqnService bupa;

  @On(entity = BusinessPartners.CDS_NAME)
  Result readSuppliers(CdsReadEventContext context) {
    return bupa.run(context.getCqn());
  }
}
```

:::

[For Node.js, get more details in the end-to-end tutorial.](https://developers.sap.com/tutorials/btp-app-ext-service-add-consumption.html#0a5ed8cc-d0fa-4a52-bb56-9c864cd66e71){.learn-more}


::: warning
If you receive `404` errors, check if the request contains fields that don't exist in the service and start with the name of an association. `cds import` adds an empty keys declaration (`{ }`) to each association. Without this declaration, foreign keys for associations are generated in the runtime model, that don't exist in the real service. To solve this problem, you need to reimport the external service definition using `cds import`.
:::

This works when accessing the entity directly. Additional work is required to support [navigation](#handle-navigations-across-local-and-remote-entities) and [expands](#handle-expands-across-local-and-remote-entities) from or to a remote entity.

Instead of exposing the remote service's entity unchanged, you can [model your own projection](#model-projections). For example, you can define a subset of fields and change their names.

::: tip
CAP does the magic that maps the incoming query, according to your projections, to the remote service and maps back the result.
:::

```cds
using { API_BUSINESS_PARTNER as bupa } from '../srv/external/API_BUSINESS_PARTNER';

extend service RiskService with {
  entity Suppliers as projection on bupa.A_BusinessPartner {
    key BusinessPartner as ID,
    BusinessPartnerFullName as fullName,
    BusinessPartnerIsBlocked as isBlocked
  }
}
```

```js
module.exports = cds.service.impl(async function() {
  const bupa = await cds.connect.to('API_BUSINESS_PARTNER');

  this.on('READ', 'Suppliers', req => {
      return bupa.run(req.query);
  });
});
```

[Learn more about queries on projections to remote services.](#execute-queries-on-projections-to-a-remote-service){.learn-more}

### Expose Remote Services with Associations

It's possible to expose associations of a remote service entity. You can adjust the [projection for the association target](#model-projections) and change the name of the association:

```cds
using { API_BUSINESS_PARTNER as bupa } from '../srv/external/API_BUSINESS_PARTNER';

extend service RiskService with {
  entity Suppliers as projection on bupa.A_BusinessPartner {
    key BusinessPartner as ID,
    BusinessPartnerFullName as fullName,
    BusinessPartnerIsBlocked as isBlocked,
    to_BusinessPartnerAddress as addresses: redirected to SupplierAddresses
  }

  entity SupplierAddresses as projection on bupa.A_BusinessPartnerAddress {
    BusinessPartner as bupaID,
    AddressID as ID,
    CityName as city,
    StreetName as street,
    County as county
  }
}
```

As long as the association is only resolved using expands (for example `.../risk/Suppliers?$expand=addresses`), a handler for the __source entity__ is sufficient:

```js
this.on('READ', 'Suppliers', req => {
    return bupa.run(req.query);
});
```

If you need to resolve the association using navigation or request it independently from the source entity, add a handler for the __target entity__ as well:

```js
this.on('READ', 'SupplierAddresses', req => {
    return bupa.run(req.query);
});
```

As usual, you can put two handlers into one handler matching both entities:

```js
this.on('READ', ['Suppliers', 'SupplierAddresses'], req => {
    return bupa.run(req.query);
});
```

### Mashing up with Remote Services

You can combine local and remote services using associations. These associations need manual handling, because of their different data sources.

#### Integrate Remote into Local Services

Use managed associations from local entities to remote entities:

```cds
@path: 'service/risk'
service RiskService {
  entity Risks : managed {
    key ID      : UUID  @(Core.Computed : true);
    title       : String(100);
    prio        : String(5);
    supplier    : Association to Suppliers;
  }

  entity Suppliers as projection on BusinessPartner.A_BusinessPartner {
    key BusinessPartner as ID,
    BusinessPartnerFullName as fullName,
    BusinessPartnerIsBlocked as isBlocked,
  };
}
```

#### Extend a Remote by a Local Service { #extend-a-remote-by-a-local-service}

You can augment a projection with a new association, if the required fields for the on condition are present in the remote service. The use of managed associations isn't possible, because this requires to create new fields in the remote service.


```cds
entity Suppliers as projection on bupa.A_BusinessPartner {
  key BusinessPartner as ID,
  BusinessPartnerFullName as fullName,
  BusinessPartnerIsBlocked as isBlocked,
  risks : Association to many Risks on risks.supplier.ID = ID,
};
```

### Handle Mashups with Remote Services { #building-mashups}

Depending on how the service is accessed, you need to support direct requests, navigation, or expands. CAP resolves those three request types only for service entities that are served from the database. When crossing the boundary between database and remote sourced entities, you need to take care of those requests.

The list of [required implementations for mashups](#required-implementations-for-mashups) explains the different combinations.

#### Handle Expands Across Local and Remote Entities

Expands add data from associated entities to the response. For example, for a risk, you want to display the suppliers name instead of just the technical ID. But this property is part of the (remote) supplier and not part of the (local) risk.

To handle expands, you need to add a handler for the main entity:
1. Check if a relevant `$expand` column is present.
2. Remove the `$expand` column from the request.
3. Get the data for the request.
4. Execute a new request for the expand.
5. Add the expand data to the returned data from the request.

Example of a CQN request with an expand:

```json
{
  "from": { "ref": [ "RiskService.Suppliers" ] },
  "columns": [
    { "ref": [ "ID" ] },
    { "ref": [ "fullName" ] },
    { "ref": [ "isBlocked" ] },
    { "ref": [ "risks" ] },
    { "expand": [
      { "ref": [ "ID" ] },
      { "ref": [ "title" ] },
      { "ref": [ "descr" ] },
      { "ref": [ "supplier_ID" ] }
    ] }
  ]
}
```

[See an example how to handle expands in Node.js.](https://github.com/SAP-samples/cloud-cap-risk-management/blob/ext-service-s4hc-suppliers-ui/srv/risk-service.js){.node .learn-more}

[See an example how to handle expands in Java.](https://github.com/SAP-samples/cloud-cap-risk-management/blob/ext-service-s4hc-suppliers-ui-java/srv/src/main/java/com/sap/cap/riskmanagement/handler/RiskServiceHandler.java){.java .learn-more}


Expands across local and remote can cause stability and performance issues. For a list of items, you need to collect all IDs and send it to the database or the remote system. This can become long and may exceed the limits of a URL string in case of OData. Do you really need expands for a list of items?

```http
GET /service/risk/Risks?$expand=supplier
```

Or is it sufficient for single items?

```http
GET /service/risk/Risks(545A3CF9-84CF-46C8-93DC-E29F0F2BC6BE)/?$expand=supplier
```
::: warning Keep performance in mind
Consider to reject expands if it's requested on a list of items.
:::

#### Handle Navigations Across Local and Remote Entities

Navigations allow to address items via an association from a different entity:

```http
GET /service/risks/Risks(20466922-7d57-4e76-b14c-e53fd97dcb11)/supplier
```

The CQN consists of a `from` condition with 2 values for `ref`. The first `ref` selects the record of the source entity of the navigation. The second `ref` selects the name of the association, to navigate to the target entity.

```json
{
  "from": {
    "ref": [ {
      "id": "RiskService.Risks",
      "where": [
        { "ref": [ "ID" ] },
        "=",
        { "val": "20466922-7d57-4e76-b14c-e53fd97dcb11" }
      ]},
      "supplier"
    ]
  },
  "columns": [
    { "ref": [ "ID" ] },
    { "ref": [ "fullName" ] },
    { "ref": [ "isBlocked" ] }
  ],
  "one": true
}
```

To handle navigations, you need to check in your code if the `from.ref` object contains 2 elements. Be aware, that for navigations the handler of the **target** entity is called.

If the association's on condition equals the key of the source entity, you can directly select the target entity using the key's value. You find the value in the `where` block of the first `from.ref` entry.

Otherwise, you need to select the source item using that `where` block and take the required fields for the associations on condition from that result.

[See an example how to handle navigations in Node.js.](https://github.com/SAP-samples/cloud-cap-risk-management/blob/ext-service-s4hc-suppliers-ui/srv/risk-service.js){.learn-more .node}

[See an example how to handle navigations in Java.](https://github.com/SAP-samples/cloud-cap-risk-management/blob/ext-service-s4hc-suppliers-ui-java/srv/src/main/java/com/sap/cap/riskmanagement/handler/RiskServiceHandler.java){.learn-more .java}

### Limitations and Feature Matrix
#### Required Implementations for Mashups { #required-implementations-for-mashups}

You need additional logic, if remote entities are in the game. The following table shows what is required. "Local" is a database entity or a projection on a database entity.

| **Request**                                                           | **Example**                              | **Implementation**                                                |
| --------------------------------------------------------------------- | ---------------------------------------- | ----------------------------------------------------------------- |
| Local (including navigations and expands)                             | `/service/risks/Risks`                   | Handled by CAP                                                    |
| Local: Expand remote                                                  | `/service/risks/Risks?$expand=supplier`  | Delegate query w/o expand to local service and implement expand.  |
| Local: Navigate to remote                                             | `/service/risks(...)/supplier`           | Implement navigation and delegate query target to remote service. |
| Remote (including navigations and expands to the same remote service) | `/service/risks/Suppliers`               | Delegate query to remote service                                  |
| Remote: Expand local                                                  | `/service/risks/Suppliers?$expand=risks` | Delegate query w/o expand to remote service and implement expand. |
| Remote: Navigate to local                                             | `/service/Suppliers(...)/risks`          | Implement navigation, delegate query for target to local service  |

#### Transient Access vs. Replication

> This chapter shows only techniques for transient access.

The following matrix can help you to find the best approach for your scenario:

| **Feature**                                           | **Transient Access**  | **Replication**                   |
|-------------------------------------------------------|-----------------------|-----------------------------------|
| Filtering on local **or** remote fields <sup>1</sup>  | Possible              | Possible                          |
| Filtering on local **and** remote fields <sup>2</sup> | Not possible          | Possible                          |
| Relationship: Uni-/Bidirectional associations         | Possible              | Possible                          |
| Relationship: Flatten                                 | Not possible          | Possible                          |
| Evaluate user permissions in remote system            | Possible              | Requires workarounds <sup>3</sup> |
| Data freshness                                        | Live data             | Outdated until replicated         |
| Performance                                           | Degraded <sup>4</sup> | Best                              |

<br>

> <sup>1</sup> It's **not required** to filter both, on local and remote fields, in the same request. <br>
> <sup>2</sup> It's **required** to filter both, on local and remote fields, in the same request. <br>
> <sup>3</sup> Because replicated data is accessed, the user permission checks of the remote system aren't evaluated. <br>
> <sup>4</sup> Depends on the connectivity and performance of the remote system. <br>


## Connect and Deploy {#connect-and-deploy}





### Using Destinations { #using-destinations}

Destinations contain the necessary information to connect to a remote system. They're basically an advanced URL, that can carry additional metadata like, for example, the authentication information.

You can choose to use [SAP BTP destinations](#btp-destinations) or [application defined destinations](#app-defined-destinations).

#### Use SAP BTP Destinations { #btp-destinations}

CAP leverages the destination capabilities of the SAP Cloud SDK.

##### Create Destinations on SAP BTP

Create a destination using one or more of the following options.

- **Register a system in your global account:** You can check here how to [Register an SAP System](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/2ffdaff0f1454acdb046876045321c91.html) in your SAP BTP global account and which systems are supported for registration. Once the system is registered and assigned to your subaccount, you can create a service instance. A destination is automatically created along with the service instance.


- **Connect to an on-premise system:** With SAP BTP [Cloud Connector](https://help.sap.com/docs/CP_CONNECTIVITY/cca91383641e40ffbe03bdc78f00f681/e6c7616abb5710148cfcf3e75d96d596.html), you can create a connection from your cloud application to an on-premise system.

- **Manually create destinations:** You can create destinations manually in your SAP BTP subaccount. See section [destinations](https://help.sap.com/docs/CP_CONNECTIVITY/cca91383641e40ffbe03bdc78f00f681/5eba6234a0e143fdacd8535f44c315c5.html) in the SAP BTP documentation.

- **Create a destination to your application:** If you need a destination to your application, for example, to call it from a different application, then you can automatically create it in the MTA deployment.

##### Use Destinations with Node.js {.node}

In your _package.json_, a configuration for the `API_BUSINESS_PARTNER` looks like this:

```json
"cds": {
  "requires": {
    "API_BUSINESS_PARTNER": {
      "kind": "odata",
      "model": "srv/external/API_BUSINESS_PARTNER"
    }
  }
}
```

If you've imported the external service definition using `cds import`, an entry for the service in the _package.json_ has been created already. Here you specify the name of the destination in the `credentials` block.

In many cases, you also need to specify the `path` prefix to the service, which is added to the destination's URL. For services listed on the SAP Business Accelerator Hub, you can find the path in the linked service documentation.

Since you don't want to use the destination for local testing, but only for production, you can profile it by wrapping it into a `[production]` block:

```json
"cds": {
  "requires": {
    "API_BUSINESS_PARTNER": {
      "kind": "odata",
      "model": "srv/external/API_BUSINESS_PARTNER",
      "[production]": {
        "credentials": {
          "destination": "S4HANA",
          "path": "/sap/opu/odata/sap/API_BUSINESS_PARTNER"
        }
      }
    }
  }
}
```

Additionally, you can provide [destination options](https://sap.github.io/cloud-sdk/api/v4/interfaces/sap-cloud-sdk_connectivity.DestinationFetchOptions.html) inside a `destinationOptions` object:

```jsonc
"cds": {
  "requires": {
    "API_BUSINESS_PARTNER": {
      /* ... */
      "[production]": {
        "credentials": {
          /* ... */
        },
        "destinationOptions": {
          "selectionStrategy": "alwaysSubscriber",
          "useCache": true
        }
      }
    }
  }
}
```

The `selectionStrategy` property controls how a [destination is resolved](#destination-resolution).

The `useCache` option controls whether the SAP Cloud SDK caches the destination. It's enabled by default but can be disabled by explicitly setting it to `false`.
Read [Destination Cache](https://sap.github.io/cloud-sdk/docs/js/features/connectivity/destination-cache#destination-cache) to learn more about how the cache works.

If you want to configure additional headers for the HTTP request to the system behind the destination, for example an Application Interface Register (AIR) header, you can specify such headers in the destination definition itself using the property [_URL.headers.\<header-key\>_](https://help.sap.com/docs/CP_CONNECTIVITY/cca91383641e40ffbe03bdc78f00f681/4e1d742a3d45472d83b411e141729795.html?q=URL.headers).

##### Use Destinations with Java {.java}

Destinations are configured in Spring Boot's _application.yaml_ file:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  remote.services:
    API_BUSINESS_PARTNER:
      type: "odata-v2"
      destination:
        name: "cpapp-bupa"
      http:
        suffix: "/sap/opu/odata/sap"
```
:::
[Learn more about configuring destinations for Java.](../java/cqn-services/remote-services#destination-based-scenarios){.learn-more}

#### Use Application Defined Destinations { #app-defined-destinations}

If you don't want to use SAP BTP destinations, you can also define destinations, which means the URL, authentication type, and additional configuration properties, in your application configuration or code.

Application defined destinations support a subset of [properties](#destination-properties) and [authentication types](#authentication-types) of the SAP BTP destination service.

##### Configure Application Defined Destinations in Node.js {.node}

You specify the destination properties in `credentials` instead of putting the name of a destination there.

This is an example of a destination using basic authentication:

```jsonc
"cds": {
  "requires": {
    "REVIEWS": {
      "kind": "odata",
      "model": "srv/external/REVIEWS",
      "[production]": {
        "credentials": {
          "url": "https://reviews.ondemand.com/reviews",
          "authentication": "BasicAuthentication",
          "username": "<set from code or env>",
          "password": "<set from code or env>",
          "headers": {
            "my-header": "header value"
          },
          "queries": {
            "my-url-param": "url param value"
          }
        }
      }
    }
  }
}
```

[Supported destination properties.](#destination-properties){.learn-more}

::: warning
You shouldn't put any sensitive information here.
:::

Instead, set the properties in the bootstrap code of your CAP application:

```js
const cds = require("@sap/cds");

if (cds.env.requires?.credentials?.authentication === "BasicAuthentication") {
  const credentials = /* read your credentials */
  cds.env.requires.credentials.username = credentials.username;
  cds.env.requires.credentials.password = credentials.password;
}
```

You might also want to set some values in the application deployment. This can be done using env variables. For this example, the env variable for the URL would be `cds_requires_REVIEWS_credentials_destination_url`.

This variable can be parameterized in the _manifest.yml_ for a `cf push` based deployment:
::: code-group
```yaml [manifest.yml]
applications:
- name: reviews
  ...
  env:
    cds_requires_REVIEWS_credentials_url: ((reviews_url))
```
:::
```sh
cf push --var reviews_url=https://reviews.ondemand.com/reviews
```

The same can be done using _mtaext_ file for MTA deployment.

If the URL of the target service is also part of the MTA deployment, you can automatically receive it as shown in this example:

::: code-group
```yaml [mta.yaml]
 - name: reviews
   provides:
    - name: reviews-api
      properties:
        reviews-url: ${default-url}
 - name: bookshop
   requires:
    ...
    - name: reviews-api
   properties:
     cds_requires_REVIEWS_credentials_url: ~{reviews-api/reviews-url}
```
:::

::: code-group
```properties [.env]
cds_requires_REVIEWS_credentials_url=http://localhost:4008/reviews
```
:::

::: warning
For the _configuration path_, you **must** use the underscore ("`_`") character as delimiter. CAP supports dot ("`.`") as well, but Cloud Foundry won't recognize variables using dots. Your _service name_ **mustn't** contain underscores.
:::

##### Implement Application Defined Destinations in Node.js {.node}

There is no API to create a destination in Node.js programmatically. However, you can change the properties of a remote service before connecting to it, as shown in the previous example.

##### Configure Application Defined Destinations in Java {.java}

Destinations are configured in Spring Boot's _application.yaml_ file.

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  remote.services:
    REVIEWS:
      type: "odata-v4"
      destination:
        properties:
          url: https://reviews.ondemand.com/reviews
          authentication: TokenForwarding
      http:
        headers:
          my-header: "header value"
        queries:
          my-url-param: "url param value"
```
:::

[Learn more about supported destination properties.](#destination-properties){.learn-more}

##### Implement Application Defined Destinations in Java {.java}

You can use the APIs offered by SAP Cloud SDK to create destinations programmatically. The destination can be used by its name the same way as destinations on the SAP BTP destination service.
::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  remote.services:
    REVIEWS:
      type: "odata-v2"
      destination:
        name: "reviews-destination"
```
:::
[Learn more about programmatic destination registration.](../java/cqn-services/remote-services#programmatic-destination-registration){.learn-more} [See examples for different authentication types.](../java/cqn-services/remote-services#programmatic-destinations){.learn-more}


### Connect to Remote Services Locally

If you use SAP BTP destinations, you can access them locally using [CAP's hybrid testing capabilities](../advanced/hybrid-testing) with the following procedure:

#### Bind to Remote Destinations

Your local application needs access to an XSUAA and Destination service instance in the same subaccount where the destination is:

1. Login to your Cloud Foundry org and space
2. Create an XSUAA service instance and service key:

    ```sh
    cf create-service xsuaa application cpapp-xsuaa
    cf create-service-key cpapp-xsuaa cpapp-xsuaa-key
    ```

3. Create a Destination service instance and service key:

    ```sh
    cf create-service destination lite cpapp-destination
    cf create-service-key cpapp-destination cpapp-destination-key
    ```

4. Bind to XSUAA and Destination service:

    ```sh
    cds bind -2 cpapp-xsuaa,cpapp-destination
    ```

    [Learn more about `cds bind`.](../advanced/hybrid-testing#services-on-cloud-foundry){.learn-more}

#### Run a Node.js Application with a Destination {.node}

Add the destination for the remote service to the `hybrid` profile in the _.cdsrc-private.json_ file:

```jsonc
{
  "requires": {
    "[hybrid]": {
      "auth": {
        /* ... */
      },
      "destinations": {
        /* ... */
      },
      "API_BUSINESS_PARTNER": {
        "credentials": {
          "path": "/sap/opu/odata/sap/API_BUSINESS_PARTNER",
          "destination": "cpapp-bupa"
        }
      }
    }
  }
}
```

Run your application with the Destination service:

```sh
cds watch --profile hybrid
```

::: tip
If you are developing in the Business Application Studio and want to connect to an on-premise system, you will need to do so via Business Application Studio's built-in proxy, for which you need to add configuration in an `.env` file. See [Connecting to External Systems From the Business Application Studio](https://sap.github.io/cloud-sdk/docs/js/guides/bas) for more details.
:::

#### Run a Java Application with a Destination {.java}

Add a new profile `hybrid` to your _application.yaml_ file that configures the destination for the remote service.
::: code-group
```yaml [srv/src/main/resources/application.yaml]
spring:
  config.activate.on-profile: hybrid
  sql.init.schema-locations:
  - "classpath:schema-nomocks.sql"
cds:
  remote.services:
  - name: API_BUSINESS_PARTNER
    type: "odata-v2"
    destination:
      name: "cpapp-bupa"
    http:
      suffix: "/sap/opu/odata/sap"
```
:::
Run your application with the Destination service:

```sh
cds bind --exec -- mvn spring-boot:run \
  -Dspring-boot.run.profiles=default,hybrid
```

[Learn more about `cds bind --exec`.](../advanced/hybrid-testing#run-arbitrary-commands-with-service-bindings){.learn-more}

::: tip
If you are developing in the Business Application Studio and want to connect to an on-premise system, you will need to do so via Business Application Studio's built-in proxy, for which you need to add configuration to your destination environment variable. See [Reach On-Premise Service from the SAP Business Application Studio](https://sap.github.io/cloud-sdk/docs/java/features/connectivity/destination-service#reach-on-premise-service-from-the-sap-business-application-studio) for more details.
:::


### Connect to an Application Using the Same XSUAA (Forward Authorization Token) {#forward-auth-token}

If your application consists of microservices and you use one (or more) as a remote service as described in this guide, you can leverage the same XSUAA instance. In that case, you don't need an SAP BTP destination at all.

Assuming that your microservices use the same XSUAA instance, you can just forward the authorization token. The URL of the remote service can be injected into the application in the [MTA or Cloud Foundry deployment](#deployment) using [application defined destinations](#app-defined-destinations).

#### Forward Authorization Token with Node.js{.node}

To enable the token forwarding, set the `forwardAuthToken` option to `true` in your application defined destination:

```json
{
  "requires": {
    "kind": "odata",
    "model": "./srv/external/OrdersService",
    "credentials": {
      "url": "<set via env var in deployment>",
      "forwardAuthToken": true
    }
  }
}
```

#### Forward Authorization Token with Java{.java}

For Java, you set the authentication type to `TOKEN_FORWARDING` for the destination.

You can implement it in your code:

```java
urlFromConfig = ...; // read from config
DefaultHttpDestination mockDestination = DefaultHttpDestination
    .builder(urlFromConfig)
    .name("order-service")
    .authenticationType(AuthenticationType.TOKEN_FORWARDING)
    .build();
```

Or declare the destination in your _application.yaml_ file:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  remote.services:
    order-service:
      type: "odata-v4"
      destination:
        properties:
          url: "<set via env var in deployment>"
          authentication: TokenForwarding
```
:::
Alternatively to setting the authentication type, you can set the property `forwardAuthToken` to `true`.

### Connect to an Application in Your Kyma Cluster

The [Istio](https://istio.io) service mesh provides secure communication between the services in your service mesh. You can access a service in your applications' namespace by just reaching out to `http://<service-name>` or using the full hostname `http://<service-name>.<namespace>.svc.cluster.local`. Istio sends the requests through an mTLS tunnel.

With Istio, you can further secure the communication [by configuring authentication and authorization for your services](https://istio.io/latest/docs/concepts/security)


### Deployment

Your micro service needs bindings to the **XSUAA** and **Destination** service to access destinations on SAP BTP. If you want to access an on-premise service using **Cloud Connector**, then you need a binding to the **Connectivity** service as well.

[Learn more about deploying CAP applications.](deployment/){.learn-more}
[Learn more about deploying an application using the end-to-end tutorial.](https://developers.sap.com/group.btp-app-cap-deploy.html){.learn-more}



#### Add Required Services to MTA Deployments

The MTA-based deployment is described in [the deployment guide](deployment/). You can follow this guide and make some additional adjustments to the [generated _mta.yml_](deployment/to-cf#add-mta-yaml) file.


```sh
cds add xsuaa,destination,connectivity
```

::: details Learn what this does in the background...

1. Adds **XSUAA**, **Destination**, and **Connectivity** services to your _mta.yaml_:
    ::: code-group
    ```yaml [mta.yml]
    - name: cpapp-uaa
      type: org.cloudfoundry.managed-service
      parameters:
        service: xsuaa
        service-plan: application
        path: ./xs-security.json

    - name: cpapp-destination
      type: org.cloudfoundry.managed-service
      parameters:
        service: destination
        service-plan: lite

    # Required for on-premise connectivity only
    - name: cpapp-connectivity
      type: org.cloudfoundry.managed-service
      parameters:
        service: connectivity
        service-plan: lite
    ```
    :::
2. Requires the services for your server in the _mta.yaml_:
    ::: code-group
    ```yaml [mta.yaml]
    - name: cpapp-srv
      ...
      requires:
        ...
        - name: cpapp-uaa
        - name: cpapp-destination
        - name: cpapp-connectivity # Required for on-premise connectivity only
    ```
    :::
:::

Build your application:

```sh
mbt build -t gen --mtar mta.tar
```

Now you can deploy it to Cloud Foundry:
```sh
cf deploy gen/mta.tar
```

#### Connectivity Service Credentials on Kyma

The secret of the connectivity service on Kyma needs to be modified for the Cloud SDK to connect to on-premise destinations.

[Support for Connectivity Service Secret in Java](https://github.com/SAP/cloud-sdk/issues/657){.java .learn-more}
[Support for Connectivity Service Secret in Node.js](https://github.com/SAP/cloud-sdk-js/issues/2024){.node .learn-more}

### Destinations and Multitenancy

With the destination service, you can access destinations in your provider account, the account your application is running in, and destinations in the subscriber accounts of your multitenant-aware application.

#### Use Destinations from Subscriber Account

Customers want to see business partners from, for example, their SAP S/4 HANA system.

As provider, you need to define a name for a destination, which enables access to systems of the subscriber of your application. In addition, your multitenant application or service needs to have a dependency to the destination service. For destinations in an on-premise system, the connectivity service must be bound.

The subscriber needs to create a destination with that name in their subscriber account, for example, pointing to their SAP S/4HANA system.





#### Destination Resolution

The destination is read from the tenant of the request's JWT (authorization) token. If no JWT token is present, the destination is read from the tenant of the application's XSUAA binding.{.java}

The destination is read from the tenant of the request's JWT (authorization) token. If no JWT token is present *or the destination isn't found*, the destination is read from the tenant of the application's XSUAA binding.{.node}

::: warning JWT token vs. XSUAA binding
Using the tenant of the request's JWT token means reading from the **subscriber subaccount** for a multitenant application. The tenant of the application's XSUAA binding points to the destination of the **provider subaccount**, the account where the application is deployed to.
:::

<div class="impl node">

You can change the destination lookup behavior as follows:

```jsonc
"cds": {
  "requires": {
    "SERVICE_FOR_PROVIDER": {
      /* ... */
      "credentials": {
        /* ... */
      },
      "destinationOptions": {
        "selectionStrategy": "alwaysProvider",
        "jwt": null
      }
    }
  }
}
```


Setting the [`selectionStrategy`](https://sap.github.io/cloud-sdk/docs/js/features/connectivity/destination#multi-tenancy) property for the [destination options](#use-destinations-with-node-js) to `alwaysProvider`, you can ensure that the destination is always read from your provider subaccount. With that you ensure that a subscriber cannot overwrite your destination.

Set the destination option `jwt` to `null`, if you don't want to pass the request's JWT to SAP Cloud SDK. Passing the request's JWT to SAP Cloud SDK has implications on, amongst others, the effective defaults for selection strategy and isolation level. In rare cases, these defaults are not suitable, for example when the request to the upstream server does not depend on the current user. Please see [Authentication and JSON Web Token (JWT) Retrieval](https://sap.github.io/cloud-sdk/docs/js/features/connectivity/destinations#authentication-and-json-web-token-jwt-retrieval) for more details.

</div>

<div class="impl java">

For Java use the property `retrievalStrategy` in the destination configuration, to ensure that the destination is always read from your provider subaccount:

```yaml
cds:
  remote.services:
    service-for-provider:
      type: "odata-v4"
      destination:
        retrievalStrategy: "AlwaysProvider"

```

Read more in the full reference of all [supported retrieval strategy values](https://sap.github.io/cloud-sdk/docs/java/features/connectivity/sdk-connectivity-destination-service#retrieval-strategy-options). Please note that the value must be provided in pascal case, for example: `AlwaysProvider`.


</div>


## Add Qualities

<div id="inaddqualities" />
<Fragment target="#inaddqualities">

### Authentication and Authorization of Remote Services <Beta />
#### Principle (User) Propagation

#### Technical User


</Fragment>

### Resilience

There are two ways to make your outbound communications resilient:

1. Run your application in a service mesh (for example, Istio, Linkerd, etc.). For example, [Kyma is provided as service mesh](#resilience-in-kyma).
2. Implement resilience in your application.

Refer to the documentation for the service mesh of your choice for instructions. No code changes should be required.


To build resilience into your application, there are libraries to help you implement functions, like doing retries, circuit breakers or implementing fallbacks.

<div class="impl java">

You can use the [resilience features](https://sap.github.io/cloud-sdk/docs/java/features/resilience) provided by the SAP Cloud SDK with CAP Java. You need to wrap your remote calls with a call of `ResilienceDecorator.executeSupplier` and a resilience configuration (`ResilienceConfiguration`). Additionally, you can provide a fallback function.

```java
ResilienceConfiguration config = ResilienceConfiguration.of(AdminServiceAddressHandler.class)
  .timeLimiterConfiguration(TimeLimiterConfiguration.of(Duration.ofSeconds(10)));

context.setResult(ResilienceDecorator.executeSupplier(() ->  {
  // ..to access the S/4 system in a resilient way..
  logger.info("Delegating GET Addresses to S/4 service");
  return bupa.run(select);
}, config, (t) -> {
  // ..falling back to the already replicated addresses in our own database
  logger.warn("Falling back to already replicated Addresses");
  return db.run(select);
}));
```

[See the full example](https://github.com/SAP-samples/cloud-cap-samples-java/blob/main/srv/src/main/java/my/bookshop/handlers/AdminServiceAddressHandler.java){.learn-more}

</div>

<div class="impl node">


There's no resilience library provided out of the box for CAP Node.js. However, you can use packages provided by the Node.js community. Usually, they provide a function to wrap your code that adds the resilience logic.

</div>

#### Resilience in Kyma

Kyma clusters run an [Istio](https://istio.io/) service mesh. Istio allows to [configure resilience](https://istio.io/latest/docs/concepts/traffic-management/#network-resilience-and-testing) for the network destinations of your service mesh.

### Tracing

CAP adds headers for request correlation to its outbound requests that allows logging and tracing across micro services.

[Learn more about request correlation in Node.js.](../node.js/cds-log#node-observability-correlation){.learn-more .node}
[Learn more about request correlation in Java.](../java/operating-applications/observability#correlation-ids){.learn-more .java}

<div id="aftertracing" />
<Fragment target="#aftertracing">

## Automated Testing <Beta />

### Unit Tests

### Integration Tests


## Replicating Data <Beta />

> TODO: Using the sample in branch `adding-suppliers`, the following is already done

1. Use the [mashup.cds](https://github.com/SAP-samples/cloud-cap-samples/blob/adding-suppliers/suppliers/srv/mashup.cds) to define the persistence.

### Define Persistence

You don't want to call the external API for every request, because this has performance implications. It's good practice to replicate the data.

```cds
/*
  Optionally add a local persistence to keep replicas of external
  entities to have data in fast access locally; much like a cache.
 */
annotate S4.Suppliers with @cds.persistence : {
  table,
  skip : false
};

/**
 * Having locally cached replicas also allows us to display
 * supplier data in lists of books, which otherwise would
 * generate unwanted traffic on S4 backends.
 */
extend projection CatalogService.ListOfBooks with {
  supplier
}
```

By default, services in CAP are compiled to views on database tables. In this case you want to create a table, so let's add the `@cds.persistence.table` annotation. And normally CAP would skip the compilation of an external service, so add `skip: false` to the annotation.
### Custom Handler

- Show effect in DB / or via UI

### Add `Supplier` Entity Using `extend`

> needs to be changed

The BuPa API comes with many fields, fields you not necessarily need. The next challenge is to use the fields according to your needs, which include limiting the fields to a subset of those that are available.

Go into your _srv/mashup.cds_ file and add a new entity based on the business partner API.



```cds
using {API_BUSINESS_PARTNER as S4} from './external/API_BUSINESS_PARTNER';

extend service S4 with {
  entity Suppliers as projection on S4.A_BusinessPartner {
    key BusinessPartner as ID, BusinessPartnerFullName as name,
  // REVISIT: following is not supported so far in cds compiler...
  // to_BusinessPartnerAddress as city {
  //    CityCode as code,
  //    CityName as name
  // }
  // REVISIT: following is not supported so far in cqn2odata...
  // to_BusinessPartnerAddress.CityCode as city,
  // to_BusinessPartnerAddress.CityName as city_name,
  }
}

```
[Learn more about the `using` directive.](../cds/cdl#using){.learn-more}
[Learn more about the `extend` directive.](../cds/cdl#extend){.learn-more}

This adds the supplier that is based on the business partner definition and maps fields from the API to the terminology I want to use. For example, I want to refer to suppliers by `name` instead of `BusinessPartnerFullName` in my models and rename it here.
### Sample Data

> Using the sample in branch `adding-suppliers`, the following is already done

It always helps to see sample data, when you're trying out new things. To add sample data to the service that is served out of an imported API, you need a _data_ folder next to the API. Create the folder _srv/external/data_ and add the following files:

::: code-group
```csv [API_BUSINESS_PARTNER-A_BusinessPartner.csv]
BusinessPartner;BusinessPartnerFullName
ACME;A Company Making Everything
B4U;Books for You
S&C;Shakespeare & Co.
WSL;Waterstones
TLD;Thalia
PNG;Penguin Books
```
:::

> Maybe add that later, when mashup has been made.

::: code-group
```csv [API_BUSINESS_PARTNER-Suppliers.csv]
ID;name
ACME;A Company Making Everything
B4U;Books for You
S&C;Shakespeare & Co.
WSL;Waterstones
```
:::

> Showcase the effect in a screenshot or so.

1. Add sample data, see the [_srv/external/data_ folder](https://github.com/SAP-samples/cloud-cap-samples/tree/adding-suppliers/suppliers/srv/external/data).

</Fragment>

## Feature Details

### Legend

| Tag  | Explanation   |
|:----:|---------------|
| <Y/> | supported     |
| <X/> | not supported |

### Supported Protocols

| Protocol | Java | Node.js |
|----------|:----:|:-------:|
| odata-v2 | <Y/> |  <Y/>   |
| odata-v4 | <Y/> |  <Y/>   |
| rest     | <X/> |  <Y/>   |

::: tip
The Node.js runtime supports `odata` as an alias for `odata-v4` as well.
:::

### Querying API Features

| Feature                            | Java | Node.js |
|------------------------------------|:----:|:-------:|
| READ                               | <Y/> |  <Y/>   |
| INSERT/UPDATE/DELETE               | <Y/> |  <Y/>   |
| Actions                            | <Y/> |  <Y/>   |
| `columns`                          | <Y/> |  <Y/>   |
| `where`                            | <Y/> |  <Y/>   |
| `orderby`                          | <Y/> |  <Y/>   |
| `limit` (top & skip)               | <Y/> |  <Y/>   |
| `$apply` (aggregate, groupby, ...) | <X/> |  <X/>   |
| `$search` (OData v4)               | <Y/> |  <Y/>   |
| `search` (SAP OData v2 extension)  | <Y/> |  <Y/>   |

### Supported Projection Features

| Feature                                                   | Java | Node.js |
|-----------------------------------------------------------|:----:|:-------:|
| Resolve projections to remote services                    | <Y/> |  <Y/>   |
| Resolve multiple levels of projections to remote services | <Y/> |  <Y/>   |
| Aliases for fields                                        | <Y/> |  <Y/>   |
| `excluding`                                               | <Y/> |  <Y/>   |
| Resolve associations (within the same remote service)     | <Y/> |  <Y/>   |
| Redirected associations                                   | <Y/> |  <Y/>   |
| Flatten associations                                      | <X/> |  <X/>   |
| `where` conditions                                        | <X/> |  <X/>   |
| `order by`                                                | <X/> |  <X/>   |
| Infix filter for associations                             | <X/> |  <X/>   |
| Model Associations with mixins                            | <Y/> |  <Y/>   |

### Supported Features for Application Defined Destinations

The following properties and authentication types are supported for *[application defined destinations](#app-defined-destinations)*:

#### Properties { #destination-properties}

These destination properties are fully supported by both, the Java and the Node.js runtime.
::: tip
This list specifies the properties for application defined destinations.
:::

| Properties                 | Description                               |
| -------------------------- | ----------------------------------------- |
| `url`                      |                                           |
| `authentication`           | Authentication type                       |
| `username`                 | User name for BasicAuthentication         |
| `password`                 | Password for BasicAuthentication          |
| `headers`                  | Map of HTTP headers                       |
| `queries`                  | Map of URL parameters                     |
| `forwardAuthToken`         | [Forward auth token](#forward-auth-token) |

[Destination Type in SAP Cloud SDK for JavaScript](https://sap.github.io/cloud-sdk/api/v4/interfaces/sap-cloud-sdk_connectivity.Destination.html){.learn-more .node}
[HttpDestination Type in SAP Cloud SDK for Java](https://help.sap.com/doc/82a32040212742019ce79dda40f789b9/1.0/en-US/index.html){.learn-more .java}

#### Authentication Types

| Authentication Types    |                                  Java                                   |            Node.js             |
|-------------------------|:-----------------------------------------------------------------------:|:------------------------------:|
| NoAuthentication        |                                  <Y/>                                   |              <Y/>              |
| BasicAuthentication     |                                  <Y/>                                   |              <Y/>              |
| TokenForwarding         |                                  <Y/>                                   | <X/><br>Use `forwardAuthToken` |
| OAuth2ClientCredentials | [code only](../java/cqn-services/remote-services#programmatic-destinations) |              <X/>              |
| UserTokenAuthentication | [code only](../java/cqn-services/remote-services#programmatic-destinations) |              <X/>              |

<div id="secondary-file">guides/using-services.fragment.md</div>


# Events and Messaging



CAP provides intrinsic support for emitting and receiving events. This is complemented by Messaging Services connecting to message brokers to exchange event messages across remote services.

## Ubiquitous Events in CAP {#intro}

We're starting with an introduction to the core concepts in CAP. If you want to skip the introduction, you can fast-forward to the samples part starting at [Books Reviews Sample](#books-reviews-sample).


### Intrinsic Eventing in CAP Core

As introduced in [About CAP](../../about/best-practices#events), everything happening at runtime is in response to events, and all service implementations take place in [event handlers](../providing-services#event-handlers). All CAP services intrinsically support emitting and reacting to events, as shown in this simple code snippet (you can copy & run it in `cds repl`):

```js
let srv = new cds.Service
// Receiving Events
srv.on ('some event', msg => console.log('1st listener received:', msg))
srv.on ('some event', msg => console.log('2nd listener received:', msg))
// Emitting Events
await srv.emit ('some event', { foo:11, bar:'12' })
```

::: tip Intrinsic support for events
The core of CAP's processing model: all services are event emitters. Events can be sent to them, emitted by them, and event handlers register with them to react to such events.
:::

### Typical Emitter and Receiver Roles

In contrast to the previous code sample, emitters and receivers of events are decoupled, in different services and processes. And as all active things in CAP are services, so are usually emitters and receivers of events. Typical patterns look like that:

```js
class Emitter extends cds.Service { async someMethod() {
  // inform unknown receivers about something happened
  await this.emit ('some event', { some:'payload' })
}}
```

```js
class Receiver extends cds.Service { async init() {
  // connect to and register for events from Emitter
  const Emitter = await cds.connect.to('Emitter')
  Emitter.on ('some event', msg => {...})
}}
```

::: tip Emitters vs Receivers
**Emitters** usually emit messages to *themselves* to inform *potential* listeners about certain events.
**Receivers** connect to *Emitters* to register handlers to such emitted events.
:::


### Ubiquitous Notion of Events

A *Request* in CAP is actually a specialization of an *Event Message*. The same intrinsic mechanisms of sending and reacting to events are used for asynchronous communication in inverse order. A typical flow:

![Clients send requests to services which are handled in event handlers.](assets/sync.drawio.svg)

Asynchronous communication looks similar, just with reversed roles:

![Services emit event. Receivers subscribe to events which are handled in event hanlders. ](assets/async.drawio.svg)

::: tip Event Listeners vs Interceptors
Requests are handled the same ways as events, with one major difference: While `on` handlers for events are *listeners* (all are called), handlers for synchronous requests are *interceptors* (only the topmost is called by the framework). An interceptor then decides whether to pass down control to `next` handlers or not.
:::

### Asynchronous & Synchronous APIs

To sum up, handling events in CAP is done in the same way as you would handle requests in a service provider. Also, emitting event messages is similar to sending requests. The major difference is that the initiative is inverted: While *Consumers* connect to *Services* in synchronous communications, the *Receivers* connect to _Emitters_ in asynchronous ones;
_Emitters_ in turn don't know _Receivers_.

![This graphic is explained in the accompanying text.](assets/sync-async.drawio.svg)

::: tip Blurring the line between synchronous and asynchronous API
In essence, services receive events. The emitting service itself or other services can register handlers for those events in order to implement the logic of how to react to these events.
:::


### Why Using Messaging?

Using messaging has two major advantages:

::: tip Resilience
If a receiving service goes offline for a while, event messages are safely stored, and guaranteed to be delivered to the receiver as soon as it goes online again.
:::

::: tip Decoupling
Emitters of event messages are decoupled from the receivers and don't need to know them at the time of sending. This way a service is able to emit events that other services can register on in the future, for example, to implement **extension** points.
:::



## Books Reviews Sample

The following explanations walk us through a books review example from cap/samples:

* **[@capire/bookshop](https://github.com/sap-samples/cloud-cap-samples/tree/main/bookshop)** provides the well-known basic bookshop app.
* **[@capire/reviews](https://github.com/sap-samples/cloud-cap-samples/tree/main/reviews)** provides an independent service to manage reviews.
* **[@capire/bookstore](https://github.com/sap-samples/cloud-cap-samples/tree/main/bookstore)** combines both into a composite application.

![This graphic is explained in the accompanying text.](assets/cap-samples.drawio.svg)

::: tip
Follow the instructions in [*cap/samples/readme*](https://github.com/SAP-samples/cloud-cap-samples#readme) for getting the samples and exercising the following steps.
:::

### Declaring Events in CDS

Package `@capire/reviews` essentially provides a `ReviewsService`, [declared like that](https://github.com/sap-samples/cloud-cap-samples/blob/main/reviews/srv/reviews-service.cds):

```cds
service ReviewsService {

  // Sync API
  entity Reviews as projection on my.Reviews excluding { likes }
  action like (review: Reviews:ID);
  action unlike (review: Reviews:ID);

  // Async API
  event reviewed : {
    subject : Reviews:subject;
    count   : Integer;
    rating  : Decimal; // new avg rating
  }

}
```

[Learn more about declaring events in CDS.](../../cds/cdl#events){.learn-more}

As you can read from the definitions, the service's synchronous API allows to create, read, update, and delete user `Reviews` for arbitrary review subjects. In addition, the service's asynchronous API declares the `reviewed` event that shall be emitted whenever a subject's average rating changes.

::: tip
**Services in CAP** combine **synchronous** *and* **asynchronous** APIs. Events are declared on conceptual level focusing on domain, instead of low-level wire protocols.
:::

### Emitting Events

Find the code to emit events in *[@capire/reviews/srv/reviews-service.js](https://github.com/SAP-samples/cloud-cap-samples/blob/139d9574950d1a5ead475c7b47deb174418500e4/reviews/srv/reviews-service.js#L12-L20)*:

```js
class ReviewsService extends cds.ApplicationService { async init() {

  // Emit a `reviewed` event whenever a subject's avg rating changes
  this.after (['CREATE','UPDATE','DELETE'], 'Reviews', (_, req) => {
    let { subject } = req.data, count, rating //= ...
    return this.emit ('reviewed', { subject, count, rating })
  })

}}
```
[Learn more about `srv.emit()` in Node.js.](../../node.js/core-services#srv-emit-event){.learn-more}
[Learn more about `srv.emit()` in Java.](../../java/services#an-event-based-api){.learn-more}

Method `srv.emit()` is used to emit event messages. As you can see, emitters usually emit messages to themselves, that is, `this`, to inform potential listeners about certain events. Emitters don't know the receivers of the events they emit. There might be none, there might be local ones in the same process, or remote ones in separate processes.

::: tip Messaging on Conceptual Level
Simply use `srv.emit()` to emit events, and let the CAP framework care for wire protocols like CloudEvents, transports via message brokers, multitenancy handling, and so forth.
:::

### Receiving Events

Find the code to receive events in *[@capire/bookstore/srv/mashup.js](https://github.com/SAP-samples/cloud-cap-samples/blob/30764b261b6bf95854df59f54a8818a4ceedd462/bookstore/srv/mashup.js#L39-L47)* (which is the basic bookshop app enhanced by reviews, hence integration with `ReviewsService`):

```js
  // Update Books' average ratings when reviews are updated
  ReviewsService.on ('reviewed', (msg) => {
    const { subject, count, rating } = msg.data
    // ...
  })
```

[Learn more about registering event handlers in Node.js.](../../node.js/core-services#srv-on-before-after){.learn-more}
[Learn more about registering event handlers in Java.](../../java/event-handlers/#introduction-to-event-handlers){.learn-more}

The message payload is in the `data` property of the inbound `msg` object.


::: tip
To have more control over imported service definitions, you can set the `model` configuration of your external service to a cds file where you define the external service and only use the imported definitions your app needs. This way, plugins like [Open Resource Discovery (ORD)](../../plugins/#ord-open-resource-discovery) know which parts of the external service you actually use in your application.
:::


## In-Process Eventing

As emitting and handling events is an intrinsic feature of the CAP core runtimes, there's nothing else required when emitters and receivers live in the same process.

![This graphic is explained in the accompanying text.](assets/local.drawio.svg)

Let's see that in action...

### 1. Start a Single Server Process {#start-single-server}

Run the following command to start a reviews-enhanced bookshop as an all-in-one server process:

```sh
cds watch bookstore
```

It produces a trace output like that:

```log
[cds] - mocking ReviewsService { path: '/reviews', impl: '../reviews/srv/reviews-service.js' }
[cds] - mocking OrdersService { path: '/orders', impl: '../orders/srv/orders-service.js' }
[cds] - serving CatalogService { path: '/browse', impl: '../bookshop/srv/cat-service.js' }
[cds] - serving AdminService { path: '/admin', impl: '../bookshop/srv/admin-service.js' }

[cds] - server listening on { url: 'http://localhost:4004' }
[cds] - launched at 5/25/2023, 4:53:46 PM, version: 7.0.0, in: 991.573ms
```

As apparent from the output, both, the two bookshop services `CatalogService` and `AdminService` as well as our new `ReviewsService`, are served in the same process (mocked, as the `ReviewsService` is configured as required service in _bookstore/package.json_).

### 2. Add or Update Reviews {#add-or-update-reviews}

Now, open [http://localhost:4004/reviews](http://localhost:4004/reviews) to display the Vue.js UI that is provided with the reviews service sample:

![A vue.js UI, showing the bookshop sample with the adding a review functionality](assets/capire-reviews.png)

- Choose one of the reviews.
- Change the 5-star rating with the dropdown.
- Choose *Submit*.
- Enter *bob* to authenticate.

→ In the terminal window you should see a server reaction like this:

```log
[cds] - PATCH /reviews/Reviews/148ddf2b-c16a-4d52-b8aa-7d581460b431
< emitting: reviewed { subject: '201', count: 2, rating: 4.5 }
> received: reviewed { subject: '201', count: 2, rating: 4.5 }
```

Which means the `ReviewsService` emitted a `reviewed` message that was received by the enhanced `CatalogService`.

### 3. Check Ratings in Bookshop App

Open [http://localhost:4004/bookshop](http://localhost:4004/bookshop) to see the list of books served by `CatalogService` and refresh to see the updated average rating and reviews count:

![A vue.js UI showing the pure bookhsop sample without additional features.](assets/capire-books.png)


## Using Message Channels

When emitters and receivers live in separate processes, you need to add a message channel to forward event messages. CAP provides messaging services, which take care for that message channel behind the scenes as illustrated in the following graphic:

![The reviews service and the catalog service, each in a seperate process, are connected to the messaging service which holds the messaging channel behind the scenes.](assets/remote.drawio.svg)


::: tip Uniform, Agnostic Messaging
CAP provides messaging services, which transport messages behind the scenes using different messaging channels and brokers. All of this happens without the need to touch your code, which stays on conceptual level.
:::

### 1. Use `file-based-messaging` in Development

For quick tests during development, CAP provides a simple file-based messaging service implementation. Configure that as follows for the `[development]` profile:

```jsonc
"cds": {
  "requires": {
    "messaging": {
      "[development]": { "kind": "file-based-messaging" }
    },
  }
}
```

[Learn more about `cds.env` profiles.](../../node.js/cds-env#profiles){.learn-more}

In our samples, you find that in [@capire/reviews/package.json](https://github.com/SAP-samples/cloud-cap-samples/blob/main/reviews/package.json) as well as [@capire/bookstore/package.json](https://github.com/SAP-samples/cloud-cap-samples/blob/main/bookstore/package.json), which you'll run in the next step as separate processes.


### 2. Start the `reviews` Service and `bookstore` Separately

First start the `reviews` service separately:

```sh
cds watch reviews
```

The trace output should contain these lines, confirming that you're using `file-based-messaging`, and that the `ReviewsService` is served by that process at port 4005:

```log
[cds] - connect to messaging > file-based-messaging { file: '~/.cds-msg-box' }
[cds] - serving ReviewsService { path: '/reviews', impl: '../reviews/srv/reviews-service.js' }

[cds] - server listening on { url: 'http://localhost:4005' }
[cds] - launched at 5/25/2023, 4:53:46 PM, version: 7.0.0, in: 593.274ms
```

Then, in a separate terminal start the `bookstore` server as before:

```sh
cds watch bookstore
```

This time the trace output is different to [when you started all in a single server](#start-single-server). The output confirms that you're using `file-based-messaging`, and that you now *connected* to the separately started `ReviewsService` at port 4005:

```log
[cds] - connect to messaging > file-based-messaging { file: '~/.cds-msg-box' }
[cds] - mocking OrdersService { path: '/orders', impl: '../orders/srv/orders-service.js' }
[cds] - serving CatalogService { path: '/browse', impl: '../reviews/srv/cat-service.js' }
[cds] - serving AdminService { path: '/admin', impl: '../reviews/srv/admin-service.js' }
[cds] - connect to ReviewsService > odata { url: 'http://localhost:4005/reviews' }

[cds] - server listening on { url: 'http://localhost:4004' }
[cds] - launched at 5/25/2023, 4:55:46 PM, version: 7.0.0, in: 1.053s
```

### 3. Add or Update Reviews {#add-or-update-reviews-2}

Similar to before, open [http://localhost:4005/vue/index.html](http://localhost:4005/vue/index.html) to add or update reviews.

→ In the terminal window for the `reviews` server you should see this:

```log
[cds] - PATCH /reviews/Reviews/74191a20-f197-4829-bd47-c4676710e04a
< emitting: reviewed { subject: '251', count: 1, rating: 3 }
```

→ In the terminal window for the `bookstore` server you should see this:

```log
> received: reviewed { subject: '251', count: 1, rating: 3 }
```

::: tip **Agnostic Messaging APIs**
Without touching any code the event emitted from the `ReviewsService` got transported via `file-based-messaging` channel behind the scenes and was received in the `bookstore` as before, when you used in-process eventing → which was to be shown (*QED*).
:::

### 4. Shut Down and Restart Receiver → Resilience by Design

You can simulate a server outage to demonstrate the value of messaging for resilience as follows:

1. Terminate the `bookstore` server with <kbd>Ctrl</kbd> + <kbd>C</kbd> in the respective terminal.
2. Add or update more reviews as described before.
3. Restart the receiver with `cds watch bookstore`.

→ You should see some trace output like that:

```log
[cds] - server listening on { url: 'http://localhost:4004' }
[cds] - launched at 5/25/2023, 10:45:42 PM, version: 7.0.0, in: 1.023s
[cds] - [ terminate with ^C ]

> received: reviewed { subject: '207', count: 1, rating: 2 }
> received: reviewed { subject: '207', count: 1, rating: 2 }
> received: reviewed { subject: '207', count: 1, rating: 2 }
```

::: tip **Resilience by Design**
All messages emitted while the receiver was down stayed in the messaging queue and are delivered when the server is back.
:::


### Have a Look Into _~/.cds-msg-box_

You can watch the messages flowing through the message queue by opening _~/.cds-msg-box_ in a text editor. When the receiver is down and therefore the message not already consumed, you can see the event messages emitted by the `ReviewsService` in entries like that:

```json
ReviewsService.reviewed {"data":{"subject":"201","count":4,"rating":5}, "headers": {...}}
```



## Using Multiple Channels

By default CAP uses a single message channel for all messages.

For example: If you consume messages from SAP S/4HANA in an enhanced version of `bookstore`, as well as emit messages a customer could subscribe and react to in a customer extension, the overall topology would look like that:

![The reviews service, bookstore, and the SAP S/4HANA system send events to a common message bus. The bookstore also receives events and customer extensions as well.](assets/composite1.drawio.svg)

### Using Separate Channels

Now, sometimes you want to use separate channels for different emitters or receivers. Let's assume you want to have a dedicated channel for all events from SAP S/4HANA, and yet another separate one for all outgoing events, to which customer extensions can subscribe too. This situation is illustrated in this graphic:

![The graphic shows seperate message channels for each event emitter and its subscribers.](assets/composite2.drawio.svg)

This is possible when using [low-level messaging](#low-level-messaging), but comes at the price of loosing all advantages of conceptual-level messaging as explained in the following.

### Using `composite-messaging` Implementation

To avoid falling back to low-level messaging, CAP provides the `composite-messaging` implementation, which basically acts like a transparent dispatcher for both, inbound and outbound messages. The resulting topology would look like that:

![Each emitter and subscriber has its own message channel. In additon there's a composite message channel that dispatches to/from each of those seperate channels.](assets/composite3.drawio.svg)


::: tip **Transparent Topologies**
The `composite-messaging` implementation allows to flexibly change topologies of message channels at deployment time, without touching source code or models.
:::

### Configuring Individual Channels and Routes

You would configure this in `bookstore`'s _package.json_ as follows:

```jsonc
"cds": {
  "requires": {
    "messaging": {
      "kind": "composite-messaging",
      "routes": {
        "ChannelA": ["**/ReviewsService/*"],
        "ChannelB": ["**/sap/s4/**"]
        "ChannelC": ["**/bookshop/**"]
      }
    },
    "ChannelA": {
      "kind": "enterprise-messaging", ...
    },
    "ChannelB": {
      "kind": "enterprise-messaging", ...
    },
    "ChannelC": {
      "kind": "enterprise-messaging", ...
    }
  }
}
```

In essence, you first configure a messaging service for each channel. In addition, you would configure the default `messaging` service to be of kind `composite-messaging`.

In the `routes`, you can use the glob pattern to define filters for event names, that means:

- `**` will match any number of characters.
- `*` will match any number of characters except `/` and `.`.
- `?` will match a single character.

::: tip
You can also refer to events declared in CDS models, by using their fully qualified event name (unless annotation `@topic` is used on them).
:::

## Low-Level Messaging

In the previous sections it's documented how CAP promotes messaging on conceptual levels, staying agnostic to topologies and message brokers. While CAP strongly recommends staying on that level, CAP also offers lower-level messaging, which loses some of the advantages but still stays independent from specific message brokers.

::: tip Messaging as Just Another CAP Service
All messaging implementations are provided through class `cds.MessagingService` and broker-specific subclasses of that. This class is in turn a standard CAP service, derived from `cds.Service`, hence it's consumed as any other CAP service, and can also be extended by adding event handlers as usual.
:::

#### Configure Messaging Services

As with all other CAP services, add an entry to `cds.requires` in your _package.json_ or _.cdsrc.json_ like that:

```jsonc
"cds": {
  "requires": {
    "messaging": {
      "kind": // ...
    },
  }
}
```

[Learn more about `cds.env` and `cds.requires`.](../../node.js/cds-env#services){.learn-more}

You're free how you name your messaging service. Could be `messaging` as in the previous example, or any other name you choose. You can also configure multiple messages services with different names.

#### Connect to the Messaging Service

Instead of connecting to an emitter service, connect to the messaging service:

```js
const messaging = await cds.connect.to('messaging')
```

#### Emit Events to Messaging Service

Instead of emitter services emitting to themselves, emit to the messaging service:

```js
await messaging.emit ('ReviewsService.reviewed', { ... })
```

#### Receive Events from Messaging Service

Instead of registering event handlers with a concrete emitter service, register handlers on the messaging service:

```js
messaging.on ('ReviewsService.reviewed', msg => console.log(msg))
```

<br>

#### Declared Events and `@topic` Names

When declaring events in CDS models, be aware that the fully qualified name of the event is used as topic names when emitting to message brokers. Based on the following model, the resulting topic name is `my.namespace.SomeEventEmitter.SomeEvent`.

```cds
namespace my.namespace;
service SomeEventEmitter {
  event SomeEvent { ... }
}
```

If you want to manually define the topic, you can use the `@topic` annotation:

```cds
//...
@topic: 'some.very.different.topic-name'
event SomeEvent { ... }
```



#### Conceptual vs. Low-Level Messaging

When looking at the previous code samples, you see that in contrast to conceptual messaging you need to provide fully qualified event names now. This is just one of the advantages you lose. Have a look at the following list of advantages you have using conceptual messaging and lose with low-level messaging.

- Service-local event names (as already mentioned)
- Event declarations (as they go with individual services)
- Generated typed API classes for declared events
- Run in-process without any messaging service

::: tip Always prefer conceptual-level API over low-level API variants.
Besides the things listed above, this allows you to flexibly change topologies, such as starting with co-located services in a single process, and moving single services out to separate micro services later on.
:::



## CloudEvents Standard {#cloudevents}

CAP messaging has built-in support for formatting event data compliant to the [CloudEvents](https://cloudevents.io/) standard. Enable this using the `format` config option as follows:

```json
"cds": {
  "requires": {
    "messaging": {
      "format": "cloudevents"
    }
  }
}
```

With this setting, all mandatory and some more basic header fields, like `type`, `source`, `id`, `datacontenttype`, `specversion`, `time` are filled in automatically. The event name is used as `type`. The message payload is in the `data` property anyways.

::: tip CloudEvents is a wire protocol specification.
Application developers shouldn't have to care for such technical details. CAP ensures that for you, by filling in the respective fields behind the scenes.
:::



## [Using SAP Cloud Application Event Hub](./event-broker) {#sap-event-broker}

CAP has growing out-of-the-box support for SAP Cloud Application Event Hub.
As an application developer, all you need to do is configuring CAP to use `event-broker`, as in this excerpt from a _package.json_:

```jsonc
"cds": {
  "requires": {
    "messaging": {
      "[production]": {
        "kind": "event-broker"
      }
    }
  }
}
```

[Learn more about `cds.env` profiles](../../node.js/cds-env#profiles){.learn-more}


::: tip Read the guide
Find additional information about deploying SAP Cloud Application Event Hub on SAP BTP in this guide:
[&rarr; **_Using SAP Cloud Application Event Hub in BTP_**](./event-broker)
:::



## [Using SAP Event Mesh](./event-mesh) {#sap-event-mesh}

CAP has out-of-the-box support for SAP Event Mesh.
As an application developer, all you need to do is configuring CAP to use `enterprise-messaging`, usually in combination with `cloudevents` format, as in this excerpt from a _package.json_:

```jsonc
"cds": {
  "requires": {
    "messaging": {
      "[production]": {
        "kind": "enterprise-messaging",
        "format": "cloudevents"
      }
    }
  }
}
```

[Learn more about `cds.env` profiles](../../node.js/cds-env#profiles){.learn-more}


::: tip Read the guide
Find additional information about deploying SAP Event Mesh on SAP BTP in this guide:
[&rarr; **_Using SAP Event Mesh in BTP_**](./event-mesh)
:::



## [Events from SAP S/4HANA](./s4)


SAP S/4HANA integrates SAP Event Mesh as well as SAP Cloud Application Event Hub for messaging.
That makes it relatively easy for CAP-based applications to receive events from SAP S/4HANA systems.

In contrast to CAP, the asynchronous APIs of SAP S/4HANA are separate from the synchronous ones (OData, REST).
So, the effort on the CAP side is to fill this gap.
You can achieve it like that, for example, for an already imported SAP S/4HANA BusinessPartner API:

```cds
// filling in missing events as found on SAP Business Accelerator Hub
using { API_BUSINESS_PARTNER as S4 } from './API_BUSINESS_PARTNER';
extend service S4 with {
  event BusinessPartner.Created @(topic:'sap.s4.beh.businesspartner.v1.BusinessPartner.Created.v1') {
    BusinessPartner : String
  }
  event BusinessPartner.Changed @(topic:'sap.s4.beh.businesspartner.v1.BusinessPartner.Changed.v1') {
    BusinessPartner : String
  }
}
```

[Learn more about importing SAP S/4HANA service APIs.](../using-services#external-service-api){.learn-more}

With that gap filled, we can easily receive events from SAP S/4HANA the same way as from CAP services as explained in this guide, for example:

```js
const S4Bupa = await cds.connect.to ('API_BUSINESS_PARTNER')
S4Bupa.on ('BusinessPartner.Changed', msg => {...})
```

::: tip Read the guide
Find more detailed information specific to receiving events from SAP S/4HANA in this separate guide:
[&rarr; **_Receiving Events from SAP S/4HANA_**](./s4)
:::



# Using SAP Cloud Application Event Hub in Cloud Foundry

[SAP Cloud Application Event Hub](https://help.sap.com/docs/event-broker) is the new default offering for messaging in SAP Business Technology Platform (SAP BTP).
CAP provides out-of-the-box support for SAP Cloud Application Event Hub, and automatically handles many things behind the scenes, so that application coding stays agnostic and focused on conceptual messaging.

::: warning
The following guide is based on a productive (paid) account on SAP BTP.
:::

## Prerequisite: Set up SAP Cloud Application Event Hub

Follow guides [Initial Setup](https://help.sap.com/docs/sap-cloud-application-event-hub/sap-cloud-application-event-hub-service-guide/initial-setup) as well as [Integration Scenarios &rarr; CAP Application as a Consumer](https://help.sap.com/docs/sap-cloud-application-event-hub/sap-cloud-application-event-hub-service-guide/cap-application-as-subscriber) to set up SAP Cloud Application Event Hub in your account.



## Configuration


### Use `event-broker` in Node.js

Install plugin [`@cap-js/event-broker`](../../plugins/#event-hub):

```sh
npm add @cap-js/event-broker
```

And add the following to your _package.json_ to use SAP Cloud Application Event Hub:

```jsonc
"cds": {
  "requires": {
    "messaging": {
      // kind "event-broker" is derived from the service's technical name
      "[production]": { "kind": "event-broker" }
    }
  }
}
```


[Learn more about configuring SAP Cloud Application Event Hub in CAP Node.js.](../../node.js/messaging#event-broker){.learn-more}

[Learn more about `cds.env` profiles.](../../node.js/cds-env#profiles){.learn-more}


### Use `event-hub` in Java

Install plugin [`com.sap.cds:cds-feature-event-hub`](../../plugins/#event-hub) and add the following to your _application.yaml_ to use SAP Cloud Application Event Hub:

::: code-group
```xml [srv/pom.xml]
<dependency>
    <groupId>com.sap.cds</groupId>
    <artifactId>cds-feature-event-hub</artifactId>
    <version>${latest-version}</version>
</dependency>
```

```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging.services:
  - name: "messaging-name"
    kind: "event-hub"
```
:::

[Find the latest version on Maven central.](https://central.sonatype.com/artifact/com.sap.cds/cds-feature-event-hub/versions){.learn-more}
[Learn more about configuring SAP Cloud Application Event Hub in CAP Java.](../../java/messaging#using-real-brokers){.learn-more}



## Hybrid Testing

Since SAP Cloud Application Event Hub sends events via HTTP, you won't be able to receive events on your local machine unless you use a tunneling service.
Therefore we recommend to use a messaging service of kind [`local-messaging`](../../node.js/messaging#local-messaging) for local testing.



## Prepare for MTA Deployment {#deploy}

A general description of how to deploy CAP applications to SAP BTP Cloud Foundry, can be found in the [Deploy to Cloud guide](../deployment/).
As documented there, MTA is frequently used to deploy to SAP BTP.

[Learn more about using MTA.](../deployment/){.learn-more}

Follow these steps to ensure proper binding of your deployed application to the SAP Cloud Application Event Hub instance.
The guide makes use of the [@capire/incidents](https://github.com/cap-js/incidents-app) reference application.

We'll start with the definition of the app itself:

::: code-group
```yaml [mta.yaml]
modules:
  - name: incidents-srv
    provides:
      - name: incidents-srv-api
        properties:
          url: ${default-url} #> needed in references below
```
:::


### Add SAP Cloud Application Event Hub Instance

Your SAP Cloud Application Event Hub configuration must include your system namespace as well as the webhook URL.


::: code-group
```yaml [mta.yaml in Node.js]
resources:
  - name: incidents-event-broker
    type: org.cloudfoundry.managed-service
    parameters:
      service: event-broker
      service-plan: event-connectivity
      config:
        # unique identifier for this event broker instance
        # should start with own namespace (i.e., "foo.bar") and may not be longer than 15 characters
        systemNamespace: cap.incidents
        webhookUrl: ~{incidents-srv-api/url}/-/cds/event-broker/webhook
      requires:
        - name: incidents-srv-api
```

```yaml [mta.yaml in Java]
resources:
  - name: incidents-event-broker
    type: org.cloudfoundry.managed-service
    parameters:
      service: event-broker
      service-plan: event-connectivity
      config:
        # unique identifier for this event broker instance
        # should start with own namespace (i.e., "foo.bar") and may not be longer than 15 characters
        systemNamespace: cap.incidents
        webhookUrl: ~{incidents-srv-api/url}/messaging/v1.0/eb
      requires:
        - name: incidents-srv-api
```
:::


### Add Identity Authentication Service Instance

Your Identity Authentication service instance must be configured to include your SAP Cloud Application Event Hub instance under `consumed-services` in order for your application to accept requests from SAP Cloud Application Event Hub.
For this purpose, the Identity Authentication service instance should further be `processed-after` the SAP Cloud Application Event Hub instance.

::: code-group
```yaml {6,14} [mta.yaml]
resources:
  - name: incidents-ias
    type: org.cloudfoundry.managed-service
    requires:
      - name: incidents-srv-api
    processed-after:
      # for consumed-services (cf. below), incidents-event-broker must already exist
      # -> ensure incidents-ias is created after incidents-event-broker
      - incidents-event-broker
    parameters:
      service: identity
      service-plan: application
      config:
        consumed-services:
          - service-instance-name: incidents-event-broker
       	xsuaa-cross-consumption: true #> if token exchange from IAS token to XSUAA token is needed
        display-name: cap.incidents #> any value, e.g., reuse MTA ID
        home-url: ~{incidents-srv-api/url}
```
:::


### Bind the Service Instances

Finally, we can bring it all together by binding the two service instances to the application.
The bindings must both be parameterized with `credential-type: X509_GENERATED` and `authentication-type: X509_IAS`, respectively, to enable Identity Authentication service-based authentication.

::: code-group
```yaml {1-3} [mta.yaml]
modules:
  - name: incidents-srv
    provides:
      - name: incidents-srv-api
        properties:
          url: ${default-url} 
    requires: #[!code focus:10]
      - name: incidents-ias #[!code ++]
        parameters: #[!code ++]
          config: #[!code ++]
            credential-type: X509_GENERATED #[!code ++]
            app-identifier: cap.incidents #> any value, e.g., reuse MTA ID [!code ++]
      - name: incidents-event-broker #[!code ++]
        parameters: #[!code ++]
          config: #[!code ++]
            authentication-type: X509_IAS #[!code ++]
```
:::


<span id="event-hub-mt" />
<Fragment target="#event-hub-mt">

## Setup for Multitenancy <Internal /> { #multitenancy }

SaaS applications can be built as multitenant CAP applications managed by SAP. In comparison to side-by-side extensions as described previously, a multitenant application uses the BTP SaaS Provisioning Service (technical name `saas-registry`) or BTP Subscription Manager (technical name `subscription-manager`) for managing application subscriptions and has to use the multitenant service plan `event-mesh-multi-tenant` of Event Hub. 

### Add SAP Cloud Application Event Hub Instance

The configuration of your SaaS application has to be extended with a service instance of Event Hub. Event Hub requires deployment region, application namespace and  webhook URL as parameters.<br>
For production use, the namespace must be [registered with Cross Product Architecture (CPA)](https://github.tools.sap/CPA/namespace-registry).


::: code-group
```yaml [mta.yaml in Node.js]
resources:
  - name: incidents-event-broker
    type: org.cloudfoundry.managed-service
    parameters:
      service: eventmesh-sap2sap-internal
      service-plan: event-mesh-multi-tenant
      config:
        # <event-hub-namespace> is a unique identifier for this event broker instance or sap-managed application,
        # it should start with "sap" and may not be longer than 15 characters, e.g., "sap.<name>".
        # <region> is the deployment region, e.g., cf-eu12.
        ceSource:
          - "/<region>/<event-hub-namespace>"
        deploymentRegion: <region>
        webhookUrl: ~{incidents-srv-api/url}/-/cds/event-broker/webhook
      requires:
        - name: incidents-srv-api
```

```yaml [mta.yaml in Java]
resources:
  - name: incidents-event-broker
    type: org.cloudfoundry.managed-service
    parameters:
      service: eventmesh-sap2sap-internal
      service-plan: event-mesh-multi-tenant
      config:
        # <event-hub-namespace> is a unique identifier for this event broker instance or sap-managed application,
        # it should start with "sap" and may not be longer than 15 characters, e.g., "sap.<name>".
        # <region> is the deployment region, e.g., cf-eu12.
        ceSource:
          - "/<region>/<event-hub-namespace>"
        deploymentRegion: <region>
        webhookUrl: ~{incidents-srv-api/url}/messaging/v1.0/eb
      requires:
        - name: incidents-srv-api
```
:::

Each application subscription needs to be represented as individual [UCL system](https://pages.github.tools.sap/atom-cfs/atom-docs/docs/product-concepts/customer-landscape/) and added to [formations](https://help.sap.com/docs/sap-cloud-application-event-hub/sap-cloud-application-event-hub-draft-service/configure-formations) to [enable event subscriptions](https://help.sap.com/docs/sap-cloud-application-event-hub/sap-cloud-application-event-hub-service-guide/enable-subscriptions) for exchanging events via Event Hub.

For a description on how to onboard a SaaS application to Unified Customer Landscape (UCL), see [_UCL Onboarding_ guide](https://pages.github.tools.sap/ucl/stakeholders-documentation/docs/onboarding/declarative-unified-services-interface/).


</Fragment>

<div id="secondary-file">guides/messaging/event-broker.fragment.md</div>


# Using SAP Event Mesh in Cloud Foundry

CAP provides out-of-the-box support for [SAP Event Mesh](https://help.sap.com/docs/event-mesh), and automatically handles many things behind the scenes, so that application coding stays agnostic and focused on conceptual messaging.

::: warning
The following guide is based on a productive (paid) account on SAP BTP. It's not supported to use the trial offering of SAP Event Mesh.
:::

## Prerequisite: Create an Instance of SAP Event Mesh

- [Follow this tutorial](https://developers.sap.com/group.cp-enterprisemessaging-get-started.html) to create an instance of SAP Event Mesh with plan `default`.
- Alternatively follow [one of the guides in SAP Help Portal](https://help.sap.com/docs/SAP_EM/bf82e6b26456494cbdd197057c09979f/3ef34ffcbbe94d3e8fff0f9ea2d5911d.html).

::: tip
**Important:** You don't need to manually create queues or queue subscriptions as CAP takes care for that automatically based on declared events and subscriptions.
:::


## Use `enterprise-messaging`

Add the following to your _package.json_ to use SAP Event Mesh:

```jsonc
"cds": {
  "requires": {
    "messaging": {
      "[production]": { "kind": "enterprise-messaging" },
    }
  }
}
```

[Learn more about `cds.env` profiles](../../node.js/cds-env#profiles){.learn-more}
[Learn how to use the CloudEvents protocol.](../../node.js/messaging#cloudevents-protocol){.learn-more}

:::tip **Behind the Scenes**

The `enterprise-messaging` implementation handles these things automatically and transparently:

  - Creation of queues & subscriptions for event receivers
  - Handling all broker-specific handshaking and acknowledgments
  - Constructing topic names as expected by the broker

:::

### Optional: Add `namespace` Prefixing Rules

SAP Event Mesh documentation recommends to prefix all event names with the service instance's configured `namespace`, both, when emitting as well as when subscribing to events. If you followed these rules, add corresponding rules to your configuration in _package.json_ to have CAP's messaging service implementations enforcing these rules automatically:

```json
"cds": {
  "requires": {
    "messaging": {
      "publishPrefix": "$namespace/",
      "subscribePrefix": "$namespace/"
    }
  }
}
```

The variable `$namespace` is resolved from your SAP Event Mesh service instance's configured `namespace` property.


## Run Tests in `hybrid` Setup

Before [deploying to the cloud](#deploy-to-the-cloud-with-mta), you may want to run some ad-hoc tests with a hybrid setup, that is, keep running the CAP services locally, but using the SAP Event Mesh instance from the cloud. Do that as follows:

1. Configure CAP to use the `enterprise-messaging-shared` implementation in the `reviews` and `bookstore` sample:

    ```jsonc
    "cds": {
      "requires": {
        "messaging": {
          "[hybrid]": { "kind": "enterprise-messaging-shared" }
        }
      }
    }
    ```

    > The `enterprise-messaging-shared` variant is for single-tenant usage and uses AMQP by default. Thus, it requires much less setup for local tests compared to the production variant, which uses HTTP-based protocols by default.

2. Add `@sap/xb-msg-amqp-v100` as dependency to `reviews` and `bookstore`:

    ```sh
    npm add @sap/xb-msg-amqp-v100
    ```

    [Learn more about SAP Event Mesh (Shared).](../../node.js/messaging#event-mesh-shared){.learn-more}

3. Create a service key for your Event Mesh instance [→ see help.sap.com](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/4514a14ab6424d9f84f1b8650df609ce.html)

4. Bind to your Event Mesh instance's service key from `reviews` and `bookstore`:

    ```sh
    cds bind -2 <instance>:<service-key>
    ```


    [Learn more about `cds bind` and hybrid testing.](../../advanced/hybrid-testing){.learn-more}

5. Run your services in separate terminal shells with the `hybrid` profile:

    ```sh
    cds watch reviews --profile hybrid
    ```
    ```sh
    cds watch bookstore --profile hybrid
    ```

    [Learn more about `cds.env` profiles.](../../node.js/cds-env#profiles){.learn-more}

6. Test your app [as described in the messaging guide](./#add-or-update-reviews).


### CAP Automatically Creates Queues and Subscriptions

When you run the services with a bound instance of SAP Event Mesh as documented in a previous section, CAP messaging service implementations will automatically create a queue for each receiver process. The queue name is chosen automatically and the receiver's subscriptions added.


### Optional: Configure Queue Names

In case you want to manage queues yourself, use config option `queue.name` as follows:

```jsonc
"cds": {
  "requires": {
    "messaging": { // ...
      "queue": { "name": "$namespace/my/own/queue" }
    }
  }
}
```

In both cases — automatically chosen queue names or explicitly configured ones — if the queue already exists it's reused, otherwise it's created.

[Learn more about queue configuration options.](../../node.js/messaging#message-brokers){.learn-more}


## Deploy to the Cloud (with MTA)

A general description of how to deploy CAP applications to SAP BTP's Cloud Foundry, can be found in the [Deploy to Cloud* guide](../deployment/). As documented there, MTA is frequently used to deploy to SAP BTP. Follow these steps to ensure binding of your deployed application to the SAP Event Mesh instance.


### 1. Specify Binding to SAP Event Mesh Instance

Add SAP Event Mesh's service instance's name to the `requires` section of your CAP application's module, and a matching entry to the `resources` section, for example:

```yaml
modules:
  - name: bookstore-srv
    requires:
      - name: <Event Mesh Service Instance - Name>

resources:
  # SAP Event Mesh
  - name: <Event Mesh Service Instance - Name>
    type: org.cloudfoundry.managed-service
    parameters:
      service: enterprise-messaging
      service-plan: <Event Mesh Service Instance - Plan>
```

[Learn more about using MTA.](../deployment/){.learn-more}

::: warning
Make sure to use the exact `name` and `service-plan` used at the time creating the service instance you want to use.
:::


### 2. Optional: Auto-Create SAP Event Mesh Instances

MTA can also create the service instance automatically. To do so, you need to additionally provide a service descriptor file and reference that through the `path` parameter in the `resources` section:

```yaml
resources:
  # SAP Event Mesh as above...
    parameters:
      path: ./<Event Mesh Service Descriptor JSON file>
```

[Learn more about Service Descriptors for SAP Event Mesh.](https://help.sap.com/docs/SAP_EM/bf82e6b26456494cbdd197057c09979f/5696828fd5724aa5b26412db09163530.html){.learn-more}


<span id="afterdeploymta" />
<Fragment target="#afterdeploymta">

## Setup for Multitenancy <Internal /> { #multitenancy }

::: warning
SAP Event Mesh deprecated its multitenancy capability for new stakeholders, see [Getting Started with Event Mesh (default plan) in the SaaS context](https://wiki.one.int.sap/wiki/x/kUIAgQ).
:::

CAP's support for SAP Event Mesh includes advanced support and optimizations for multitenant usage.


<div class='tip'>

**Behind the Scenes** — In multitenant mode the `enterprise-messaging` implementation additionally cares for:

- Onboarding SaaS tenants → Creating SAP Event Mesh client instances
- Using HTTP-based protocols instead of AMQP for better scalability
- Providing webhook endpoints and registering them with SAP Event Mesh
- Tenant-specific handshaking

</div>

### Using HTTP-Based Protocols by Default

SAP Event Mesh can be used using [different protocols, like AMQP, MQTT or REST APIs](https://help.sap.com/docs/SAP_EM/bf82e6b26456494cbdd197057c09979f/3f424ff1ae3b4bc084c4f1ea0be96f54.html). AMQP is connection-based which frequently creates resource and scalability issues for multitenant operations. Therefore, when in multitenant mode, the `enterprise-messaging` implementation uses [REST APIs, with webhooks for inbound messages](https://help.sap.com/docs/SAP_EM/bf82e6b26456494cbdd197057c09979f/00d56d697c7549408cfacc8cb6a46b11.html).

### 1. Configure Event Mesh Instance for Multitenancy

You need to configure SAP Event Mesh to enforce tenant isolation by having one dedicated event bus per tenant. This can be achieved by setting the instance type to reuse in the [service descriptor](https://help.sap.com/docs/SAP_EM/bf82e6b26456494cbdd197057c09979f/5696828fd5724aa5b26412db09163530.html) as follows:

```json
{
  "instanceType": "reuse"
}
```

### 2. Ensure to Use `enterprise-messaging`

Add the following to your _package.json_ to ensure using the multitenancy-aware variant of SAP Event Mesh:

```jsonc
"cds": {
  "requires": {
    "messaging": {
      "[production]": { "kind": "enterprise-messaging" },
    }
  }
}
```

[Learn more about `cds.env` profiles.](../../node.js/cds-env#profiles){.learn-more}

### 3. Secure Inbound Access to HTTP Webhooks {#inbound-access-webhooks}

Incoming messages are delivered by SAP Event Mesh to webhook endpoints of the SaaS application. To make this endpoint accessible for SAP Event Mesh, you need to grant the respective authority, for example like this in the XSUAA service descriptor _xs-security.json_:

```jsonc
{
  "scopes": [
    {
      "name": "$XSAPPNAME.emcallback",
      "description": "Event Mesh Callback Access",
      "grant-as-authority-to-apps": [
        "$XSSERVICENAME(<SERVICE_NAME_OF_YOUR_EVENT_MESH_INSTANCE>)"
      ]
    }
  ]
}
```

[Learn more about **XSUAA configuration**.](/guides/security/authorization#xsuaa-configuration){.learn-more}

In addition, you've to let your SAP Event Mesh instance accept the granted authorities. Add `$ACCEPT_GRANTED_AUTHORITIES` to the `authorities` array in the service descriptor of your SAP Event Mesh instance:

```js
{
  […],
  "instanceType": "reuse",
  "authorities": [
    "$ACCEPT_GRANTED_AUTHORITIES"
  ]
}
```

### 4. Deploy Your App with Profile `multitenancy`

Finally deploy your application for multitenant usage as described in the [Multitenancy](../deployment/to-cf) guide and the [Java companion](../../java/multitenancy) to it.

## Onboarding Tenants

CAP's `enterprise-messaging` implementation plugs in to `@sap/cds-mtx` to fully automate tenant onboarding for SAP Event Mesh as follows:

- **Creating Isolated Event Mesh Instances** — The SAP Event Mesh service is included in response to Cloud Foundry's SaaS provisioning service's check for dependencies → in response to that the SaaS provisioning service creates the tenant's dedicated event bus.

- **Creating Queues on Subscriptions** — Once the tenant's event bus has been created, the SaaS provisioning service calls the subscription path, which triggers the process of creating all required queues and webhook subscriptions.

### Important: Use Asynchronous Onboarding

As the creation of the event bus **can take up to several minutes**, it's important to inform the SaaS provisioning service to make this process asynchronous. Do so by setting these properties in the [SaaS provisioning service's service descriptor](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/3971151ba22e4faa9b245943feecea54.html):

```json
 "onSubscriptionAsync": true,
 "callbackTimeoutMillis": 600000
```

In case of Java, you additionally need to set `CDS_MULTITENANCY_CALLBACKURL`.

## Upgrading Tenants

When upgrading deployed applications **new subscriptions are currently not propagated to already onboarded tenants** → as a temporary work-around to compensate for this, a REST API is provided to trigger that manually. Calling this REST API requires the caller to have a role that includes the scope `$XSAPPNAME.emmanagement`.

::: warning _❗ Warning_
As soon as a better integration into the SaaS management processes is found, the provided REST APIs will be deprecated and removed.
:::

::: tip
To create the messaging infrastructure for existing tenants you have to trigger the tenant update by the SaaS provisioning service. The tenant update only updates the messaging-related configuration, such as related queues, topic subscriptions and webhook registrations.
:::

### For Node.js

To update one, multiple, or all tenants to the current messaging-related configuration of the app, the following HTTP endpoint can be used:

```http
POST <APP_URL>/messaging/enterprise-messaging/deploy HTTP/1.1
Content-Type: application/json

{
  "tenants": ["<TENANT_ID_1>", …], // or ["all"] (default: ["all"])
  "queues": ["<QUEUE_NAME_1>", …] // or ["all"] (default: ["all"])
}
```

Alternatively, you can run the following task on Cloud Foundry:

```sh
cf run-task <YOUR_APP> "node node_modules/@sap/cds/tasks/enterprise-messaging-deploy.js"
```

### For Java

To update one, multiple, or all tenants to the current messaging-related configuration of the app, run the [`Deploy` main method](/java/multitenancy#deploy-main-method) as a task on Cloud Foundry.

[Learn more about upgrading tenants.](/java/multitenancy#database-update){ .learn-more}

## SAP Event Specifications

SAP has sophisticated rules for constructing event messages:

1. [**SAP Event Specification**](https://github.tools.sap/CentralEngineering/sap-event-specification), part of [TG27](https://github.tools.sap/CentralEngineering/TechnologyGuidelines/tree/latest/tg27), is a stricter form of the [CloudEvents](https://cloudevents.io/) standard that all SAP-internal projects are asked to comply to.

2. [**SAP Event Mesh** has defined a mapping and rules](https://github.tools.sap/cloudevents/ems/blob/master/topics.md) how to construct valid message topics from the `source` and `type` properties.

### Using `cloudevents` With `enterprise-messaging`

CAP automatically creates messages, which comply to both by using format `cloudevents` in combination with `enterprise-messaging`, for example:

```json
"cds": {
  "requires": {
    "messaging": {
      "kind": "enterprise-messaging",
      "format": "cloudevents"
    }
  }
}
```

### Special `$namespace/ce/` Prefixing by Default

To comply to [SAP Event Mesh's mapping rules for CloudEvents messages](https://github.tools.sap/cloudevents/ems/blob/master/topics.md), the `enterprise-messaging` implementation with `format: cloudevents` automatically prefixes topic names when emitting or subscribing to events, as if configured like that:

```jsonc
"cds": {
  "requires": {
    "messaging": {
      "kind": "enterprise-messaging",
      "format": "cloudevents",
      // implicitly applied default prefixes
      "publishPrefix": "$namespace/ce/",
      "subscribePrefix": "+/+/+/ce/"
     }
  }
}
```

> Explicitly override these settings if you want a different prefixing.

### Special Topic Rewriting Applied

Also to comply to [SAP Event Mesh's mapping rules for CloudEvents messages](https://github.tools.sap/cloudevents/ems/blob/master/topics.md), dots in event names are replaced by slashes when generating topic names, and the `source` header field is derived based on the set `publishPrefix`:

| publishPrefix            | derived source      |
| ------------------------ | ------------------- |
| `my/own/namespace/ce/`   | `/my/own/namespace` |
| `my/own.namespace/-/ce/` | `/my/own.namespace` |

## SAP Message Queuing

When using SAP Message Queuing as messaging service (only available to SAP-internal stakeholders using `kind: message-queuing`), all dots in the event name are automatically replaced by slashes, as SAP Message Queuing doesn't allow dots to appear in topics.

Example:

`my.custom.topic` is changed to `my/custom/topic`.

</Fragment>

<div id="secondary-file">guides/messaging/event-mesh.fragment.md</div>


# Using Apache Kafka

SAP-internal
{ .subtitle}

[Apache Kafka on BTP](https://wiki.one.int.sap/wiki/display/HCPBD/Kafka) is available in all public SAP BTP landscapes, as well as AliCloud and AWS GovCloud.

CAP messaging provides out-of-the-box support for Apache Kafka. Its runtimes handle emitting and receiving CAP events in a Kafka cluster under the hood. Hence, application coding can be agnostic to the concrete messaging infrastructure and developers can deal with messaging on a conceptual level. The CAP Kafka integration is the recommended method for asynchronous intra-application communication. It hides the complexity of Apache Kafka while still providing publish-subscribe-based messaging, horizontal scalability and compatibility with other message broker integrations provided by CAP.

::: warning Do not send sensitive data
CAP doesn't encrypt any data that is sent to Apache Kafka clusters as it only provides an interface for asynchronous communication. Hence, applications must not send any personal, confidential or sensitive data using Apache Kafka. For further information, please refer to the page for [go-live checks](https://wiki.one.int.sap/wiki/display/HCPBD/Kafka+Go-Live+Checks) in the [Apache Kafka on BTP](https://wiki.one.int.sap/wiki/display/HCPBD/Kafka) wiki.
:::

## Create an Instance of Apache Kafka {#create-instance}

**Prerequisite:** You need to have the Kafka service entitled in your global account, see [Creating an Entitlement for Kafka Service](https://wiki.one.int.sap/wiki/display/HCPBD/Getting+Started+With+Kafka#GettingStartedWithKafka-CreatinganEntitlementforKafkaService).

Simply set up Kafka using this command:

```sh
cds add kafka
```

::: details See what this does in your project...

1. If you're deploying to Cloud Foundry using MTA deployments, it adds an `mta.yaml` configuration:

   ```yaml
   # ...
   modules:
     - name: bookshop-srv
       # ...
       requires:
         - name: bookshop-kafka
   #...
   resources:
     - name: bookshop-kafka
       type: org.cloudfoundry.managed-service
       parameters:
         service: kafka
         service-plan: standard
   # ...
   ```

  <div class="impl node">

2. Dependencies and `cds` configuration are added to your _package.json_:

   ```json [Node.js]{3,8-10}
   {
     "dependencies": {
       "kafkajs": "^2"
     },
     "cds": {
       "requires": {
         "[production]": {
           "messaging": {
             "kind": "kafka"
           }
         }
       }
     }
   }
   ```

  </div>
  <div class="impl java">

2. The dependency is added to your _srv/pom.xml_:
`xml [Java]
    <dependency>
        <groupId>com.sap.cds</groupId>
        <artifactId>cds-feature-kafka</artifactId>
        <scope>runtime</scope>
    </dependency>
    `

  </div>
:::

You can override default settings by creating a `kafka.json` file with custom parameters for the Apache Kafka service instance:

::: code-group

```json [kafka.json]
{
  "auto_create_topics_enable": true,
  "disk_per_broker": "500G",
  "dynatrace_enabled": false,
  "message_max_bytes": 1048588,
  "min_insync_replicas": 2,
  "number_of_brokers": 3
}
```

:::

[Learn more about available parameters for creating an Apache Kafka service instance](https://wiki.one.int.sap/wiki/display/HCPBD/Getting+Started+With+Kafka#GettingStartedWithKafka-AvailableParametersforcreate-service/update-service){.learn-more}

You can reference this file in your deployment descriptor:

::: code-group

```yaml [mta.yaml (Cloud Foundry)]
#...
resources:
  - name: bookshop-kafka
    #...
    parameters:
      config: kafka.json
```

:::

Alternatively, you can create a Kafka service via the Cloud Foundry CLI or the SAP BTP Cockpit.

::: details Using the Cloud Foundry CLI

Make sure that the [Clound Foundry command line client](https://docs.cloudfoundry.org/cf-cli/install-go-cli.html) and the [BigData plugin](https://github.tools.sap/hcpbd/cf_cli_bigdata_plugin/blob/master/README.md) are installed correctly.

Login to BTP and select the space in which the instance shall be created.

```sh
cf login -a <api-endpoint>
```

Create the service instance:

```sh
cf create-service kafka standard bookshop-kafka
```

This results in an Apache Kafka cluster named `bookshop-kafka` with 3 brokers and 500GB disk space per broker.

It's possible to pass a configuration that contains custom parameters for the Apache Kafka cluster to be created:

```sh
cf create-service kafka standard bookshop-kafka -c kafka.json
```

The file `kafka.json` contains the custom parameters.

[Find an example of such a configuration file in the deployment section.](#create-instance){.learn-more}

:::

::: details Using SAP BTP Cockpit

A general description to [create service instances is available on the SAP Help Portal](https://help.sap.com/docs/service-manager/sap-service-manager/creating-service-instances-in-cloud-foundry?locale=en-US).

The following steps illustrate the dialog when creating an Apache Kafka service instance.

1. Enter basic information for the service instance.
   ![This screenshot is explained in the accompanying text.](assets/kafka-btp-cockpit-create-instance-1.jpg){}
1. Configure instance parameters.
   ![This screenshot is explained in the accompanying text.](assets/kafka-btp-cockpit-create-instance-2.jpg){}
   [Learn more about parameters for creating an Apache Kafka service instance](https://wiki.one.int.sap/wiki/display/HCPBD/Getting+Started+With+Kafka#GettingStartedWithKafka-AvailableParametersforcreate-service/update-service){.learn-more}
1. Review / verify the instance details and **Create** the service instance.

:::

## Enable the Kafka Integration

The Kafka feature automatically finds the binding and establishes a connection to the Apache Kafka cluster. If you integrate more than one message broker in your microservice, you have to configure multiple channels. The CAP Kafka integration can be used in your code just like any other CAP Messaging integration.

[Learn more about using multiple channels.](/guides/messaging/#using-multiple-channels){.learn-more}
[Learn more about CAP Java Messaging.](/java/messaging){.learn-more .java}
[Learn more about CAP Node.js Messaging.](/node.js/messaging){.learn-more .node}

## Multitenancy

The CAP Kafka feature comes with multitenancy support. If your microservice is running in a multitenant environment, producers add the tenant ID to events automatically before sending them. The consumers retrieve the tenant ID from the event and the event handlers of your microservice are called in the context of the corresponding tenant. It is not required to develop any custom code to enable multitenancy.

::: info Kafka Message Header with tenant ID
The tenant ID is added as a Kafka message header on producer side by the CAP Kafka feature. Consumers retrieve the tenant ID from the Kafka message header to create a CAP context before calling the event handlers.
:::

## Using Multiple Channels

To match the CAP channel concept as described in the chapter [Using Message Channels](/guides/messaging/#using-message-channels), the CAP Kafka feature maps the channel to the Apache Kafka topic `cds.default`. All events that are emitted by producers, are written to this Apache Kafka topic. Consumers of events don't subscribe to the Apache Kafka topic, but to the CAP events. The CAP events that are not subscribed by a consumer are ignored.

You can configure a custom channel name as follows:

::: code-group

```json [Node.js]
// package.json
"cds": {
  "requires": {
    "[production]": {
      "messaging": {
        "kind": "composite-messaging",
        "routes": {
          "kafka1": ["reviews/**"],
          "kafka2": ["bookstore/**"]
        }
      },
      "kafka1": {
        "kind": "kafka",
        "topic": "my.reviews"
      },
      "kafka2": {
        "kind": "kafka",
        "topic": "my.bookstore"
      }
    }
  }
}
```

```yaml [Java]
# application.yaml
cds:
  messaging:
    services:
      kafka-messaging:
        binding: kafka-shared
        queue:
          config:
            channel: my-application-channel
```

:::

If you want to have different channels for different sets of events that shall be send to the same Apache Kafka cluster, you have to configure composite messaging.

[Learn more about Using Multiple Channels](/guides/messaging/#using-multiple-channels){.learn-more}
[Learn more about the Composite Messaging Service in CAP Java](/java/messaging#composite-messaging-service){.learn-more .java}
[Learn more about the Composite Messaging Service in CAP Node.js](/node.js/messaging#composite-messaging){.learn-more .node}

::: info
The Apache Kafka topics to which the channels will be mapped are created automatically using default settings from the cluster. Existing Apache Kafka topics are not touched by the CAP Kafka feature.
:::

### Composite Messaging Example

The following example illustrates the configuration of composite messaging:

![This screenshot is explained in the accompanying text.](assets/kafka-composite-messaging-example-scenario.drawio.svg)

This diagram shows the microservices of a book store application. The application consists of business-related microservices (Catalog, Reviews, Orders, Bookstore) and a technical service that collects telemetry data. The business-related microservices send telemetry events as well as business events. Since the number of telemetry events exceeds the number of business events, the telemetry events shall be send to a dedicated channel called `telemetry`; the business events shall be send to the default channel `cds.default`.

To achieve this, composite messaging is configured to route the events accordingly. The following configuration reflects this routing:

::: code-group

```json [Node.js]
// package.json
{
  "cds": {
    "requires": {
      "[production]": {
        "messaging": {
          "kind": "composite-messaging",
          "routes": {
            "business-channel": [
              "CatalogService.**",
              "ReviewService.**",
              "OrderService.**"
            ],
            "telemetry-channel": ["TelemetryService.**"]
          },
          "business-channel": {
            "kind": "kafka"
          },
          "telemetry-channel": {
            "kind": "kafka",
            "topic": "telemetry"
          }
        }
      }
    }
  }
}
```

```yaml [Java]
# application.yaml
cds:
  messaging:
    routes:
      - service: "business-channel"
        events:
          - "CatalogService.*"
          - "ReviewService.*"
          - "OrderService.*"
      - service: "telemetry-channel"
        events:
          - "TelemetryService.*"
    services:
      business-channel:
        binding: kafka-shared
      telemetry-channel:
        binding: kafka-shared
        queue:
          config:
            channel: telemetry
```

:::

This configuration defines two CAP messaging services, `business-channel` and `telemetry-channel`. Both CAP messaging services use the same binding to the Apache Kafka cluster. The business channel is mapped to the Apache Kafka topic `cds.default`, the telemetry-channel is mapped to the Apache Kafka topic `telemetry`. The route definitions determine to which channel an event shall be send to or received from, based on its fully qualified name.

Sending and receiving events is transparent with respect to composite messaging. The application code doesn't need to decide to which channel an event is send to or received from.

[Learn more about sending and receiving CDS-Declared Events in CAP Java](/java/messaging#cds-declared-events){.learn-more .java}

## Horizontal Scalability

Apache Kafka provides capabilities to support horizontal scalability of consumers. This is achieved by the concept of topic partitions. An Apache Kafka is not a single storage but can be split into partition where producers of an event decide to which topic partition it is written to. The topic partition can by determined by a partition key that is set by the producer. Apache Kafka then calculates the target partition based on that partition key:

`topic partition = hash(partition key) % number of topic partition`

::: info
Apache Kafka only guarantees the order of events within a single topic partition.
:::
[Learn more about topic partitions in Apache Kafka](https://stackoverflow.com/a/51829144){.learn-more}
[Learn more about Apacha Kafka design principles](https://kafka.apache.org/documentation/#design){.learn-more}

CAP Kafka supports the concept of partition keys by defining key fields in an event. The values of each key field is used as a partition key when sending an event.

The following example of an event illustrates this feature:

```cds
event BookReviewed {
    key bookID  : UUID;
        reviewID: UUID;
        title   : String;
        text    : Text;
        rating  : Integer;
}
```

The event `BookReviewed` shall be sent whenever a user writes a book review. Its key `bookID` is used as its partition key, making sure all events for the same `bookID` are written to the same topic partition.

::: info Choose `key` fields of an event as the ID of the related business object
Other CAP messaging integrations, such as Event Mesh or Message Queueing, ignore key fields. This way, event definitions with key fields stay compatible.
:::

## Using Custom Client Configuration {.java}

There are use cases, where the default CAP Kafka consumer/producer configuration is not suitable. For this reason, the CAP messaging configuration can be used to customize the configuration to your needs.

In CAP Java, the configuration is split into a consumer and a producer configuration, which is transferred to the Apache Kafka client:

::: code-group

```yaml [application.yaml]

cds:
  messaging:
    services:
      kafka-messaging:
        binding: kafka-shared
        queue:
          config:
            producer:
              ["request.timeout.ms"]: 30000
            consumer:
              "[auto.offset.reset]": earliest
```

:::

[Learn more about Kafka Consumer Configuration](https://docs.confluent.io/platform/current/installation/configuration/consumer-configs.html#cp-config-consumer){.learn-more}
[Learn more about Kafka Producer Configuration](https://docs.confluent.io/platform/current/installation/configuration/producer-configs.html#cp-config-producer){.learn-more}

#### Custom Serializer and Deserializer

During the transmission of messages in Apache Kafka, the client and server agree on the use of a common syntactic format. Apache Kafka brings default converters (such as String and Long) but also supports custom serializers for specific use cases.

[Learn more about Custom Serializers in Apache Kafka](https://www.baeldung.com/kafka-custom-serializer){.learn-more}

Here you can see how to set a custom (de-)serializer via CAP messaging configuration:

::: code-group

```yaml [application.yaml]
cds:
  messaging:
    services:
      kafka-messaging:
        binding: kafka-shared
        queue:
          config:
            producer:
              "[value.serializer]": com.sap.my.kafka.Serializer
            consumer:
              "[value.deserializer]": com.sap.my.kafka.Deserializer
```

:::

A typical example of user-defined serialization is the use of the Kafka Customer Managed Keys library. The library provides serializers and deserializers that should be used by the application to encrypt and decrypt messages. In the documentation of the library you will find a programmatic example that is not applicable for the CAP Kafka integration. As a workaround, you can integrate the serializers and deserializers via the configuration. Here is an example for the serializer of the producer:

::: code-group

```yaml [application.yaml]
cds:
  messaging:
    services:
      kafka-messaging:
        binding: kafka-shared
        queue:
          config:
            producer:
              "[value.serializer]": "com.sap.cp.bigdata.kafka.serialization.CustomerManagedKeySerializer"
              "[cmk.base_serializer]": "org.apache.kafka.common.serialization.StringSerializer"
              "[cmk.topics_to_subaccounts_mapping]":
                "[out.channel]": "mytenantsubdomain"
```

:::

Similarly, the deserializer can be configured so that the rest of the documentation can be used unchanged.

[Learn more about Encryption for Apache Kafka with Customer Managed Keys](https://github.tools.sap/hcpbd/kafka/tree/3.5/cmk){.learn-more}




# Receiving Events from SAP S/4HANA Cloud Systems

SAP S/4HANA integrates SAP Event Mesh as well as SAP Cloud Application Event Hub for messaging.
Hence, it is relatively easy for CAP-based application to receive events from SAP S/4HANA systems.
This guide provides detailed information on that.

## Find & Import APIs

As documented in the [Service Consumption guide](../using-services#external-service-api), get, and `cds import` the API specification of an SAP S/4HANA service you want to receive events from. For example, for "BusinessPartner" using [SAP Business Accelerator Hub](https://api.sap.com/):

1. Find / open [Business Partner (A2X) API](https://api.sap.com/api/API_BUSINESS_PARTNER).
2. Choose button *"API Specification"*.
3. Download the EDMX spec from this list:
![Showing all available specifications on the SAP Business Accelerator Hub.](./assets/api-specification.png){ }
1. Import it as a CDS model:

```sh
cds import <downloaded edmx file>
```
[Learn more about importing SAP S/4HANA service APIs.](../using-services#external-service-api){.learn-more}

## Find Information About Events

For example, using [SAP Business Accelerator Hub](https://api.sap.com/):

1. [Find the BusinessPartner Events page.](https://api.sap.com/event/SAPS4HANABusinessEvents_BusinessPartnerEvents/overview)
2. Choose _View Event Reference_.
3. Expand the _POST_ request shown.
4. Choose _Schema_ tab.
5. Expand the `data` property.

![Shows the event reference page on the SAP Business Accelerator Hub, highlighting the data property.](assets/business-partner-events.png){.mute-dark}

The expanded part, highlighted in red, tells you all you need to know:

- the event name: `sap.s4.beh.businesspartner.v1.BusinessPartner.Changed.v1`
- the payload's schema → in `{...}`

> All the other information on this page can be ignored, as it's about standard CloudEvents wire format attributes, which are always the same, and handled automatically by CAP behind the scenes for you.

## Add Missing Event Declarations

In contrast to CAP, the asynchronous APIs of SAP S/4HANA are separate from synchronous APIs (that is, OData, REST).
On CAP side, you need to fill this gap.
For example, for an already imported SAP S/4HANA BusinessPartner API:

```cds
// filling in missing events as found on SAP Business Accelerator Hub
using { API_BUSINESS_PARTNER as S4 } from './API_BUSINESS_PARTNER';
extend service S4 with {
  event BusinessPartner.Created @(topic:'sap.s4.beh.businesspartner.v1.BusinessPartner.Created.v1') {
    BusinessPartner : String
  }
  event BusinessPartner.Changed @(topic:'sap.s4.beh.businesspartner.v1.BusinessPartner.Changed.v1') {
    BusinessPartner : String
  }
}
```

::: tip
If using SAP Event Mesh, please see [CloudEvents Standard](./index.md#cloudevents) and [Node - Messaging - CloudEvents Protocol](../../node.js/messaging.md#cloudevents-protocol) to learn about `format: 'cloudevents'`, `publishPrefix` and `subscribePrefix`.
:::

<div id="events-policy-sap" />
<Fragment target="#events-policy-sap">

::: danger
SAP has special governance rules as outlined in [SAP Event Specification](./event-mesh#sap-event-specifications), which require event producers like SAP S/4HANA to prefix all topics with their namespace. Unfortunately, the documentation in SAP Business Accelerator Hub doesn't reflect this rule.
:::

</Fragment>


## Consume Events Agnostically

With agnostic consumption, you can easily receive events from SAP S/4HANA the same way as from CAP services as already explained in this guide, for example like that:

```js
const S4Bupa = await cds.connect.to ('API_BUSINESS_PARTNER')
S4bupa.on ('BusinessPartner.Changed', msg => {...})
```


## Configure CAP

To ease the pain of the afore-mentioned topic rewriting effects, CAP has built-in support for [SAP Event Mesh](./event-mesh) as well as [SAP Cloud Application Event Hub](./event-broker).
Configure the messaging service as follows, to let it automatically create correct technical topics to subscribe to SAP S/4HANA events:

For SAP Event Mesh:

```json
"cds": {
  "requires": {
    "messaging": {
      "kind": "enterprise-messaging-shared",
      "format": "cloudevents",
      // implicitly applied default prefixes
      "publishPrefix": "$namespace/ce/",
      "subscribePrefix": "+/+/+/ce/"
    }
  }
}
```

**Note:** In contrast to the default configuration recommended in the [SAP Event Mesh documentation](https://help.sap.com/docs/SAP_EM/bf82e6b26456494cbdd197057c09979f/5499e2e74e674c69b057072272c80d4f.html), ensure you configure your service instance to allow the pattern `+/+/+/ce/*` for subscriptions. That is, **do not** restrict `subscribeFilter`s to `${namespace}`!

For SAP Cloud Application Event Hub:

```json
"cds": {
  "requires": {
    "messaging": {
      "kind": "event-broker"
    }
  }
}
```

With that, your developers can enter event names as they're found on SAP Business Accelerator Hub. And our CDS extensions, as previously described, simplify to that definition:

```cds
// filling in missing events as found on SAP Business Accelerator Hub
using { API_BUSINESS_PARTNER as S4 } from './API_BUSINESS_PARTNER';
extend service S4 with {
  event BusinessPartner.Created @(topic:'sap.s4.beh.businesspartner.v1.BusinessPartner.Created.v1') {
    BusinessPartner : String
  }
  event BusinessPartner.Changed @(topic:'sap.s4.beh.businesspartner.v1.BusinessPartner.Changed.v1') {
    BusinessPartner : String
  }
}
```


## Configure SAP S/4HANA

As a prerequisite for consuming SAP S/4HANA events, the SAP S/4HANA system itself needs to be configured to send out specific event messages to a specific SAP Event Mesh or SAP Cloud Application Event Hub service instance.
How to create the necessary service instances and use them with a CAP application was already described in the previous sections [SAP Event Mesh](./event-mesh) and [SAP Cloud Application Event Hub](./event-broker), respectively.
A description of how to configure an SAP S/4HANA system to send out specific events is out of scope of this documentation here.
See [this documentation](https://help.sap.com/docs/SAP_S4HANA_CLOUD/0f69f8fb28ac4bf48d2b57b9637e81fa/82e97d5329044732af1efd996bfdc2ab.html) for more details.


## Using Low-Level Messaging

Instead of adding events found on [SAP Business Accelerator Hub](https://api.sap.com/content-type/Events/events/packages) to a CDS service model, it's also possible to use a messaging service directly to consume events from SAP S/4HANA.

You have to bind the `messaging` service directly to the SAP Event Mesh or SAP Cloud Application Event Hub service instance that the SAP S/4HANA system sends the event messages to. Then you can consume the event by registering a handler on the `type` of the event that should be received (`sap.s4.beh.businesspartner.v1.BusinessPartner.Changed.v1` in the example):

```js
const messaging = await cds.connect.to ('messaging')
messaging.on ('sap.s4.beh.businesspartner.v1.BusinessPartner.Changed.v1', (msg) => {
  const { BusinessPartner } = msg.data
  console.log('--> Event received: BusinessPartner changed (ID="'+BusinessPartner+'")')
})
```

All the complex processes, like determining the correct technical topic to subscribe to and adding this subscription to a queue, will be done automatically in the background.

<div id="secondary-file">guides/messaging/s4.fragment.md</div>


# Publishing APIs

How to publish APIs in different formats




<br>
<IndexList :pages='pages' />






# Serving OData APIs

## Feature Overview { #overview}

OData is an OASIS standard, which essentially enhances plain REST with standardized system query options like `$select`, `$expand`, `$filter`, etc. Find a rough overview of the feature coverage in the following table:

| Query Options  | Remarks                                   | Node.js    | Java    |
|----------------|-------------------------------------------|:------------:|:---------:|
| `$search`      | Search in multiple/all text elements<sup>(1)</sup>| <X/> | <X/>   |
| `$value`       | Retrieves single rows/values              | <X/>      | <X/>  |
| `$top`,`$skip` | Requests paginated results                | <X/>      | <X/>   |
| `$filter`      | Like SQL where clause                     | <X/>      | <X/>   |
| `$select`      | Like SQL select clause                    | <X/>      | <X/>   |
| `$orderby`     | Like SQL order by clause                  | <X/>      | <X/>   |
| `$count`       | Gets number of rows for paged results     | <X/>      | <X/>   |
| `$apply`       | For [data aggregation](#data-aggregation) | <X/>      | <X/>   |
| `$expand`      | Deep-read associated entities             | <X/>      | <X/>   |
| [Lambda Operators](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31361024)   | Boolean expressions on a collection       | <X/>      | <X/> <sup>(2)</sup> |
| [Parameters Aliases](https://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#sec_ParameterAliases) | Replace literal value in URL with parameter alias | <X/> | <X/> <sup>(3)</sup>   |

- <sup>(1)</sup> The elements to be searched are specified with the [`@cds.search` annotation](../guides/providing-services#searching-data).
- <sup>(2)</sup> The navigation path identifying the collection can only contain one segment.
- <sup>(3)</sup> Supported for key values and for parameters of functions only.

System query options can also be applied to an [expanded navigation property](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31361039) (nested within `$expand`):

| Query Options  | Remarks                                  | Node.js | Java  |
|----------------|------------------------------------------|:-------:|:-----:|
| `$select`      | Select properties of associated entities |  <X/>   | <X/>  |
| `$filter`      | Filter associated entities               |  <X/>   | <X/>  |
| `$expand`      | Nested expand                            |  <X/>   | <X/>  |
| `$orderby`     | Sort associated entities                 |  <X/>   | <X/>  |
| `$top`,`$skip` | Paginate associated entities             |  <X/>   | <X/>  |
| `$count`       | Count associated entities                |  <Na/>  | <X/>  |
| `$search`      | Search associated entities               |  <Na/>  | <Na/> |


[Learn more in the **Getting Started guide on odata.org**.](https://www.odata.org/getting-started/){.learn-more}
[Learn more in the tutorials **Take a Deep Dive into OData**.](https://developers.sap.com/mission.scp-3-odata.html){.learn-more}

| Data Modification | Remarks                                   | Node.js      |   Java    |
|-------------------|-------------------------------------------|:------------:|:---------:|
| [Create an Entity](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_CreateanEntity) | `POST` request on Entity collection | <X/> | <X/> |
| [Update an Entity](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UpdateanEntity) | `PATCH` or `PUT` request on Entity | <X/> | <X/> |
[ETags](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UseofETagsforAvoidingUpdateConflicts) | For avoiding update conflicts | <X/> | <X/> |
| [Delete an Entity](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_DeleteanEntity) | `DELETE` request on Entity |  <X/> | <X/> |
| [Delta Payloads](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_DeltaPayloads) | For nested entity collections in [deep updates](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UpdateRelatedEntitiesWhenUpdatinganE) | <D/> | <X/> |
| [Patch Collection](#odata-patch-collection) | Update Entity collection with [delta](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_DeltaPayloads) | <Na/> | <X/><sup><Beta /></sup> |


## PATCH Entity Collection with Mass Data (Java) { #odata-patch-collection }

With OData v4, you can [update a collection of entities](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UpdateaCollectionofEntities) with a _single_ PATCH request.
The resource path of the request targets the entity collection and the body of the request is given as a [delta payload](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_DeltaPayloads):

```js
PATCH /CatalogService/Books
Content-Type: application/json

{
  "@context": "#$delta",
  "value": [
    {
      "ID": 17,
      "title": "CAP - what's new in 2023",
      "price": 29.99,
      "author_ID": 999
    },
    {
      "ID": 85,
      "price": 9.99
    },
    {
      "ID": 42,
      "@removed": { "reason": "deleted" }
    }
  ]
}
```

PATCH requests with delta payload are executed using batch delete and [upsert](../java/working-with-cql/query-api#bulk-upsert) statements, and are more efficient than OData [batch requests](https://docs.oasis-open.org/odata/odata/v4.01/csprd02/part1-protocol/odata-v4.01-csprd02-part1-protocol.html#sec_BatchRequests).

Use PATCH on entity collections for uploading mass data using a dedicated service, which is secured using [role-based authorization](../guides/security/authorization#requires). Delta updates must be explicitly enabled by annotating the entity with

```cds
@Capabilities.UpdateRestrictions.DeltaUpdateSupported
```

Limitations:
 * Conflict detection via [ETags](../guides/providing-services#etag) is not supported.
 * [Draft flow](../java/fiori-drafts#bypassing-draft-flow) is bypassed, `IsActiveEntity` has to be `true`.
 * [Draft locks](../java/fiori-drafts#draft-lock) are ignored, active entities are updated or deleted w/o canceling drafts.
 * [Added and deleted links](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_IteminaDeltaPayloadResponse) are not supported.
 * The header `Prefer=representation` is not yet supported.
 * The `continue-on-error` preference is not yet supported.
 * The generic CAP handler support for [upsert](../java/working-with-cql/query-api#upsert) is limited, for example, audit logging is not supported.


## Mapping of CDS Types { #type-mapping}

The table below lists [CDS's built-in types](../cds/types) and their mapping to the OData EDM type system.

| CDS Type       | OData V4                                  |
| -------------- | ---------------------------------------   |
| `UUID`         | _Edm.Guid_ <sup>(1)</sup>                 |
| `Boolean`      | _Edm.Boolean_                             |
| `UInt8  `      | _Edm.Byte_                                |
| `Int16`        | _Edm.Int16_                               |
| `Int32`        | _Edm.Int32_                               |
| `Integer`      | _Edm.Int32_                               |
| `Int64`        | _Edm.Int64_                               |
| `Integer64`    | _Edm.Int64_                               |
| `Decimal`      | _Edm.Decimal_                             |
| `Double`       | _Edm.Double_                              |
| `Date`         | _Edm.Date_                                |
| `Time`         | _Edm.TimeOfDay_                           |
| `DateTime`     | _Edm.DateTimeOffset_                      |
| `Timestamp`    | _Edm.DateTimeOffset_ with Precision="7"   |
| `String`       | _Edm.String_                              |
| `Binary`       | _Edm.Binary_                              |
| `LargeBinary`  | _Edm.Binary_                              |
| `LargeString`  | _Edm.String_                              |
| `Map`          | represented as empty, open complex type   |
| `Vector`       | not supported <sup>(2)</sup>              |

> <sup>(1)</sup> Mapping can be changed with, for example, `@odata.Type='Edm.String'`

> <sup>(2)</sup> Type `cds.Vector` must not appear in an OData service

OData V2 has the following differences:

| CDS Type     | OData V2                                        |
| ------------ | ----------------------------------------------- |
| `Date`       | _Edm.DateTime_ with `sap:display-format="Date"` |
| `Time`       | _Edm.Time_                                      |
| `Map`        | not supported                                   |


### Overriding Type Mapping { #override-type-mapping}

Override standard type mappings using the annotation `@odata.Type` first, and then additionally define `@odata {MaxLength, Precision, Scale, SRID}`.

`@odata.Type` is effective on scalar CDS types only and the value must be a valid OData (EDM) primitive type for the specified protocol version. Unknown types and non-matching facets are silently ignored. No further value constraint checks are applied.

They allow, for example, to produce additional OData EDM types which are not available in the standard type mapping. This is done during
the import of external service APIs, see [Using Services](../guides/using-services#external-service-api).

```cds
entity Foo {
  // ...
  @odata: { Type: 'Edm.GeometryPolygon', SRID: 0 }
  geoCollection : LargeBinary;
};
```

Another prominent use case is the CDS type `UUID`, which maps to `Edm.Guid` by default. However, the OData standard
puts up restrictive rules for _Edm.Guid_ values - for example, only hyphenated strings are allowed - which can conflict with existing data.
Therefore, you can override the default mapping as follows:

```cds
entity Books {
  key ID : UUID @odata.Type:'Edm.String';
  // ...
}
```

::: warning
This annotation affects the client side facing API only. There's no automatic data modification of any kind behind the scenes, like rounding, truncation, conversion, and so on. It's your responsibility to perform all required modifications on the data stream such that the values match their type in the API.
If you are not doing the required conversions, you can "cast" any scalar CDS type into any incompatible EDM type:

```cds
entity Foo {
  // ...
  @odata: {Type: 'Edm.Decimal', Scale: 'floating' }
  str: String(17) default '17.4';
}
```

This translates into the following OData API contract:

```xml
<Property Name="str" Type="Edm.Decimal" Scale="floating" DefaultValue="17.4"/>
```

The client can now rightfully expect that float numbers are transmitted but in reality the values are still strings.
:::


## OData Annotations { #annotations}

The following sections explain how to add OData annotations to CDS models and how they're mapped to EDMX outputs.
Only annotations defined in the vocabularies mentioned in section [Annotation Vocabularies](#vocabularies) are
considered in the translation.

### Terms and Properties

OData defines a strict two-fold key structure composed of `@<Vocabulary>.<Term>` and all annotations are always specified as a _Term_ with either a primitive value, a record value, or collection values. The properties themselves may, in turn, be primitives, records, or collections.

#### Example

```cds
@Common.Label: 'Customer'
@UI.HeaderInfo: {
  TypeName       : 'Customer',
  TypeNamePlural : 'Customers',
  Title          : { Value : name }
}
entity Customers { /* ... */ }
```

This is represented in CSN as follows:

```jsonc
{"definitions":{
  "Customers":{
    "kind": "entity",
    "@Common.Label": "Customer",
    "@UI.HeaderInfo.TypeName": "Customer",
    "@UI.HeaderInfo.TypeNamePlural": "Customers",
    "@UI.HeaderInfo.Title.Value": {"=": "name"},
    /* ... */
  }
}}
```

And would render to EDMX as follows:

```xml
<Annotations Target="MyService.Customers">
  <Annotation Term="Common.Label" String="Customer"/>
  <Annotation Term="UI.HeaderInfo">
    <Record Type="UI.HeaderInfoType">
      <PropertyValue Property="TypeName" String="Customer"/>
      <PropertyValue Property="TypeNamePlural" String="Customers"/>
      <PropertyValue Property="Title">
        <Record Type="UI.DataField">
          <PropertyValue Property="Value" Path="name"/>
        </Record>
      </PropertyValue>
    </Record>
  </Annotation>
</Annotations>
```

::: tip
The value for `@UI.HeaderInfo` is flattened to individual key-value pairs in CSN and 'restructured'
to a record for OData exposure in EDMX.
:::

For each annotated target definition in CSN, the rules for restructuring from CSN sources are:

1. Annotations with a single-identifier key are skipped (as OData annotations always have a `@Vocabulary.Term...` key signature).
2. All individual annotations with the same `@<Vocabulary.Term>` prefix are collected.
3. If there is only one annotation without a suffix, &rarr; that one is a scalar or array value of an OData term.
4. If there are more annotations with suffix key parts &rarr; it's a record value for the OData term.


### Qualified Annotations

OData foresees [qualified annotations](https://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/part3-csdl/odata-v4.0-errata03-os-part3-csdl-complete.html#_Toc453752511), which essentially allow to specify different values for a given property. CDS syntax for annotations was extended to also allow appending OData-style qualifiers after a `#` sign to an annotation key, but always only as the last component of a key in the syntax.

For example, this is supported:

```cds
@Common.Label: 'Customer'
@Common.Label#Legal: 'Client'
@Common.Label#Healthcare: 'Patient'
@Common.ValueList: {
  Label: 'Customers',
  CollectionPath:'Customers'
}
@Common.ValueList#Legal: {
  Label: 'Clients',
  CollectionPath:'Clients'
}
```

and would render as follows in CSN:

```json
{
  "@Common.Label": "Customer",
  "@Common.Label#Legal": "Clients",
  "@Common.Label#Healthcare": "Patients",
  "@Common.ValueList.Label": "Customers",
  "@Common.ValueList.CollectionPath": "Customers",
  "@Common.ValueList#Legal.Label": "Clients",
  "@Common.ValueList#Legal.CollectionPath": "Clients",
}
```

Note that there's no interpretation and no special handling for these qualifiers in CDS. You have to write and apply them in exactly the same way as your chosen OData vocabularies specify them.


### Primitives

> Note: The `@Some` annotation isn't a valid term definition. The following example illustrates the rendering of primitive values.

Primitive annotation values, meaning Strings, Numbers, `true`, and `false` are mapped to corresponding OData annotations as follows:

```cds
@Some.Boolean: true
@Some.Integer: 1
@Some.Number: 3.14
@Some.String: 'foo'
```

```xml
<Annotation Term="Some.Boolean" Bool="true"/>
<Annotation Term="Some.Integer" Int="1"/>
<Annotation Term="Some.Number" Decimal="3.14"/>
<Annotation Term="Some.String" String="foo"/>
```

#### Null Value { #null-value }

A `null` value can be set either as an [annotation expression](#expression-annotations) or as a [dynamic expression](#dynamic-expressions):

```cds
@Some.NullXpr:  (null)                  // annotation expression, short form
@Some.NullFunc: ($Null())               // annotation expression, functional form
@Some.NullDyn:  { $edmJson: { $Null } } // dynamic expression
```
All three expressions result in the following rendering:
```xml
<Annotation Term="Some.Null">
  <Null/>
</Annotation>
```

[Have a look at our *CAP SFLIGHT* sample, showcasing the usage of OData annotations.](https://github.com/SAP-samples/cap-sflight/blob/main/app/travel_processor/capabilities.cds){.learn-more}

### Records

> Note: The `@Some` annotation isn't a valid term definition. The following example illustrates the rendering of record values.

Record-like source structures are mapped to `<Record>` nodes in EDMX, with primitive types translated analogously to the above:

```cds
@Some.Record: {
  Null: (null),
  Boolean: true,
  Integer: 1,
  Number: 3.14,
  String: 'foo'
}
```
```xml
<Annotation Term="Some.Record">
  <Record>
    <PropertyValue Property="Null"><Null/></PropertyValue>
    <PropertyValue Property="Boolean" Bool="true"/>
    <PropertyValue Property="Integer" Int="1"/>
    <PropertyValue Property="Number" Decimal="3.14"/>
    <PropertyValue Property="String" String="foo"/>
  </Record>
</Annotation>
```

If possible, the type of the record in OData is deduced from the information in the [OData Annotation Vocabularies](#vocabularies):
```cds
@Common.ValueList: {
  CollectionPath: 'Customers'
}
```
```xml
<Annotation Term="Common.ValueList">
  <Record Type="Common.ValueListType">
    <PropertyValue Property="CollectionPath" String="Customers"/>
  </Record>
</Annotation>
```

Frequently, the OData record type cannot be determined unambiguously, for example if the type found in the vocabulary is abstract.
Then you need to explicitly specify the type by adding a property named `$Type` in the record. For example:
```cds
@UI.Facets : [{
  $Type  : 'UI.CollectionFacet',
  ID     : 'Customers'
}]
```
```xml
<Annotation Term="UI.Facets">
  <Collection>
    <Record Type="UI.CollectionFacet">
      <PropertyValue Property="ID" String="Travel"/>
    </Record>
  </Collection>
</Annotation>
```

There is one exception for a very prominent case: if the deduced [record type is `UI.DataFieldAbstract`](https://github.com/SAP/odata-vocabularies/blob/main/vocabularies/UI.md), the compiler
by default automatically chooses `UI.DataField`:
```cds
@UI.Identification: [{
  Value: deliveryId
}]
```
```xml
<Annotation Term="UI.Identification">
  <Collection>
    <Record Type="UI.DataField">
      <PropertyValue Property="Value" Path="deliveryId"/>
    </Record>
  </Collection>
</Annotation>
```
To overwrite the default, use an explicit `$Type` like shown previously.

[Have a look at our *CAP SFLIGHT* sample, showcasing the usage of OData annotations.](https://github.com/SAP-samples/cap-sflight/blob/a7b166b7b9b3d2adb1640b4b68c3f8a26c6961c1/app/travel_processor/value-helps.cds){.learn-more}


### Collections

> Note: The `@Some` annotation isn't a valid term definition. The following example illustrates the rendering of collection values.

Arrays are mapped to `<Collection>` nodes in EDMX and if primitives show up as direct elements of the array, these elements are wrapped into individual primitive child nodes of the resulting collection as is. The rules for records and collections are applied recursively:

```cds
@Some.Collection: [
  null, true, 1, 3.14, 'foo',
  { $Type:'UI.DataField', Label:'Whatever', Hidden }
]
```

```xml
<Annotation Term="Some.Collection">
  <Collection>
    <Null/>
    <Bool>true</Bool>
    <Int>1</Int>
    <Decimal>3.14</Decimal>
    <String>foo</String>
    <Record Type="UI.DataField">
      <PropertyValue Property="Label" String="Whatever"/>
      <PropertyValue Property="Hidden" Bool="True"/>
    </Record>
  </Collection>
</Annotation>
```

### References { #references }

> Note: The `@Some` annotation isn't a valid term definition. The following example illustrates the rendering of reference values.

References in CDS annotations are mapped to `Path` properties or nested `<Path>` elements, respectively:

```cds
@Some.Term: My.Reference
@Some.Record: {
  Value: My.Reference
}
@Some.Collection: [
  My.Reference
]
```

```xml
<Annotation Term="Some.Term" Path="My/Reference"/>
<Annotation Term="Some.Record">
  <Record>
    <PropertyValue Property="Value" Path="My/Reference"/>
  </Record>
</Annotation>
<Annotation Term="Some.Collection">
  <Collection>
    <Path>My/Reference</Path>
  </Collection>
</Annotation>
```

As the compiler isn't aware of the semantics of such references, the mapping is very simplistic:
each `.` in a path is replaced by a `/`.
Use [expression-valued annotations](#expression-annotations) for more convenience.

Use a [dynamic expression](#dynamic-expressions) if the generic mapping can't produce the desired `<Path>`:

```cds
@Some.Term: {$edmJson: {$Path: '/com.sap.foo.EntityContainer/EntityName/FieldName'}}
```

```xml
<Annotation Term="Some.Term">
  <Path>/com.sap.foo.EntityContainer/EntityName/FieldName</Path>
</Annotation>
```


### Enumeration Values

Enumeration symbols are mapped to corresponding `EnumMember` properties in OData.

Here are a couple of examples of enumeration values and the annotations that are generated. The first example is for a term in the
[Common vocabulary](https://github.com/SAP/odata-vocabularies/blob/main/vocabularies/Common.md):

```cds
@Common.TextFormat: #html
```

```xml
<Annotation Term="Common.TextFormat" EnumMember="Common.TextFormatType/html"/>
```

The second example is for a (record type) term in the [Communication vocabulary](https://github.com/SAP/odata-vocabularies/blob/main/vocabularies/Communication.md):

```cds
@Communication.Contact: {
  gender: #F
}
```

```xml
<Annotation Term="Communication.Contact">
  <Record Type="Communication.ContactType">
    <PropertyValue Property="gender" EnumMember="Communication.GenderType/F"/>
  </Record>
</Annotation>
```


### Expressions <Beta /> { #expression-annotations }

If the value of an OData annotation is an [expression](../cds/cdl#expressions-as-annotation-values),
the OData backend provides improved handling of references and automatic mapping from
CDS expression syntax to OData expression syntax.

#### Flattening

In contrast to [simple references](#references), the references in expression-like
annotation values are correctly handled during model transformations, like other references in the model.
When the CDS model is flattened for OData, the flattening is consequentially also applied
to these references, and they are translated to the flat model.

::: tip

Although CAP supports structured types and elements, we recommend to use them only
if they bring a real benefit. In general, you should keep your models as flat as possible.

:::

Example:
```cds
type Price {
  @Measures.ISOCurrency: (currency) // [!code highlight]
  amount : Decimal;
  currency : String(3); // [!code highlight]
}

service S {
  entity Product {
    key id : Integer;
    name : String;
    price : Price;
  }
}
```
Structured element `price` of `S.Product` is unfolded to flat elements
`price_amount` and `price_currency`. Accordingly, the reference in the annotation
is rewritten from `currency` to `price_currency`:
```xml
<Schema Namespace="S">
  
  <EntityType Name="Product">
    
    <Property Name="price_amount" Type="Edm.Decimal" Scale="variable"/>
    <Property Name="price_currency" Type="Edm.String" MaxLength="3"/>
  </EntityType>
  <Annotations Target="S.Product/price_amount">
    <Annotation Term="Measures.ISOCurrency" Path="price_currency"/>
  </Annotations>
</Schema>
```


Example:
```cds
service S {
  entity E {
    key id : Integer;
    f : Association to F;
    @Some.Term: (f.struc.y) // [!code highlight]
    val : Integer;
  }
  entity F {
    key id : Integer;
    struc {
      y : Integer;
    }
  }
}
```
The OData backend is aware of the semantics of a path and distinguishes association path steps from structure access.
The CDS path `f.struc.y` is translated to the OData path `f/struc_y`:
```xml
<Schema Namespace="S">
  
  <EntityType Name="E">
    
    <NavigationProperty Name="f" Type="S.F"/>
    <Property Name="val" Type="Edm.Int32"/>
  </EntityType>
  <EntityType Name="F">
    
    <Property Name="struc_y" Type="Edm.Int32"/>
  </EntityType>
  <Annotations Target="S.E/val">
    <Annotation Term="Some.Term" Path="f/struc_y"/> 
  </Annotations>
</Schema>
```

#### Managed Associations

The OData backend translates managed associations into unmanaged ones plus explicit foreign key elements.
During this translation, annotations assigned to the managed association are copied to the respective foreign key elements.

Example:
```cds
service S {
  entity Authors { key ID : Integer; name : String; }
  entity Books   { key ID : Integer; author : Association to Authors; }

  annotate Books:author with @Common.Text: (author.name); // [!code highlight]
}
```

Resulting OData API:
```xml
<Schema Namespace="S">
  
  <EntityType Name="Authors">
    
    <Property Name="name" Type="Edm.String"/>
  </EntityType>
  <EntityType Name="Books">
    
    <NavigationProperty Name="author" Type="S.Authors"/>
    <Property Name="author_ID" Type="Edm.Int32"/> 
  </EntityType>
  <Annotations Target="S.Books/author_ID"> 
    <Annotation Term="Common.Text" Path="author/name"/> 
  </Annotations> 
</Schema>
```

Instead of relying on this copy mechanism, you can also explicitly annotate a foreign key element:
```cds
annotate Books:author.ID with @Common.Text: ($self.author.name);  // here $self is necessary
```

::: warning Restriction concerning the foreign key elements of managed associations

In an expression-valued annotation, it is not possible to reference the foreign key element
of a managed association.

:::

#### Expression Translation

If the expression provided as annotation value is more complex than just a reference,
the OData backend translates CDS expressions to the corresponding OData expression syntax and rejects those expressions that are not applicable in an OData API.

::: info

While the flattening of references described in the section above is applied to all
annotations, the syntactic translation of expressions is only done for annotations
defined in one of the [OData vocabularies](#vocabularies).

:::

The following operators and clauses of CDL are supported:

* `case when ... then ... else ...` and the logical ternary operator ` ? : `
* Logical: `and`,  `or`,  `not`
* Relational: `=`, `<>`,  `!=`,  `<`,  `<=`,  `>`,  `>=`, `in`, `between ... and ...`
* Unary `+` and `-`
* Arithmetic: `+`,  `-`,  `*`,  `/`
* Concat: `||`
* `cast(...)`

Example:
```cds
@Some.Xpr: ( -(a + b) )
```

```xml
<Annotation Term="Some.Xpr">
  <Neg>
    <Add>
      <Path>a</Path>
      <Path>b</Path>
    </Add>
  </Neg>
</Annotation>
```

Such expressions can for example be used
for [some Fiori UI annotations](https://ui5.sap.com/#/topic/0e7b890677c240b8ba65f8e8d417c048):

```cds
service S {
  @UI.LineItem: [ // ...
  {
    Value: (status), // [!code highlight]
    Criticality: ( status = 'O' ? 2 : ( status = 'A' ? 3 : 0 ) ) // [!code highlight]
  }]
  entity Order {
    key id : Integer;
    // ...
    status : String;
  }
}
```

If you need to access an element of an entity in an annotation for a bound action or function,
use a path that navigates via an explicitly defined [binding parameter](../cds/cdl#bound-actions).

Example:
```cds
service S {
  entity Order {
    key id : Integer;
    // ...
    status : String;
  } actions {
    @Core.OperationAvailable: ( :in.status <> 'A' ) // [!code highlight]
    action accept (in: $self)
  }
}
```

In addition, the following functions are supported:

* `$Null()` representing the `null` value [`Null`]([annotation expression](#null-value)).
* `Div(...)` (or `$Div(...)`) and `Mod(...)` (or `$Mod(...)`) for integer division and modulo
* [`Has(...)`](https://docs.oasis-open.org/odata/odata/v4.02/csd01/part2-url-conventions/odata-v4.02-csd01-part2-url-conventions.html#Has) (or `$Has(...)`)
* the functions listed in sections
  [5.1.1.5](https://docs.oasis-open.org/odata/odata/v4.02/csd01/part2-url-conventions/odata-v4.02-csd01-part2-url-conventions.html#StringandCollectionFunctions)
  through [5.1.1.11](https://docs.oasis-open.org/odata/odata/v4.02/csd01/part2-url-conventions/odata-v4.02-csd01-part2-url-conventions.html#GeoFunctions)
  of [OData URL conventions](https://docs.oasis-open.org/odata/odata/v4.02/odata-v4.02-part2-url-conventions.html)
  + See examples below for the syntax for `cast` and `isof` (section [5.1.1.10](https://docs.oasis-open.org/odata/odata/v4.02/csd01/part2-url-conventions/odata-v4.02-csd01-part2-url-conventions.html#TypeFunctions))
  + The names of the geo functions (section [5.1.1.11](https://docs.oasis-open.org/odata/odata/v4.02/csd01/part2-url-conventions/odata-v4.02-csd01-part2-url-conventions.html#GeoFunctions))
    need to be escaped like <br> `![geo.distance]`
* [`fillUriTemplate(...)`](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_FunctionodatafillUriTemplate)
  and [`uriEncode(...)`](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_FunctionodatauriEncode)
* `Type(...)` (or `$Type(...)`) is to be used to specify a type name with their corresponding type facets such as `MaxLength(...)`, `Precision(...)`, `Scale(...)` and `SRID(...)`
   (or `$MaxLength(...)`, `$Precision(...)`, `$Scale(...)`, `$SRID(...)`)

Example:
```cds
@Some.Func1: ( concat(a, b, c) )
@Some.Func2: ( round(aNumber) )
@Some.Func3: ( $Cast(aValue, $Type('Edm.Decimal', $Precision(38), $Scale(19)) ) )
@Some.Func4: ( $IsOf(aValue, $Type('Edm.Decimal', $Precision(38), $Scale(19)) ) )
@Some.Func5: ( ![geo.distance](a, b) )
@Some.Func6: ( fillUriTemplate(a, b) )
```

If a functional expression starts with a `$`, all inner function must also be `$` functions and vice versa.
Instead of `[$]Type(...)` an EDM primitive type name can be directly used as function name like in CDL.

It is worth to mention that there are two alternatives for the cast function, one in the EDM and one in the CDS domain:


```cds
@Some.ODataStyleCast:  ( Cast(aValue, Decimal(38, 'variable') ) )  // => Edm.Decimal
@Some.ODataStyleCast2: ( Cast(aValue, PrimitiveType()) )           // => Edm.PrimitiveType
@Some.SQLStyleCast:    ( cast(aValue as Decimal(38, variable)) )   // => cds.Decimal
@Some.SQLStyleCast2:   ( cast(aValue as String) )                  // => cds.String without type facets
```

Both `cast` functions look similar, but there are some differences:

The OData style `Cast` _function_ starts with a capital letter and the SQL `cast` _operator_ uses the keyword `as`
to delimit the element reference from the type specifier. The OData `Cast` requires an EDM primitive type to be used
either as `[$]Type()` or as direct type function whereas the SQL `cast` requires a scalar CDS type as argument which is then
converted into the corresponding EDM primitive type.

::: info

CAP only provides a syntactic translation. It is up to each client
whether an expression value is supported for a particular annotation.
See for example [SAP Fiori Elements' list of supported annotations](https://ui5.sap.com/#/topic/0e7b890677c240b8ba65f8e8d417c048).

:::

Use a [dynamic expression](#dynamic-expressions) if the desired EDMX expression cannot be
obtained via the automatic translation of a CDS expression.


### Annotating Annotations { #annotating-annotations}

OData can annotate annotations. This often occurs in combination with enums like `UI.Importance` and `UI.TextArrangement`.
CDS has no corresponding language feature. For OData annotations, nesting can be achieved in the following way:
* To annotate a Record, add an additional element to the CDS source structure. The name of this element is the full name of the annotation, including the `@`. See `@UI.Importance` in the following example.
* To annotate a single value or a Collection, add a parallel annotation that has the nested annotation name appended to the outer annotation name. See `@UI.Criticality` and `@UI.TextArrangement` in the following example.

```cds
@UI.LineItem: [
  {Value: ApplicationName, @UI.Importance: #High}, // [!code highlight]
  {Value: Description},
  {Value: SourceName},
  {Value: ChangedBy},
  {Value: ChangedAt}
]
@UI.LineItem.@UI.Criticality: #Positive // [!code highlight]


@Common.Text: Text
@Common.Text.@UI.TextArrangement: #TextOnly // [!code highlight]
```

Alternatively, annotating a single value or a Collection by turning them into a structure with an artificial property `$value` is still possible, but deprecated:

```cds
@UI.LineItem: {
  $value:[ /* ... */ ], @UI.Criticality: #Positive
}

@Common.Text: {
  $value: Text, @UI.TextArrangement: #TextOnly
}
```

As `TextArrangement` is common, there's a shortcut for this specific situation:

```cds
...
@Common: {
  Text: Text, TextArrangement: #TextOnly
}
```

In any case, the resulting EDMX is:

```xml
<Annotation Term="UI.LineItem">
  <Collection>
    <Record Type="UI.DataField">
      <PropertyValue Property="Value" Path="ApplicationName"/>
      <Annotation Term="UI.Importance" EnumMember="UI.ImportanceType/High"/> 
    </Record>
    ...
  </Collection>
  <Annotation Term="UI.Criticality" EnumMember="UI.CriticalityType/Positive"/> 
</Annotation>
<Annotation Term="Common.Text" Path="Text">
  <Annotation Term="UI.TextArrangement" EnumMember="UI.TextArrangementType/TextOnly"/> 
</Annotation>
```

### Dynamic Expressions { #dynamic-expressions}

OData supports dynamic expressions in annotations.
For OData annotations you can use the "edm-json inline mechanism" by providing a [dynamic expression](https://docs.oasis-open.org/odata/odata-csdl-json/v4.01/odata-csdl-json-v4.01.html#_Toc38466479) as defined
in the [JSON representation of the OData Common Schema Language](https://docs.oasis-open.org/odata/odata-csdl-json/v4.01/odata-csdl-json-v4.01.html) enclosed in `{ $edmJson: { ... }}`.

Note that here the CDS syntax for string literals with single quotes (`'foo'`) applies,
and that paths are not automatically recognized but need to be written as `{$Path: 'fieldName'}`.
The CDS compiler translates the expression into the corresponding
[XML representation](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#_Toc38530421).

For example, the CDS annotation:

```cds
@UI.Hidden: {$edmJson: {$Ne: [{$Path: 'status'}, 'visible']}}
```

is translated to:

```xml
<Annotation Term="UI.Hidden">
  <Ne>
    <Path>status</Path>
    <String>visible</String>
  </Ne>
</Annotation>
```

One of the main use cases for such dynamic expressions is SAP Fiori,
but note that SAP Fiori supports dynamic expressions only for
[specific annotations](https://ui5.sap.com/#/topic/0e7b890677c240b8ba65f8e8d417c048).

::: tip Use expression-like annotation values

Instead of writing annotations directly with EDM JSON syntax,
try using [expression-like annotation values](#expression-annotations), which
are automatically translated. For the example above you would
simply write `@UI.Hidden: (status <> 'visible')`.

:::


### `sap:` Annotations

In general, back ends and SAP Fiori UIs understand or even expect OData V4 annotations. You should use those rather than the OData V2 SAP extensions.

<div id="translate-odata" />
<Fragment target="#translate-odata">

For translating the OData V2 SAP extensions into corresponding OData V4 annotations, see
[Annotations OData V2 > OData V4 ](https://wiki.one.int.sap/wiki/display/odata/Annotations+OData+v2+-%3E+OData+v4).

</Fragment>

If necessary, CDS automatically translates OData V4 annotations to
OData V2 SAP extensions when invoked with `v2` as the OData version.
This means that you shouldn't have to deal with this at all.

Nevertheless, in case you need to do so, you can add `sap:...` attribute-style annotations as follows:

```cds
  @sap.applicable.path: 'to_eventStatus/EditEnabled'
  action EditEvent(...) returns SomeType;
```

Which would render to OData EDMX as follows:

```xml
  <FunctionImport Name="EditEvent" ...
    sap:applicable-path="to_eventStatus/EditEnabled">
    ...
  </FunctionImport>
```

The rules are:

* Only strings are supported as values.
* The first dot in `@sap.` is replaced by a colon `:`.
* Subsequent dots are replaced by dashes.


### Differences to ABAP

In contrast to ABAP CDS, we apply a **generic, isomorphic approach** where names and positions of annotations are exactly as specified in the [OData Vocabularies](#vocabularies). This has the following advantages:

* Single source of truth — users only need to consult the official OData specs
* Speed — we don't need complex case-by-case mapping logic
* No bottlenecks — we always support the full set of OData annotations
* Bidirectional mapping — we can translate CDS to EDMX and vice versa

Last but not least, it also saves us lots of effort as we don't have to write derivatives of all the OData vocabulary specs.


## Annotation Vocabularies { #vocabularies}

When translating a CDS model to an OData API, by default only those annotations
are considered that are part of the standard OASIS or SAP vocabularies listed below.
You can add further vocabularies to the translation process [using configuration.](#additional-vocabularies)

### [OASIS Vocabularies](https://github.com/oasis-tcs/odata-vocabularies#further-description-of-this-repository) { target="_blank"}

| Vocabulary                                                                                                                              | Description                                  |
|-----------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------|
| [@Aggregation](https://github.com/oasis-tcs/odata-vocabularies/tree/main/vocabularies/Org.OData.Aggregation.V1.md){target="_blank"}     | for describing aggregatable data             |
| [@Authorization](https://github.com/oasis-tcs/odata-vocabularies/tree/main/vocabularies/Org.OData.Authorization.V1.md){target="_blank"} | for authorization requirements               |
| [@Capabilities](https://github.com/oasis-tcs/odata-vocabularies/tree/main/vocabularies/Org.OData.Capabilities.V1.md){target="_blank"}   | for restricting capabilities of a service    |
| [@Core](https://github.com/oasis-tcs/odata-vocabularies/tree/main/vocabularies/Org.OData.Core.V1.md){target="_blank"}                   | for general purpose annotations              |
| [@JSON](https://github.com/oasis-tcs/odata-vocabularies/tree/main/vocabularies/Org.OData.JSON.V1.md){target="_blank"}                   | for JSON properties                          |
| [@Measures](https://github.com/oasis-tcs/odata-vocabularies/tree/main/vocabularies/Org.OData.Measures.V1.md){target="_blank"}           | for monetary amounts and measured quantities |
| [@Repeatability](https://github.com/oasis-tcs/odata-vocabularies/tree/main/vocabularies/Org.OData.Repeatability.V1.md){target="_blank"} | for repeatable requests                      |
| [@Temporal](https://github.com/oasis-tcs/odata-vocabularies/tree/main/vocabularies/Org.OData.Temporal.V1.md){target="_blank"}           | for temporal annotations                     |
| [@Validation](https://github.com/oasis-tcs/odata-vocabularies/tree/main/vocabularies/Org.OData.Validation.V1.md){target="_blank"}       | for adding validation rules                  |

### [SAP Vocabularies](https://github.com/SAP/odata-vocabularies#readme){target="_blank"}

| Vocabulary                                                                                                               | Description                                       |
|--------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------|
| [@Analytics](https://github.com/SAP/odata-vocabularies/tree/main/vocabularies/Analytics.md){target="_blank"}             | for annotating analytical resources               |
| [@CodeList](https://github.com/SAP/odata-vocabularies/tree/main/vocabularies/CodeList.md){target="_blank"}               | for code lists                                    |
| [@Common](https://github.com/SAP/odata-vocabularies/tree/main/vocabularies/Common.md){target="_blank"}                   | for all SAP vocabularies                          |
| [@Communication](https://github.com/SAP/odata-vocabularies/tree/main/vocabularies/Communication.md){target="_blank"}     | for annotating communication-relevant information |
| [@DataIntegration](https://github.com/SAP/odata-vocabularies/tree/main/vocabularies/DataIntegration.md){target="_blank"} | for data integration                              |
| [@PDF](https://github.com/SAP/odata-vocabularies/tree/main/vocabularies/PDF.md){target="_blank"}                         | for PDF                                           |
| [@PersonalData](https://github.com/SAP/odata-vocabularies/tree/main/vocabularies/PersonalData.md){target="_blank"}       | for annotating personal data                      |
| [@Session](https://github.com/SAP/odata-vocabularies/tree/main/vocabularies/Session.md){target="_blank"}                 | for sticky sessions for data modification         |
| [@UI](https://github.com/SAP/odata-vocabularies/tree/main/vocabularies/UI.md){target="_blank"}                           | for presenting data in user interfaces            |

[Learn more about annotations in CDS and OData and how they work together](https://github.com/SAP-samples/odata-basics-handsonsapdev/blob/annotations/bookshop/README.md){.learn-more}


### Additional Vocabularies

Assuming you have a vocabulary `com.MyCompany.vocabularies.MyVocabulary.v1`, you can set the configuration option <Config keyOnly filesOnly>cds.cdsc.odataVocabularies.MyVocabulary: {"Alias": "MyVocabulary", "Namespace": "com.sap.vocabularies.MyVocabulary.v1", "Uri": "\<link to vocabulary document\>"}</Config>.

With this configuration, all annotations prefixed with `MyVocabulary` are considered in the translation.

```cds
service S {
  @MyVocabulary.MyAnno: 'My new Annotation'
  entity E { /*...*/ };
};
```

The annotation is added to the OData API, as well as the mandatory reference to the vocabulary definition:

```xml
<edmx:Reference Uri="link to vocabulary document">
  <edmx:Include Alias="MyVocabulary" Namespace="com.MyCompany.vocabularies.MyVocabulary.v1"/>
</edmx:Reference>
...
<Annotations Target="S.E">
  <Annotation Term="MyVocabulary.MyAnno" String="My new Annotation"/>
</Annotations>
```

The compiler evaluates neither annotation values nor the URI.
It is your responsibility to make the URI accessible if required.
Unlike for the standard vocabularies listed above, the compiler has no access to the content of
the vocabulary, so the values are translated completely generically.


## Data Aggregation

Data aggregation in OData V4 is leveraged by the `$apply` system query option, which defines a pipeline of transformations that is applied to the _input set_ specified by the URI. On the _result set_ of the pipeline, the standard system query options come into effect.

<div id="data-aggregation-v2" />
<Fragment target="#data-aggregation-v2">

For data aggregation in OData v2, see [Analytics in OData V2](../advanced/analytics#aggregation).

</Fragment>

### Example

```http
GET /Orders(10)/books?
    $apply=filter(year eq 2000)/
           groupby((author/name),aggregate(price with average as avg))/
    orderby(title)/
    top(3)
```

This request operates on the books of the order with ID 10. First it filters out the books from the year 2000 to an intermediate result set. The intermediate result set is then grouped by author name and the price is averaged. Finally, the result set is sorted by title and only the top 3 entries are retained.

::: warning
If the `groupby` transformation only includes a subset of the entity keys, the result order might be unstable.
:::

### Transformations

| Transformation               | Description                                 |      Node.js       | Java  |
|------------------------------|---------------------------------------------|:------------------:|:-----:|
| `filter`                     | filter by filter expression                 |        <X/>        | <X/>  |
| `search`                     | filter by search term or expression         |       <Na/>        | <X/>  |
| `groupby`                    | group by dimensions and aggregates values   |        <X/>        | <X/>  |
| `aggregate`                  | aggregate values                            |        <X/>        | <X/>  |
| `compute`                    | add computed properties to the result set   |       <Na/>        | <X/>  |
| `expand`                     | expand navigation properties                |       <Na/>        | <Na/> |
| `concat`                     | append additional aggregation to the result |        <X/>        | <X/>  |
| `skip` / `top`               | paginate                                    |        <X/>        | <X/>  |
| `orderby`                    | sort the input set                          |        <X/>        | <X/>  |
| `topcount`/`bottomcount`     | retain highest/lowest _n_ values            |       <Na/>        | <Na/> |
| `toppercent`/`bottompercent` | retain highest/lowest _p_% values           |       <Na/>        | <Na/> |
| `topsum`/`bottomsum`         | retain _n_ values limited by sum            |       <Na/>        | <Na/> |


#### `concat`

The [`concat` transformation](https://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016581) applies additional transformation sequences to the input set and concatenates the result:

```http
GET /Books?$apply=
    filter(author/name eq 'Bram Stroker')/
    concat(
        aggregate($count as totalCount),
        groupby((year), aggregate($count as countPerYear)))
```

This request filters all books, keeping only books by Bram Stroker. From these books, `concat` calculates (1) the total count of books *and* (2) the count of books per year. The result is heterogeneous.

The `concat` transformation must be the last of the apply pipeline. If `concat` is used, then `$apply` can't be used in combination with other system query options.


#### `skip`, `top`, and `orderby`

Beyond the standard transformations specified by OData, CDS Java supports the transformations `skip`, `top`, and `orderby` that allow you to sort and paginate an input set:

```http
GET /Order(10)/books?
    $apply=orderby(price desc)/
           top(500)/
           groupby((author/name),aggregate(price with max as maxPrice))
```

This query groups the 500 most expensive books by author name and determines the price of the most expensive book per author.


### Hierarchical Transformations

Provide support for hierarchy attribute calculation and navigation, and allow the execution of typical hierarchy operations directly on relational data.

| Transformation                                | Description                                                      | Node.js |        Java        |
|-----------------------------------------------|------------------------------------------------------------------|:-------:|:------------------:|
| `com.sap.vocabularies.Hierarchy.v1.TopLevels` | generate a hierarchy based on recursive parent-child source data |  <X/><sup>(1)</sup>  | <X/><sup>(1)</sup> |
| `ancestors`                                   | return all ancestors of a set of start nodes in a hierarchy      |  <X/><sup>(1)</sup>  | <X/><sup>(1)</sup> |
| `descendants`                                 | return all descendants of a set of start nodes in a hierarchy    |  <X/><sup>(1)</sup>  | <X/><sup>(1)</sup> |

- <sup>(1)</sup> Beta feature, API may change

Generic implementation is supported on the following databases:

|   | SAP HANA | H2 | PostgreSQL | SQLite |
|---|---|---|---|---|
| CAP Java | ✓ | ✓ | | |
| CAP Node.js | ✓ |  |✓ |✓ |

:::info
The source elements of the entity defining the recursive parent-child relation are identified by a naming convention or aliases `node_id` and `parent_id`.
For more refer to [SAP HANA Hierarchy Developer Guide](https://help.sap.com/docs/SAP_HANA_PLATFORM/4f9859d273254e04af6ab3e9ea3af286/f29c70e984254a6f8df76ad84e78f123.html?locale=en-US&version=2.0.05)
:::

#### `com.sap.vocabularies.Hierarchy.v1.TopLevels`

The [`TopLevels` transformation](https://github.com/SAP/odata-vocabularies/blob/main/vocabularies/Hierarchy.xml) produces the hierarchical result based on recursive parent-child relationship:

```http
GET /SalesOrganizations?$apply=
     com.sap.vocabularies.Hierarchy.v1.TopLevels(..., NodeProperty='ID', Levels=2)
```
#### `ancestors` and `descendants`

The [`ancestors` and `descendants` transformations](https://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs03/odata-data-aggregation-ext-v4.0-cs03.html#Transformationsancestorsanddescendants) compute the subset of a given recursive hierarchy, which contains all nodes that are ancestors or descendants of a start nodes set. Its output is the ancestors or descendants set correspondingly.

```http
GET SalesOrganizations?$apply=
    descendants(..., ID, filter(ID eq 'US'), keep start)
   /ancestors(..., ID, filter(contains(Name, 'New York')), keep start)
```


### Aggregation Methods

| Aggregation Method | Description                      | Node.js | Java  |
|--------------------|----------------------------------|:-------:|:-----:|
| `min`              | smallest value                   |  <X/>   | <X/>  |
| `max`              | largest                          |  <X/>   | <X/>  |
| `sum`              | sum of values                    |  <X/>   | <X/>  |
| `average`          | average of values                |  <X/>   | <X/>  |
| `countdistinct`    | count of distinct values         |  <X/>   | <X/>  |
| custom method      | custom aggregation method        |  <Na/>  | <Na/> |
| `$count`           | number of instances in input set |  <X/>   | <X/>  |

### Custom Aggregates

Instead of explicitly using an expression with an aggregation method in the `aggregate` transformation, the client can use a _custom aggregate_. A custom aggregate can be considered as a virtual property that aggregates the input set. It's calculated on the server side. The client doesn't know _How_ the custom aggregate is calculated.

They can only be used for the special case when a default aggregation method can be specified declaratively on the server side for a measure.

A custom aggregate is declared in the CDS model as follows:

* The measure must be annotated with an `@Aggregation.default` annotation that specifies the aggregation method.
* The CDS entity should be annotated with an `@Aggregation.CustomAggregate` annotation to expose the custom aggregate to the client.

```cds
@Aggregation.CustomAggregate#stock : 'Edm.Decimal'
entity Books as projection on bookshop.Books {
  ID,
  title,

  @Aggregation.default: #SUM
  stock
};
```

With this definition, it's now possible to use the custom aggregate `stock` in an `aggregate` transformation:

```http
GET /Books?$apply=aggregate(stock) HTTP/1.1
```

which is equivalent to:

```http
GET /Books?$apply=aggregate(stock with sum as stock) HTTP/1.1
```

#### Currencies and Units of Measure

If a property represents a monetary amount, it may have a related property that indicates the amount's *currency code*. Analogously, a property representing a measured quantity can be related to a *unit of measure*. To indicate that a property is a currency code or a unit of measure it can be annotated with the [Semantics Annotations](https://help.sap.com/docs/SAP_NETWEAVER_750/cc0c305d2fab47bd808adcad3ca7ee9d/fbcd3a59a94148f6adad80b9c97304ff.html) `@Semantics.currencyCode` or `@Semantics.unitOfMeasure`.
The aggregation method (typically, sum) is specified with the `@Aggregation.default` annotation.

```cds
@Aggregation.CustomAggregate#amount   : 'Edm.Decimal'
@Aggregation.CustomAggregate#currency : 'Edm.String'
entity Sales {
  key id        : GUID;
      productId : GUID;
      @Semantics.amount.currencyCode: 'currency'
      @Aggregation.default: #SUM
      amount    : Decimal(10,2);
      @Semantics.currencyCode
      currency  : String(3);
}
```

The CAP Java SDK exposes all properties annotated with `@Semantics.currencyCode` or `@Semantics.unitOfMeasure` as a [custom aggregate](../advanced/odata#custom-aggregates) with the property's name that returns:

* The property's value if it's unique within a group of dimensions
* `null` otherwise

A custom aggregate for a currency code or unit of measure should also be exposed by the `@Aggregation.CustomAggregate` annotation. Moreover, a property for a monetary amount or a measured quantity should be annotated with `@Semantics.amount.currencyCode` or `@Semantics.quantity.unitOfMeasure` to reference the corresponding property that holds the amount's currency code or the quantity's unit of measure, respectively.

### Other Features

| Feature                                 | Node.js | Java  |
|-----------------------------------------|:-------:|:-----:|
| use path expressions in transformations |  <X/>   | <X/>  |
| chain transformations                   |  <X/>   | <X/>  |
| chain transformations within group by   |  <Na/>  | <Na/> |
| `groupby` with `rollup`/`$all`          |  <Na/>  | <Na/> |
| `$expand` result set of `$apply`        |  <Na/>  | <Na/> |
| `$filter`/`$search` result set          |  <X/>   | <X/>  |
| sort result set with `$orderby`         |  <X/>   | <X/>  |
| paginate result set with `$top`/`$skip` |  <X/>   | <X/>  |


## Open Types

An entity type or a complex type may be declared as _open_, allowing clients to add properties dynamically to instances of the type by specifying uniquely named property values in the payload used to insert or update an instance of the type. To indicate that the entity or complex type is open, the corresponding type must be annotated with `@open`:


```cds
service CatalogService {
  @open // [!code focus]
  entity Book { // [!code focus]
    key id : Integer; // [!code focus]
  } // [!code focus]
}
```

The cds build for OData v4 will render the entity type `Book` in `edmx` with the [`OpenType` attribute](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_OpenEntityType) set to `true`:

```xml
<EntityType Name="Book" OpenType="true"> // [!code focus]
  <Key>
    <PropertyRef Name="id"/>
  </Key>
  <Property Name="id" Type="Edm.Integer" Nullable="false"/>
</EntityType>
```

The entity `Book` is open, allowing the client to enrich the entity with additional properties.

Example 1:

```json
{"id": 1, "title": "Tow Sawyer"}
```
Example 2:

```json
{"title": "Tow Sawyer",
 "author": { "name": "Mark Twain", "age": 74 } }
```

Open types can also be referenced in non-open types and entities. This, however, doesn't make the referencing entity or type open.

```cds
service CatalogService {
  type Order {
    guid: Integer;
    book: Book;
  }

  @open // [!code focus]
  type Book {} // [!code focus]
}
```
The following payload for `Order` is allowed:

`{"guid": 1, "book": {"id": 2, "title": "Tow Sawyer"}}`

Note that type `Order` itself is not open thus doesn't allow dynamic properties, in contrast to type `Book`.

::: warning
Dynamic properties are not persisted in the underlying data source automatically and must be handled completely by custom code.
:::

### Java Type Mapping

#### Simple Types

The simple values of deserialized JSON payload can be of type: `String`, `Boolean`, `Number` or simply an `Object` for `null` values.

|JSON                     | Java Type of the `value`       |
|-------------------------|--------------------------------|
|`{"value": "Tom Sawyer"}`| `java.lang.String`             |
|`{"value": true}`        | `java.lang.Boolean`            |
|`{"value": 42}`          | `java.lang.Number` (Integer)   |
|`{"value": 36.6}`        | `java.lang.Number` (BigDecimal)|
|`{"value": null}`        | `java.lang.Object`             |

#### Structured Types

The complex and structured types are deserialized to `java.util.Map`, whereas collections are deserialized to `java.util.List`.

|JSON                                                               | Java Type of the `value`             |
|-------------------------------------------------------------------|--------------------------------------|
|`{"value": {"name": "Mark Twain"}}`                                | `java.util.Map<String, Object>`      |
|`{"value":[{"name": "Mark Twain"}, {"name": "Charlotte Bronte"}}]}`| `java.util.List<Map<String, Object>>`|



## Singletons

A singleton is a special one-element entity introduced in OData V4. It can be addressed directly by its name from the service root without specifying the entity's keys.

Annotate an entity with `@odata.singleton` or `@odata.singleton.nullable`, to use it as a singleton within a service, for example:

```cds
service Sue {
  @odata.singleton entity MySingleton {
    key id : String; // can be omitted in OData v4.01
    prop : String;
    assoc : Association to myEntity;
  }
}
```

It can also be defined as an ordered `SELECT` from another entity:

```cds
service Sue {
  @odata.singleton entity OldestEmployee as
    select from Employees order by birthyear;
}
```

### Requesting Singletons

As mentioned above, singletons are accessed without specifying keys in the request URL. They can contain navigation properties, and other entities can include singletons as their navigation properties as well. The `$expand` query option is also supported.

```http
GET …/MySingleton
GET …/MySingleton/prop
GET …/MySingleton/assoc
GET …/MySingleton?$expand=assoc
```

### Updating Singletons

The following request updates a prop property of a singleton MySingleton:

```http
PATCH/PUT …/MySingleton
{prop: “New value”}
```

### Deleting Singletons

A `DELETE` request to a singleton is possible only if a singleton is annotated with `@odata.singleton.nullable`. An attempt to delete a singleton annotated with `@odata.singleton` will result in an error.

### Creating Singletons

Since singletons  represent a one-element entity, a `POST` request is not supported.

<div id ="api-flavors" />
<Fragment target="#api-flavors">

## API Flavors <Beta />

CAP supports different flavors of OData APIs with respect to how associations, compositions, and structured elements are rendered to respective OData EDMX `$metadata` documents. The sections below describe the respective config options, which you can set in the _package.json_ or _.cdsrc.json_ files as documented in the [Node.js Configuration guide](../node.js/cds-env).


### Sample Model

In the following sections we use this sample model:

```cds
aspect cuid { key ID : UUID }
service Sue {
  entity Foo : cuid {
    struct : { x:String; y:Integer };
    bar : Association to Bar;
  }
  entity Bar : cuid {}
}
```


### 'Flattened' API Flavor { #flat-odata}

By default generated OData APIs are 'flattened', which renders the [sample model](#sample-model) to this EDMX output:

```xml
<EntityType Name="Foo">
  <Key>
    <PropertyRef Name="ID"/>
  </Key>
  <Property Name="ID" Type="Edm.Guid" Nullable="false"/>
  
  <Property Name="struct_x" Type="Edm.String"/>
  <Property Name="struct_y" Type="Edm.Int32"/>
  
  <Property Name="bar_ID" Type="Edm.Guid"/>
  
  <NavigationProperty Name="bar" Type="Sue.Bar">
    <ReferentialConstraint Property="bar_ID" ReferencedProperty="ID"/>
  </NavigationProperty>
</EntityType>
...
```


### `cds.odata.version` = _v2_ | _v4_

The `cds.odata.version` configuration option specifies the OData protocol version (see also [OData V2 support](#v2-support)).


### `cds.odata.structs` = _true_ | _false_ { #cds-odata-structs}

Set `cds.odata.structs = true` to have struct elements in CDS models mapped to `ComplexTypes` in OData EDMX output as follows:

```xml
<EntityType Name="Foo">
  <Key>
    <PropertyRef Name="ID"/>
  </Key>
  <Property Name="ID" Type="Edm.Guid" Nullable="false"/>
  
  <Property Name="struct" Type="Sue.Foo_struct"/>
  ...
</EntityType>
...


<ComplexType Name="Foo_struct">
  <Property Name="x" Type="Edm.String"/>
  <Property Name="y" Type="Edm.Int32"/>
</ComplexType>
```


### `cds.odata.refs` = _true_ | _false_ <Beta />

Set `cds.odata.refs = true`, to switch off the generation of foreign key elements for managed to-one associations. For example, in the EDMX output this looks like this:

```xml
<EntityType Name="Foo"> ...
  
  <NavigationProperty Name="bar" Type="Sue.Bar"/>
</EntityType>
```

At runtime, a `GET /Foo` would result in an auto-expanded navigation property, selecting the target's primary keys:

```js
GET /Foo -> [{ ..., bar:{ID:4711} }]
```

> This is the equivalent of a `GET /Foo?$expand=bar($select=ID)`.



### `cds.odata.proxies` = _true_ | _false_ <Beta />

Set `cds.odata.proxies = true` to switch on the generation of proxy entity types to serve as targets for `NavigationProperties` to external entities.

For example, if we extend our sample model with an association to an entity, which isn't exposed itself by the service as follows:

```cds
service Sue { ...
  entity Foo : cuid { ...
    ext : Association to External;
  }
}
entity External : cuid {}
```

This renders as `NavigationProperties` without foreign keys like this:

```xml
<EntityType Name="Foo"> ...
  
  <NavigationProperty Name="ext" Type="Sue.External_proxy"/>
</EntityType>
```

referring to proxy entities covering the target entity's primary key signature only:

```xml

<EntityType Name="External_proxy">
  <Key> <PropertyRef Name="ID"/> </Key>
  <Property Name="ID" Type="Edm.Guid" Nullable="false"/>
</EntityType>
```


### `cds.odata.containment` = _true_ | _false_

Set `cds.odata.containment = true` to map CDS Compositions to [effective OData Containment Navigation Properties](https://www.odata.org/getting-started/advanced-tutorial/#containment).

For example, given a CDS model like this:

```cds
service Sue {
  entity Orders {
    key ID : UUID;
    Items : Composition of many {
      key pos  : Integer;
      product  : UUID;
      quantity : Integer;
    }
  }
}
```

Without containment, this would have to use auto-exposed entities as follows:

```xml
<EntityContainer Name="EntityContainer">
  <EntitySet Name="Orders" EntityType="Sue.Orders">
    <NavigationPropertyBinding Path="Items" Target="Orders_Items"/>
  </EntitySet>
  <EntitySet Name="Orders_Items" EntityType="Sue.Orders_Items">
    <NavigationPropertyBinding Path="up_" Target="Orders"/>
  </EntitySet>
</EntityContainer>

<EntityType Name="Orders"> ...
  <NavigationProperty Name="Items" Type="Collection(Sue.Orders_Items)" Partner="up_">
    <OnDelete Action="Cascade"/>
  </NavigationProperty>
</EntityType>

<EntityType Name="Orders_Items"> ... </EntityType>
```

With containment switched on, only `Orders` is exposed as an entity set:

```xml
<EntityContainer Name="EntityContainer">
  <EntitySet Name="Orders" EntityType="Sue.Orders"/>
</EntityContainer>

<EntityType Name="Orders"> ...
  <NavigationProperty Name="Items" Type="Collection(Sue.Orders_Items)" Partner="up_"
    ContainsTarget="true"
  />
</EntityType>

<EntityType Name="Orders_Items"> ... </EntityType>
```

> For reasons of backward compatibility, especially with respect to legacy OData
> client frameworks, OData flavors `v2` as well as `v4` don't use OData containment,
> while the presets of `w4` and `x4` do.


### `cds.odata.safe_ax` = _true_ | _false_ <Beta />

For auto-exposed entities, setting `cds.odata.safe_ax = true` ensures unique names
of helper entities.

> For reasons of backward compatibility, especially with respect to legacy OData
> client frameworks, OData flavors `v2` as well as `v4` don't this option,
> while the presets of `w4` and `x4` do.



### `cds.odata.flavor` = _v2_ | _v4_ | _w4_ | _x4_

More precisely and somewhat behind the scenes, this setting acts as a reference to `cds.odata.flavors`, which contains a map of configuration presets of the config options documented above, as follows:

| Config Option           | v2 | v4 |  w4  |  x4  |
|-------------------------|:--:|:--:|:----:|:----:|
| `cds.odata.containment` |    |    | true | true |
| `cds.odata.structs`     |    |    | true | true |
| `cds.odata.refs`        |    |    |      | true |
| `cds.odata.proxies`     |    |    |      | true |
| `cds.odata.safe_ax`     |    |    | true | true |

In essence:
- Preset `x4` switches on all struct features &rarr; mostly used in A2X APIs.
- Preset `w4` is like `x4` but keeps foreign keys in order to support existing Fiori or mobile clients, which require that
- Presets for `v2` and `v4` stay with ['flattened' format](#flat-odata) and also don't use `containment` for reasons of extended compatibility to existing or legacy clients.

#### Inspect flavor presets with `cds env`

Use the `cds env` CLI command to inspect the API flavor presets as follows:

```sh
cds env get odata.flavors
cds env get odata.flavors.x4
```

#### Inspect effective `odata` config with `cds env` <Beta />

Use the `cds env` CLI command to inspect the effective configuration resulting out of a chosen API flavor preset as follows:

```sh
cds env --odata x4 get effective.odata
```

Explicitly configured `odata` options have precedence over those from presets:

```sh
cds_odata_structs=false cds env --odata x4 get effective.odata
```


#### Inspect effective `cdsc` config with `cds env` <Beta />

The public config options are translated to internal CDS compiler-specific options, which can also be overridden by setting `cds.cdsc` config options.

Use the `cds env` CLI command to inspect the effective `cdsc` configuration as follows:

```sh
cds env --odata x4 get effective.cdsc
```

Explicitly configured `cdsc` options have precedence over those from presets:

```sh
cds_cdsc_odataProxies=false cds env --odata x4 get effective.cdsc
```

</Fragment>

## V2 Support

While CAP defaults to OData V4, the latest protocol version, older projects may need to fallback to OData V2, for example, to keep using existing V2-based UIs.


::: warning

OData V2 is deprecated. Use OData V2 only if you need to support existing UIs or if you need to use specific controls that don't work with V4 **yet** like, tree tables (sap.ui.table.TreeTable).

:::

### Enabling OData V2 via CDS OData V2 Adapter in Node.js Apps { #odata-v2-adapter-node}

CAP Node.js supports serving the OData V2 protocol through the [_OData V2 adapter for CDS_](https://www.npmjs.com/package/@cap-js-community/odata-v2-adapter), which translates between the OData V2 and V4 protocols.

For Node.js projects, add the CDS OData V2 adapter as express.js middleware as follows:

1. Add the adapter package to your project:

    ```sh
    npm add @cap-js-community/odata-v2-adapter
    ```

2. Access OData V2 services at [http://localhost:4004/odata/v2/${path}](http://localhost:4004/odata/v2).
3. Access OData V4 services at [http://localhost:4004/odata/v4/${path}](http://localhost:4004/odata/v4) (as before).

Example: Read service metadata for `CatalogService`:

- CDS:

    ```cds
    @path:'/browse'
    service CatalogService { ... }
    ```

- OData V2: `GET http://localhost:4004/odata/v2/browse/$metadata`
- OData V4: `GET http://localhost:4004/odata/v4/browse/$metadata`

[Find detailed instructions at **@cap-js-community/odata-v2-adapter**.](https://www.npmjs.com/package/@cap-js-community/odata-v2-adapter){.learn-more}

### Using OData V2 in Java Apps

In CAP Java, serving the OData V2 protocol is supported natively by the [CDS OData V2 Adapter](../java/migration#v2adapter).

## Miscellaneous

### Omitting Elements from APIs

Add annotation `@cds.api.ignore` to suppress unwanted entity fields (for example, foreign-key fields) in APIs exposed from this the CDS model, that is, OData or OpenAPI. For example:

```cds
entity Books { ...
  @cds.api.ignore
  author : Association to Authors;
}
```

Please note that `@cds.api.ignore` is effective on regular elements that are rendered as `Edm.Property` only. The annotation doesn't suppress an `Edm.NavigationProperty` which is rendered for associations or compositions. If a managed association is annotated, the annotations are propagated to the (generated) foreign keys. In the previous example, the foreign keys of the managed association `author` are muted in the API.

### Absolute Context URL { #absolute-context-url}

In some scenarios, an absolute [context URL](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ContextURL) is needed. In the Node.js runtime, this can be achieved through configuration `cds.odata.contextAbsoluteUrl`.

You can use your own URL (including a protocol and a service path), for example:

```js
cds.odata.contextAbsoluteUrl = "https://your.domain.com/yourService"
```

to customize the annotation as follows:

```json
{
  "@odata.context":"https://your.domain.com/yourService/$metadata#Books(title,author,ID)",
  "value":[
    {"ID": 201,"title": "Wuthering Heights","author": "Emily Brontë"},
    {"ID": 207,"title": "Jane Eyre","author": "Charlotte Brontë"},
    {"ID": 251,"title": "The Raven","author": "Edgar Allen Poe"}
  ]
}
```

If `contextAbsoluteUrl` is set to something truthy that doesn't match `http(s)://*`, an absolute path is constructed based on the environment of the application on a best effort basis.

Note that we encourage you to stay with the default relative format, if possible, as it's proxy safe.

<div id="secondary-file">advanced/odata.fragment.md</div>





# Publishing to AsyncAPI

You can convert events in CDS models to the [AsyncAPI specification](https://www.asyncapi.com), a widely adopted standard used to describe and document message-driven asynchronous APIs.

## Usage from CLI { #cli}

Use the following command to convert all services in `srv/` and store the generated AsyncAPI documents in the `docs/` folder:

```sh
cds compile srv --service all -o docs --to asyncapi
```

For each service that is available in the `srv/` files, an AsyncAPI document with the service name is generated in the output folder.
If you want to generate one AsyncAPI document for all the services, you can use `--asyncapi:merged` flag:

```sh
cds compile srv --service all -o docs --to asyncapi --asyncapi:merged
```

[Learn how to programmatically convert the CSN file into an AsyncAPI Document](/node.js/cds-compile#to-asyncapi){.learn-more}

## Presets { #presets}

Use presets to add configuration for the AsyncAPI export tooling.

::: code-group
```json [.cdsrc.json]
{
  "export": {
    "asyncapi": {
      "application_namespace": "sap.example"
      [...]
    }
  }
}
```
:::

| Term                    | Preset Target | AsyncAPI field                | Remarks                                                                                                                  |
|-------------------------|---------------|-------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| `merged.title`          | Service       | info.title                    | Mandatory when `--asyncapi:merged` flag is given.<br> `title` from here is used in the generated AsyncAPI document.      |
| `merged.version`        | Service       | info.version                  | Mandatory when `--asyncapi:merged` flag is given.<br> `version` from here is used in the generated AsyncAPI document     |
| `merged.description`    | Service       | info.description              | Optional when `--asyncapi:merged` flag is given.<br> `description` from here is used in the generated AsyncAPI document. |
| `merged.short_text`     | Service       | x-sap-shortText               | Optional when `--asyncapi:merged` flag is given.<br> The value from here is used in the generated AsyncAPI document.     |
| `application_namespace` | Document      | x-sap-application-namespace   | Mandatory                                                                                                                |
| `event_spec_version`    | Event         | x-sap-event-spec-version      |                                                                                                                          |
| `event_source`          | Event         | x-sap-event-source            |                                                                                                                          |
| `event_source_params`   | Event         | x-sap-event-source-parameters |                                                                                                                          |
| `event_characteristics` | Event         | x-sap-event-characteristics   |                                                                                                                          |

## Annotations { #annotations}

Use annotations to add configuration for the AsyncAPI export tooling.

::: tip
Annotations will take precedence over [presets](#presets).
:::

| Term (`@AsyncAPI.`)    | Annotation Target | AsyncAPI field                | Remarks                                                                                                                 |
|------------------------|-------------------|-------------------------------|-------------------------------------------------------------------------------------------------------------------------|
| `Title`                | Service           | info.title                    | Mandatory                                                                                                               |
| `SchemaVersion`        | Service           | info.version                  | Mandatory                                                                                                               |
| `Description`          | Service           | info.description              |                                                                                                                         |
| `StateInfo`            | Service           | x-sap-stateInfo               |                                                                                                                         |
| `ShortText`            | Service           | x-sap-shortText               |                                                                                                                         |
| `EventSpecVersion`     | Event             | x-sap-event-spec-version      |                                                                                                                         |
| `EventSource`          | Event             | x-sap-event-source            |                                                                                                                         |
| `EventSourceParams`    | Event             | x-sap-event-source-parameters |                                                                                                                         |
| `EventCharacteristics` | Event             | x-sap-event-characteristics   |                                                                                                                         |
| `EventStateInfo`       | Event             | x-sap-stateInfo               |                                                                                                                         |
| `EventSchemaVersion`   | Event             | x-sap-event-version           |                                                                                                                         |
| `EventType`            | Event             |                               | Optional; The value from this annotation will be used to<br> overwrite the default event type in the AsyncAPI document. |

For example:

```cds
@AsyncAPI.Title        : 'CatalogService Events'
@AsyncAPI.SchemaVersion: '1.0.0'
@AsyncAPI.Description  : 'Events emitted by the CatalogService.'

service CatalogService {
  @AsyncAPI.EventSpecVersion    : '2.0'
  @AsyncAPI.EventCharacteristics: {
    ![state-transfer]: 'full-after-image'
  }
  @AsyncAPI.EventSchemaVersion       : '1.0.0'

  event SampleEntity.Changed.v1 : projection on CatalogService.SampleEntity;
}
```

## Extensions { #extensions}

`@AsyncAPI.Extensions` can be used to provide arbitrary extensions. 
If a specific annotation exists for a given extension, it takes precedence over the definition using @AsyncAPI.Extensions.
For example, if both `@AsyncAPI.ShortText` and `@AsyncAPI.Extensions: { ![sap-shortText]: 'baz' }` are provided, the value from `@AsyncAPI.ShortText` will override the one defined in @AsyncAPI.Extensions.

For example:

```cds
@AsyncAPI.Extensions   : {
  ![foo-bar]                    : 'baz',
  ![sap-shortText]              : 'Service Base 1'
}

service CatalogService {
  @AsyncAPI.Extensions          : {
    ![sap-event-source]           : '/{region}/sap.app.test'
  }
  event SampleEntity.Changed.v1 : projection on CatalogService.SampleEntity;
}
```

The `@AsyncAPI.Extensions` annotation can be applied at both the service level and the event level.

Since the AsyncAPI specification requires all extensions to be prefixed with `x-`, the compiler will automatically add this prefix. Therefore, do not include the `x-` prefix when specifying extensions in `@AsyncAPI.Extensions`.

### Behavior with `--merged` flag

When the `--merged` CLI flag is used:

- Extensions defined via `@AsyncAPI.Extensions` on `services` are **ignored**.
- Extensions defined via `@AsyncAPI.Extensions` on `events` remain effective and are applied as expected.

## Type Mapping { #mapping}

CDS Type to AsyncAPI Mapping

| CDS Type                               | AsyncAPI Supported Types                                                                            |
|----------------------------------------|-----------------------------------------------------------------------------------------------------|
| `UUID`                                 | `{ "type": "string", "format": "uuid" }`                                                            |
| `Boolean`                              | `{ "type": "boolean" }`                                                                             |
| `Integer`                              | `{ "type": "integer" }`                                                                             |
| `Integer64`                            | `{ "type": "string", "format": "int64" }`                                                           |
| `Decimal`, `{precision, scale}`        | `{ "type": "string", "format": "decimal", "x-sap-precision": <precision>, "x-sap-scale": <scale> }` |
| `Decimal`, without scale               | `{ "type": "string", "format": "decimal", "x-sap-precision": <precision> }`                         |
| `Decimal`, without precision and scale | `{ "type": "string", "format": "decimal" }`                                                         |
| `Double`                               | `{ "type": "number" }`                                                                              |
| `Date`                                 | `{ "type": "string", "format": "date" }`                                                            |
| `Time`                                 | `{ "type": "string", "format": "partial-time" }`                                                    |
| `DateTime`                             | `{ "type": "string", "format": "date-time" }`                                                       |
| `Timestamp`                            | `{ "type": "string", "format": "date-time" }`                                                       |
| `String`, `{maxLength}`                | `{ "type": "string", "maxLength": length }`                                                         |
| `Binary`, `{maxLength}`                | `{ "type": "string", "maxLength": length }`                                                         |
| `LargeBinary`                          | `{ "type": "string" }`                                                                              |
| `LargeString`                          | `{ "type": "string" }`                                                                              |



# Serving Fiori UIs

CAP provides out-of-the-box support for SAP Fiori elements front ends.

This guide explains how to add one or more SAP Fiori elements apps to a CAP project, how to add SAP Fiori elements annotations to respective service definitions, and more. In the following sections, when mentioning Fiori, we always mean SAP Fiori elements.

[Learn more about developing SAP Fiori elements and OData V4 (since 1.84.)](https://sapui5.hana.ondemand.com/#/topic/62d3f7c2a9424864921184fd6c7002eb){.learn-more}


## SAP Fiori Preview

For entities exposed via OData V4 there is a _Fiori preview_ link on the index page. It dynamically serves an SAP Fiori Elements list page that allows you to quickly see the effect of annotation changes without having to create a UI application first.

::: details Be aware that this is **not meant for production**.

<div class="impl node">

The preview not meant as a replacement for a proper SAP Fiori Elements (UI5) application.
It is only active locally where the [development profile](../node.js/cds-env#profiles) is enabled.

To also enable it in cloud deployments, for test or demo purposes maybe, set <Config>cds.fiori.preview:true</Config>.

</div>

<div class="impl java">

The preview not meant as a replacement for a proper SAP Fiori Elements (UI5) application.
It is active by default, but disabled automatically in case the [production profile](../java/developing-applications/configuring#production-profile) is enabled.

To also enable it in cloud deployments, for test or demo purposes maybe, set <Config java>cds.index-page.enabled:true</Config>.

</div>

:::


## Adding Fiori Apps

As showcased in [cap/samples](https://github.com/sap-samples/cloud-cap-samples/tree/main/fiori/app), SAP Fiori apps should be added as sub folders to the `app/` of a CAP project. Each sub folder constitutes an individual SAP Fiori application, with [local annotations](#fiori-annotations), _manifest.json_, etc. So, a typical folder layout would look like this:


| Folder/Sub Folder          | Description                          |
|----------------------------|--------------------------------------|
| `app/`                     | All SAP Fiori apps should go in here |
| &nbsp; &nbsp; `browse/`    | SAP Fiori app for end users          |
| &nbsp; &nbsp; `orders/`    | SAP Fiori app for order management   |
| &nbsp; &nbsp; `admin/`     | SAP Fiori app for admins             |
| &nbsp; &nbsp; `index.html` | For sandbox tests                    |
| `srv/`                     | All services                         |
| `db/`                      | Domain models, and db stuff          |

::: tip
Links to Fiori applications created in the `app/` folder are automatically added to the index page of your CAP application for local development.
:::

### Using SAP Fiori Tools

The SAP Fiori tools provide advanced support for [adding SAP Fiori apps](https://help.sap.com/docs/SAP_FIORI_tools/17d50220bcd848aa854c9c182d65b699/db44d45051794d778f1dd50def0fa267.html) to existing CAP projects as well as a wealth of productivity tools, for example for adding SAP Fiori annotations, or graphical modeling and editing. They can be used locally in [Visual Studio Code (VS Code)](https://marketplace.visualstudio.com/items?itemName=SAPSE.sap-ux-fiori-tools-extension-pack) or in [SAP Business Application Studio](https://help.sap.com/docs/SAP_FIORI_tools/17d50220bcd848aa854c9c182d65b699/b0110400b44748d7b844bb5977a657fa.html).


### Using [`cds add`](../tools/cds-cli#sample)

Use `cds add sample` to add Fiori sample code to an existing project, or create a new one with `cds init <project> --add sample`.


### From [cap/samples](https://github.com/sap-samples/cloud-cap-samples)

For example, you can copy the [SAP Fiori apps from cap/samples](https://github.com/sap-samples/cloud-cap-samples/tree/main/fiori/app) as a template and modify the content as appropriate.


### From [Incidents Sample](https://github.com/SAP-samples/fiori-elements-incident-management/tree/sampleSolution)

This is a sample to create an incident management app with SAP Fiori elements for OData V4.


## Fiori Annotations

The main content to add is service definitions annotated with information about how to render respective data.


### What Are SAP Fiori Annotations?

SAP Fiori elements apps are generic front ends, which construct and render the pages and controls based on annotated metadata documents. The annotations provide semantic annotations used to render such content, for example:


```cds
annotate CatalogService.Books with @(
  UI: {
    SelectionFields: [ ID, price, currency_code ],
    LineItem: [
      {Value: title},
      {Value: author, Label:'{i18n>Author}'},
      {Value: genre.name},
      {Value: price},
      {Value: currency.symbol, Label:' '},
    ]
  }
);
```


[Find this source and many more in **cap/samples**.](https://github.com/sap-samples/cloud-cap-samples/tree/main/fiori/app){.learn-more target="_blank"}
[Learn more about **OData Annotations in CDS**.](./odata#annotations){.learn-more}


### Where to Put Them?

While CDS in principle allows you to add such annotations everywhere in your models, we recommend putting them in separate _.cds_ files placed in your _./app/*_ folders, for example, as follows.

```sh
./app  #> all your Fiori annotations should go here, for example:
   ./admin
      fiori-service.cds #> annotating ../srv/admin-service.cds
   ./browse
      fiori-service.cds #> annotating ../srv/cat-service.cds
   services.cds #> imports ./admin/fiori-service and ./browse/fiori-service
./srv  #> all service definitions should stay clean in here:
   admin-service.cds
   cat-service.cds
...
```

[See this also in **cap/samples/fiori**.](https://github.com/SAP-samples/cloud-cap-samples/blob/6fa2aaee34e862337c5bc5a413817355ab283437/fiori/app/services.cds){.learn-more}

**Reasoning:** This recommendation essentially follows the best practices and guiding principles of [Conceptual Modeling](../guides/domain-modeling#domain-driven-design) and [Separation of Concerns](../guides/domain-modeling#separation-of-concerns).


### Maintaining Annotations

Maintaining OData annotations in _.cds_ files is accelerated by the SAP Fiori tools - CDS OData Language Server [@sap/ux-cds-odata-language-server-extension](https://www.npmjs.com/package/@sap/ux-cds-odata-language-server-extension) in the [SAP CDS language support plugin](https://marketplace.visualstudio.com/items?itemName=SAPSE.vscode-cds). It helps you add and edit OData annotations in CDS syntax with:

-   Code completion
-   Validation against the OData vocabularies and project metadata
-   Navigation to the referenced annotations
-   Quick view of vocabulary information
-   Internationalization support

These assisting features are provided for [OData annotations in CDS syntax](../advanced/odata#annotations) and can't be used yet for the [core data services common annotations](../cds/annotations).

The [@sap/ux-cds-odata-language-server-extension](https://www.npmjs.com/package/@sap/ux-cds-odata-language-server-extension) module doesn't require any manual installation. The latest version is fetched by default from [npmjs.com](https://npmjs.com) as indicated in the user preference setting **CDS > Contributions: Registry**.

[Learn more about the **CDS extension for VS Code**.](https://www.youtube.com/watch?v=eY7BTzch8w0){.learn-more}

### Code Completion

The CDS OData Language Server provides a list of context-sensitive suggestions based on the service metadata and OData vocabularies. You can use it to choose OData annotation terms, their properties, and values from the list of suggestions in annotate directives applied to service entities and entity elements. See [annotate directives](../cds/cdl#annotate) for more details.


#### Using Code Completion

To trigger code completion, choose <kbd>Ctrl</kbd><kbd>Space</kbd>. The list of suggested values is displayed.

> Note: You can filter the list of suggested values by typing more characters.

Navigate to the desired value using the up or down arrows or your mouse. Accept the highlighted value by pressing <kbd>Enter</kbd> or by clicking the mouse.
Use code completion to add and change individual values (word-based completion) and to add small code blocks containing annotation structures along with mandatory properties (micro-snippets). In an active code snippet, you can use the <kbd>&#x21e5;</kbd> (tab) key to quickly move to the next tab stop.


##### Example: Annotating Service Entities

  \(cursor position indicated by `|`\)

1.  Place cursor in the `annotate` directive for a service entity, for example `annotate Foo.Bar with ;` and trigger code completion.

2.  Type `u` to filter the suggestions and choose `{} UI`. Micro-snippet `@UI : {|}` is inserted: `annotate Foo.Bar with @UI : {|};`

3.  Use code completion again to add an annotation term from the UI vocabulary, in this example `SelectionFields`. The micro snippet for this annotation is added and the cursor is placed directly after the term name letting you define a qualifier: `annotate Foo.Bar with @UI : {SelectionFields | : []};`

4.  Press the <kbd>&#x21e5;</kbd> (tab) key to move the cursor to the next tab stop and use code completion again to add values. Because the `UI.SelectionFields` annotation is a collection of entity elements \(entity properties\), all elements of the annotated entity are suggested.

    ::: tip
    To choose an element of an associated entity, first select the corresponding association from the list and type *. \(period\)*. Elements of associated entity are suggested.

    Note: You can add multiple values separated by comma.
    :::

   ```cds
   annotate Foo.Bar with @UI : { SelectionFields : [
       description, assignedIndividual.lastName|
     ],
   };
   ```

5. Add a new line after `,` (comma) and use code completion again to add another annotation from the UI vocabulary, such as `LineItem`. Line item is a collection of `DataField` records. To add a record, select the record type you need from the completion list.


   ```cds
   annotate Foo.Bar with @UI : {
      SelectionFields : [
        description, assignedIndividual.lastName
      ],
      LineItem : [{
        $Type:'UI.DataField',
        Value : |,
     },
   };
   ```

    > Note: For each record type, two kinds of micro-snippets are provided: one containing only mandatory properties and one containing all properties defined for this record \(full record\). Usually you need just a subset of properties. So, you either select a full record and then remove the properties you don't need, or add the record containing only required properties and then add the remaining properties.

6.  Use code completion to add values for the annotation properties.


    ```cds
    annotate Foo.Bar with @UI : {
      SelectionFields : [
        description, assignedIndividual.lastName
      ],
      LineItem : [
        {
            $Type:'UI.DataField',
            Value : description,
        },
        {
            $Type:'UI.DataFieldForAnnotation',
            Target :  'assignedIndividual/@Communication.Contact',
        },|
      ]
    };
    ```

    > Note: To add values pointing to annotations defined in another CDS source, you must reference this source with the `using` directive. See [The `using` Directive](../cds/cdl#using) for more details.


##### Example: Annotating Entity Elements

  \(cursor position indicated by `|`\)

1.  Place the cursor in the `annotate` directive, for example `annotate Foo.Bar with {|};`, add a new line and trigger code completion. You get the list of entity elements. Choose the one that you want to annotate.

  ```cds
  annotate Foo.Bar with {
      code|
  };
  ```

2.  Press the <kbd class="space">⎵</kbd> key, use code completion again, and choose `{} UI`. The `@UI : {|}` micro-snippet is inserted:

  ```cds
  annotate Foo.Bar with {
      code @UI : { | }
  };
  ```

3.  Trigger completion again and choose an annotation term from the UI vocabulary, in this example: **Hidden**.


  ```cds
  annotate Foo.Bar with {
      code @UI : {Hidden : |}
  };
  ```

4.  Press the <kbd>&#x21e5;</kbd> (tab) key to move the cursor to the next tab stop and use code completion again to add the value. Because the `UI.Hidden` annotation is of Boolean type, the values true and false are suggested:


  ```cds
  annotate Foo.Bar with {
      code @UI : {Hidden : false }
  };
  ```

### Diagnostics

The CDS OData Language Server validates OData annotations in _.cds_ files against the service metadata and OData vocabularies. It also checks provided string content for language-dependent annotation values and warns you if the format doesn't match the internationalization (i18n) key reference. It shows you that this string is hard coded and won't change based on the language setting in your application. See [Internationalization support](#internationalization-support) for more details.

Validation is performed when you open a _.cds_ file and then is retriggered with each change to the relevant files.

You can view the diagnostic messages by hovering over the highlighted part in the annotation file or by opening the problems panel. Click on the message in the problems panel to navigate to the related place in the annotation file.

> Note: If an annotation value points to the annotation defined in another CDS source, you must reference this source with a `using` directive to avoid warnings. See [The `using` Directive](../cds/cdl#using) for more details.


### Navigation to Referenced Annotations

CDS OData Language Server enables quick navigation to the definition of referenced annotations. For example, if your annotation file contains a `DataFieldForAnnotation` record referencing an `Identification` annotation defined in the service file, you can view which file it's defined in and what fields or labels this annotation contains. You can even update the `Identification` annotation or add comments.

You can navigate to the referenced annotation using the [Peek Definition](#peek-definition) and [Go To Definition](#go-to-definition) features.

> Note: If the referenced annotation is defined in another CDS source, you must reference this source with the `using` directive to enable the navigation. See [The `using` Directive](../cds/cdl#using) for more details.


#### Peek Definition { #peek-definition}

Peek Definition lets you preview and update the referenced annotation without switching away from the code that you're writing. It's triggered when your cursor is inside the referenced annotation value.
- Using a keyboard: choose <kbd class="space">⌥</kbd><kbd>F12</kbd> (macOS) or <kbd>Alt</kbd><kbd>F12</kbd> (other platforms)
- Using a mouse: right-click and select **Peek Definition**
If an annotation is defined in multiple sources, all these sources are listed. You can select which one you want to view or update. Annotation layering isn't considered.


#### Go to Definition { #go-to-definition}

Go To Definition lets you navigate to the source of the referenced annotation and opens the source file scrolled to the respective place in a new tab. It's triggered when your cursor is inside the referenced annotation value.

Place your cursor inside the path referencing the annotation term segment or translatable string value, and trigger Go to Definition:

-   Using a keyboard: choose <kbd>F12</kbd> in VS Code, or <kbd>Ctrl</kbd><kbd>F12</kbd> in SAP Business Application Studio
-   Using a mouse: right-click and select **Go To Definition**
-   Using a keyboard and mouse: <kbd>⌘</kbd> + mouse click (macOS) or <kbd>Ctrl</kbd> + mouse click (other platforms)

If an annotation is defined in multiple sources, a Peek definition listing these sources will be shown instead. Annotation layering isn't considered.


### Documentation \(Quick Info\)

The annotation language server provides quick information for annotation terms, record types, and properties used in the annotation file, or provided as suggestions in code completion lists. This information is retrieved from the respective OData vocabularies and can provide answers to the following questions:

-   What is the type and purpose of the annotation term/record type/property?
-   What targets can the annotation term apply to?
-   Is the annotation term/record type/property experimental? Is it deprecated?
-   Is this annotation property mandatory or optional?

> Note: The exact content depends on the availability in OData vocabularies.

To view the quick info for an annotation term, record type, or property used in the annotation file, hover your mouse over it. The accompanying documentation is displayed in a hover window, if provided in the respective OData vocabularies.

To view the quick info for each suggestion in the code completion list, either pressing <kbd>Ctrl</kbd><kbd>Space</kbd>, or click the *info* icon. The accompanying documentation for the suggestion expands to the side. The expanded documentation stays open and updates as you navigate the list.


#### Internationalization Support

When you open an annotation file, all language-dependent string values are checked against the _i18n.properties_ file. Each value that doesn't represent a valid reference to the existing text key in the _i18n.properties_ file, is indicated with a warning. A Quick Fix action is suggested to generate a text key in i18n file and substitute your string value with the reference to that entry.


### Prefer `@title` and `@description`

Influenced by the [JSON Schema](https://json-schema.org), CDS supports the [common annotations](../cds/annotations#common-annotations) `@title` and `@description`, which are mapped to corresponding [OData annotations](./odata#annotations) as follows:

| CDS            | JSON Schema   | OData               |
|----------------|---------------|---------------------|
| `@title`       | `title`       | `@Common.Label`     |
| `@description` | `description` | `@Core.Description` |

We recommend preferring these annotations over the OData ones in protocol-agnostic data models and service models, for example:

```cds
annotate my.Books with { //...
   title @title: 'Book Title';
   author @title: 'Author ID';
}
```


### Prefer `@readonly`, `@mandatory`, ...

CDS supports `@readonly` as a common annotation, which translates to respective [OData annotations](./odata#annotations) from the `@Capabilities` vocabulary. We recommend using the former for reasons of conciseness and comprehensibility as shown in this example:

```cds
@readonly entity Foo {   // entity-level
  @readonly foo : String // element-level
}
```

is equivalent to:

```cds
entity Foo @(Capabilities:{
  // entity-level
  InsertRestrictions.Insertable: false,
  UpdateRestrictions.Updatable: false,
  DeleteRestrictions.Deletable: false
}) {
  // element-level
  @Core.Computed foo : String
}
```

Similar recommendations apply to `@mandatory` and others &rarr; see [Common Annotations](../cds/annotations#common-annotations).


## Draft Support

SAP Fiori supports edit sessions with draft states stored on the server, so users can interrupt and continue later on, possibly from different places and devices. CAP, as well as SAP Fiori elements, provide out-of-the-box support for drafts as outlined in the following sections. **We recommend to always use draft** when your application needs data input by end users.

[For details and guidelines, see **SAP Fiori Design Guidelines for Draft**.](https://experience.sap.com/fiori-design-web/draft-handling/){.learn-more}

[Find a working end-to-end version in **cap/samples/fiori**.](https://github.com/sap-samples/cloud-cap-samples/tree/main/fiori){.learn-more}

[For details about the draft flow in SAP Fiori elements, see **SAP Fiori elements > Draft Handling**](https://ui5.sap.com/#/topic/ed9aa41c563a44b18701529c8327db4d){.learn-more}


### Enabling Draft with `@odata.draft.enabled`

To enable draft for an entity exposed by a service, simply annotate it with `@odata.draft.enabled` as in this example:

```cds
annotate AdminService.Books with @odata.draft.enabled;
```

[See it live in **cap/samples**.](https://github.com/SAP-samples/cloud-cap-samples/blob/6fa2aaee34e862337c5bc5a413817355ab283437/fiori/app/admin-books/fiori-service.cds#L94){.learn-more}

::: warning
You can't project from draft-enabled entities, as annotations are propagated. Either _enable_ the draft for the projection and not the original entity or _disable_ the draft on the projection using `@odata.draft.enabled: null`.
:::

### Difference between Compositions and Associations

Be aware that you cannot modify _associated_ entities through drafts. Only _compositions_ will get a "Create" button in SAP Fiori elements UIs because they are stored as part of the same draft entity.

### Enabling Draft for [Localized Data](../guides/localized-data) {#draft-for-localized-data}

Annotate the underlying base entity in the base model with `@fiori.draft.enabled` to also support drafts for [localized data](../guides/localized-data):

```cds
annotate sap.capire.bookshop.Books with @fiori.draft.enabled;
```

:::info Background
SAP Fiori drafts required single keys of type `UUID`, which isn't the case by default for the automatically generated `_texts` entities (&rarr; [see the _Localized Data_ guide for details](../guides/localized-data#behind-the-scenes)). The `@fiori.draft.enabled` annotation tells the compiler to add such a technical primary key element named `ID_texts`.
:::

::: warning
Adding the annotation `@fiori.draft.enabled` won't work if the corresponding `_texts` entities contain any entries, because existing entries don't have a value for the new key field `ID_texts`.
:::

![An SAP Fiori UI showing how a book is edited in the bookshop sample and that the translations tab is used for non-standard languages.](../assets/draft-for-localized-data.png){}

[See it live in **cap/samples**.](https://github.com/SAP-samples/cloud-cap-samples/blob/6fa2aaee34e862337c5bc5a413817355ab283437/fiori/app/admin-books/fiori-service.cds#L93){.learn-more}

If you're editing data in multiple languages, the _General_ tab in the example above is reserved for the default language (often "en"). Any change to other languages has to be done in the _Translations_ tab, where a corresponding language can be chosen [from a drop-down menu](https://github.com/SAP-samples/cloud-cap-samples/blob/6fa2aaee34e862337c5bc5a413817355ab283437/fiori/app/admin-books/fiori-service.cds#L116) as illustrated above. This also applies if you use the URL parameter `sap-language` on the draft page.

### Draft Choreography: How Draft Editing Works

With draft-enabled entities, changes are made to a draft copy instead of the active entity. The typical flow is:
- Create a draft
- Edit the draft
- Activate the draft

Below are example HTTP requests for each step:

#### 1. Create a Draft
```http
POST /odata/v4/AdminService/Books
Content-Type: application/json

{}
```

#### 2. Edit the Draft
```http
PATCH /odata/v4/AdminService/Books(ID=a11fb6f1-36ab-46ec-b00c-d379031e817a,IsActiveEntity=false)
Content-Type: application/json

{
  "title": "Book Title"
}
```

#### 3. Activate the Draft
```http
POST /odata/v4/AdminService/Books(ID=a11fb6f1-36ab-46ec-b00c-d379031e817a,IsActiveEntity=false)/draftActivate
Content-Type: application/json

{}


For more details, see the [official UI5 documentation](https://ui5.sap.com/#/topic/ed9aa41c563a44b18701529c8327db4d).

### Validating Drafts

You can add [custom handlers](../guides/providing-services#custom-logic) to add specific validations, as usual. In addition, for a draft, you can register handlers to the respective `UPDATE` events to validate input per field, during the edit session, as follows.


##### ... in Java

You can add your validation logic before operation event handlers. Specific events for draft operations exist. See [Java > Fiori Drafts > Editing Drafts](../java/fiori-drafts#draftevents) for more details.


##### ... in Node.js

You can add your validation logic before the operation handler for either CRUD or draft-specific events. See [Node.js > Fiori Support > Handlers Registration](../node.js/fiori#draft-support) for more details about handler registration.


<div id="query-data-draft-enabled" />
<Fragment target="#query-data-draft-enabled">

### Query Data For a Draft-Enabled Entity <Internal />

To query data, make sure you adhere to the [OData draft choreography documentation](https://wiki.one.int.sap/wiki/x/rsz6dw). Generic handlers react accordingly if this prerequisite is fulfilled.

</Fragment>

### Query Drafts Programmatically

To access drafts in code, you can use the [`.drafts` reflection](../node.js/cds-reflect#drafts).
```js
SELECT.from(Books.drafts) //returns all drafts of the Books entity
```

[Learn how to query drafts in Java.](../java/fiori-drafts#draftservices){.learn-more}

## Use Roles to Toggle Visibility of UI elements

In addition to adding [restrictions on services, entities, and actions/functions](/guides/security/authorization#restrictions), there are use cases where you only want to hide certain parts of the UI for specific users. This is possible by using the respective UI annotations like `@UI.Hidden` or `@UI.CreateHidden` in conjunction with `$edmJson` pointing to a singleton.

First, you define the [singleton](../advanced/odata#singletons) in your service and annotate it with [`@cds.persistence.skip`](../guides/databases#cds-persistence-skip) so that no database artefact is created:

```cds
@odata.singleton @cds.persistence.skip
entity Configuration {
    key ID: String;
    isAdmin : Boolean;
}
```
> A key is technically not required, but without it some consumers might run into problems.

Then define an `on` handler for serving the request:

```js
srv.on('READ', 'Configuration', async req => {
    req.reply({
        isAdmin: req.user.is('admin') //admin is the role, which for example is also used in @requires annotation
    });
});
```

Finally, refer to the singleton in the annotation by using a [dynamic expression](../advanced/odata#dynamic-expressions):

```cds
annotate service.Books with @(
    UI.CreateHidden : { $edmJson: {$Not: { $Path: '/CatalogService.EntityContainer/Configuration/isAdmin'} } },
    UI.UpdateHidden : { $edmJson: {$Not: { $Path: '/CatalogService.EntityContainer/Configuration/isAdmin'} } },
);
```

The Entity Container is OData specific and refers to the `$metadata` of the OData service in which all accessible entities are located within the Entity Container.

:::details SAP Fiori elements also allows to not include it in the path
```cds
annotate service.Books with @(
    UI.CreateHidden : { $edmJson: {$Not: { $Path: '/Configuration/isAdmin'} } },
    UI.UpdateHidden : { $edmJson: {$Not: { $Path: '/Configuration/isAdmin'} } },
);
```
:::

## Value Helps

In addition to supporting the standard `@Common.ValueList` annotations as defined in the [OData Vocabularies](odata#annotations), CAP provides advanced, convenient support for Value Help as understood and supported by SAP Fiori.


### Convenience Option `@cds.odata.valuelist`

Simply add the `@cds.odata.valuelist` annotation to an entity, and all managed associations targeting this entity will automatically receive Value Lists in SAP Fiori clients. For example:

```cds
@cds.odata.valuelist
entity Currencies {}
```
```cds
service BookshopService {
   entity Books { //...
      currency : Association to Currencies;
   }
}
```


### Pre-Defined Types in `@sap/cds/common`

[@sap/cds/common]: ../cds/common

The reuse types in [@sap/cds/common] already have this added to base types and entities, so all uses automatically benefit from this. This is an effective excerpt of respective definitions in `@sap/cds/common`:

```cds
type Currencies : Association to sap.common.Currencies;
```
```cds
context sap.common {
  entity Currencies : CodeList {...};
  entity CodeList { name : localized String; ... }
}
```
```cds
annotate sap.common.CodeList with @(
   UI.Identification: [name],
   cds.odata.valuelist,
);
```

### Usages of `@sap/cds/common`

In effect, usages of [@sap/cds/common] stay clean of any pollution, for example:

```cds
using { Currency } from '@sap/cds/common';
entity Books { //...
  currency : Currency;
}
```

[Find this also in our **cap/samples**.](https://github.com/sap-samples/cloud-cap-samples/tree/main/bookshop/db/schema.cds){.learn-more}

Still, all SAP Fiori UIs, on all services exposing `Books`, will automatically receive Value Help for currencies. You can also benefit from that when [deriving your project-specific code list entities from **sap.common.CodeList**](../cds/common#adding-own-code-lists).


### Resulting Annotations in EDMX

Here is an example showing how this ends up as OData `Common.ValueList` annotations:

```xml
<Annotations Target="AdminService.Books/currency_code">
  <Annotation Term="Common.ValueList">
    <Record Type="Common.ValueListType">
      <PropertyValue Property="CollectionPath" String="Currencies"/>
      <PropertyValue Property="Label" String="Currency"/>
      <PropertyValue Property="Parameters">
        <Collection>
          <Record Type="Common.ValueListParameterInOut">
            <PropertyValue Property="ValueListProperty" String="code"/>
            <PropertyValue Property="LocalDataProperty" PropertyPath="currency_code"/>
          </Record>
          <Record Type="Common.ValueListParameterDisplayOnly">
            <PropertyValue Property="ValueListProperty" String="name"/>
          </Record>
        </Collection>
      </PropertyValue>
    </Record>
  </Annotation>
</Annotation>
```

## Actions

In our SFLIGHT sample application, we showcase how to use actions covering the definition in your CDS model, the needed custom code and the UI implementation.

[Learn more about Custom Actions & Functions.](../guides/providing-services#actions-functions){.learn-more}


We're going to look at three things.
1. Define the action in CDS and custom code.
1. Create buttons to bring the action to the UI
1. Dynamically define the buttons status on the UI


First you need to define an action, like in the [_travel-service.cds_ file](https://github.com/SAP-samples/cap-sflight/blob/42ee666e40f9dba1176f8263b512c10d23f07907/srv/travel-service.cds#L11).

```cds
entity Travel as projection on my.Travel actions {
    action createTravelByTemplate() returns Travel;
    action rejectTravel();
    action acceptTravel();
    action deductDiscount( percent: Percentage not null ) returns Travel;
  };
```

To define what the action actually is doing, you need to write some custom code. See the [_travel-service.ts_](https://github.com/SAP-samples/cap-sflight/blob/42ee666e40f9dba1176f8263b512c10d23f07907/srv/travel-service.ts#L86) file for example:

```js
this.on('acceptTravel', req => UPDATE(req.subject).with({TravelStatus_code:'A'}))
```

Create the buttons, to bring this action onto the UI and make it actionable for the user. There are two buttons: On the overview and in the detail screen. Both are defined in the [_layouts.cds_](https://github.com/SAP-samples/cap-sflight/blob/42ee666e40f9dba1176f8263b512c10d23f07907/app/travel_processor/layouts.cds) file.

For the overview of all travels, use the [`@UI.LineItem` annotation](https://github.com/SAP-samples/cap-sflight/blob/42ee666e40f9dba1176f8263b512c10d23f07907/app/travel_processor/layouts.cds#L40-L41).

```cds
annotate TravelService.Travel with @UI : {
LineItem : [
    { $Type  : 'UI.DataFieldForAction',
      Action : 'TravelService.acceptTravel',
      Label  : '{i18n>AcceptTravel}'   }
  ]
};
```

For the detail screen of a travel, use the [`@UI.Identification` annotation](https://github.com/SAP-samples/cap-sflight/blob/42ee666e40f9dba1176f8263b512c10d23f07907/app/travel_processor/layouts.cds#L9-L10).

```cds
annotate TravelService.Travel with @UI : {
  Identification : [
    { $Type  : 'UI.DataFieldForAction',
      Action : 'TravelService.acceptTravel',
      Label  : '{i18n>AcceptTravel}'   }
  ]
};
```

Now, the buttons are there and connected to the action. The missing piece is to define the availability of the buttons dynamically. Annotate the `Travel` entity in the `TravelService` service accordingly in the [_field-control.cds_](https://github.com/SAP-samples/cap-sflight/blob/42ee666e40f9dba1176f8263b512c10d23f07907/app/travel_processor/field-control.cds#L23-L36) file.

```cds
annotate TravelService.Travel with actions {
 acceptTravel @(
   Core.OperationAvailable : {
     $edmJson: { $Ne: [{ $Path: 'in/TravelStatus_code'}, 'A']}
   },
   Common.SideEffects.TargetProperties : ['in/TravelStatus_code'], ) };
```
This annotation uses [dynamic expressions](../advanced/odata#dynamic-expressions) to control the buttons for each action. And the status of a travel on the UI is updated, triggered by the `@Common.SideEffects.TargetProperties` annotation.

:::info More complex calculation
If you have the need for a more complex calculation, then the interesting parts in (an older version of) SFLIGHT are [virtual fields in _field-control.cds_](https://github.com/SAP-samples/cap-sflight/blob/dfc7827da843ace0ea126f76fc78a6591b325c67/app/travel_processor/field-control.cds#L10-L16) (also lines 37-44) and [custom code in _travel-service.js_](https://github.com/SAP-samples/cap-sflight/blob/dfc7827da843ace0ea126f76fc78a6591b325c67/srv/travel-service.js#L13-L22).
:::


## Cache Control

CAP provides the option to set a [Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) header with a [max-age](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control#max-age) directive to indicate that a response remains fresh until _n_ seconds after it was generated .
In the CDS model, this can be done using the `@http.CacheControl: {maxAge: <seconds>}` annotation on stream properties. The header indicates that caches can store the response and reuse it for subsequent requests while it's fresh.
The `max-age` (in seconds) specifies the maximum age of the content before it becomes stale.

:::info Elapsed time since the response was generated
The `max-age` is the elapsed time since the response was generated on the origin server. It's not related to when the response was received.
:::

::: warning Only Java
Cache Control feature is currently supported on the Java runtime only.
:::

<div id="client-side-validations" />
<Fragment target="#client-side-validations">

## Client-side Validations <Concept />

</Fragment>

<div id="fiori-compat" />
<Fragment target="#fiori-compat">

## Version Compatibility <Internal /> { #fiori-compatibility}

Some features may be dependent on the respective versions of SAP Fiori elements and CAP. We will list known restrictions here.

##### Locked by Another User

The scenario [Locked by Another User](https://wiki.one.int.sap/wiki/pages/viewpage.action?spaceKey=odata&title=Draft+Choreography#DraftChoreography-ListEditingStatus:LockedbyAnotherUser) of the draft choreography has been adjusted since SAP Fiori elements v1.91. The new implementation can only be served by backend versions `@sap/cds` 5 (Node.js) and 1.12.0 (Java), respectively.

</Fragment>

<div id="reserved-words" />
<Fragment target="#reserved-words">

## Reserved Words and Keywords <Internal /> { #reserved-words}

Reserved words have a special meaning in the SAP Fiori draft context and can't be used, for example, as identifiers. The draft-related keywords are listed below.

- IsActiveEntity
- HasActiveEntity
- HasDraftEntity
- DraftAdministrativeData
- DraftAdministrativeData_DraftUUID
- DRAFT_DraftAdministrativeData
- SiblingEntity
- DraftUUID
- InProcessByUser

[Learn more about database-related keywords.](../guides/databases#reserved-words){.learn-more}

</Fragment>

<div id="secondary-file">advanced/fiori.fragment.md</div>



# Using Databases


This guide provides instructions on how to use databases with CAP applications. Out of the box-support is provided for SAP HANA, SQLite, H2 (Java only), and PostgreSQL.

<ImplVariantsHint />

## Setup & Configuration

<div class="impl node">

### Migrating to the `@cap-js/` Database Services?  {.node}

With CDS 8, the [`@cap-js`](https://github.com/cap-js/cds-dbs) database services for SQLite, PostgreSQL, and SAP HANA are generally available. It's highly recommended to migrate. You can find instructions in the [migration guide](databases-sqlite#migration). Although the guide is written in the context of the SQLite Service, the same hints apply to PostgreSQL and SAP HANA.

### Adding Database Packages  {.node}

Following are cds-plugin packages for CAP Node.js runtime that support the respective databases:

| Database                       | Package                                                      | Remarks                            |
| ------------------------------ | ------------------------------------------------------------ | ---------------------------------- |
| **[SAP HANA Cloud](databases-hana)**     | [`@cap-js/hana`](https://www.npmjs.com/package/@cap-js/hana) | recommended for production         |
| **[SQLite](databases-sqlite)**       | [`@cap-js/sqlite`](https://www.npmjs.com/package/@cap-js/sqlite) | recommended for development        |
| **[PostgreSQL](databases-postgres)** | [`@cap-js/postgres`](https://www.npmjs.com/package/@cap-js/postgres) | maintained by community + CAP team |


> Follow the preceding links to find specific information for each.

In general, all you need to do is to install one of the database packages, as follows:

Using SQLite for development:

```sh
npm add @cap-js/sqlite -D
```

Using SAP HANA for production:

```sh
npm add @cap-js/hana
```


::: details Prefer `cds add hana` ...

... which also does the equivalent of `npm add @cap-js/hana` but in addition cares for updating `mta.yaml` and other deployment resources as documented in the [deployment guide](deployment/to-cf#_1-sap-hana-database).

:::

### Auto-Wired Configuration  {.node}

The afore-mentioned packages use `cds-plugin` techniques to automatically configure the primary database with `cds.env`. For example, if you added SQLite and SAP HANA, this effectively results in this auto-wired configuration:


```json
{"cds":{
  "requires": {
    "db": {
      "[development]": { "kind": "sqlite", "impl": "@cap-js/sqlite", "credentials": { "url": "memory" } },
      "[production]": { "kind": "hana", "impl": "@cap-js/hana", "deploy-format": "hdbtable" }
    }
  }
}}
```

::: details In contrast to pre-CDS 7 setups this means...

1. You don't need to — and should not — add direct dependencies to driver packages, like [`hdb`](https://www.npmjs.com/package/hdb) or [`sqlite3`](https://www.npmjs.com/package/sqlite3) anymore in your *package.json* files.
2. You don't need to configure `cds.requires.db` anymore, unless you want to override defaults brought with the new packages.

:::



### Custom Configuration  {.node}

The auto-wired configuration uses configuration presets, which are automatically enabled via `cds-plugin` techniques. You can always use the basic configuration and override individual properties to create a different setup:

1. Install a database driver package, for example:
   ```sh
   npm add @cap-js/sqlite
   ```

   > Add option `-D` if you want this for development only.

2. Configure the primary database as a required service through `cds.requires.db`, for example:

   ```json
   {"cds":{
     "requires": {
       "db": {
         "kind": "sqlite",
         "impl": "@cap-js/sqlite",
         "credentials": {
           "url": "db.sqlite"
         }
       }
     }
   }}
   ```

The config options are as follows:

- `kind` — a name of a preset, like `sql`, `sqlite`, `postgres`, or `hana`
- `impl` — the module name of a CAP database service implementation
- `credentials` — an object with db-specific configurations, most commonly `url`

::: warning Don't configure credentials

Credentials like `username` and  `password` should **not** be added here but provided through service bindings, for example, via `cds bind`.

:::

::: tip Use `cds env` to inspect effective configuration

For example, running this command:

```sh
cds env cds.requires.db
```
→ prints:

```sh
{
  kind: 'sqlite',
  impl: '@cap-js/sqlite',
  credentials: { url: 'db.sqlite' }
}
```

:::

</div>

### Built-in Database Support {.java}

CAP Java has built-in support for different SQL-based databases via JDBC. This section describes the different databases and any differences between them with respect to CAP features. There's out of the box support for SAP HANA with CAP currently as well as H2 and SQLite. However, it's important to note that H2 and SQLite aren't enterprise grade databases and are recommended for non-productive use like local development or CI tests only. PostgreSQL is supported in addition, but has various limitations in comparison to SAP HANA, most notably in the area of schema evolution.

Database support is enabled by adding a Maven dependency to the JDBC driver, as shown in the following table:

| Database                       | JDBC Driver                                                 | Remarks                            |
| ------------------------------ | ------------------------------------------------------------ | ---------------------------------- |
| **[SAP HANA Cloud](databases-hana)**     | `com.sap.cloud.db.jdbc:ngdbc` | Recommended for productive use         |
| **[H2](databases-h2)**       | `com.h2database:h2` | Recommended for development and CI     |
| **[SQLite](databases-sqlite)**       | `org.xerial:sqlite-jdbc` | Supported for development and CI <br> Recommended for local MTX |
| **[PostgreSQL](databases-postgres)** | `org.postgresql:postgresql` | Supported for productive use |

[Learn more about supported databases in CAP Java and their configuration](../java/cqn-services/persistence-services#database-support){ .learn-more}

## Providing Initial Data

You can use CSV files to fill your database with initial data - see [Location of CSV Files](#location-of-csv-files).

<div class="impl node">

For example, in our [*cap/samples/bookshop*](https://github.com/SAP-samples/cloud-cap-samples/tree/main/bookshop/db/data) application, we do so for *Books*, *Authors*, and *Genres* as follows:

```zsh
bookshop/
├─ db/
│ ├─ data/ # place your .csv files here
│ │ ├─ sap.capire.bookshop-Authors.csv
│ │ ├─ sap.capire.bookshop-Books.csv
│ │ ├─ sap.capire.bookshop-Books.texts.csv
│ │ └─ sap.capire.bookshop-Genres.csv
│ └─ schema.cds
└─ ...
```
</div>

<div class="impl java">

For example, in our [CAP Samples for Java](https://github.com/SAP-samples/cloud-cap-samples-java/tree/main/db/data) application, we do so for some entities such as *Books*, *Authors*, and *Genres* as follows:

```zsh
db/
├─ data/ # place your .csv files here
│ ├─ my.bookshop-Authors.csv
│ ├─ my.bookshop-Books.csv
│ ├─ my.bookshop-Books.texts.csv
│ ├─ my.bookshop-Genres.csv
│ └─ ...
└─ index.cds
```
</div>


The **filenames** are expected to match fully qualified names of respective entity definitions in your CDS models, optionally using a dash `-` instead of a dot `.` for cosmetic reasons.

### Using `.csv` Files

The **content** of these files is standard CSV content with the column titles corresponding to declared element names, like for `Books`:

::: code-group

```csvc [db/data/sap.capire.bookshop-Books.csv]
ID,title,author_ID,stock
201,Wuthering Heights,101,12
207,Jane Eyre,107,11
251,The Raven,150,333
252,Eleonora,150,555
271,Catweazle,170,22
```

:::

> Note: `author_ID` is the generated foreign key for the managed Association  `author` → learn more about that in the [Generating SQL DDL](#generating-sql-ddl) section.

If your content contains ...

- commas or line breaks → enclose it in double quotes `"..."`
- double quotes → escape them with doubled double quotes: `""...""`

```csvc
ID,title,descr
252,Eleonora,"""Eleonora"" is a short story by Edgar Allan Poe, first published in 1842 in Philadelphia in the literary annual The Gift."
```

::: danger
On SAP HANA, only use CSV files for _configuration data_ that can't be changed by application users.
→ See [CSV data gets overridden in the SAP HANA guide for details](databases-hana#csv-data-gets-overridden).
:::

### Use `cds add data`

Run this to generate an initial set of empty `.csv` files with header lines based on your CDS model:

```sh
cds add data
```

### Location of CSV Files

CSV files can be found in the folders _db/data_ and _test/data_, as well as in any _data_ folder next to your CDS model files. When you use `cds watch` or `cds deploy`, CSV files are loaded by default from _test/data_. However, when preparing for production deployments using `cds build`, CSV files from _test/data_ are not loaded.

::: details Adding initial data next to your data model
The content of these 'co-located' `.cds` files actually doesn't matter, but they need to be included in your data model, through a `using` clause in another file for example.

If you need to use certain CSV files exclusively for your production deployments, but not for tests, you can achieve this by including them in a separate data folder, for example, _db/hana/data_. Create an empty _index.cds_ file in the _hana_ folder. Then, set up this model location in a dummy cds service, for example _hanaDataSrv_, using the `[production]` profile.

```json
"cds": {
  "requires": {
    "[production]": {
      "hanaDataSrv ": { "model": "db/hana" }
     }
  }
}
````

As a consequence, when you run `cds build -–production` the model folder _hana_ is added, but it's not added when you run `cds deploy` or `cds watch` because the development profile is used by default. You can verify this by checking the cds build logs for the hana build task. Of course, this mechanism can also be used for PostgreSQL database deployments.
:::

::: details On SAP HANA ...
CSV and _hdbtabledata_ files found in the _src_ folder of your database module are treated as native SAP HANA artifacts and deployed as they are. This approach offers the advantage of customizing the _hdbtabledata_ files if needed, such as adding a custom `include_filter` setting to mix initial and customer data in one table. However, the downside is that you must redundantly maintain them to keep them in sync with your CSV files.
:::

Quite frequently you need to distinguish between sample data and real initial data. CAP supports this by allowing you to provide initial data in two places:

<div class="impl node">

| Location    | Deployed...          | Purpose                                                  |
| ----------- | -------------------- | -------------------------------------------------------- |
| `db/data`   | always               | initial data for configurations, code lists, and similar |
| `test/data` | if not in production | sample data for tests and demos                          |

</div>

<div class="impl java">

Use the properties [cds.dataSource.csv.*](../java/developing-applications/properties#cds-dataSource-csv) to configure the location of the CSV files. You can configure different sets of CSV files in different [Spring profiles](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#features.profiles). This configuration reads CSV data from `test/data` if the profile `test` is active:

::: code-group

```yaml [srv/src/main/resources/application.yaml]
---
spring:
  config.activate.on-profile: test
cds:
  dataSource.csv.paths:
  - test/data/**
```

:::
</div>





## Querying at Runtime




Most queries to databases are constructed and executed from [generic event handlers of CRUD requests](providing-services#serving-crud), so quite frequently there's nothing to do. The following is for the remaining cases where you have to provide custom logic, and as part of it execute database queries.




### DB-Agnostic Queries

<div class="impl node">

At runtime, we usually construct and execute queries using cds.ql APIs in a database-agnostic way. For example, queries like this are supported for all databases:

```js
SELECT.from (Authors, a => {
  a.ID, a.name, a.books (b => {
    b.ID, b.title
  })
})
.where ({name:{like:'A%'}})
.orderBy ('name')
```

</div>

<div class="impl java">

At runtime, we usually construct queries using the [CQL Query Builder API](../java/working-with-cql/query-api) in a database-agnostic way. For example, queries like this are supported for all databases:

```java
Select.from(AUTHOR)
      .columns(a -> a.id(), a -> a.name(),
               a -> a.books().expand(b -> b.id(), b.title()))
      .where(a -> a.name().startWith("A"))
      .orderBy(a -> a.name());
```

</div>

### Standard Operators {.node}

The database services guarantee the identical behavior of these operators:

* `==`, `=` — with `=` null being translated to `is null`
* `!=`, `<>` — with `!=` translated to `IS NOT` in SQLite, or to `IS DISTINCT FROM` in standard SQL, or to an equivalent polyfill in SAP HANA
* `<`, `>`, `<=`, `>=`, `IN`, `LIKE` — are supported as is in standard SQL

In particular, the translation of `!=` to `IS NOT` in SQLite — or to `IS DISTINCT FROM` in standard SQL, or to an equivalent polyfill in SAP HANA — greatly improves the portability of your code.


### Session Variables {.node}

The API shown after this, which includes the function `session_context()` and specific pseudo variable names, is supported by **all** new database services, that is, *SQLite*, *PostgreSQL* and *SAP HANA*.
This allows you to write the respective code once and run it on all these databases:

```sql
SELECT session_context('$user.id')
SELECT session_context('$user.locale')
SELECT session_context('$valid.from')
SELECT session_context('$valid.to')
```

Among other things, this allows us to get rid of static helper views for localized data like `localized_de_sap_capire_Books`.

### Native DB Queries

If required you can also use native database features by executing native SQL queries:

<div class="impl node">

```js
cds.db.run (`SELECT from sqlite_schema where name like ?`, name)
```
</div>

<div class="impl java">

Use Spring's [JDBC Template](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html) to [leverage native database features](../java/cqn-services/persistence-services#jdbctemplate) as follows:

```java
@Autowired
JdbcTemplate db;
...
db.queryForList("SELECT from sqlite_schema where name like ?", name);
```
</div>

### Reading `LargeBinary` / BLOB {.node}

Formerly, `LargeBinary` elements (or BLOBs) were always returned as any other data type. Now, they're skipped from `SELECT *` queries. Yet, you can still enforce reading BLOBs by explicitly selecting them. Then the BLOB properties are returned as readable streams.

```js
SELECT.from(Books)          //> [{ ID, title, ..., image1, image2 }] // [!code --]
SELECT.from(Books)          //> [{ ID, title, ... }]
SELECT(['image1', 'image2']).from(Books) //> [{ image1, image2 }] // [!code --]
SELECT(['image1', 'image2']).from(Books) //> [{ image1: Readable, image2: Readable }]
```

[Read more about custom streaming in Node.js.](../node.js/best-practices#custom-streaming-beta){.learn-more}


## Generating DDL Files {#generating-sql-ddl}

<div class="impl node">


When you run your server with `cds watch` during development, an in-memory database is bootstrapped automatically, with SQL DDL statements generated based on your CDS models.

You can also do this manually with the CLI command `cds compile --to <dialect>`.

</div>

<div class="impl java">

When you've created a CAP Java application with `cds init --java` or with CAP Java's [Maven archetype](../java/developing-applications/building#the-maven-archetype), the Maven build invokes the CDS compiler to generate a `schema.sql` file for your target database. In the `default` profile (development mode), an in-memory database is [initialized by Spring](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto.data-initialization) and the schema is bootstrapped from the `schema.sql` file.

[Learn more about adding an initial database schema.](../java/cqn-services/persistence-services#initial-database-schema){.learn-more}

</div>

### Using `cds compile`


For example, given these CDS models (derived from [*cap/samples/bookshop*](https://github.com/SAP-samples/cloud-cap-samples/tree/main/bookshop)):

::: code-group

```cds [db/schema.cds]
using { Currency } from '@sap/cds/common';
namespace sap.capire.bookshop;

entity Books {
  key ID : UUID;
  title  : localized String;
  descr  : localized String;
  author : Association to Authors;
  price  : {
    amount   : Decimal;
    currency : Currency;
  }
}

entity Authors {
  key ID : UUID;
  name  : String;
  books : Association to many Books on books.author = $self;
}
```
:::
::: code-group

```cds [srv/cat-service.cds]
using { sap.capire.bookshop as my } from '../db/schema';
service CatalogService {
  entity ListOfBooks as projection on Books {
    *, author.name as author
  }
}
```
:::


Generate an SQL DDL script by running this in the root directory containing both *.cds* files:

<div class="impl node">


```sh
cds compile srv/cat-service --to sql --dialect sqlite > schema.sql
```

Output:

::: code-group

```sql [schema.sql]
CREATE TABLE sap_capire_bookshop_Books (
  ID NVARCHAR(36) NOT NULL,
  title NVARCHAR(5000),
  descr NVARCHAR(5000),
  author_ID NVARCHAR(36),
  price_amount DECIMAL,
  price_currency_code NVARCHAR(3),
  PRIMARY KEY(ID)
);

CREATE TABLE sap_capire_bookshop_Authors (
  ID NVARCHAR(36) NOT NULL,
  name NVARCHAR(5000),
  PRIMARY KEY(ID)
);

CREATE TABLE sap_common_Currencies (
  name NVARCHAR(255),
  descr NVARCHAR(1000),
  code NVARCHAR(3) NOT NULL,
  symbol NVARCHAR(5),
  minorUnit SMALLINT,
  PRIMARY KEY(code)
);

CREATE TABLE sap_capire_bookshop_Books_texts (
  locale NVARCHAR(14) NOT NULL,
  ID NVARCHAR(36) NOT NULL,
  title NVARCHAR(5000),
  descr NVARCHAR(5000),
  PRIMARY KEY(locale, ID)
);

CREATE VIEW CatalogService_ListOfBooks AS SELECT
  Books.ID,
  Books.title,
  Books.descr,
  author.name AS author,
  Books.price_amount,
  Books.price_currency_code
FROM sap_capire_bookshop_Books AS Books
LEFT JOIN sap_capire_bookshop_Authors AS author
ON Books.author_ID = author.ID;

--- some more technical views skipped ...
```

:::

</div>


<div class="impl java">

```sh
cds compile srv/cat-service --to sql > schema.sql
```

Output:

::: code-group

```sql [schema.sql]
CREATE TABLE sap_capire_bookshop_Books (
  createdAt TIMESTAMP(7),
  createdBy NVARCHAR(255),
  modifiedAt TIMESTAMP(7),
  modifiedBy NVARCHAR(255),
  ID INTEGER NOT NULL,
  title NVARCHAR(111),
  descr NVARCHAR(1111),
  author_ID INTEGER,
  genre_ID INTEGER,
  stock INTEGER,
  price DECFLOAT,
  currency_code NVARCHAR(3),
  image BINARY LARGE OBJECT,
  PRIMARY KEY(ID)
);
CREATE TABLE sap_capire_bookshop_Books (
  ID NVARCHAR(36) NOT NULL,
  title NVARCHAR(5000),
  descr NVARCHAR(5000),
  author_ID NVARCHAR(36),
  price_amount DECIMAL,
  price_currency_code NVARCHAR(3),
  PRIMARY KEY(ID)
);

CREATE TABLE sap_capire_bookshop_Authors (
  ID NVARCHAR(36) NOT NULL,
  name NVARCHAR(5000),
  PRIMARY KEY(ID)
);

CREATE TABLE sap_common_Currencies (
  name NVARCHAR(255),
  descr NVARCHAR(1000),
  code NVARCHAR(3) NOT NULL,
  symbol NVARCHAR(5),
  minorUnit SMALLINT,
  PRIMARY KEY(code)
);

CREATE TABLE sap_capire_bookshop_Books_texts (
  locale NVARCHAR(14) NOT NULL,
  ID NVARCHAR(36) NOT NULL,
  title NVARCHAR(5000),
  descr NVARCHAR(5000),
  PRIMARY KEY(locale, ID)
);

CREATE VIEW CatalogService_ListOfBooks AS SELECT
  Books_0.createdAt,
  Books_0.modifiedAt,
  Books_0.ID,
  Books_0.title,
  Books_0.author,
  Books_0.genre_ID,
  Books_0.stock,
  Books_0.price,
  Books_0.currency_code,
  Books_0.image
FROM CatalogService_Books AS Books_0;
CREATE VIEW CatalogService_ListOfBooks AS SELECT
  Books.ID,
  Books.title,
  Books.descr,
  author.name AS author,
  Books.price_amount,
  Books.price_currency_code
FROM sap_capire_bookshop_Books AS Books
LEFT JOIN sap_capire_bookshop_Authors AS author
ON Books.author_ID = author.ID;

--- some more technical views skipped ...
```

:::

</div>

::: tip
Use the specific SQL dialect (`hana`, `sqlite`, `h2`, `postgres`) with `cds compile --to sql --dialect <dialect>` to get DDL that matches the target database.
:::


### Rules for Generated DDL

A few observations on the generated SQL DDL output:

1. **Tables / Views** — Declared entities become tables, projected entities become views.
2. **Type Mapping** — [CDS types are mapped to database-specific SQL types](../cds/types).
3. **Slugified FQNs** — Dots in fully qualified CDS names become underscores in SQL names.
4. **Flattened Structs** — Structured elements like `Books:price` are flattened with underscores.
5. **Generated Foreign Keys** — For managed to-one Associations, foreign key columns are created. For example, this applies to `Books:author`.





In addition, you can use the following annotations to fine-tune generated SQL.



### @cds.persistence.skip

Add `@cds.persistence.skip` to an entity to indicate that this entity should be skipped from generated DDL scripts, and also no SQL views to be generated on top of it:

```cds
@cds.persistence.skip
entity Foo {...}                 //> No SQL table will be generated
entity Bar as select from Foo;   //> No SQL view will be generated
```



### @cds.persistence.exists

Add `@cds.persistence.exists` to an entity to indicate that this entity should be skipped from generated DDL scripts. In contrast to `@cds.persistence.skip` a database relation is expected to exist, so we can generate SQL views on top.

```cds
@cds.persistence.exists
entity Foo {...}                 //> No SQL table will be generated
entity Bar as select from Foo;   //> The SQL view will be generated
```

::: details On SAP HANA ...

If the respective entity is a user-defined function or a calculation view, one of the annotations `@cds.persistence.udf` or `@cds.persistence.calcview` also needs to be assigned. See [Calculated Views and User-Defined Functions](../advanced/hana#calculated-views-and-user-defined-functions) for more details.

:::



### @cds.persistence.table

Annotate an entity with `@cds.persistence.table` to create a table with the effective signature of the view definition instead of an SQL view.

```cds
@cds.persistence.table
entity Foo as projection on Bar {...}
```

> All parts of the view definition not relevant for the signature (like `where`, `group by`, ...) are ignored.

Use case for this annotation: Use projections on imported APIs as replica cache tables.



### @sql.prepend / append

Use `@sql.prepend` and `@sql.append` to add native SQL clauses to before or after generated SQL output of CDS entities or elements.

Example:

````cds
@sql.append: ```sql
  GROUP TYPE foo
  GROUP SUBTYPE bar
```
entity E { ...,
  @sql.append: 'FUZZY SEARCH INDEX ON'
  text: String(100);
}

@sql.append: 'WITH DDL ONLY'
entity V as select from E { ... };
````

Output:

```sql
CREATE TABLE E ( ...,
  text NVARCHAR(100) FUZZY SEARCH INDEX ON
) GROUP TYPE foo
GROUP SUBTYPE bar;

CREATE VIEW V AS SELECT ... FROM E WITH DDL ONLY;
```

The following rules apply:

- The value of the annotation must be a [string literal](../cds/cdl#multiline-literals).

- The compiler doesn't check or process the provided SQL snippets in any way. You're responsible to ensure that the resulting statement is valid and doesn't negatively impact your database or your application. We don't provide support for problems caused by using this feature.

- If you refer to a column name in the annotation, you need to take care of
  a potential name mapping yourself, for example, for structured elements.

- Annotation `@sql.prepend` is only supported for entities translating to tables. It can't be used with views or with elements.
- For SAP HANA tables, there's an implicit `@sql.prepend: 'COLUMN'` that is overwritten by an explicitly provided `@sql.prepend`.

* Both `@sql.prepend` and `@sql.append` are disallowed in SaaS extension projects.

If you use native database clauses in combination with `@cds.persistence.journal`, see [Schema Evolution Support of Native Database Clauses](databases-hana#schema-evolution-native-db-clauses).



#### Creating a Row Table on SAP HANA

By using `@sql.prepend: 'ROW'`, you can create a row table:

```cds
@sql.prepend: 'ROW'
entity E {
  key id: Integer;
}
```

Run `cds compile - 2 hdbtable` on the previous sample and this is the result:

```sql [E.hdbtable]
ROW TABLE E (
  id INTEGER NOT NULL,
  PRIMARY KEY(id)
)
```

[Learn more about Columnar and Row-Based Data Storage](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-administration-guide/columnar-and-row-based-data-storage){.learn-more}
### Reserved Words

The CDS compiler and CAP runtimes provide smart quoting for reserved words in SQLite and in SAP HANA so that they can still be used in most situations. But in general reserved words can't be used as identifiers. The list of reserved words varies per database.

Find here a collection of resources on selected databases and their reference documentation:

* [SAP HANA SQL Reference Guide for SAP HANA Platform (Cloud Version)](https://help.sap.com/docs/HANA_SERVICE_CF/7c78579ce9b14a669c1f3295b0d8ca16/28bcd6af3eb6437892719f7c27a8a285.html)
* [SAP HANA SQL Reference Guide for SAP HANA Cloud](https://help.sap.com/docs/HANA_CLOUD_DATABASE/c1d3f60099654ecfb3fe36ac93c121bb/28bcd6af3eb6437892719f7c27a8a285.html)
* [SQLite Keywords](https://www.sqlite.org/lang_keywords.html)
* [H2 Keywords/Reserved Words](https://www.h2database.com/html/advanced.html#keywords)
* [PostgreSQL SQL Key Words](https://www.postgresql.org/docs/current/sql-keywords-appendix.html)

[There are also reserved words related to SAP Fiori.](../advanced/fiori#reserved-words){.learn-more}





## Database Constraints

### Not Null

You can specify that a column's value must not be `NULL` by adding the [`not null` constraint](../cds/cdl#null-values) to the element, for example:

```cds
entity Books {
  key ID: Integer;
  title: String not null;
}
```


### Unique

Annotate an entity with `@assert.unique.<constraintName>`, specifying one or more element combinations to enforce uniqueness checks on all CREATE and UPDATE operations. For example:

```cds
@assert.unique: {
  locale: [ parent, locale ],
  timeslice: [ parent, validFrom ],
}
entity LocalizedTemporalData {
  key record_ID : UUID; // technical primary key
  parent    : Association to Data;
  locale    : String;
  validFrom : Date;  
  validTo : Date;
}
```
{.indent}

The value of the annotation is an array of paths referring to elements in the entity. These elements may be of a scalar type, structs, or managed associations. Individual foreign keys or unmanaged associations are not supported.

If structured elements are specified, the unique constraint will contain all columns stemming from it. If the path points to a managed association, the unique constraint will contain all foreign key columns stemming from it.
::: tip
You don't need to specify `@assert.unique` constraints for the primary key elements of an entity as these are automatically secured by a SQL `PRIMARY KEY` constraint.
:::

### Foreign Keys

The information about foreign key relations contained in the associations of CDS models can be used to generate foreign key constraints on the database tables. Within CAP, referential consistency is established only at commit. The ["deferred" concept for foreign key constraints](https://www.sqlite.org/foreignkeys.html) in SQL databases allows the constraints to be checked and enforced at the time of the [COMMIT statement within a transaction](https://www.sqlite.org/lang_transaction.html) rather than immediately when the data is modified, providing more flexibility in maintaining data integrity.

Enable generation of foreign key constraints on the database with:

<Config>cds.features.assert_integrity = db</Config>

::: warning Database constraints are not supported for H2
Referential constraints on H2 cannot be defined as "deferred", which is needed for database constraints within CAP.
:::

With that switched on, foreign key constraints are generated for managed to-one associations. For example, given this model:

```cds
entity Books {
  key ID : Integer; ...
  author : Association to Authors;
}
entity Authors {
  key ID : Integer; ...
}
```

The following `Books_author` constraint would be added to table `Books`:

```sql
CREATE TABLE Authors (
  ID INTEGER NOT NULL,  -- primary key referenced by the constraint
  ...,
  PRIMARY KEY(ID)
);
CREATE TABLE Books (
  ID INTEGER NOT NULL,
  author_ID INTEGER,    -- generated foreign key field
  ...,
  PRIMARY KEY(ID),
  CONSTRAINT Books_author   -- constraint is explicitly named // [!code focus]
    FOREIGN KEY(author_ID)  -- link generated foreign key field author_ID ...
    REFERENCES Authors(ID)  -- ... with primary key field ID of table Authors
    ON UPDATE RESTRICT
    ON DELETE RESTRICT
    VALIDATED           -- validate existing entries when constraint is created
    ENFORCED            -- validate changes by insert/update/delete
    INITIALLY DEFERRED  -- validate only at commit
)
```

No constraints are generated for...
* Unmanaged associations or compositions
* To-many associations or compositions
* Associations annotated with `@assert.integrity: false`
* Associations where the source or target entity is annotated with `@cds.persistence.exists` or `@cds.persistence.skip`

If the association is the backlink of a **composition**, the constraint's delete rule changes to `CASCADE`.
That applies, for example, to the `parent` association in here:

```cds
entity Genres {
  key ID   : Integer;
  parent   : Association to Genres;
  children : Composition of many Genres on children.parent = $self;
}
```

As a special case, a referential constraint with `delete cascade` is also generated
for the text table of a [localized entity](../guides/localized-data#localized-data),
although no managed association is present in the `texts` entity.

Add a localized element to entity `Books` from the previous example:
```cds
entity Books {
  key ID : Integer; ...
  title : localized String;
}
```

The generated text table then is:
```sql
CREATE TABLE Books_texts (
  locale NVARCHAR(14) NOT NULL,
  ID INTEGER NOT NULL,
  title NVARCHAR(5000),
  PRIMARY KEY(locale, ID),
  CONSTRAINT Books_texts_texts // [!code focus]
    FOREIGN KEY(ID)
    REFERENCES Books(ID)
    ON UPDATE RESTRICT
    ON DELETE CASCADE
    VALIDATED
    ENFORCED
    INITIALLY DEFERRED
)
```

::: warning Database constraints aren't intended for checking user input
Instead, they protect the integrity of your data in the database layer against programming errors. If a constraint violation occurs, the error messages coming from the database aren't standardized by the runtimes but presented as-is.

→ Use [`@assert.target`](providing-services#assert-target) for corresponding input validations.
:::

## Standard Database Functions
{ #functions-mappings-for-runtime-queries }

A specified set of standard functions - inspired by [OData](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_StringandCollectionFunctions) and [SAP HANA](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-sql-reference-guide/alphabetical-list-of-functions?locale=en-US) - is supported in a **database-agnostic**, hence portable way, and translated to the best-possible native SQL functions or polyfills during runtime (currently only Node.js) and for your CDL files.


### OData standard functions

The `@sap/cds-compiler` and all CAP Node.js database services come with out of the box support for common OData functions.

::: warning Case Sensitivity
The OData function mappings are case-sensitive and must be written as in the list below.
:::

Assuming you have the following entity definition:

```cds
entity V as select from Books {
  startswith(title, 'Raven') as lowerCase, // mapped to native SQL equivalent
  startsWith(title, 'Raven') as camelCase, // passed as-is
}
```


Then you compile the SAP HANA artifacts:

`$ cds compile -2 sql --dialect hana`


This is the result:

```sql
CREATE VIEW V AS SELECT
  (CASE WHEN locate(title, 'Raven') = 1 THEN TRUE ELSE FALSE END) AS lowerCase,
  -- the below will most likely fail on SAP HANA
  startsWith(title, 'Raven') AS camelCase
FROM Books;
```

💡 If you want to use a DB native function or a UDF (User-Defined Function) instead of the OData function mappings, you can
do that by using a different casing than the OData function names as defined in the list below.
For example, `startsWith` instead of `startswith` will be passed as-is to the database.

#### String Functions

- `concat(x, y, ...)`
  Concatenates the given strings or numbers.

- `trim(x)`
  Removes leading and trailing whitespaces.

- `contains(x, y)`
  Checks whether `y` is contained in `x` (case-sensitive).

- `startswith(x, y)`
  Checks whether `y` starts with `x` (case-sensitive).

- `endswith(x, y)`
  Checks whether `y` ends with `x` (case-sensitive).

- `matchespattern(x, y)`
  Checks whether `x` matches the regular expression `y`.

- `indexof(x, y)` <sup>1</sup>
  Returns the index of the first occurrence of `y` in `x` (case-sensitive).

- `substring(x, i, n?)` <sup>1</sup>
  Extracts a substring from `x` starting at index `i` (0-based) with an optional length `n`.

  | Parameter | Positive | Negative | Omitted
  | --- | --- | --- | -- |
  | `i` | starts at index `i` | starts `i` positions before the end |
  | `n` | extracts `n` characters | invalid |  extracts until the end of the string

- `length(x)`
  Returns the length of the string `x`.

- `tolower(x)`
  Converts all characters in `x` to lowercase.

- `toupper(x)`
  Converts all characters in `x` to uppercase.

> <sup>1</sup> These functions work zero-based. For example, `substring('abcdef', 1, 3)` returns 'bcd'

#### Numeric Functions

- `ceiling(x)`
  Rounds the numeric parameter up to the nearest integer.

- `floor(x)`
  Rounds the numeric parameter down to the nearest integer.

- `round(x)`
  Rounds the numeric parameter to the nearest integer.
  The midpoint between two integers is rounded away from zero (e.g., `0.5` → `1` and `-0.5` → `-1`).

  ::: warning `round` function with more than one argument
  Note that most databases support `round` functions with multiple arguments,
  the second parameter being the precision. SAP HANA even has a third argument which is the rounding mode.
  If you provide more than one argument, the `round` function may behave differently depending on the database.
  :::

#### Date and Time Functions

- `year(x)`, `month(x)`, `day(x)`, `hour(x)`, `minute(x)`, `second(x)`
  Extracts and returns specific date / time parts as integer value from a given `cds.DateTime`, `cds.Date`, or `cds.Time`.

- `time(x)`, `date(x)`
  Extracts and returns a time or date from a given `cds.DateTime`, `cds.Date`, or `cds.Time`.

- `fractionalseconds(x)`
  Returns a `Decimal` representing the fractional seconds for a given `cds.Timestamp`.

- `maxdatetime()`
  Returns the latest possible point in time: `'9999-12-31T23:59:59.999Z'`.

- `mindatetime()`
  Returns the earliest possible point in time: `'0001-01-01T00:00:00.000Z'`.

#### Aggregate Functions

- `min(x)`, `max(x)`, `sum(x)`, `average(x)`, `count(x)`, `countdistinct(x)`
  Standard aggregate functions used to calculate minimum, maximum, sum, average, count, and distinct count of values.


### SAP HANA Functions

In addition to the OData standard functions, the `@sap/cds-compiler` and all CAP Node.js database services come with
out of the box support for some common SAP HANA functions, to further increase the scope for portable testing:

::: warning Upper- and Lowercase are supported
For the SAP HANA functions, both usages are allowed: all-lowercase as given above, as well as all-uppercase.
:::

- `years_between`
  Computes the number of years between two specified dates. ([link](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-sql-reference-guide/years-between-function-datetime?locale=en-US))
- `months_between`
  Computes the number of months between two specified dates. ([link](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-sql-reference-guide/months-between-function-datetime?locale=en-US))
- `days_between`
  Computes the number of days between two specified dates. ([link](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-sql-reference-guide/days-between-function-datetime?locale=en-US))
- `seconds_between`
  Computes the number of seconds between two specified dates. ([link](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-sql-reference-guide/seconds-between-function-datetime?locale=en-US))
- `nano100_between`
  Computes the time difference between two dates to the precision of 0.1 microseconds. ([link](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-sql-reference-guide/nano100-between-function-datetime?locale=en-US))

### Special Runtime Functions

In addition to the OData and SAP HANA standard functions, the **CAP runtimes** provides special functions that are only available for runtime queries:

- `search(x, y)`
  Checks whether `y` is contained in any element of `x` (fuzzy matching may apply).
  See [Searching Data](../guides/providing-services#searching-data) for more details.

- `session_context(<var>)`
  Utilizes standard variable names to maintain session context.
  Refer to [Session Variables](#session-variables) for additional information.

- `now()`
  Returns the current timestamp.

## Using Native Features  { #native-db-functions}

In general, the CDS 2 SQL compiler doesn't 'understand' SQL functions but translates them to SQL generically as long as they follow the standard call syntax of `function(param1, param2)`. This allows you to use native database functions inside your CDS models.

Example:

```cds
entity BookPreview as select from Books {
  IFNULL (descr, title) as shorttext   //> using HANA function IFNULL
};
```

The `OVER` clause for SQL Window Functions is supported, too:

```cds
entity RankedBooks as select from Books {
  name, author,
  rank() over (partition by author order by price) as rank
};
```



#### Using Native Functions with Different DBs { #sqlite-and-hana-functions}

In case of conflicts, follow these steps to provide different models for different databases:

1. Add database-specific schema extensions in specific subfolders of `./db`:

   ::: code-group

   ```cds [db/sqlite/index.cds]
   using { AdminService } from '..';
   extend projection AdminService.Authors with {
      strftime('%Y',dateOfDeath)-strftime('%Y',dateOfBirth) as age : Integer
   }
   ```

   ```cds [db/hana/index.cds]
   using { AdminService } from '..';
   extend projection AdminService.Authors with {
      YEARS_BETWEEN(dateOfBirth, dateOfDeath) as age : Integer
   }
   ```

   :::

2. Add configuration in specific profiles to your *package.json*, to use these database-specific extensions:

   ```json
   { "cds": { "requires": {
     "db": {
      "kind": "sql",
      "[development]": { "model": "db/sqlite" },
      "[production]": { "model": "db/hana" }
    }
   }}}
   ```
<div class="impl java">

:::info The following steps are only needed when you use two different local databases.

3. For CAP Java setups you might need to reflect the different profiles in your CDS Maven plugin configuration. This might not be needed for all setups, like using a standard local database (sqlite, H2, or PostgreSQL) and a production SAP HANA setup. In that case the local build defaults to the `development` profile. But for other setups, like using a local PostgreSQL and a local SQLite you'll need two (profiled) `cds deploy` commands:

   ```xml
    <execution>
      <id>cds.build</id>
      <goals>
        <goal>cds</goal>
      </goals>
      <configuration>
        <commands>
          <command>build --for java</command>
          <command>deploy --profile development --dry --out "${project.basedir}/src/main/resources/schema-h2.sql"</command>
          <command>deploy --profile production --dry --out "${project.basedir}/src/main/resources/schema-postresql.sql"</command>
        </commands>
      </configuration>
    </execution>
   ```

4. For the Spring Boot side it's similar. If you have a local development database and a hybrid profile with a remote SAP HANA database, you only need to run in default (or any other) profile. For the SAP HANA part, the build and deploy part is done separately and the application just needs to be started using `cds bind`.
Once you have 2 non-HANA local databases, you need to have 2 distinct database configurations in your Spring Boot configuration (in most cases application.yaml).

    ```yaml
    spring:
      config:
        activate:
          on-profile: default,h2
      sql:
        init:
          schema-locations: classpath:schema-h2.sql
    ---
    spring:
      config:
        activate:
          on-profile: postgresql
      sql:
        init:
          schema-locations: classpath:schema-postgresql.sql
      datasource:
        url: "jdbc:postgresql://localhost:5432/my_schema"
        driver-class-name: org.postgresql.Driver
        hikari:
          maximum-pool-size: 1
          max-lifetime: 0
    ```
  In case you use 2 different databases you also need to make sure that you have the JDBC drivers configured (on the classpath).

:::

</div>

CAP samples demonstrate this in [cap/samples/fiori](https://github.com/SAP-samples/cloud-cap-samples/commit/65c8c82f745e0097fab6ca8164a2ede8400da803). <br>
There's also a [code tour](https://github.com/SAP-samples/cloud-cap-samples#code-tours) available for that.



# Using SQLite for Development {#sqlite}

CAP provides extensive support for [SQLite](https://www.sqlite.org/index.html), which allows projects to speed up development by magnitudes at minimized costs. We strongly recommend using this option as much as possible during development and testing.

<div class="impl node">

::: tip New SQLite Service
This guide focuses on the new SQLite Service provided through *[@cap-js/sqlite](https://www.npmjs.com/package/@cap-js/sqlite)*, which has many advantages over the former one, as documented in the [*Features*](#features) section. To migrate from the old service, find instructions in the [*Migration*](#migration) section.
:::

</div>

<div class="impl java">

[Learn more about the features and limitations of using CAP with SQlite.](../java/cqn-services/persistence-services#sqlite){.learn-more}


</div>

<ImplVariantsHint />

## Setup & Configuration

<div class="impl node">

Run this to use SQLite for development:

```sh
npm add @cap-js/sqlite -D
```

### Auto-Wired Configuration {.node}

The `@cap-js/sqlite` package uses the `cds-plugin` technique to auto-configure your application for using an in-memory SQLite database for development.

You can inspect the effective configuration using `cds env`:

```sh
cds env requires.db
```

Output:

```js
{
  impl: '@cap-js/sqlite',
  credentials: { url: ':memory:' },
  kind: 'sqlite'
}
```

[See also the general information on installing database packages.](databases#setup-configuration){.learn-more}

</div>


### Using the Maven Archetype {.java}

When a new CAP Java project is created with the [Maven Archetype](../java/developing-applications/building#the-maven-archetype),
you can specify the in-memory database to be used. Use the option `-DinMemoryDatabase=sqlite` to create a project that uses
SQLite as in-memory database.

### Manual Configuration {.java}

To use SQLite, add a Maven dependency to the SQLite JDBC driver:

```xml
<dependency>
  <groupId>org.xerial</groupId>
  <artifactId>sqlite-jdbc</artifactId>
  <scope>runtime</scope>
</dependency>
```

Further configuration depends on whether you run SQLite as an [in-memory database](#in-memory-databases) or as a [file-based](#persistent-databases) database.

## Deployment

<div class="impl java">

### Initial Database Schema

Configure the build to create an initial _schema.sql_ file for SQLite using `cds deploy --to sqlite --dry --out srv/src/main/resources/schema.sql`.

::: code-group
```xml [srv/pom.xml]
<execution>
	<id>schema.sql</id>
	<goals>
		<goal>cds</goal>
	</goals>
	<configuration>
		<commands>
			<command>deploy --to sqlite --dry --out srv/src/main/resources/schema.sql</command>
		</commands>
	</configuration>
</execution>
```
:::


[Learn more about creating an initial database schema](/java/cqn-services/persistence-services#initial-database-schema-1){.learn-more}

</div>


### In-Memory Databases

<div class="impl node">


As stated previously, `@cap-js/sqlite` uses an in-memory SQLite database by default. For example, when starting your application with `cds watch`, you can see this in the log output:

```log
...
[cds] - connect to db > sqlite { url: ':memory:' } // [!code focus]
  > init from db/init.js
  > init from db/data/sap.capire.bookshop-Authors.csv
  > init from db/data/sap.capire.bookshop-Books.csv
  > init from db/data/sap.capire.bookshop-Books.texts.csv
  > init from db/data/sap.capire.bookshop-Genres.csv
/> successfully deployed to in-memory database. // [!code focus]
...
```

::: tip

Using in-memory databases is the most recommended option for test drives and test pipelines.

:::

</div>

<div class="impl java">


The database content is stored in-memory. Configure the DB connection in the non-productive `default` profile:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
---
spring:
  config.activate.on-profile: default
  sql:
    init:
      mode: always
  datasource:
    url: "jdbc:sqlite:file::memory:?cache=shared"
    driver-class-name: org.sqlite.JDBC
    hikari:
      maximum-pool-size: 1
      max-lifetime: 0
```
:::


[Learn how to configure an in-memory SQLite database.](../java/cqn-services/persistence-services#in-memory-storage){.learn-more}

</div>

### Persistent Databases



<div class="impl node">


You can also use persistent SQLite databases. Follow these steps to do so:

</div>

<div class="impl java">


You can also use persistent SQLite databases. In this case, the schema is initialized by `cds deploy` and not by Spring. Follow these steps:

</div>

1. Specify a database filename in your `db` configuration as follows:

   ::: code-group

   ```json [package.json]
   { "cds": { "requires": {
      "db": {
         "kind": "sqlite",
         "credentials": { "url": "db.sqlite" } // [!code focus]
      }
   }}}
   ```

   :::

2. Run `cds deploy`:

   ```sh
   cds deploy
   ```

This will:

1. Create a database file with the given name.
2. Create the tables and views according to your CDS model.
3. Fill in initial data from the provided _.csv_ files.

<div class="impl node">


With that in place, the server will use this prepared database instead of bootstrapping an in-memory one upon startup:

```log
...
[cds] - connect to db > sqlite { url: 'db.sqlite' }
...
```

</div>

<div class="impl java">


Finally, configure the DB connection - ideally in a dedicated `sqlite` profile:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
---
spring:
  config.activate.on-profile: sqlite
  datasource:
    url: "jdbc:sqlite:db.sqlite"
    driver-class-name: org.sqlite.JDBC
    hikari:
      maximum-pool-size: 1
```
:::

[Learn how to configure a file-based SQLite database](../java/cqn-services/persistence-services#file-based-storage){.learn-more}

</div>

::: tip Redeploy on changes

Remember to always redeploy your database whenever you change your models or your data. Just run `cds deploy` again to do so.

:::

### Drop-Create Schema

When you redeploy your database, it will always drop-create all tables and views. This is **most suitable for development environments**, where schema changes are very frequent and broad.

### Schema Evolution

While drop-create is most appropriate for development, it isn't suitable for database upgrades in production, as all customer data would be lost. To avoid this, `cds deploy` also supports automatic schema evolution, which you can use as follows:

1. Enable automatic schema evolution in your `db` configuration:

   ::: code-group

   ```json [package.json]
   { "cds": { "requires": {
      "db": {
         "kind": "sqlite",
         "credentials": { "url": "db.sqlite" },
         "schema_evolution": "auto" // [!code focus]
      }
   }}}
   ```

   :::

2. Run `cds deploy`:

   ```sh
   cds deploy
   ```



[Learn more about automatic schema evolution in the PostgreSQL guide. <br>The information in there is also applicable to SQLite with persistent databases.](databases-postgres#schema-evolution) {.learn-more}



## Features

<div class="impl java">

CAP supports most of the major features on SQLite:

* [Path Expressions](../java/working-with-cql/query-api#path-expressions) & Filters
* [Expands](../java/working-with-cql/query-api#projections)
* [Localized Queries](../guides/localized-data#read-operations)
* [Comparison Operators](../java/working-with-cql/query-api#comparison-operators)
* [Predicate Functions](../java/working-with-cql/query-api#predicate-functions)

[Learn about features and limitations of SQLite.](../java/cqn-services/persistence-services#sqlite){.learn-more}

</div>

<div class="impl node">

The following is an overview of advanced features supported by the new database services.

> These apply to all new database services, including SQLiteService, HANAService, and PostgresService.



### Path Expressions & Filters {.node}

The new database service provides **full support** for all kinds of [path expressions](../cds/cql#path-expressions), including [infix filters](../cds/cql#with-infix-filters) and [exists predicates](../cds/cql#exists-predicate). For example, you can try this out with *[cap/samples](https://github.com/sap-samples/cloud-cap-samples)* as follows:

```js
// $ cds repl --profile better-sqlite
var { server } = await cds.test('bookshop'), { Books, Authors } = cds.entities
await INSERT.into (Books) .entries ({ title: 'Unwritten Book' })
await INSERT.into (Authors) .entries ({ name: 'Upcoming Author' })
await SELECT `from ${Books} { title as book, author.name as author, genre.name as genre }`
await SELECT `from ${Authors} { books.title as book, name as author, books.genre.name as genre }`
await SELECT `from ${Books} { title as book, author[ID<170].name as author, genre.name as genre }`
await SELECT `from ${Books} { title as book, author.name as author, genre.name as genre }` .where ({'author.name':{like:'Ed%'},or:{'author.ID':170}})
await SELECT `from ${Books} { title as book, author.name as author, genre.name as genre } where author.name like 'Ed%' or author.ID=170`
await SELECT `from ${Books}:author[name like 'Ed%' or ID=170] { books.title as book, name as author, books.genre.name as genre }`
await SELECT `from ${Books}:author[150] { books.title as book, name as author, books.genre.name as genre }`
await SELECT `from ${Authors} { ID, name, books { ID, title }}`
await SELECT `from ${Authors} { ID, name, books { ID, title, genre { ID, name }}}`
await SELECT `from ${Authors} { ID, name, books.genre { ID, name }}`
await SELECT `from ${Authors} { ID, name, books as some_books { ID, title, genre.name as genre }}`
await SELECT `from ${Authors} { ID, name, books[genre.ID=11] as dramatic_books { ID, title, genre.name as genre }}`
await SELECT `from ${Authors} { ID, name, books.genre[name!='Drama'] as no_drama_books_count { count(*) as sum }}`
await SELECT `from ${Authors} { books.genre.ID }`
await SELECT `from ${Authors} { books.genre }`
await SELECT `from ${Authors} { books.genre.name }`

```



### Optimized Expands {.node}

The old database service implementation(s) used to translate deep reads, that is, SELECTs with expands, into several database queries and collect the individual results into deep result structures. The new service uses `json_object` and other similar functions to instead do that in one single query, with sub selects, which greatly improves performance.

For example:

```sql
SELECT.from(Authors, a => {
  a.ID, a.name, a.books (b => {
    b.title, b.genre (g => {
       g.name
    })
  })
})
```

While this used to require three queries with three roundtrips to the database, now only one query is required.





### Localized Queries {.node}

With the old implementation, running queries like `SELECT.from(Books)` would always return localized data, without being able to easily read the non-localized data. The new service does only what you asked for, offering new `SELECT.localized` options:

```js
let books = await SELECT.from(Books)       //> non-localized data
let lbooks = await SELECT.localized(Books) //> localized data
```

Usage variants include:

```js
SELECT.localized(Books)
SELECT.from.localized(Books)
SELECT.one.localized(Books)
```

### Using Lean Draft {.node}

The old implementation was overly polluted with draft handling. But as draft is actually a Fiori UI concept, none of that should show up in database layers. Hence, we eliminated all draft handling from the new database service implementations, and implemented draft in a modular, non-intrusive way — called *'Lean Draft'*. The most important change is that we don't do expensive UNIONs anymore but work with single (cheap) selects.



### Consistent Timestamps {.node}

Values for elements of type `DateTime`  and `Timestamp` are handled in a consistent way across all new database services along these lines:

:::tip *Timestamps* = `Timestamp` as well as `DateTime`

When we say *Timestamps*, we mean elements of type `Timestamp` as well as `DateTime`. Although they have different precision levels, they are essentially the same type. `DateTime` elements have seconds precision, while `Timestamp` elements have milliseconds precision in SQLite, and microsecond precision in SAP HANA and PostgreSQL.

:::



#### Writing Timestamps

When writing data using INSERT, UPSERT or UPDATE, you can provide values for `DateTime` and `Timestamp` elements as JavaScript  `Date` objects or ISO 8601 Strings. All input is normalized to ensure `DateTime` and `Timestamp` values can be safely compared. In case of SAP HANA and PostgreSQL, they're converted to native types. In case of SQLite, they're stored as ISO 8601 Strings in Zulu timezone as returned by JavaScript's `Date.toISOString()`.

For example:

```js
await INSERT.into(Books).entries([
  { createdAt: new Date },                       //> stored .toISOString()
  { createdAt: '2022-11-11T11:11:11Z' },         //> padded with .000Z
  { createdAt: '2022-11-11T11:11:11.123Z' },     //> stored as is
  { createdAt: '2022-11-11T11:11:11.1234563Z' }, //> truncated to .123Z
  { createdAt: '2022-11-11T11:11:11+02:00' },    //> converted to zulu time
])
```



#### Reading Timestamps

Timestamps are returned as they're stored in a normalized way, with milliseconds precision, as supported by the JavaScript `Date` object. For example, the entries inserted previously would return the following:

```js
await SELECT('createdAt').from(Books).where({title:null})
```

```js
[
  { createdAt: '2023-08-10T14:24:30.798Z' },
  { createdAt: '2022-11-11T11:11:11.000Z' },
  { createdAt: '2022-11-11T11:11:11.123Z' },
  { createdAt: '2022-11-11T11:11:11.123Z' },
  { createdAt: '2022-11-11T09:11:11.000Z' }
]
```

`DateTime` elements are returned with seconds precision, with all fractional second digits truncated. That is, if the `createdAt` in our examples was a `DateTime`, the previous query would return this:

```js
[
  { createdAt: '2023-08-10T14:24:30Z' },
  { createdAt: '2022-11-11T11:11:11Z' },
  { createdAt: '2022-11-11T11:11:11Z' },
  { createdAt: '2022-11-11T11:11:11Z' },
  { createdAt: '2022-11-11T09:11:11Z' }
]
```



#### Comparing DateTimes & Timestamps

You can safely compare DateTimes & Timestamps with each other and with input values. The input values have to be `Date` objects or ISO 8601 Strings in Zulu timezone with three fractional digits.

For example, all of these would work:

```js
SELECT.from(Foo).where `someTimestamp = anotherTimestamp`
SELECT.from(Foo).where `someTimestamp = someDateTime`
SELECT.from(Foo).where `someTimestamp = ${new Date}`
SELECT.from(Foo).where `someTimestamp = ${req.timestamp}`
SELECT.from(Foo).where `someTimestamp = ${'2022-11-11T11:11:11.123Z'}`
```

While these would fail, because the input values don't comply to the rules:

```js
SELECT.from(Foo).where `createdAt = ${'2022-11-11T11:11:11+02:00'}` // non-Zulu time zone
SELECT.from(Foo).where `createdAt = ${'2022-11-11T11:11:11Z'}` // missing 3-digit fractions
```

> This is because we can never reliably infer the types of input to `where` clause expressions. Therefore, that input will not receive any normalisation, but be passed down as is as plain string.

:::tip Always ensure proper input in `where` clauses

Either use strings strictly in `YYYY-MM-DDThh:mm:ss.fffZ` format, or `Date` objects, as follows:

```js
SELECT.from(Foo).where ({ createdAt: '2022-11-11T11:11:11.000Z' })
SELECT.from(Foo).where ({ createdAt: new Date('2022-11-11T11:11:11Z') })
```

:::

The rules regarding Timestamps apply to all comparison operators: `=`, `<`, `>`, `<=`, `>=`.



### Improved Performance {.node}

The combination of the above-mentioned improvements commonly leads to significant performance improvements. For example, displaying the list page of Travels in [cap/sflight](https://github.com/SAP-samples/cap-sflight) took **>250ms** in the past, and **~15ms** now.





## Migration {.node}



While we were able to keep all public APIs stable, we had to apply changes and fixes to some **undocumented behaviours and internal APIs** in the new implementation. While not formally breaking changes, you may have used or relied on these undocumented APIs and behaviours. In that case, you can find instructions about how to resolve this in the following sections.

> These apply to all new database services: SQLiteService, HANAService, and PostgresService.



### Use Old and New in Parallel {.node}

During migration, you may want to occasionally run and test your app with both the new SQLite service and the old one. You can accomplish this as follows:

1. Add the new service with `--no-save`:
   ```sh
   npm add @cap-js/sqlite --no-save
   ```

   > This bypasses the *cds-plugin* mechanism, which works through package dependencies.

2. Run or test your app with the `better-sqlite` profile using one of these options:

   ```sh
   cds watch bookshop --profile better-sqlite
   ```

   ```sh
   CDS_ENV=better-sqlite cds watch bookshop
   ```

   ```sh
   CDS_ENV=better-sqlite jest --silent
   ```

3. Run or test your app with the old SQLite service as before:
   ```sh
   cds watch bookshop
   ```
   ```sh
   jest --silent
   ```


### Avoid UNIONs and JOINs {.node}

Many advanced features supported by the new database services, like path expressions or deep expands, rely on the ability to infer queries from CDS models. This task gets extremely complex when adding UNIONs and JOINs to the equation — at least the effort and overhead is hardly matched by generated value. Therefore, we dropped support of UNIONs and JOINs in CQN queries.

For example, this means queries like these are deprecated / not supported any longer:

```js
SELECT.from(Books).join(Authors,...)
```

Mitigations:

1. Use [path expressions](#path-expressions-filters) instead of joins. (The former lack of support for path expressions was the most common reason for having to use joins at all.)

2. Use plain SQL queries like so:

   ```js
   await db.run(`SELECT from ${Books} join ${Authors} ...`)
   ```

3. Use helper views modeled in CDS, which still supports all complex UNIONs and JOINs, then use this view via `cds.ql`.





### Fixed Localized Data {.node}

Formerly, when reading data using `cds.ql`, this *always* returned localized data. For example:

```js
SELECT.from(Books)       // always read from localized.Books instead
```

This wasn't only wrong, but also expensive. Localized data is an application layer concept. Database services should return what was asked for, and nothing else. → Use [*Localized Queries*](#localized-queries) if you really want to read localized data from the database:

```js
SELECT.localized(Books)  // reads localized data
SELECT.from(Books)       // reads plain data
```

::: details No changes to app services behaviour

Generic application service handlers use *SELECT.localized* to request localized data from the database. Hence, CAP services automatically serve localized data as before.

:::

### Skipped Virtuals {.node}

In contrast to their former behaviour, new database services ignore all virtual elements and hence don't add them to result set entries. Selecting only virtual elements in a query leads to an error.

::: details Reasoning

Virtual elements are meant to be calculated and filled in by custom handlers of your application services. Nevertheless, the old database services always returned `null`, or specified `default` values for virtual elements. This behavior was removed, as it provides very little value, if at all.

:::

For example, given this definition:

```cds
entity Foo {
  foo : Integer;
  virtual bar : Integer;
}
```

The behaviour has changed to:

```js
[dev] cds repl
> SELECT.from('Foo')         //> [{ foo:1, bar:null }, ...] // [!code --]
> SELECT.from('Foo')         //> [{ foo:1 }, ...]
> SELECT('bar').from('Foo')  //> ERROR: no columns to read
```

### <> Operator {.node}

Before, both `<>` and `!=` were translated to `name <> 'John' OR name is null`.
* The operator `<>` now works as specified in the SQL standard.
* `name != 'John'` is translated as before to `name <> 'John' OR name is null`.


::: warning
This is a breaking change in regard to the previous implementation.
:::

### Miscellaneous {.node}

- Only `$now` and `$user` are supported as values for `@cds.on.insert/update`.
- Managed fields are automatically filled with `INSERT.entries()`, but not when using `INSERT.columns().values()` or `INSERT.columns().rows()`.
- If the column of a `SELECT` is a path expression without an alias, the field name in the result is the concatenated name using underscores. For example, `SELECT.from(Books).columns('author.name')` results in `author_name`.
- CQNs with subqueries require table aliases to refer to elements of outer queries.
- Table aliases must not contain dots.
- CQNs with an empty columns array now throw an error.
- `*` isn't a column reference. Use `columns: ['*']` instead of `columns: [{ref:'*'}]`.
- Column names in CSVs must map to physical column names:

```csvc
ID;title;author_ID;currency_code // [!code ++]
ID;title;author.ID;currency.code // [!code --]
```



### Adopt Lean Draft  {.node}

As mentioned in [Using Lean Draft](#using-lean-draft), we eliminated all draft handling from new database service implementations, and instead implemented draft in a modular, non-intrusive, and optimized way — called *'Lean Draft'*.

When using the new service, the new `cds.fiori.lean_draft` mode is automatically switched on.

More detailed documentation for that is coming.





### Finalizing Migration  {.node}

When you have finished migration, remove the old [*sqlite3* driver](https://www.npmjs.com/package/sqlite3) :

```sh
npm rm sqlite3
```

And activate the new one as cds-plugin:

```sh
npm add @cap-js/sqlite --save
```

</div>

## SQLite in Production?

As stated in the beginning, SQLite is mostly intended to speed up development, but is not fit for production. This is not because of limited warranties or lack of support, but rather because of suitability.

A major criterion is this: cloud applications are usually served by server clusters, in which each server is connected to a shared database. SQLite could only be used in such setups with the persistent database file accessed through a network file system. This is rarely available and results in slow performance. Hence, an enterprise client-server database is a more fitting choice for these scenarios.

Having said this, there can indeed be scenarios where SQLite might also be used in production, such as using SQLite as in-memory caches. → [Find a detailed list of criteria on the sqlite.org website](https://www.sqlite.org/whentouse.html).

::: warning
SQLite only has limited support for concurrent database access due to its very coarse lock granularity. This makes it badly suited for applications with high concurrency.
:::





# Using H2 for Development in CAP Java

For local development and testing, CAP Java supports the [H2](https://www.h2database.com/) database, which can be configured to run in-memory.

[Learn more about features and limitations of using CAP with H2](../java/cqn-services/persistence-services#h2){.learn-more}

<div class="impl node">

::: warning
Not supported for CAP Node.js.
:::

</div>


<div class="impl java">

</div>

## Setup & Configuration {.java}

### Using the Maven Archetype {.java}

When a new CAP Java project is created with the [Maven Archetype](../java/developing-applications/building#the-maven-archetype) or with `cds init`,
H2 is automatically configured as in-memory database used for development and testing in the `default` profile.

### Manual Configuration {.java}

To use H2, just add a Maven dependency to the H2 JDBC driver:

```xml
<dependency>
  <groupId>com.h2database</groupId>
  <artifactId>h2</artifactId>
  <scope>runtime</scope>
</dependency>
```

Next, configure the build to [create an initial _schema.sql_ file](../java/cqn-services/persistence-services#initial-database-schema-1) for H2 using `cds deploy --to h2 --dry`.

In Spring, H2 is automatically initialized as in-memory database when the driver is present on the classpath.

[Learn more about the configuration of H2 ](../java/cqn-services/persistence-services#h2){.learn-more}

## Features {.java}

CAP supports most of the major features on H2:

* [Path Expressions](../java/working-with-cql/query-api#path-expressions) & Filters
* [Expands](../java/working-with-cql/query-api#projections)
* [Localized Queries](../guides/localized-data#read-operations)
* [Comparison Operators](../java/working-with-cql/query-api#comparison-operators)
* [Predicate Functions](../java/working-with-cql/query-api#predicate-functions)

[Learn about features and limitations of H2](../java/cqn-services/persistence-services#h2){.learn-more}



# Using PostgreSQL

<div class="impl node">

This guide focuses on the new PostgreSQL Service provided through *[@cap-js/postgres](https://www.npmjs.com/package/@cap-js/postgres)*, which is based on the same new database services architecture as the new [SQLite Service](databases-sqlite). This architecture brings significantly enhanced feature sets and feature parity, as documented in the [*Features* section of the SQLite guide](databases-sqlite#features).

*Learn about migrating from the former `cds-pg` in the [Migration](#migration) chapter.*{.learn-more}

</div>

<div class="impl java">

CAP Java 3 is tested on [PostgreSQL](https://www.postgresql.org/) 16 and most CAP features are supported on PostgreSQL.

[Learn more about features and limitations of using CAP with PostgreSQL](../java/cqn-services/persistence-services#postgresql){.learn-more}

</div>

<ImplVariantsHint />

## Setup & Configuration

<div class="impl node">

Run this to use [PostgreSQL](https://www.postgresql.org/) for production:

</div>

<div class="impl java">

To run CAP Java on PostgreSQL, add a Maven dependency to the PostgreSQL feature in `srv/pom.xml`:

```xml
<dependency>
    <groupId>com.sap.cds</groupId>
    <artifactId>cds-feature-postgresql</artifactId>
    <scope>runtime</scope>
</dependency>
```

In order to use the CDS tooling with PostgreSQL, you also need to install the module `@cap-js/postgres`:

</div>

```sh
npm add @cap-js/postgres
```

<div class="impl java">

After that, you can use the `cds deploy` command to [deploy](#using-cds-deploy) to a PostgreSQL database or to [create a DDL script](#deployment-using-liquibase) for PostgreSQL.

</div>

### Auto-Wired Configuration {.node}

The `@cap-js/postgres` package uses `cds-plugin` technique to auto-configure your application and use a PostgreSQL database for production.

You can inspect the effective configuration using `cds env`:

```sh
cds env requires.db --for production
```

Output:

```js
{
  impl: '@cap-js/postgres',
  dialect: 'postgres',
  kind: 'postgres'
}
```

[See also the general information on installing database packages](databases#setup-configuration){.learn-more}

## Provisioning a DB Instance

To connect to a PostgreSQL offering from the cloud provider in Production, leverage the [PostgreSQL on SAP BTP, hyperscaler option](https://discovery-center.cloud.sap/serviceCatalog/postgresql-hyperscaler-option). For local development and testing convenience, you can run PostgreSQL in a [docker container](#using-docker).


<div class="impl java">

To consume a PostgreSQL instance from a CAP Java application running on SAP BTP, consider the following:

- Only the Java buildpack `java_buildpack` provided by the Cloud Foundry community allows to consume a PostgreSQL service from a CAP Java application.

- By default, the `java_buildpack` initializes a PostgreSQL datasource with the Java CFEnv library. However, to work properly with CAP, the PostgreSQL datasource must be created by the CAP Java runtime and not by the buildpack. You need to disable the [datasource initialization by the buildback](https://docs.cloudfoundry.org/buildpacks/java/configuring-service-connections.html) using `CFENV_SERVICE_<POSTGRESQL_SERVICE_NAME>_ENABLED: false` at your CAP Java service module.

The following example shows these configuration settings applied to a CAP Java service:

::: code-group
```yaml [mta.yaml]
modules:
  - name: bookshop-pg-srv
    type: java
    path: srv
    parameters:
      buildpack: java_buildpack
    properties:
        SPRING_PROFILES_ACTIVE: cloud
        JBP_CONFIG_COMPONENTS: '{jres: ["JavaBuildpack::Jre::SapMachineJRE"]}'
        JBP_CONFIG_SAP_MACHINE_JRE: '{ jre: { version: "17.+" } }'
        CFENV_SERVICE_BOOKSHOP-PG-DB_ENABLED: false
```

:::

> `BOOKSHOP-PG-DB` is the real PostgreSQL service instance name in this example.
</div>


### Using Docker

You can use Docker to run a PostgreSQL database locally as follows:

1. Install and run [Docker Desktop](https://www.docker.com)

2. Create the following file in your project root directory:
   ::: code-group

   ```yaml [pg.yml]
   services:
     db:
       image: postgres:alpine
       environment: { POSTGRES_PASSWORD: postgres }
       ports: [ '5432:5432' ]
       restart: always
   ```

   :::

3. Create and run the docker container:

   ```sh
   docker-compose -f pg.yml up -d
   ```

<div class="impl java">

::: tip
With the introduction of [Testcontainers support](https://spring.io/blog/2023/06/23/improved-testcontainers-support-in-spring-boot-3-1) in Spring Boot 3.1, you can create PostgreSQL containers on the fly for local development or testing purposes.
:::

</div>

## Service Bindings

You need a service binding to connect to the PostgreSQL database.

In the cloud, use given techniques to bind a cloud-based instance of PostgreSQL to your application.

<div class="impl node">

For local development provide the credentials using a suitable [`cds env`](../node.js/cds-env) technique, like one of the following.

</div>

### Configure Connection Data {.java}

If a PostgreSQL service binding exists, the corresponding `DataSource` is auto-configured.

You can also explicitly [configure the connection data](../java/cqn-services/persistence-services#postgres-connection) of your PostgreSQL database in the _application.yaml_ file.
If you run the PostgreSQL database in a [docker container](#using-docker) your connection data might look like this:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
spring:
  config.activate.on-profile: postgres-docker
  datasource:
    url: jdbc:postgresql://localhost:5432/postgres
    username: postgres
    password: postgres
    driver-class-name: org.postgresql.Driver
```
:::
To start the application with the new profile `postgres-docker`, the `spring-boot-maven-plugin` can be used: `mvn spring-boot:run -Dspring-boot.run.profiles=postgres-docker`.

[Learn more about the configuration of a PostgreSQL database](../java/cqn-services/persistence-services#postgresql-1){ .learn-more}

### Service Bindings for CDS Tooling {.java}

#### Using Defaults with `[pg]` Profile {.java}

`@cds-js/postgres` comes with a set of default credentials under the profile `[pg]` that matches the defaults used in the [docker setup](#using-docker). So, if you stick to these defaults you can skip to deploying your database with:

```sh
cds deploy --profile pg
```

#### In Your Private `.cdsrc-private.json` {.java}

If you don't use the default credentials and want to use just `cds deploy`, you need to configure the service bindings (connection data) for the CDS tooling. Add the connection data to your private `.cdsrc-private.json`:

```json
{
  "requires": {
    "db": {
      "kind": "postgres",
      "credentials": {
        "host": "localhost",
        "port": 5432,
        "user": "postgres",
        "password": "postgres",
        "database": "postgres"
      }
    }
  }
}
```

### Configure Service Bindings {.node}

#### Using Defaults with `[pg]` Profile

The `@cds-js/postgres` comes with default credentials under profile `[pg]` that match the defaults used in the [docker setup](#using-docker). So, in case you stick to these defaults you can skip the next sections and just go ahead, deploy your database:

```sh
cds deploy --profile pg
```

Run your application:

```sh
cds watch --profile pg
```

Learn more about that in the [Deployment](#deployment) chapter below.{.learn-more}



#### In Your private `~/.cdsrc.json`

Add it to your private `~/.cdsrc.json` if you want to use these credentials on your local machine only:

::: code-group

```json [~/.cdsrc.json]
{
  "requires": {
    "db": {
      "[pg]": {
        "kind": "postgres",
        "credentials": {
          "host": "localhost", "port": 5432,
          "user": "postgres",
          "password": "postgres",
          "database": "postgres"
        }
      }
    }
  }
}
```

:::

#### In Project `.env` Files

Alternatively, use a `.env` file in your project's root folder if you want to share the same credentials with your team:

::: code-group

```properties [.env]
cds.requires.db.[pg].kind = postgres
cds.requires.db.[pg].credentials.host = localhost
cds.requires.db.[pg].credentials.port = 5432
cds.requires.db.[pg].credentials.user = postgres
cds.requires.db.[pg].credentials.password = postgres
cds.requires.db.[pg].credentials.database = postgres
```

:::

::: tip Using Profiles

The previous configuration examples use the [`cds.env` profile](../node.js/cds-env#profiles) `[pg]` to allow selectively testing with PostgreSQL databases from the command line as follows:

```sh
cds watch --profile pg
```

The profile name can be freely chosen, of course.

:::



## Deployment

### Using `cds deploy`

Deploy your database as usual with that:

```sh
cds deploy
```

Or with that if you used profile `[pg]` as introduced in the setup chapter above:

```sh
cds deploy --profile pg
```

### With a Deployer App

When deploying to Cloud Foundry, this can be accomplished by providing a simple deployer app. Similar to SAP HANA deployer apps, it is auto-generated for PostgreSQL-enabled projects by running

```sh
cds build --production
```

::: details What `cds build` does…
1. Compiles the model into _gen/pg/db/csn.json_.
2. Copies required `.csv` files into _gen/pg/db/data_.
3. Adds a _gen/pg/package.json_ with this content:
   ```json
   {
     "dependencies": {
       "@sap/cds": "^9",
       "@cap-js/postgres": "^2"
     },
     "scripts": {
       "start": "cds-deploy"
     }
   }
   ```

> **Note the dash in `cds-deploy`**, which is required as we don't use `@cds-dk` for deployment and runtime, so the `cds` CLI executable isn't available.
:::


### Add PostgreSQL Deployment Configuration

```sh
cds add postgres
```

::: details See what this does…
1. Adds `@cap-js/postgres` dependency to your _package.json_ `dependencies`.
2. Sets up deployment descriptors such as _mta.yaml_ to use a PostgreSQL instance deployer application.
3. Wires up the PostgreSQL service to your deployer app and CAP backend.
:::

### Deploy

You can package and deploy that application, for example using [MTA-based deployment](deployment/to-cf#add-mta-yaml).

## Automatic Schema Evolution { #schema-evolution }

When redeploying after you changed your CDS models, like adding fields, automatic schema evolution is applied. Whenever you  run `cds deploy` (or `cds-deploy`) it executes these steps:

1. Read a CSN of a former deployment from table `cds_model`.
2. Calculate the **delta** to current model.
3. Generate and run DDL statements with:
   - `CREATE TABLE` statements for new entities
   - `CREATE VIEW` statements for new views
   - `ALTER TABLE` statements for entities with new or changed elements
   - `DROP & CREATE VIEW` statements for views affected by changed entities
4. Fill in initial data from provided _.csv_ files using `UPSERT` commands.
5. Store a CSN representation of the current model in `cds_model`.


> You can disable automatic schema evolution, if necessary, by setting <Config>cds.requires.db.schema_evolution = false</Config>.

::: danger No manual altering

Manually altering the database will most likely break automatic schema evolution!

:::

### Limitations

Automatic schema evolution only allows changes without potential data loss.

#### Allowed{.good}

- Adding entities and elements
- Increasing the length of Strings
- Increasing the size of Integers

#### Disallowed{.bad}

- Removing entities or elements
- Changes to primary keys
- All other type changes

For example the following type changes are allowed:

```cds
entity Foo {
   anInteger : Int64;     // from former: Int32
   aString : String(22);  // from former: String(11)
}
```

::: tip

If you need to apply such disallowed changes during development, just drop and re-create your database, for example by killing it in docker and re-create it using the `docker-compose` command, [see Using Docker](#using-docker).

:::



### Dry-Run Offline

You can use `cds deploy` with option `--dry` to simulate and inspect how things work.

1. Capture your current model in a CSN file:

   ```sh
   cds deploy --dry --model-only --out cds-model.csn
   ```

2. Change your models, for example in *[cap/samples/bookshop/db/schema.cds](https://github.com/SAP-samples/cloud-cap-samples/blob/main/bookshop/db/schema.cds)*:

   ```cds
   entity Books { ...
      title : localized String(222); //> increase length from 111 to 222
      foo : Association to Foo;      //> add a new relationship
      bar : String;                  //> add a new element
   }
   entity Foo { key ID: UUID }       //> add a new entity
   ```

3. Generate delta DDL statements:

   ```sh
   cds deploy --dry --delta-from cds-model.csn --out delta.sql
   ```

4. Inspect the generated SQL statements, which should look like this:
   ::: code-group

   ```sql [delta.sql]
   -- Drop Affected Views
   DROP VIEW localized_CatalogService_ListOfBooks;
   DROP VIEW localized_CatalogService_Books;
   DROP VIEW localized_AdminService_Books;
   DROP VIEW CatalogService_ListOfBooks;
   DROP VIEW localized_sap_capire_bookshop_Books;
   DROP VIEW CatalogService_Books_texts;
   DROP VIEW AdminService_Books_texts;
   DROP VIEW CatalogService_Books;
   DROP VIEW AdminService_Books;

   -- Alter Tables for New or Altered Columns
   ALTER TABLE sap_capire_bookshop_Books ALTER title TYPE VARCHAR(222);
   ALTER TABLE sap_capire_bookshop_Books_texts ALTER title TYPE VARCHAR(222);
   ALTER TABLE sap_capire_bookshop_Books ADD foo_ID VARCHAR(36);
   ALTER TABLE sap_capire_bookshop_Books ADD bar VARCHAR(255);

   -- Create New Tables
   CREATE TABLE sap_capire_bookshop_Foo (
     ID VARCHAR(36) NOT NULL,
     PRIMARY KEY(ID)
   );

   -- Re-Create Affected Views
   CREATE VIEW AdminService_Books AS SELECT ... FROM sap_capire_bookshop_Books AS Books_0;
   CREATE VIEW CatalogService_Books AS SELECT ... FROM sap_capire_bookshop_Books AS Books_0 LEFT JOIN sap_capire_bookshop_Authors AS author_1 O ... ;
   CREATE VIEW AdminService_Books_texts AS SELECT ... FROM sap_capire_bookshop_Books_texts AS texts_0;
   CREATE VIEW CatalogService_Books_texts AS SELECT ... FROM sap_capire_bookshop_Books_texts AS texts_0;
   CREATE VIEW localized_sap_capire_bookshop_Books AS SELECT ... FROM sap_capire_bookshop_Books AS L_0 LEFT JOIN sap_capire_bookshop_Books_texts AS localized_1 ON localized_1.ID = L_0.ID AND localized_1.locale = session_context( '$user.locale' );
   CREATE VIEW CatalogService_ListOfBooks AS SELECT ... FROM CatalogService_Books AS Books_0;
   CREATE VIEW localized_AdminService_Books AS SELECT ... FROM localized_sap_capire_bookshop_Books AS Books_0;
   CREATE VIEW localized_CatalogService_Books AS SELECT ... FROM localized_sap_capire_bookshop_Books AS Books_0 LEFT JOIN localized_sap_capire_bookshop_Authors AS author_1 O ... ;
   CREATE VIEW localized_CatalogService_ListOfBooks AS SELECT ... FROM localized_CatalogService_Books AS Books_0;
   ```

   :::

   > **Note:** If you use SQLite, ALTER TYPE commands are not necessary and so, are not supported, as SQLite is essentially typeless.

### Generate Scripts

You can use `cds deploy` with option `--script` to generate a script as a starting
point for a manual migration. The effect of `--script` essentially is the same as for
`--dry`, but it also allows changes that could lead to data loss and therefore are not
supported in the automatic schema migration (see [Limitations](#limitations)).

For generating such a script, perform the same steps as in section [Dry-Run Offline](#dry-run-offline)
above, but replace the command in step 3 by

```sh
cds deploy --script --delta-from cds-model.csn --out delta_script.sql
```

If your model change includes changes that could lead to data loss, there will be a warning
and a respective comment is added to the dangerous statements in the resulting script.
For example, deleting an element or reducing the length of an element would look like this:
 ::: code-group

```sql [delta_script.sql]
...
-- [WARNING] this statement is lossy
ALTER TABLE sap_capire_bookshop_Books DROP price;

-- [WARNING] this statement could be lossy: length reduction of element "title"
ALTER TABLE sap_capire_bookshop_Books ALTER title TYPE VARCHAR(11);
...
```
:::

:::warning

Always check and, if necessary, adapt the generated script before you apply it
to your database!

:::


## Deployment Using Liquibase  { .java }

You can also use [Liquibase](https://www.liquibase.org/) to control when, where, and how database changes are deployed. Liquibase lets you define database changes [in an SQL file](https://docs.liquibase.com/change-types/sql-file.html), use `cds deploy` to quickly generate DDL scripts which can be used by Liquibase.

Add a Maven dependency to Liquibase in `srv/pom.xml`:

```xml
<dependency>
    <groupId>org.liquibase</groupId>
    <artifactId>liquibase-core</artifactId>
    <scope>runtime</scope>
</dependency>
```

Once `liquibase-core` is on the classpath, [Spring runs database migrations](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.data-initialization.migration-tool.liquibase) automatically on application startup and before your tests run.

### ① Initial Schema Version

Once you're ready to release an initial version of your database schema, you can create a DDL file that defines the initial database schema. Create a `db/changelog` subfolder under `srv/src/main/resources`, place the Liquibase _change log_ file as well as the DDL scripts for the schema versions here. The change log is defined by the [db/changelog/db.changelog-master.yml](https://docs.liquibase.com/concepts/changelogs/home.html) file:

```yml
databaseChangeLog:
   - changeSet:
       id: 1
       author: me
       changes:
       - sqlFile:
           dbms: postgresql
           path: db/changelog/v1/model.sql
```

Use `cds deploy` to create the _v1/model.sql_ file:

```sh
cds deploy --profile pg --dry --out srv/src/main/resources/db/changelog/v1/model.sql
```
Finally, store the CSN file, which corresponds to this schema version:

```sh
cds deploy --model-only --dry --out srv/src/main/resources/db/changelog/v1/model.csn
```

The CSN file is needed as an input to compute the delta DDL script for the next change set.

If you start your application with `mvn spring-boot:run` Liquibase initializes the database schema to version `v1`, unless it has already been initialized.

::: warning
Don't change the _model.sql_ after it has been deployed by Liquibase as the [checksum](https://docs.liquibase.com/concepts/changelogs/changeset-checksums.html) of the file is validated. These files should be checked into your version control system. Follow step ② to make changes.
:::

### ② Schema Evolution { #schema-evolution-with-liquibase }

If changes of the CDS model require changes on the database, you can create a new change set that captures the necessary changes.

Use `cds deploy` to compute the delta DDL script based on the previous model versions (_v1/model.csn_) and the current model. Write the diff into a _v2/delta.sql_ file:

```sh
cds deploy --profile pg --dry --delta-from srv/src/main/resources/db/changelog/v1/model.csn --out \
                                           srv/src/main/resources/db/changelog/v2/model.sql
```

Next, add a corresponding change set in the _changelog/db.changelog-master.yml_ file:

```yml
databaseChangeLog:
   - changeSet:
       id: 1
       author: me
       changes:
       - sqlFile:
           dbms: postgresql
           path: db/changelog/v1/model.sql
   - changeSet:
       id: 2
       author: me
       changes:
       - sqlFile:
           dbms: postgresql
           path: db/changelog/v2/model.sql
```

Finally, store the CSN file, which corresponds to this schema version:

```sh
cds deploy --model-only --dry --out srv/src/main/resources/db/changelog/v2/model.csn
```

If you now start the application, Liquibase executes all change sets, which haven't yet been deployed to the database.

For further schema versions, repeat step ②.

::: info Only compatible changes

A delta DDL script is only produced for changes without potential data loss.
If the changes in the model could lead to data loss, an error is raised.

:::

## Migration { .node }

Thanks to CAP's database-agnostic cds.ql API, we're confident that the new PostgreSQL service comes without breaking changes. Nevertheless, please check the instructions in the [SQLite Migration guide](databases-sqlite#migration), with by and large applies also to the new PostgreSQL service.

### `cds deploy --model-only`

Not a breaking change, but definitely required to migrate former `cds-pg` databases, is to prepare it for schema evolution.

To do so run `cds deploy` once with the `--model-only` flag:

```sh
cds deploy --model-only
```

This will...:

- Create the `cds_model` table in your database.
- Fill it with the current model obtained through `cds compile '*'`.

::: warning IMPORTANT:

Your `.cds` models are expected to reflect the deployed state of your database.

:::

### With Deployer App

When you have a SaaS application, upgrade all your tenants using the [deployer app](#with-deployer-app) with CLI option `--model-only` added to the start script command of your *package.json*. After having done that, don't forget to remove the `--model-only` option from the start script, to activate actual schema evolution.



## MTX Support

::: warning

[Multitenancy](../guides/multitenancy/) and [extensibility](../guides/extensibility/) aren't yet supported on PostgreSQL.

:::



# Using SAP HANA Cloud for Production

[SAP HANA Cloud](https://www.sap.com/products/technology-platform/hana.html) is supported as the CAP standard database and recommended for productive use with full support for schema evolution and multitenancy.

::: warning

CAP isn't validated with other variants of SAP HANA, like "SAP HANA Database as a Service" or "SAP HANA (on premise)".

:::

## Setup & Configuration

To use SAP HANA Cloud for production, add a dependency to the _package.json_ for Node.js or to the _pom.xml_ for a CAP Java application:

::: code-group
```sh [Shell/Bash]
npm add @cap-js/hana
```

```xml [pom.xml]
<dependency>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-feature-hana</artifactId>
  <scope>runtime</scope>
</dependency>
```
:::

::: details Using other SAP HANA drivers...

Package `@cap-js/hana` uses the [`hdb`](https://www.npmjs.com/package/hdb) driver by default. You can override that by running [`npm add @sap/hana-client`](https://www.npmjs.com/package/@sap/hana-client), thereby adding it to your package dependencies, which then takes precedence over the default driver.

:::

:::details In CAP Java ...
The [modules](../java/developing-applications/building#standard-modules) `cds-starter-cloudfoundry` and `cds-starter-k8s` include `cds-feature-hana`.

The datasource for SAP HANA is then auto-configured based on available service bindings of type *service-manager* and *hana*.

[Learn more about the configuration of an SAP HANA Cloud Database](../java/cqn-services/persistence-services#sap-hana){ .learn-more}
:::

::: tip Prefer `cds add`

... as documented in the [deployment guide](deployment/to-cf#_1-sap-hana-database), which also does the equivalent of `npm add @cap-js/hana` but in addition cares for updating `mta.yaml` and other deployment resources.

:::




## Running `cds build`

Deployment to SAP HANA is done via the [SAP HANA Deployment Infrastructure (HDI)](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-developer-guide-for-cloud-foundry-multitarget-applications-sap-business-app-studio/sap-hdi-deployer?) which in turn requires running `cds build` to generate all the deployable HDI artifacts. For example, run this in [cap/samples/bookshop](https://github.com/SAP-samples/cloud-cap-samples/tree/main/bookshop):

```sh
cds build --for hana
```

Which should display this log output:

```log
[cds] - done > wrote output to:
   gen/db/init.js
   gen/db/package.json
   gen/db/src/gen/.hdiconfig
   gen/db/src/gen/.hdinamespace
   gen/db/src/gen/AdminService.Authors.hdbview
   gen/db/src/gen/AdminService.Books.hdbview
   gen/db/src/gen/AdminService.Books_texts.hdbview
   gen/db/src/gen/AdminService.Currencies.hdbview
   gen/db/src/gen/AdminService.Currencies_texts.hdbview
   gen/db/src/gen/AdminService.Genres.hdbview
   gen/db/src/gen/AdminService.Genres_texts.hdbview
   gen/db/src/gen/CatalogService.Books.hdbview
   gen/db/src/gen/CatalogService.Books_texts.hdbview
   gen/db/src/gen/CatalogService.Currencies.hdbview
   gen/db/src/gen/CatalogService.Currencies_texts.hdbview
   gen/db/src/gen/CatalogService.Genres.hdbview
   gen/db/src/gen/CatalogService.Genres_texts.hdbview
   gen/db/src/gen/CatalogService.ListOfBooks.hdbview
   gen/db/src/gen/data/sap.capire.bookshop-Authors.csv
   gen/db/src/gen/data/sap.capire.bookshop-Authors.hdbtabledata
   gen/db/src/gen/data/sap.capire.bookshop-Books.csv
   gen/db/src/gen/data/sap.capire.bookshop-Books.hdbtabledata
   gen/db/src/gen/data/sap.capire.bookshop-Books.texts.csv
   gen/db/src/gen/data/sap.capire.bookshop-Books.texts.hdbtabledata
   gen/db/src/gen/data/sap.capire.bookshop-Genres.csv
   gen/db/src/gen/data/sap.capire.bookshop-Genres.hdbtabledata
   gen/db/src/gen/localized.AdminService.Authors.hdbview
   gen/db/src/gen/localized.AdminService.Books.hdbview
   gen/db/src/gen/localized.AdminService.Currencies.hdbview
   gen/db/src/gen/localized.AdminService.Genres.hdbview
   gen/db/src/gen/localized.CatalogService.Books.hdbview
   gen/db/src/gen/localized.CatalogService.Currencies.hdbview
   gen/db/src/gen/localized.CatalogService.Genres.hdbview
   gen/db/src/gen/localized.CatalogService.ListOfBooks.hdbview
   gen/db/src/gen/localized.sap.capire.bookshop.Authors.hdbview
   gen/db/src/gen/localized.sap.capire.bookshop.Books.hdbview
   gen/db/src/gen/localized.sap.capire.bookshop.Genres.hdbview
   gen/db/src/gen/localized.sap.common.Currencies.hdbview
   gen/db/src/gen/sap.capire.bookshop.Authors.hdbtable
   gen/db/src/gen/sap.capire.bookshop.Books.hdbtable
   gen/db/src/gen/sap.capire.bookshop.Books_author.hdbconstraint
   gen/db/src/gen/sap.capire.bookshop.Books_currency.hdbconstraint
   gen/db/src/gen/sap.capire.bookshop.Books_foo.hdbconstraint
   gen/db/src/gen/sap.capire.bookshop.Books_genre.hdbconstraint
   gen/db/src/gen/sap.capire.bookshop.Books_texts.hdbtable
   gen/db/src/gen/sap.capire.bookshop.Genres.hdbtable
   gen/db/src/gen/sap.capire.bookshop.Genres_parent.hdbconstraint
   gen/db/src/gen/sap.capire.bookshop.Genres_texts.hdbtable
   gen/db/src/gen/sap.common.Currencies.hdbtable
   gen/db/src/gen/sap.common.Currencies_texts.hdbtable

```



### Generated HDI Artifacts

As we see from the log output `cds build` generates these [deployment artifacts as expected by HDI](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-deployment-infrastructure-hdi-reference/sap-hdi-artifact-types-and-build-plug-ins-reference?), based on CDS models and .csv files provided in your projects:

- `.hdbtable` files for entities
- `.hdbview` files for views / projections
- `.hdbconstraint` files for database constraints
- `.hdbtabledata` files for CSV content
- a few technical files required by HDI, such as [`.hdinamespace`](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-developer-guide-for-cloud-foundry-multitarget-applications-sap-business-app-studio/sap-hdi-name-space-configuration-syntax?version=2024_1_QRC&q=hdinamespace) and [`.hdiconfig`](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-developer-guide-for-cloud-foundry-multitarget-applications-sap-business-app-studio/sap-hdi-container-configuration-file?)



### Custom HDI Artifacts

In addition to the generated HDI artifacts, you can add custom ones by adding according files to folder `db/src`. For example, let's add an index for Books titles...

1. Add a file `db/src/sap.capire.bookshop.Books.hdbindex` and fill it with this content:

   ::: code-group

   ```sql [db/src/sap.capire.bookshop.Books.hdbindex]
   INDEX sap_capire_bookshop_Books_title_index
   ON sap_capire_bookshop_Books (title)
   ```

   :::

2. Run cds build again → this time you should see this additional line in the log output:
   ```log
   [cds] - done > wrote output to:
   [...]
   gen/db/src/sap.capire.bookshop.Books.hdbindex // [!code focus]
   ```


[Learn more about HDI Design-Time Resources and Build Plug-ins](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-developer-guide-for-cloud-foundry-multitarget-applications-sap-business-app-studio/hdi-design-time-resources-and-build-plug-ins?){.learn-more}


## Deploying to SAP HANA

There are two ways to include SAP HANA in your setup: Use SAP HANA in a [hybrid mode](#cds-deploy-hana), meaning running your services locally and connecting to your database in the cloud, or running your [whole application](deployment/) on SAP Business Technology Platform. This is possible either in trial accounts or in productive accounts.

To make the following configuration steps work, we assume that you've provisioned, set up, and started, for example, your SAP HANA Cloud instance in the [trial environment](https://cockpit.hanatrial.ondemand.com). If you need to prepare your SAP HANA first, see [How to Get an SAP HANA Cloud Instance for SAP Business Technology Platform, Cloud Foundry environment](../get-started/troubleshooting#get-hana) to learn about your options.

### Prepare for Production { #configure-hana }

To prepare the project, execute:

```sh
cds add hana --for hybrid
```

This configures deployment for SAP HANA to use the _hdbtable_ and _hdbview_ formats. The configuration is added to a `[hybrid]` profile in your _package.json_.

::: tip The profile `hybrid` relates to [the hybrid testing](../advanced/hybrid-testing) scenario
If you want to prepare your project for production and use the profile `production`, read the [Deploy to Cloud Foundry](deployment/) guide.
:::

No further configuration is necessary for Node.js. For Java, see the [Use SAP HANA as the Database for a CAP Java Application](https://developers.sap.com/tutorials/cp-cap-java-hana-db.html#880cf07a-1788-4fda-b6dd-b5a6e5259625) tutorial for the rest of the configuration.



### Using `cds deploy` for Ad-Hoc Deployments { #cds-deploy-hana }

`cds deploy` lets you deploy _just the database parts_ of the project to an SAP HANA instance. The server application (the Node.js or Java part) still runs locally and connects to the remote database instance, allowing for fast development roundtrips.

Make sure that you're [logged in to Cloud Foundry](deployment/to-cf#build-and-deploy) with the correct target, that is, org and space.
Then in the project root folder, just execute:

```sh
cds deploy --to hana
```

> To connect to your SAP HANA Cloud instance use `cds watch --profile hybrid` in Node.js or[ `mvn cds:watch` in Java](../java/developing-applications/running#local-development-support) projects.

Behind the scenes, `cds deploy` does the following:

* Compiles the CDS model to SAP HANA files (usually in _gen/db_, or _db/src/gen_)
* Generates _[.hdbtabledata](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-deployment-infrastructure-hdi-reference/table-data-hdbtabledata?)_ files for the [CSV files](databases#providing-initial-data) in the project. If a _[.hdbtabledata](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-deployment-infrastructure-hdi-reference/table-data-hdbtabledata?)_ file is already present next to the CSV files, no new file is generated.
* Creates a Cloud Foundry service of type `hdi-shared`, which creates an HDI container. Also, you can explicitly specify the name like so: `cds deploy --to hana:<myService>`.
* Starts `@sap/hdi-deploy` locally. If you need a tunnel to access the database, you can specify its address with `--tunnel-address <host:port>`.
* Stores the binding information with profile `hybrid` in the _.cdsrc-private.json_ file of your project. You can use a different profile with parameter `--for`. With this information, `cds watch`/`run` can fetch the SAP HANA credentials at runtime, so that the server can connect to it.

Specify `--profile` when running `cds deploy` as follows:

```sh
cds deploy --to hana --profile hybrid
```

Based on these profile settings, `cds deploy` executes `cds build` and also resolves additionally binding information. If a corresponding binding exists, its service name and service key are used. The development profile is used by default.

[Learn more about the deployment using HDI.](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-developer-guide-for-cloud-foundry-multitarget-applications-sap-business-app-studio/sap-hdi-deployer?){.learn-more}
[Learn more about hybrid testing using service bindings to Cloud services.](../advanced/hybrid-testing#run-with-service-bindings){.learn-more}

If you run into issues, see the [Troubleshooting](../get-started/troubleshooting#hana) guide.

#### Deploy Parameters

When using the option `--to hana`, you can specify the service name and logon information in several ways.

<br>

`cds deploy --to hana`

In this case the service name and service key either come from the environment variable `VCAP_SERVICES` or are defaulted from the project name, for example, `myproject-db` with `myproject-db-key`. Service instances and key either exist and will be used, or otherwise they're created.

##### `cds deploy --to hana:myservice`

This overwrites any information coming from environment variables. The service name `myservice` is used and the current Cloud Foundry client logon information is taken to connect to the system.

##### `cds deploy --vcap-file someEnvFile.json`

This takes the logon information and the service name from the `someEnvFile.json` file and overwrite any environment variable that is already set.

##### `cds deploy --to hana:myservice --vcap-file someEnvFile.json`

This is equivalent to `cds deploy --to hana:myservice` and ignores information coming from `--vcap-file`. A warning is printed after deploying.

### Using `cf deploy` or `cf push`

See the [Deploying to Cloud Foundry](deployment/) guide for information about how to deploy the complete application to SAP Business Technology Platform, including a dedicated deployer application for the SAP HANA database.



## Native SAP HANA Features

The HANA Service provides dedicated support for native SAP HANA features as follows.

### Vector Embeddings { #vector-embeddings }

Vector embeddings let you add semantic search, recommendations, and generative AI features to your CAP application. Embeddings are numeric arrays that represent the meaning of unstructured data (text, images, etc.), making it possible to compare and search for items that are semantically related to each other or a user query.

#### Choose an Embedding Model

Choose an embedding model that fits your use case and data (for example english or multilingual text). The model determines the number of dimensions of the resulting output vector. Check the documentation of the respective embedding model for details.

Use the [SAP Generative AI Hub](https://community.sap.com/t5/technology-blogs-by-sap/how-sap-s-generative-ai-hub-facilitates-embedded-trustworthy-and-reliable/ba-p/13596153) for unified consumption of embedding models and LLMs across different vendors and open source models. Check for available models on the [SAP AI Launchpad](https://help.sap.com/docs/ai-launchpad/sap-ai-launchpad-user-guide/models-and-scenarios-in-generative-ai-hub-fef463b24bff4f44a33e98bb1e4f3148#models).

#### Add Embeddings to Your CDS Model
Use the `cds.Vector` type in your CDS model to store embeddings on SAP HANA Cloud. Set the dimension to match your embedding model (for example, 1536 embedding dimensions for OpenAI *text-embedding-3-small*).

   ```cds
   entity Books : cuid {
     title       : String(111);
     description : LargeString;
     embedding   : Vector(1536); // adjust dimensions to embedding model
   }
   ```

#### Generate Embeddings
Use an embedding model to convert your data (for example, book descriptions) into vectors. The [SAP Cloud SDK for AI](https://sap.github.io/ai-sdk/) makes it easy to call SAP AI Core services to generate these embeddings.

:::details Example using SAP Cloud SDK for AI
```Java
var aiClient = OpenAiClient.forModel(OpenAiModel.TEXT_EMBEDDING_3_SMALL);
var response = aiClient.embedding(
   new OpenAiEmbeddingRequest(List.of(book.getDescription())));
book.setEmbedding(CdsVector.of(response.getEmbeddingVectors().get(0)));
```
:::

#### Query for Similarity
At runtime, use SAP HANA's built-in vector functions to search for similar items. For example, find books with embeddings similar to a user question:

::: code-group
```Java [Java]
// Compute embedding for user question
var request = new OpenAiEmbeddingRequest(List.of("How to use vector embeddings in CAP?"));
CdsVector userQuestion = CdsVector.of(
 aiClient.embedding(request).getEmbeddingVectors().get(0));
// Compute similarity between user question and book embeddings
var similarity = CQL.cosineSimilarity( // computed on SAP HANA
  CQL.get(Books.EMBEDDING), userQuestion);
// Find Books related to user question ordered by similarity
hana.run(Select.from(BOOKS).limit(10)
.columns(b -> b.ID(), b -> b.title(),
		 b -> similarity.as("similarity"))
.orderBy(b -> b.get("similarity").desc()));
```

```js [Node.js]
const response = await new AzureOpenAiEmbeddingClient(
 'text-embedding-3-small'
).run({
 input: 'How to use vector embeddings in CAP?'
});
const questionEmbedding = response.getEmbedding();
let similarBooks = await SELECT.from('Books')
  .where`cosine_similarity(embedding, to_real_vector(${questionEmbedding})) > 0.9`;
```

:::

:::tip
Store embeddings when you create or update your data. Regenerate embeddings if you change your embedding model.
:::

:::tip SAP Cloud SDK for AI
Use the [SAP Cloud SDK for AI](https://sap.github.io/ai-sdk/) for unified access to embedding models and large language models (LLMs) from [SAP AI Core](https://help.sap.com/docs/sap-ai-core/sap-ai-core-service-guide/what-is-sap-ai-core).
:::


[Learn more about the SAP Cloud SDK for AI (Java)](https://sap.github.io/ai-sdk/docs/java/getting-started) {.learn-more}

[Learn more about Vector Embeddings in CAP Java](../java/cds-data#vector-embeddings) {.learn-more}

[Learn more about the SAP Cloud SDK for AI (JavaScript)](https://sap.github.io/ai-sdk/docs/js/getting-started) {.learn-more}




### Geospatial Functions

CDS supports the special syntax for SAP HANA geospatial functions:

```cds
entity Geo as select from Foo {
  geoColumn.ST_Area() as area : Decimal,
  new ST_Point(2.25, 3.41).ST_X() as x : Decimal
};
```

*Learn more in the [SAP HANA Spatial Reference](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-spatial-reference/accessing-and-manipulating-spatial-data?).*{.learn-more}



### Spatial Grid Generators

SAP HANA Spatial has some built-in [grid generator table functions](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-spatial-reference/grid-generators?). To use them in a CDS model, first
define corresponding facade entities in CDS.

Example for function `ST_SquareGrid`:

```cds
@cds.persistence.exists
entity ST_SquareGrid(size: Double, geometry: hana.ST_GEOMETRY) {
  geom: hana.ST_GEOMETRY;
  i: Integer;
  j: Integer;
}
```

Then the function can be called, parameters have to be passed by name:

```cds
entity V as select
  from ST_SquareGrid(size: 1.0, geometry: ST_GeomFromWkt('Point(1.5 -2.5)'))
{ geom, i, j };
```



### Functions Without Arguments

SAP HANA allows to omit the parentheses for functions that don't expect arguments. For example:

```cds
entity Foo { key ID : UUID; }
entity Bar as select from Foo {
  ID, current_timestamp
};
```

Some of which are well-known standard functions like `current_timestamp` in the previous example, which can be written without parentheses in CDS models. However, there are many unknown ones, that aren't known to the compiler, for example:

- `current_connection`
- `current_schema`
- `current_transaction_isolation_level`
- `current_utcdate`
- `current_utctime`
- `current_utctimestamp`
- `sysuuid`

To use these in CDS models, you have to add the parentheses so that CDS generic support for using native features can kick in:

```cds
entity Foo { key ID : UUID; }
entity Bar as select from Foo {
  ID, current_timestamp,
  sysuuid() as sysid // [!code focus]
};
```





### Regex Functions

CDS supports SAP HANA Regex functions (`locate_regexpr`, `occurrences_regexpr`, `replace_regexpr`, and `substring_regexpr`), and SAP HANA aggregate functions with an additional `order by` clause in the argument list. Example:

```sql
locate_regexpr(pattern in name from 5)
first_value(name order by price desc)
```

Restriction: `COLLATE` isn't supported.

For other functions, where the syntax isn't supported by the compiler (for example, `xmltable(...)`), a native _.hdbview_ can be used. See [Using Native SAP HANA Artifacts](../advanced/hana) for more details.







## HDI Schema Evolution

CAP supports database schema updates by detecting changes to the CDS model when executing the CDS build. If the underlying database offers built-in schema migration techniques, compatible changes can be applied to the database without any data loss or the need for additional migration logic. Incompatible changes like deletions are also detected, but require manual resolution, as they would lead to data loss.

| Change                             | Detected Automatically | Applied Automatically |
| ---------------------------------- | :--------------------: | :-------------------: |
| Adding  fields                     |        **Yes**         |        **Yes**        |
| Deleting fields                    |        **Yes**         |          No           |
| Renaming fields                    |    n/a <sup>1</sup>    |          No           |
| Changing datatype of fields        |        **Yes**         |          No           |
| Changing type parameters           |        **Yes**         |        **Yes**        |
| Changing associations/compositions |        **Yes**         |    No <sup>2</sup>    |
| Renaming associations/compositions |    n/a <sup>1</sup>    |          No           |
| Renaming entities                  |          n/a           |          No           |

> <sup>1</sup> Rename field or association operations aren't detected as such. Instead, corresponding ADD and DROP statements are rendered requiring manual resolution activities.
>
> <sup>2</sup> Changing targets may lead to renamed foreign keys. Possibly hard to detect data integrity issues due to non-matching foreign key values if target key names remain the same (for example "ID").

::: warning No support for incompatible schema changes
Currently there's no framework support for incompatible schema changes that require scripted data migration steps (like changing field constraints NULL > NOT NULL). However, the CDS build does detect those changes and renders them as non-executable statements, requesting the user to take manual resolution steps. We recommend avoiding those changes in productive environments.
:::

### Schema Evolution and Multitenancy/Extensibility

There's full support for schema evolution when the _cds-mtxs_ library is used for multitenancy handling. It ensures that all schema changes during base-model upgrades are rolled out to the tenant databases.

::: warning
Tenant-specific extensibility using the _cds-mtxs_ library isn't supported yet
Right now, you can't activate extensions on entities annotated with `@cds.persistence.journal`.
:::

### Schema Updates with SAP HANA {#schema-updates-with-sap-hana}

All schema updates in SAP HANA are applied using SAP HANA Deployment Infrastructure (HDI) design-time artifacts, which are auto-generated during CDS build execution.

Schema updates using _.hdbtable_ deployments are a challenge for tables with large data volume. Schema changes with _.hdbtable_ are applied using temporary table generation to preserve the data. As this could lead to long deployment times, the support for _.hdbmigrationtable_ artifact generation has been added. The [Migration Table artifact type](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-deployment-infrastructure-hdi-reference/migration-tables-hdbmigrationtable?version=2024_1_QRC) uses explicit versioning and migration tasks. Modifications of the database table are explicitly specified in the design-time file and carried out on the database table exactly as specified. This saves the cost of an internal table-copy operation. When a new version of an already existing table is deployed, HDI performs the migration steps that haven't been applied.

#### Deploy Artifact Transitions as Supported by HDI {#deploy-artifact-transitions}

| Current format    | hdbcds | hdbtable | hdbmigrationtable |
|-------------------|:------:|:--------:|:-----------------:|
| hdbcds            |        |  yes  |      n/a      |
| hdbtable          | n/a |          |       yes       |
| hdbmigrationtable | n/a |  Yes  |                   |

::: warning
Direct migration from _.hdbcds_ to _.hdbmigrationtable_ isn't supported by HDI. A deployment using _.hdbtable_ is required up front.

[Learn more in the **Enhance Project Configuration for SAP HANA Cloud** section.](#configure-hana){.learn-more}

During the transition from _.hdbtable_ to _.hdbmigrationtable_ you have to deploy version=1 of the _.hdbmigrationtable_ artifact, which must not include any migration steps.
:::

HDI supports the _hdbcds → hdbtable → hdbmigrationtable_ migration flow without data loss. Even going back from _.hdbmigrationtable_ to _.hdbtable_ is possible. Keep in mind that you lose the migration history in this case.
For all transitions you want to execute in HDI, you need to specify an undeploy allowlist as described in [HDI Delta Deployment and Undeploy Allow List](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-developer-guide-for-cloud-foundry-multitarget-applications-sap-business-app-studio/hdi-delta-deployment-and-undeploy-allow-list?) in the SAP HANA documentation.

:::tip Moving From _.hdbcds_ To _.hdbtable_
There a migration guide providing you step-by-step instructions for making the switch.

[Learn more about Moving From _.hdbcds_ To _.hdbtable_](../cds/compiler/hdbcds-to-hdbtable){.learn-more}
:::

#### Enabling hdbmigrationtable Generation for Selected Entities During CDS Build {#enabling-hdbmigrationtable-generation}

If you're migrating your already deployed scenario to _.hdbmigrationtable_ deployment, you've to consider the remarks in [Deploy Artifact Transitions as Supported by HDI](#deploy-artifact-transitions).

By default, all entities are still compiled to _.hdbtable_ and you only selectively choose the entities for which you want to build _.hdbmigrationtable_ by annotating them with `@cds.persistence.journal`.

Example:

```cds
namespace data.model;

  @cds.persistence.journal
  entity LargeBook {
    key id : Integer;
    title : String(100);
    content : LargeString;
  }
```

CDS build generates _.hdbmigrationtable_ source files for annotated entities as well as a _last-dev/csn.json_ source file representing the CDS model state of the last build.

> These source files have to be checked into the version control system.

Subsequent model changes are applied automatically as respective migration versions including the required schema update statements to accomplish the new target state.
There are cases where you have to resolve or refactor the generated statements, like for reducing field lengths. As they can't be executed without data loss (for example, `String(100)` -> `String(50)`), the required migration steps are only added as comments for you to process explicitly.

Example:

```txt
>>>> Manual resolution required - DROP statements causing data loss are disabled
>>>> by default.
>>>> You may either:
>>>>   uncomment statements to allow incompatible changes, or
>>>>   refactor statements, e.g. replace DROP/ADD by single RENAME statement
>>>> After manual resolution delete all lines starting with >>>>>
-- ALTER TABLE my_bookshop_Books DROP (title);
-- ALTER TABLE my_bookshop_Books ADD (title NVARCHAR(50));
```

Changing the type of a field causes CDS build to create a corresponding ALTER TABLE statement. [Data type conversion rules](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-sql-reference-guide/data-type-conversion?) are applied by the SAP HANA database as part of the deployment step. This may cause the deployment to fail if the column contents can't be converted to the new format.

Examples:

1. Changing the type of a field from String to Integer may cause tenant updates to fail if existing content can't be converted.
2. Changing the type of a field from Decimal to Integer can succeed, but decimal places are truncated. Conversion fails if the content exceeds the maximum Integer length.

We recommend keeping _.hdbtable_ deployment for entities where you expect low data volume. Every _.hdbmigrationtable_ artifact becomes part of your versioned source code, creating a new migration version on every model change/build cycle. In turn, each such migration can require manual resolution.
You can switch large-volume tables to _.hdbmigrationtable_ at any time, keeping in mind that the existing _.hdbtable_ design-time artifact needs to be undeployed.

When choosing to use _.hdbmigrationtable_ for an entity with
[localized elements](../guides/localized-data#localized-data) or [compositions of aspects](../cds/cdl#managed-compositions),
the generated `.texts` and composition child entities are automatically handled via _.hdbmigrationtable_, too.
If this is not desired, annotate these generated entities with `@cds.persistence.journal: false`.

::: tip
Sticking to _.hdbtable_ for the actual application development phase avoids lots of initial migration versions that would need to be applied to the database schema.
:::

CDS build performs rudimentary checks on generated _.hdmigrationtable_ files:

- CDS build fails if inconsistencies are encountered between the generated _.hdbmigrationtable_ files and the _last-dev/csn.json_ model state. For example, the last migration version not matching the table version is such an inconsistency.
- CDS build fails if manual resolution comments starting with `>>>>>` exist in one of the generated _.hdbmigrationtable_ files. This ensures that manual resolution is performed before deployment.

### Native Database Clauses {#schema-evolution-native-db-clauses}
Not all clauses supported by SQL can directly be written in CDL syntax. To use native database clauses also in a CAP CDS model, you can provide arbitrary SQL snippets with the annotations [`@sql.prepend` and `@sql.append`](databases#sql-prepend-append). In this section, we're focusing on schema evolution specific details.

Schema evolution requires that any changes are applied by corresponding ALTER statements. See [ALTER TABLE statement reference](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-sql-reference-guide/alter-table-statement-data-definition?version=2024_1_QRC) for more information. A new migration version is generated whenever an `@sql.append` or `@sql.prepend` annotation is added, changed, or removed. ALTER statements define the individual changes that create the final database schema. This schema has to match the schema defined by the TABLE statement in the _.hdbmigrationtable_ artifact.
Please note that the compiler doesn't evaluate or process these SQL snippets. Any snippet is taken as is and inserted into the TABLE statement and the corresponding ALTER statement. The deployment fails in case of syntax errors.

CDS Model:
```cds
@cds.persistence.journal
@sql.append: 'PERSISTENT MEMORY ON'
entity E {
  ...,
  @sql.append: 'FUZZY SEARCH INDEX ON'
  text: String(100);
}
```

Result in hdbmigrationtable file:
```sql
== version=2
COLUMN TABLE E (
  ...,
  text NVARCHAR(100) FUZZY SEARCH INDEX ON
) PERSISTENT MEMORY ON

== migration=2
ALTER TABLE E PERSISTENT MEMORY ON;
ALTER TABLE E ALTER (text NVARCHAR(100) FUZZY SEARCH INDEX ON);
```

It's important to understand that during deployment new migration versions will be applied on the existing database schema. If the resulting schema doesn't match the schema as defined by the TABLE statement, deployment fails and any changes are rolled-back. In consequence, when removing or replacing an existing `@sql.append` annotation, the original ALTER statements need to be undone. As the required statements can't automatically be determined, manual resolution is required. The CDS build generates comments starting with `>>>>` in order to provide some guidance and enforce manual resolution.

Generated file with comments:
```txt
== migration=3
>>>>> Manual resolution required - insert ALTER statement(s) as described below.
>>>>> After manual resolution delete all lines starting with >>>>>
>>>>> Insert ALTER statement for: annotation @sql.append of artifact E has been removed (previous value: "PERSISTENT MEMORY ON")
>>>>> Insert ALTER statement for: annotation @sql.append of element E:text has been removed (previous value: "FUZZY SEARCH INDEX ON")
```

Manually resolved file:
```sql
== migration=3
ALTER TABLE E PERSISTENT MEMORY DEFAULT;
ALTER TABLE E ALTER (text NVARCHAR(100) FUZZY SEARCH INDEX OFF);
```
Appending text to an existing annotation is possible without manual resolution. A valid ALTER statement will be generated in this case. For example, appending the `NOT NULL` column constraint to an existing `FUZZY SEARCH INDEX ON` annotation generates the following statement:
```sql
ALTER TABLE E ALTER (text NVARCHAR(100) FUZZY SEARCH INDEX ON NOT NULL);
```

::: warning
You can use `@sql.append` to partition your table initially, but you can't subsequently change the partitions using schema evolution techniques as altering partitions isn't supported yet.
:::

### Advanced Options

The following CDS configuration options are supported to manage _.hdbmigrationtable_ generation.

::: warning
This hasn't been finalized yet.
:::

```js
{
  "hana" : {
    "journal": {
      "enable-drop": false,
      "change-mode": "alter" // "drop"
    },
    // ...
  }
}
```

The `"enable-drop"` option determines whether incompatible model changes are rendered as is (`true`) or manual resolution is required (`false`). The default value is `false`.

The `change-mode` option determines whether `ALTER TABLE ... ALTER` (`"alter"`) or `ALTER TABLE ... DROP` (`"drop"`) statements are rendered for data type related changes. To ensure that any kind of model change can be successfully deployed to the database, you can switch the `"change-mode"` to `"drop"`, keeping in mind that any existing data will be deleted for the corresponding column. See [hdbmigrationtable Generation](#enabling-hdbmigrationtable-generation) for more details. The default value is `"alter"`.



## Caveats



### CSV Data Gets Overridden

HDI deploys CSV data as _.hdbtabledata_ and assumes exclusive ownership of the data. It's overridden with the next application deployment; hence:

::: tip

Only use CSV files for _configuration data_ that can't be changed by application users.

:::

Yet, if you need to support initial data with user changes, you can use the `include_filter` option that _[.hdbtabledata](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-deployment-infrastructure-hdi-reference/table-data-hdbtabledata?version=2024_1_QRC)_ offers.



### Undeploying Artifacts

As documented in the [HDI Deployer docs](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-developer-guide-for-cloud-foundry-multitarget-applications-sap-business-app-studio/hdi-delta-deployment-and-undeploy-allow-list?), an HDI deployment by default never deletes artifacts. So, if you remove an entity or CSV files, the respective tables, and content remain in the database.

By default, `cds add hana` creates an `undeploy.json` like this:

::: code-group

```json [db/undeploy.json]
[
  "src/gen/**/*.hdbview",
  "src/gen/**/*.hdbindex",
  "src/gen/**/*.hdbconstraint",
  "src/gen/**/*_drafts.hdbtable",
  "src/gen/**/*.hdbcalculationview"
]
```

:::

If you need to remove deployed CSV files, also add this entry:

::: code-group

```json [db/undeploy.json]
[
  [...]
  "src/gen/**/*.hdbtabledata"
]
```

:::

*See this [troubleshooting](../get-started/troubleshooting#hana-csv) entry for more information.*{.learn-more}

### SAP HANA Cloud System Limits

All limitations for the SAP HANA Cloud database can be found in the [SAP Help Portal](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-sql-reference-guide/system-limitations?version=2024_2_QRC).


### Native Associations

In previous CAP releases, CDS associations were by default reflected in SAP HANA
database tables and views by _Native HANA Associations_ (HANA SQL clause `WITH ASSOCIATIONS`).
But the presence of such native associations significantly increases (re-)deploy times:
They need to be validated in the HDI deployment, and they can introduce
indirect dependencies between other objects, which can trigger other unnecessary revalidations
or even unnecessary drop/create of indexes.

As CAP doesn't need these native associations, by default no native HANA associations
are created anymore starting with CAP 9. 

In the unlikely case that you need native HANA associations because you explicitly use them
in other native HANA objects or in custom code, you can switch them back on with <Config>cds.sql.native_hana_associations = true</Config>.

::: warning Initial full table migration
Be aware that the first deployment after this **configuration change may take longer**.

For each entity with associations, the respective database object is touched
(DROP/CREATE for views, full table migration via shadow table and data copy for tables).

:::



# Embedded Analytics

With SAP HANA Cloud and SAP Analytics Cloud {.subtitle}

Embedded analytics allows you to evaluate and analyze real-time business data directly in your SAP HANA-based CAP application, without having to replicate data to an external data warehouse.



## Introduction

Using CDS, you define a multidimensional [analytical model](#glossary) on top of the entities of your application's domain model.
Upon deployment to SAP HANA Cloud, the necessary runtime objects and metadata for
SAP HANA's built-in [analytical query](#glossary) engine (SAP HANA Multi-Dimensional Services or MDS) are automatically created.

CAP applications have a built-in endpoint for handling analytical queries using the _InA_ (Information Access) protocol,
to which clients like SAP Analytics Cloud (SAC) can connect.
Based on the analytical model, the analytical queries are then executed by the SAP HANA Multi-Dimensional Services (MDS).

To be able to consume data, the analytical engine needs a (multidimensional) analytical model.
This section explains how to define such an analytical model in CAP CDS.
The following examples are snippets taken from an
[analytical model](https://github.tools.sap/cap/sflight-ea/blob/main/srv/analytics-model.cds)
of the "Embedded Analytics" variant of the CAP SFlight sample application.

The structure of the analytical model resembles a star: in the center there's an
[analytical cube](#glossary) entity (called "cube" in the remainder of the document)
surrounded by and connected to various [dimension entities](#glossary).

The cube is the analytical interface entity and is visible in analytical clients.
Usually, it's a view or projection on top of a more basic entity of the CDS model.


## Add Internal Registry <Internal />

As the [CDS Enterprise Analytics Plugins](#glossary) are right know only available within SAP,
you need to add an _.npmrc_ file for Node.js or  a _settings.xml_ for Java to your project. For CAP Java you also need to reference the _settings.xml_ in your _mta.yaml_.

::: code-group

```properties [.npmrc]
unsafe-perm=true
@sap:registry=https://int.repositories.cloud.sap/artifactory/api/npm/build-releases-npm/
registry=https://int.repositories.cloud.sap/artifactory/api/npm/build-releases-npm/
```

```xml [settings.xml]

<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd">

  
  <mirrors>
    <mirror>
      <id>mirror1</id>
      <url>https://int.repositories.cloud.sap/artifactory/build-milestones/</url>
      <mirrorOf>*,!artifactory</mirrorOf>
    </mirror>
  </mirrors>
  <profiles>
    <profile>
      <id>snapshot.build</id>
      <pluginRepositories>
        <pluginRepository>
          <id>artifactory</id>
          <url>https://int.repositories.cloud.sap/artifactory/build-snapshots/</url>
        </pluginRepository>
      </pluginRepositories>
      <repositories>
        <repository>
          <id>artifactory</id>
          <url>https://int.repositories.cloud.sap/artifactory/build-snapshots/</url>
        </repository>
      </repositories>
      <properties>
        <npm.registry>https://int.repositories.cloud.sap/artifactory/api/npm/build-snapshots-npm/</npm.registry>
        <tycho.disableP2Mirrors>true</tycho.disableP2Mirrors>
        <tycho.localArtifacts>ignore</tycho.localArtifacts>
      </properties>
    </profile>
    <profile>
      <id>milestone.build</id>
      <pluginRepositories>
        <pluginRepository>
          <id>artifactory</id>
          <url>https://int.repositories.cloud.sap/artifactory/build-milestones/</url>
        </pluginRepository>
      </pluginRepositories>
      <repositories>
        <repository>
          <id>artifactory</id>
          <url>https://int.repositories.cloud.sap/artifactory/build-milestones/</url>
        </repository>
      </repositories>
      <properties>
        <npm.registry>https://int.repositories.cloud.sap/artifactory/api/npm/build-milestones-npm/</npm.registry>
        <tycho.disableP2Mirrors>true</tycho.disableP2Mirrors>
        <tycho.localArtifacts>ignore</tycho.localArtifacts>
      </properties>
    </profile>
    <profile>
      <id>release.build</id>
      <pluginRepositories>
        <pluginRepository>
          <id>artifactory</id>
          <url>https://int.repositories.cloud.sap/artifactory/build-releases/</url>
        </pluginRepository>
      </pluginRepositories>
      <repositories>
        <repository>
          <id>artifactory</id>
          <url>https://int.repositories.cloud.sap/artifactory/build-releases/</url>
        </repository>
      </repositories>
      <properties>
        <npm.registry>https://int.repositories.cloud.sap/artifactory/api/npm/build-releases-npm/</npm.registry>
        <tycho.disableP2Mirrors>true</tycho.disableP2Mirrors>
        <tycho.localArtifacts>ignore</tycho.localArtifacts>
      </properties>
    </profile>
    <profile>
      <id>sonar</id>
      <activation>
        <activeByDefault>true</activeByDefault>
      </activation>
      <properties>
        <sonar.host.url>https://sonar.tools.sap</sonar.host.url>
        <tycho.disableP2Mirrors>true</tycho.disableP2Mirrors>
        <tycho.localArtifacts>ignore</tycho.localArtifacts>
      </properties>
    </profile>
  </profiles>
  <activeProfiles>
    <activeProfile>snapshot.build</activeProfile>
  </activeProfiles>
  <pluginGroups>
    <pluginGroup>com.sap.ldi</pluginGroup>
    <pluginGroup>com.sap.ui5.tools.maven</pluginGroup>
  </pluginGroups>
</settings>
```
```yaml [mta.yaml]
modules:
  # --------------------- SERVER MODULE ------------------------
  - name: sflight-srv-java
  # ------------------------------------------------------------
   ...
    build-parameters:
      builder: custom
      # m2-settings.xml : InA adapter only available via internal artifactory
      commands:
        - mvn clean package -DskipTests=true -s ../m2-settings.xml
      ...
```
:::

## Install Plugins

Regardless of the runtime, be it Node.js or Java, the CDS Enterprise Analytics Plugin is responsible to build the runtime objects and metadata for MDS.

Add the plugin and install it by running:

```sh
npm add @sap/cds-ea-plugin --save-dev
```

::: details The added dependency
::: code-group

```jsonc [package.json]
{
  // ...
  "devDependencies": {
    // ...
    "@sap/cds-ea-plugin": "^0.0.17",
  },
}
```

:::

:::details When using extensibility in multitenant scenarios, ...
... you have to add the dependency to `@sap/cds-ea-plugin` also to the _package.json_
in the _mtx/sidecar_ folder.
:::

To install the runtime plugin, add a dependency to the _package.json_ for Node.js or to the _pom.xml_ for a CAP Java application:

::: code-group
```sh [Node.js]
npm add @sap/cds-adapter-ina-js
```

```xml [Java (pom.xml)]
<dependencies>
  <dependency>
    <groupId>com.sap.firefly</groupId>
    <artifactId>cds-adapter-ina</artifactId>
    <version>1.0.3</version>
  </dependency>
  ...
</dependencies>
```
:::

This plugin provides the endpoint for handling InA requests.

::: tip Security Aspects
The plugin requires no further configuration but uses the security settings you added to your application. Also see [Add Authorization](#add-authorization).
:::

## Declare an Analytical Service

To expose a cube for consumption by InA clients, first declare an "analytical" service. This
is a service with protocol `ina`.

```cds
@protocol: 'ina'
service FlightService {
  // This is where you define your analytical service in the next step
  };
```

This service is then an interface, for example, for consumption by SAP Analytics Cloud.

>Add a screenshot of a dashboard build on this scenario.

## Define a Cube

A cube represents the multidimensional model. It contains [analytical measures](#about-measures) and [dimension fields](#about-dimensions).

Inside the analytical service, define a minimalistic example cube:

```cds
@protocol: 'ina'
service FlightService {
  @ObjectModel.modelingPattern: #ANALYTICAL_CUBE
  @ObjectModel.supportedCapabilities: [#ANALYTICAL_PROVIDER]
  entity FlightByAirport as select from my.Flight {
    // This is where you add measures and dimensions to your Cube in the next steps
  }
};
```

A cube is characterized by an `entity` with the annotations `@ObjectModel.modelingPattern: #ANALYTICAL_CUBE` and `@ObjectModel.supportedCapabilities: [#ANALYTICAL_PROVIDER]`. In a cube entity, every element that is not defined as a measure is automatically a dimension. So the current cube doesn't have measures, which means that all fields of the `Flight` entity become dimensions for the `FlightByAirport` cube.

> The annotations used here are the same in ABAP, S4/HANA, and SAP Datasphere. If you'd like to see more convenience to make modelling easier in CAP, let us know.

::: warning No exposure via projection
Currently it is not possible to define a cube outside of an analytical service
and then expose it via a projection in the service.
:::


### Add Authorization

The [CDS authorization concept](../guides/security/authorization#cds-based-authorization) also applies to a cube entity.
Add respective annotations to the cube to define [restrictions](../guides/security/authorization#restrictions)
(in the `where` condition for instance based authorization, [Exists predicates](../guides/security/authorization#exists-predicate)
and [Association Paths](../guides/security/authorization#association-paths) are not supported).

```cds
@restrict: [{ // role "analytics" can see everything [!code focus:8]
  grant: ['READ'],
  to: 'analytics'
}, {  // role "analytics-restricted" can see only flights related to the user's country
  grant: ['READ'],
  to: 'analytics-restricted',
  where: 'DepartureCountryCode = $user.country OR DestinationCountryCode = $user.country'
}]
@ObjectModel.modelingPattern: #ANALYTICAL_CUBE
@ObjectModel.supportedCapabilities: [#ANALYTICAL_PROVIDER]
entity FlightByAirport as select from my.Flight {
  //...
};
```

## About Measures

Analytical measures (or simply measures) are elements of the cube that contain quantifiable data,
for example, the price of a flight, or the number of available seats for a flight. Measures must have a numeric data type.
The purpose of analytics is to gain an understanding of these numbers.
A cube must have at least one measure. All elements of the cube that are not marked as measure are
treated as [dimension fields](#define-dimensions).

Add annotation `@AnalyticsDetails.measureType` to an element of a cube to make it a measure.
The value of the annotation determines the kind of the measure:

- `#BASE` for a base measure

  A _base measure_ is a cube element with the [`@AnalyticsDetails.measureType: #BASE`](#add-base-measures) annotation.
  It's a simple measure and can be a simple projection of a field in the cube's data source, or an expression based on such fields and numeric literals.

- `#CALCULATION` for a calculated measure
  
  A _calculated measure_ is a cube element with the [`@AnalyticsDetails.measureType: #CALCULATION`](#add-calculated-measures) annotation.
  It's an expression based on other measures of the cube and on numeric literals.

- `#RESTRICTION` for a restricted measure
  
  A _restricted measure_ is a cube element with the [`@AnalyticsDetails.measureType: #RESTRICTION`](#add-restricted-measure) annotation. Use it to exclude certain values from the standard aggregation, that is, only apply the standard aggregation to a part of the actual result set.


## Add Base Measures

When executing a query, the analytical engine first performs a standard aggregation for each base measure
over all dimensions that are not part of the respective drill-down.
The type of this aggregation is specified via the annotation `@Aggregation.default`
with possible values `#SUM, #MAX, #MIN, #AVG, #COUNT, #COUNT_DISTINCT`.
If no aggregation behavior is specified, `#SUM` is used.

In the case of an expression, this expression is evaluated _before_ the standard aggregation.

Example:

```cds
entity FlightByAirport as select from my.Flight {
  // ...
  @AnalyticsDetails.measureType: #BASE
  Price,
  @(AnalyticsDetails.measureType: #BASE)
  MaximumSeats,
  @(AnalyticsDetails.measureType: #BASE)
  OccupiedSeats,
  @(AnalyticsDetails.measureType: #BASE)
  @(Aggregation.default: #SUM) 
  OccupiedSeats * Price as Profit : Decimal 
  
  // ...
};
```

You learned that the default aggregation behavior is `#SUM`. So in the previous snippet you could also omit this annotation and have the same result. We added it here just for clarity.

> Note: Always add an explicit type, if you have an expression in the cube.

While the behavior of `#SUM`, `#MAX`, and `#MIN` is straightforward,
aggregation with `#AVG`, `#COUNT`, or `#COUNT_DISTINCT` need to be handled with care.
For data sources where the technical key and the semantic key are not the same,
naive usage of `#AVG`, `#COUNT`, or `#COUNT_DISTINCT` may lead to unexpected results. Those can be data sources containing delta-bookings or cancellations, or that contain the same record multiple times.
Use an [exception aggregation](#exception-aggregation) in such situations.

In SFlight we don't have these complications, so we can go with the standard aggregation.

For counting (with `#COUNT` or `#COUNT_DISTINCT`), the actual value of the referenced element
is ignored. Thus, it is recommended to always define a new element.


### Count Records

Use `#COUNT` if you simply want to show the number of flights:

```cds
entity FlightByAirport as select from my.Flight {
  // ...
  @AnalyticsDetails.measureType: #BASE
  @Aggregation.default: #COUNT
  1 as FlightCount : Integer,
  // ...
};
```


### Distinct Combinations

In a business context a plain `COUNT` usually is not very helpful.
Most often you would rather do a `#COUNT_DISTINCT`. Specify the dimensions whose
distinct values are to be counted via annotation `@Aggregation.referenceElement`.
The value of this annotation is an array where dimension fields and navigation attributes
can be provided.

Example: Get number of distinct combinations of `AirlineID` and `ConnectionID`.

```cds
entity FlightByAirport as select from my.Flight {
  // ...
  @AnalyticsDetails.measureType: #BASE
  @Aggregation.default: #COUNT_DISTINCT
  @Aggregation.referenceElement: [AirlineID, ConnectionID]
  1 as AirlineConnectionCount : Integer,
  // ...
};
```

The combination of `#COUNT_DISTINCT` and `@Aggregation.referenceElement` can be regarded
as a short-cut for an [exception aggregation](#exception-aggregation).

> TODO: **Why not move it to Exception Aggregation?**

### Average

You can use `#AVG` for doing simple averages, like the average number of occupied seats:

```cds
entity FlightByAirport as select from my.Flight {
  // ...
  @AnalyticsDetails.measureType: #BASE
  @Aggregation.default: #AVG
  OccupiedSeats as AvgOccSeats : Decimal,
  // ...
};
```

For more complicated averages, use [exception aggregation](#exception-aggregation),
or provide separate measures for the sum and the count and then compute
the average via a [Calculated Measure](#add-calculated-measures).



## Add Calculated Measures


You cannot refer to elements of the cube's data source.
The expression is evaluated _after_ standard aggregation has been performed for the `#BASE` measures.

Example:

```cds
entity FlightByAirport as select from my.Flight {
  // ...
  @AnalyticsDetails.measureType: #BASE
  MaximumSeats,
  @AnalyticsDetails.measureType: #BASE
  OccupiedSeats,

  // calculated measure
  @AnalyticsDetails.measureType: #CALCULATION
  $self.MaximumSeats - $self.OccupiedSeats as AvailableSeats : Integer,
  // ...
};
```

Note:

- To address other measures in the expression for a calculated measure, prefix them with `$self`.
- Always add an explicit type if you have an expression in the cube.
- Annotation `@Aggregation.default` is irrelevant (ignored) for calculated measures.

See also: [List of supported operators and functions (internal link)](https://github.wdf.sap.corp/pages/orca/seal/seal-service/features/views/analyticalModel/calculations/ckf/).

When an expression contains an "unsuitable" combination of measures (like adding a measure without
currency to a measure with a currency), the analytical engine will evaluate the expression
and mark the result as "mixed", like for aggregating values with different currencies/units.





## Add Restricted Measure <Beta />

The cube element must be a `CASE` expression with only one `WHEN`/`THEN` clause, `ELSE` is not allowed.
The `THEN` clause must contain a single reference to another measure of the cube,
expressions are not supported.

For computing a restricted measure, the result set is filtered according to
the `WHEN` condition before standard aggregation is applied.
This condition can use literals, dimension fields, and parameters of the cube.

Example:

```cds
entity FlightByAirport as select from my.Flight {
  // ...

  @AnalyticsDetails.measureType: #RESTRICTION
  case when $self.PlaneType = :PreferredPlaneType
    then $self.AvailableSeats
    end as AvailableSeatsOnPreferredPlaneType : Integer,

  // ...
};
```

Note: Annotation `@Aggregation.default` is irrelevant, like for Calculated Measures.

::: warning

Currently the behavior of Restricted Measures is different from what is documented here.
Either behavior or documentation will change.

:::



## Exception Aggregation <Beta /> {#exception-aggregation}

An exception aggregation can be applied to any measure (base, calculated, or restricted).

Example: Use exception aggregation to count the number of distinct combinations
of `AirlineID` and `ConnectionID`:

```cds
entity FlightByAirport as select from my.Flight {
  // ...
  @AnalyticsDetails.exceptionAggregationSteps: [{
    exceptionAggregationBehavior: #SUM,
    exceptionAggregationElements: [AirlineID,ConnectionID]
  }]
  @AnalyticsDetails.measureType: #CALCULATION
  //@Aggregation.default: #NONE
  @Common.Label: null @title:null
  1 as ExcAggCount : Integer,
  // ...
};
```

Example: You compare flight prices from various airlines.
When looking at them on the granularity of single FlightDates, you want to see the minimum prices.
When FlightDate is not part of the drill-down at all, or when the granularity
is Month, Quarter, and so on, then you want to see the average over these minimum prices
for the respective time period.

For this, define a measure with exception aggregation.

```cds
entity FlightByAirport as select from my.Flight {
  // ...
  @AnalyticsDetails.measureType: #BASE
  @AnalyticsDetails.exceptionAggregationSteps: [{
    exceptionAggregationBehavior: #AVG,
    exceptionAggregationElements: [ FlightDate ]
  }]
  Price as AvgMinPrice,
  // ...
};
```

Supported values for `exceptionAggregationBehavior` are:

| Value           | Description |
| ---             | ---         |
| SUM             | Sum         |
| MIN             | Minimum     |
| MAX             | Maximum     |
| COUNT           | Count       |
| COUNTNULL       | Count, ignore data where value is NULL                |
| COUNTNULLZERO   | Count, ignore data where value is NULL or exactly 0   |
| AVG             | Average                                               |
| AVERAGENULL     | Average, ignore data where value is NULL              |
| AVERAGENULLZERO | Average, ignore data where value is NULL or exactly 0 |
| STD             | Standard deviation                                    |
| FIRST           | First entry w.r.t. ordering by dimension key values   |
| LAST            | Last entry w.r.t. ordering by dimension key values    |

This is how the system evaluates measures with exception aggregation:

1) Group by all dimensions that are not in the drill-down plus all `exceptionAggregationElements`.
2) Apply standard aggregation.
3) (if applicable) Perform a calculation for a calculated measure.
4) Apply specified exception aggregation along `exceptionAggregationElements`.

For more complicated cases several exception aggregation steps can be defined, which
are performed sequentially.

::: warning

Currently the behavior of Exception Aggregation is different from what is documented here.
Either behavior or documentation will change.

:::

## Currency and Unit {#currency-and-unit}

Measures can have a reference to a currency key or a unit key.
For a value with a currency (amount) or a value with a unit, connect the value field with the
currency or unit field via annotation:

```cds
@Measures.ISOCurrency: CurrencyCode_code
// or
@Measures.Unit: unit_code
```

In our flight example, `Price` has a currency:

```cds
entity FlightByAirport as select from my.Flight {
  // ...
  CurrencyCode,

  @AnalyticsDetails.measureType: #BASE
  @Measures.ISOCurrency: CurrencyCode_code //[!code ++]
  Price,
  // ...
};
```

::: tip No automatic currency or unit conversion is performed
If for such a measure values with different currencies (or units) are aggregated, the analytical engine aggregates the values regardless of their currency (or unit). The engine marks the result as "mixed" and it's up to the clients how to represent such a value.
:::


## About Dimensions

_Dimension fields_, which are part of the cube, contain descriptive data, such as an airline ID or a flight date.
They provide the (business) context for the measures and are used for filtering and grouping the data.
Additional information for the dimension fields can be provided in corresponding dimension entities.

A _dimension entity_ is an entity with the annotations `@ObjectModel.modelingPattern: #ANALYTICAL_DIMENSION`
and `@ObjectModel.supportedCapabilities: [#ANALYTICAL_DIMENSION]`.
It provides additional attributes for a dimension field in the cube view.
Usually a dimension is a projection or view on top of a more basic entity in the model.

The connection between a dimension field in the cube and the corresponding dimension entity
is established via a `to-one` association from the cube to the dimension
and an annotation `@ObjectModel.foreignKey.association` at the dimension field that refers to this association.

## Define Dimensions

Turn the Airline entity into a dimension and link it in the cube:

```cds
// dimension entity
annotate my.Airline with @ObjectModel.modelingPattern: #ANALYTICAL_DIMENSION //[!code ++]
                         @ObjectModel.supportedCapabilities: [#ANALYTICAL_DIMENSION]; //[!code ++]

entity FlightByAirport as select from my.Flight {
  @ObjectModel.foreignKey.association: to_Airline //[!code ++]
  AirlineID,
  to_Airline,  // association to the dimension entity //[!code ++]
  [...]
};
```

The attributes in a dimension can be used for

- Navigation Attributes
- Providing a text for a dimension field
- Defining a hierarchy


### Navigation Attribute

If you want to use an attribute of the dimension for grouping and/or filtering like
the dimension field, you have to add it to the cube. This way it becomes a "navigation attribute".
Analytical clients may show navigation attributes grouped below the dimension field.

A navigation attribute can also be an element of a dimension entity that is
not directly referenced in the cube but reached via another association.

Example:

```cds
entity FlightByAirport as select from my.Flight {
  // ...

  @ObjectModel.foreignKey.association: to_Connection
  ConnectionID,  // dimension field
  to_Connection,

  // navigation attributes
  to_Connection.DepartureAirport.AirportID as DepartureAirportID,
  to_Connection.DestinationAirport.AirportID as DestinationAirportID,

  // ...
};
```

:::tip New dimension
Adding a navigation attribute to the cube effectively adds a new dimension to the cube,
as one more characteristic is available for drill-down.
:::

### Texts

Oftentimes you want to connect a dimension field or a navigation attribute with a text,
so that a client can display this text together with or instead of the dimension field's value.

To do so, add annotation `@ObjectModel.text.element` in the dimension entity.
The value of the annotation is a reference to the text field.

Example:

```cds
annotate my.Airline with
  @ObjectModel.modelingPattern: #ANALYTICAL_DIMENSION
  @ObjectModel.supportedCapabilities: [#ANALYTICAL_DIMENSION]
{
  @ObjectModel.text.element: Name
  AirlineID;
  @Semantics.text: true
  Name;
};
```

Now, analytical clients can show the airline name together with or instead of the ID,
even though the name is not an element of the cube.

### Localized Texts

If the text that you want to display is localized (based on CAP feature "localized data"),
do the following:

Add a projection on the respective `.texts` entity to your model, and add annotations
to declare it as a text entity. In the projection, you have to explicitly declare
the `locale` element as carrying the language code, and explicitly mark the
element that contains the actual text:

```cds
annotate sap.common.Countries.texts with
  @ObjectModel.modelingPattern: #LANGUAGE_DEPENDENT_TEXT
  @ObjectModel.supportedCapabilities: [#LANGUAGE_DEPENDENT_TEXT]
{
  @Semantics.language: true
  locale;
  @Semantics.text: true
  name;
};
```

In the dimension entity, use annotation `@ObjectModel.text.association` to connect
the `texts` association it with the `code` field. If the dimension is a projection,
make sure that the `texts` association is projected.

```cds
annotate sap.common.Countries with
  @ObjectModel.modelingPattern: #ANALYTICAL_DIMENSION
  @ObjectModel.supportedCapabilities: [#ANALYTICAL_DIMENSION]
{
  @ObjectModel.text.association: texts
  code;
};
```

::: tip
Info: if an entity contains `localized` elements, the compiler automatically generates
a corresponding `.texts` entity and adds an association `texts` that points to the `.texts`
entity into the base entity. See also [Localized Data](/guides/localized-data).
:::



### Level-Based Hierarchies

A dimension can have a Level-Based Hierarchy to define hierarchical structures,
for example year, quarter, month, and date.
These hierarchies allow for roll-up and drill down of aggregated data,
for example January, February, and March can be rolled up as Q1.

First we define a base entity for holding calendar data.

```cds
entity CalendarDate {
  key Date: Date;
  Year: String(4);
  Halfyear: String(1);
  Quarter: String(1);
  Month: String(2);
};
```

::: tip
Note: You have to provide the data for this entity by yourself.
:::

Now we define a dimension entity for `FlightDate` as projection on
top of `CalendarDate` and make it a leveled hierarchy.
The calculated fields bring the values for `Quarter` and `Month` into
the format expected by SAC.

```cds
@ObjectModel.modelingPattern: #ANALYTICAL_DIMENSION
@ObjectModel.supportedCapabilities: [#ANALYTICAL_DIMENSION]
@Analytics.dimensionType: #TIME
@Hierarchy.leveled: [{
  name: 'YQMD',
  label: 'Year/Quarter/Month',
  levels: [{ element: Year }, { element: Quarter }, { element: Month }, { element: Date }]
}]
entity CalendarDateDimension as projection on CalendarDate {
  Date,
  @Common.IsCalendarYear: true
  Year,
  @Common.IsCalendarQuarter
  Year || Quarter as Quarter : String(5),
  @Common.IsCalendarMonth
  Year || (length(Month) = 1 ? '0' : '' ) || Month as Month : String(6)
};
```

Add an association to the new dimension in the Flight entity.

```cds
extend my.Flight with {
  to_FlightDate: Association[0..1] to CalendarDateDimension on to_FlightDate.Date = FlightDate;
};
```

In the cube, select the association and link it to dimension field `FlightDate`.
The elements of the hierarchy that shall be available for drill-down need to be
added as navigation attributes.

```cds
entity FlightByAirport as select from my.Flight {
  // ...
  @ObjectModel.foreignKey.association: to_FlightDate
  FlightDate,
  to_FlightDate,

  to_FlightDate.Month as FlightMonth,
  to_FlightDate.Quarter as FlightQuarter,
  to_FlightDate.Year as FlightYear,

  // ...
};
```

### Parent-Child Hierarchies

Another type of hierarchy is a parent-child hierarchy.
We enhance our example by adding a dimension for plane types
that has a parent-child-hierarchy. In the base model there already is an entity for `PlaneType` that allows for
capturing a hierarchy:

```cds
entity sap.fe.cap.travel.PlaneType {
  key ID : String(10);
  Parent : String(10);
  // ... additional info
};
```

In the analytical model, we turn `PlaneType` into a dimension and
link it with the cube:

```cds
extend sap.fe.cap.travel.PlaneType with AnalyticalDimension;

extend my.Flight with {
  to_PlaneType: Association to PlaneType on to_PlaneType.ID = PlaneType;
};

entity FlightByAirport as select from my.Flight {
  // ...
    @ObjectModel.foreignKey.association: to_PlaneType
    PlaneType,
    to_PlaneType,

  // ...
};
```

Finally, we turn `PlaneType` into a parent-child hierarchy by adding the annotation
`@Hierarchy.parentChild`.
Property `recurse` defines the parent-child relation by linking respective elements of the entity.
In our example element `Parent` contains the ID of the parent entry.
The display order of siblings on the same hierarchy level can be defined via property `siblingsOrder`.

```cds
annotate sap.fe.cap.travel.PlaneType with @Hierarchy.parentChild: [{
  name: 'PlaneType',  // ID of the hierarchy
  label: 'Plane Types',
  recurse: {
      parent: [Parent],
      child: [ID]
  },
  siblingsOrder: [{
    by: ID,
    direction: 'DESC'
  }]
}];
```

For entities with a composite key, `recurse` and `siblingsOrder` allow to provide lists of elements.

In a client, leveled hierarchies and parent-child hierarchies behave the same.




## Prepare for Production
> Question: Or is that only a "Add SAP HANA Configuration" section, if we should decide to not elaborate too much on deployment? Otherwise we'd need to add more facets than just hana.

If not done already, add SAP HANA configuration to your project:

```sh
cds add hana,mta,xsuaa,approuter
```

This step is important to ensure that the `db/undeploy.json` file is available in your project and contains an entry for `hdbcalculationview` to undeploy possibly outdated artifacts.

Expose the route provided by the InA adapter through the approuter:

::: code-group

```js [app/router/xs-app.json]{2-6}
{"routes": [           
        {
            "source": "^/sap/bc/ina/service/v2/(.*)$",
            "destination": "srv-api",
            "authenticationType": "xsuaa"
        }
     ]
     }
```
:::

Enhance the approuter module in the mta.yaml and replace `<your SAC tenant host url>`:

::: code-group
```yaml [mta.yaml]
- name: sflight
  [...]
  properties:
     CORS: '[{"uriPattern": "^/sap/bc/ina/(.*)$", "allowedOrigin":
       [{"host":"<your SAC tenant host url>",
       "protocol":"https"}], "allowedMethods": ["GET", "POST", "OPTIONS"],
       "allowedHeaders": ["Origin", "Accept", "X-Requested-With",
       "Content-Type", "Access-Control-Request-Method",
       "Access-Control-Request-Headers", "Authorization", "X-Sap-Cid",
       "X-Csrf-Token", "application-id"], "exposeHeaders": ["Accept",
       "Authorization", "X-Requested-With", "X-Sap-Cid",
       "Access-Control-Allow-Origin", "Access-Control-Allow-Credentials",
       "X-Csrf-Token", "Content-Type"]}]'
     COOKIES: '{"SameSite": "None"}'
     SESSION_TIMEOUT: 120
```
:::

## Deploy to Cloud

> Also see [here](https://github.tools.sap/cap/golden-path/blob/main/deploy/with-sac/to-cf.md), because it adds some config to the approuter in the _mta.yaml_. Needed? If yes, can that be added by `cds add approuter`?
tbd

> Maybe similar to MT docs

## Connect to SAP Analytics Cloud

> see also https://github.tools.sap/cap/golden-path/blob/main/integrate/sac/for-cloud-foundry-runtime/sac-integration.mds





## Glossary

---

| **Term** | **Definition** |
| :------- | :------------: |
| Cube | A multidimensional model for analytics. |
| Measure | Quantifiable data in a cube. |
| Dimension | Descriptive data in a cube. |
| Base Measure | A simple measure in a cube. |
| Calculated Measure | A measure derived from other measures. |
| Restricted Measure | A measure with a filter applied before aggregation. |
| Exception Aggregation | Aggregation applied to a measure with specific conditions. |
| Analytical Service | A service with protocol `ina` for exposing analytical models. |
| Dimension Entity | An entity providing additional attributes for a dimension field. |
| Navigation Attribute | An attribute of a dimension used for grouping and filtering. |
| Hierarchy | A structure defining levels or parent-child relationships in dimensions. |
| Leveled Hierarchy | A hierarchy with predefined levels like year, quarter, month. |
| Parent-Child Hierarchy | A hierarchy where each element has a parent element. |
| Analytical Cube | The central entity in an analytical model containing measures and dimensions. |
| Analytical Model | A model defining the structure and relationships of data for analytics. |
| Analytical Query | A query executed by the analytical engine to retrieve data based on the model. |
| Analytical Plugin | A plugin responsible for creating runtime objects and metadata for analytics. |



# Localization, i18n

Guides you through the steps to internationalize your application to provide localized versions with respect to both Localized Models as well as Localized Data.

_'Localization'_ is a means to adapting your app to the languages of specific target markets.

This guide focuses on static texts such as labels. See [CDS](../cds/) and [Localized Data](localized-data) for information about how to manage and serve actual payload data in different translations.


## Externalizing Texts Bundles

All you have to do to internationalize your models is to externalize all of your literal texts to text bundles and refer to the respective keys from your models as annotation values. Here is a sample of a model and the corresponding bundle.

::: code-group
```cds [srv/my-service.1.cds]
service Bookshop {
  entity Books @(
    UI.HeaderInfo: {
      Title.Label: '{i18n>Book}',
      TypeName: '{i18n>Book}',
      TypeNamePlural: '{i18n>Books}',
    },
  ){/*...*/}
}
```
:::

::: code-group
```properties [_i18n/i18n.properties]
Book = Book
Books = Books
foo = Foo
```
:::

> You can define the keys of your properties entries.

[Learn more about annotations in CSN.](../cds/csn#annotations){ .learn-more}

Then you can translate the texts in localized bundles, each with a language/locale code appended to its name, for example:

```sh
_i18n/
  i18n.properties           # dev main --› 'default fallback'
  i18n_en.properties        # English    --› 'default language'
  i18n_de.properties        # German
  i18n_zh_TW.properties     # Traditional Chinese
  ...
```


## Where to Place Text Bundles?

Recommendation is to put your properties files in a folder named `_i18n` in the root of your project, as in this example:

```txt
bookshop/
├─ _i18n/
│  ├─ i18n_en.properties
│  ├─ i18n_de.properties
│  ├─ i18n_fr.properties
│  └─ i18n.properties
│  ...
```



By default, text bundles are fetched from folders named *_i18n* or *i18n* in the neighborhood of models, i.e. all folders that contain `.cds` sources or parent folders thereof. For example, given the following project layout and sources:

```txt
bookshop/
├─ app/
│  ├─ browse/
│  │  └─ fiori.cds
│  ├─ common.cds
│  └─ index.cds
├─ srv/
│  ├─ admin-service.cds
│  └─ cat-service.cds
├─ db/
│  └─ schema.cds
└─ readme.md
```

We will be loading i18n bundles from all of these locations, if exist:

```txt
bookshop/app/browse/_i18n
bookshop/app/_i18n
bookshop/srv/_i18n
bookshop/db/_i18n
bookshop/_i18n
```

[Learn more about the underlying machinery in the reference docs for `cds.i18n`](../node.js/cds-i18n){.learn-more}



<span id="beforecsvbundles" />
<Fragment target="#beforecsvbundles">

## Translating Text Bundles <Internal />

Use the SAP Translation process as [described here](https://wiki.one.int.sap/wiki/display/HCPCollaboration/Translation).

</Fragment>

## CSV-Based Text Bundles

For smaller projects you can use CSV files instead of _.properties_ files, which you can easily edit in _Excel_, _Numbers_, etc.

The format is as follows:

| key | en | de | zh_CN | ... |
| --- | --- | --- | --- | --- |
| Book | Book | Buch | ... |
| Books | Books | Bücher | ... |
| ... |
{}

With this CSV source:

```csv
key;en;de;zh_CN;...
Book;Book;Buch;...
Books;Books;Bücher;...
...
```

## Merging Algorithm

Each localized model is constructed by applying:

1. The _default fallback_ bundle (that is, *i18n.properties*), then ...
2. The _default language_ bundle (usually *i18n_en.properties*), then ...
3. The requested bundle (for example, *i18n_de.properties*)

In that order.

So, the complete stack of overlaid models for the given example would look like this (higher ones override lower ones):

| Source | Content |
|:--- |:--- |
| *_i18n/i18n_de.properties* | specific language bundle |
| *_i18n/i18n_en.properties* | default language bundle |
| *_i18n/i18n.properties* | default fallback bundle |
| *srv/my-service.cds* | service definition |
| *db/schema.cds* | underlying data model |

::: tip Set default language
The _default language_ is usually `en` but can be overridden by configuring <Config>cds.i18n.default_language</Config> in your project's _package.json_.
:::

## Merging Reuse Bundles

If your application is [importing models from a reuse package](extensibility/composition), that package comes with its own language bundles for localization. These are applied upon import, so they can be overridden in your models as well as in your language bundles and their translations.

For example, assuming that your data model imports from a _foundation_ package, then the overall stack of overlays would look like this:

| Source |
|:--- |
| *./_i18n/i18n_de.properties* |
| *./_i18n/i18n_en.properties* |
| *./_i18n/i18n.properties* |
| *./srv/my-service.cds* |
| *./db/schema.cds* |
| *foundation/_i18n/i18n_de.properties* |
| *foundation/_i18n/i18n_en.properties* |
| *foundation/_i18n/i18n.properties* |
| *foundation/index.cds* |
| *foundation/\<private model a\>.cds* |
| *foundation/\<private model b\>.cds* |
| ... |

## Determining User Locales { #user-locale}

Upon incoming requests at runtime, the user's preferred language is determined as follows:

1. Read the preferred language from the first of:
   1. The value of the `sap-locale` URL parameter, if present.
   2. The value of the `sap-language` URL parameter, but only if it's `1Q`, `2Q` or `3Q` as described below.
   3. The first entry from the request's `Accept-Language` header.
2. Narrow to normalized locales as described below.
::: tip
CAP Node.js accepts formats following the available standards of POSIX and RFC 1766, and transforms them into normalized locales. CAP Java only accepts language codes following the standard of RFC 1766 (or [IETF's BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt)).
:::

## Normalized Locales { #normalized-locales}

To reduce the number of required translations, most determined locales are normalized by narrowing them to their main language codes only, for example, `en_US`, `en_CA`, `en_AU` &rarr; `en`, except for these preserved language codes:

| Locale | Language |
| --- | --- |
| zh_CN | Chinese - China  |
| zh_HK | Chinese - Hong Kong, China |
| zh_TW | Chinese traditional - Taiwan, China |
| en_GB | English - English |
| fr_CA | French - Canada |
| pt_PT | Portuguese - Portugal |
| es_CO | Spanish - Colombia |
| es_MX | Spanish - Mexico |
| en_US_x_saptrc | SAP tracing translations w/ `sap-language=1Q` |
| en_US_x_sappsd | SAP pseudo translations w/ `sap-language=2Q` |
| en_US_x_saprigi | Rigi language w/ `sap-language=3Q` |

#### Configuring Normalized Locales

For CAP Node.js, the list of preserved locales is configurable, for example in the _package.json_ file, using the configuration option <Config>cds.i18n.preserved_locales</Config> as follows:

```jsonc
{"cds":{
  "i18n": {
    "preserved_locales": [
      "en_GB",
      "fr_CA",
      "pt_PT",
      "pt_BR",
      "zh_CN",
      "zh_HK",
      "zh_TW"
    ]
  }
}}
```

In this example we removed `es_CO` and `es_MX` from the list, and added `pt_BR`.

In CAP Java the preserved locales can be configured via the <Config java>cds.locales.normalization.includeList</Config> [property](../java/developing-applications/properties#cds-locales-normalization).

::: warning *Note:* 
However this list is configured, ensure to have translations for the listed locales, as the fallback language will otherwise be `en`.
:::

#### Use Underscores in File Names

Due to the ambiguity regarding  standards, for example, the usage of hyphens (`-`) in contrast to underscores (`_`), CAP follows the approach of the [SAP Translation Hub](https://discovery-center.cloud.sap/serviceCatalog/sap-translation-hub). Using that approach, CAP normalizes locales to **underscores** as our de facto standard.

In effect, this means:

- We support incoming locales as [language tags](https://www.ietf.org/rfc/bcp/bcp47.txt) using hyphens to separate sub tags <sup>1</sup>, for example `en-GB`.
- We always normalize these to underscores, which is `en_GB`.
- Always use underscores in filenames, for example, `i18n_en_GB.properties`
- Always use underscores when filling `LOCALE` columns of localized text tables (e.g. in CSV files).

<sup>1</sup> CAP Node.js also supports underscore separated tags, for example `en_GB`.

<div id="translation-sap" />
<Fragment target="#translation-sap">

## Translation Within SAP <Internal />

You can use the SAP Translation Enablement Workbench to translate, for example, properties or CSV files. Raw files are uploaded from your GitHub repository. After translation, language-specifics are downloaded to your GitHub repository. You'll get files for all translated languages with the language-specific suffix, for example `_de` for German.

See [SAP Translation Enablement Workbench User Guide](https://slsapps.slsna.c.eu-de-1.cloud.sap/TEWWebHelp/#Topics/getting_started_with_tew.html) for more details.

#### Translatable Content for SAP HANA

You can deploy [CSV files with initial database content](./databases#providing-initial-data) with translatable texts to SAP HANA through _hdbtabledata_'s `include_filter` feature. See [this example](https://github.wdf.sap.corp/CloudConso/grdc/blob/e27eee9ae9be4aa76d41c6e2992e86e8d156e8a9/db/src/csv/Data.hdbtabledata#L26) for more information.

::: warning Migration to language-specific translation files
If you've already deployed your application using translation files _without_ language key like `xxx_texts.csv` and now want to use language-specific translation files like `xxx_texts_de.csv`, you have to **undeploy the existing translation files**.
<br>
Add the corresponding file entries, for example `"src/gen/data/xxx_texts.hdbtabledata", "src/gen/data/xxx_texts.csv"` to your `undeploy.json`.
<br>
Otherwise you will get a deployment error similar to this one:
`The include_filter definitions in the table import files src/gen/data/xxx_texts.hdbtabledata and src/gen/data/xxx_texts_de.hdbtabledata use key values that are not disjunct; src/gen/data/xxx_texts.hdbtabledata defines no include_filters which prohibits other imports from importing into the same table.`
:::

</Fragment>

<div id="secondary-file">guides/i18n.fragment.md</div>


# Localized Data

This guide extends the localization/i18n of static content, such as labels or messages, to serve localized versions of actual application data.

Localized data refers to the maintenance of different translations of textual data and automatically fetching the translations matching the users' preferred language, with per-row fallback to default languages, if the required translations aren't available. Language codes are in ISO 639-1 format.

> Find a **working sample** at <https://github.com/sap-samples/cloud-cap-samples/tree/main/bookshop>.

## Declaring Localized Data

Use the `localized` modifier to mark entity elements that require translated texts.

```cds
entity Books {
  key ID       : UUID;
      title    : localized String;
      descr    : localized String;
      price    : Decimal;
      currency : Currency;
}
```

[Find this source also in **cap/samples**.](https://github.com/sap-samples/cloud-cap-samples/blob/ea6e27481071a765dfd701ddb239ed89b92bf426/bookshop/db/schema.cds#L4-L7){ .learn-more}

::: warning _Restriction_
If you want to use the `localized` modifier, the entity's keys must not be associations.
:::

> `localized` in entity sub elements isn't currently supported and is ignored.
> This includes `localized` in structured elements and structured types.

## Behind the Scenes

The `cds` compiler automatically unfolds the previous definition as follows,
applying the basic mechanisms of [Managed Compositions](../cds/cdl#managed-compositions),
and [Scoped Names](../cds/cdl#scoped-names):

First, a separate _Books.texts_ entity is added to hold translated texts:

```cds
entity Books.texts {
  key locale : sap.common.Locale;
  key ID : UUID; //= source's primary key
  title : String;
  descr : String;
}
```

[See the definition of `sap.common.Locale`.](../cds/common#locale-type){ .learn-more}

Second, the source entity is extended with associations to _Books.texts_:

```cds
extend entity Books with {
  texts : Composition of many Books.texts on texts.ID=ID;
  localized : Association to Books.texts on localized.ID=ID
    and localized.locale = $user.locale;
}
```

The composition `texts` points to all translated texts for the given entity, whereas the `localized` association points to the translated texts and is narrowed to the request's locale.

Third, views are generated in SQL DDL to easily read localized texts with an equivalent fallback:

```cds
entity localized.Books as select from Books {*,
  coalesce (localized.title, title) as title,
  coalesce (localized.descr, descr) as descr
};
```
::: warning Note:
In contrast to former versions, with CDS compiler v2 we don't add such entities to CSN anymore, but only on generated SQL DDL output.
:::

### Resolving localized texts via views

As we already mentioned, the CDS compiler is already creating views that resolve the translated texts internally. Once a CDS runtime detects
a request with a user locale, it uses those views instead of the table of the involved entity.

Note that SQLite doesn't support locales like _SAP HANA_ does. For _SQLite_, additional views are generated for different languages. Currently those views are generated for the locales 'de' and 'fr' and the default locale is handled as 'en'.

```json
"i18n": { "for_sqlite": ["en", ...] }
```

> In _package.json_ put this snippet in the `cds` block, but don't do so for _.cdsrc.json_.

> For testing with SQLite: Make sure that the _Books_ table contains the English texts and that the other languages go into the _Books.texts_ table.

For _H2_, you need to use the property as follows.

```json
"i18n": { "for_sql": ["en", ...] }
```


### Resolving search over localized texts at runtime { #resolving-localized-texts-at-runtime}

Although the approach with the generated localized views is very convenient, it's limited on SQLite and shows suboptimal performance with large data sets on _SAP HANA_. Especially for search operations the performance penalty is very critical. Therefore, both CAP runtimes have implemented a solution targeted for search operations. If the `localized` association of your entity is present and accessible by the given CQL statement, the runtimes generate SQL statements that resolve the localized texts. This is optimized for the underlying database.

When your CQL queries select entities directly there is no issue as the `localized` association is automatically accessible in an entity with localized elements. If your CQL query selects from a view, it is important that your views' projection preserves the `localized` association.

The following view definitions preserve the `localized` association in the view, allowing you to optimize query execution, or for broader language support on SQLite, H2, and PostgreSQL.

**Preferred -** Exclude elements that mustn't be exposed:

```cds
entity OpenBookView as select from Books {*}
  excluding { price, currency };
```

Include the `localized` association:

```cds
entity ClosedBookView as select from Books { ID, title, descr, localized };
```


### Base Entities Stay Intact

In contrast to similar strategies, all texts aren't externalized but the original texts are kept in the source entity. This saves one join when reading localized texts with fallback to the original ones.


### Extending *.texts* Entities { #extending-texts-entities}

It's possible to collectively extend all generated *.texts* entities by extending
the aspect `sap.common.TextsAspect`, which is defined in [*common.cds*](../cds/common#texts-aspects).

For example, the aspect can be used to add an association to the `Languages` code list entity,
or to add flags that help you to control the translation process.

Example:
```cds
extend sap.common.TextsAspect with {
  language : Association to sap.common.Languages on language.code = locale;
}
```

The earlier description is simplified, *.texts* entities are generated with an include on `sap.common.TextsAspect`,
if the aspect exists. For the *Books* entity, the generated *.texts*
entity looks like:

```cds
entity Books.texts : sap.common.TextsAspect {
  key ID : UUID;
  title : String;
  descr : String;
}
```

When the include is expanded, the key element `locale` is inserted into *.texts* entities,
alongside all the other elements that have been added to `sap.common.TextsAspect` via extensions.

```cds
entity Books.texts {
  // from sap.common.TextsAspect
  key locale: sap.common.Locale;
  language : Association to sap.common.Languages on language.code = locale;
  // from Books
  key ID : UUID;
  title : String;
  descr : String;
}
```

It isn't allowed to extend `sap.common.TextsAspect` with
* [Managed Compositions of Aspects](../cds/cdl#managed-compositions)
* localized elements
* key elements

For entities that have an annotation `@fiori.draft.enabled`, the corresponding *.texts*
entities also include the aspect, but the element `locale` isn't marked as a
key and an element `key ID_texts : UUID` is added.

## Pseudo var `$user.locale` { #user-locale}

[`$user.locale`]: #user-locale

As shown in the second step, the pseudo variable `$user.locale` is used to refer to the user's preferred locale and join matching translations from `.texts` tables. This pseudo variable allows expressing such queries in a database-independent way, which is realized in the service runtimes as follows:

### Determining `$user.locale` from Inbound Requests

The user's preferred locale is determined from request parameters, user settings, or the _accept-language_ header of inbound requests [as explained in the Localization guide](i18n#user-locale).

### Programmatic Access to `$user.locale`

The resulting [normalized locale](i18n#normalized-locales) is available programmatically, in your event handlers.

* Node.js: `req.locale`
* Java: `eventContext.getParameterInfo().getLocale()`

### Propagating `$user.locale` to Databases {#propagating-of-user-locale}
[propagation]: #propagating-of-user-locale

Finally, the [normalized locale](i18n#normalized-locales) is **propagated** to underlying databases using session variables, that is, `$user.locale` translates to `session_context('locale')` in native SQL of SAP HANA and most databases.

Not all databases support session variables. For example, for _SQLite_ we currently would just create stand-in views for selected languages. With that, the APIs are kept stable but have restricted feature support.

## Reading Localized Data

Given the asserted unfolding and user locales propagated to the database, you can read localized data as follows:

### In Agnostic Code

Read _original_ texts, that is, the ones in the originally created data entry:

```sql
SELECT ID, title, descr from Books
```

### For End Users

Reading texts for end users uses the `localized` association, which requires prior [propagation] of [`$user.locale`] to the underlying database.

Read _localized_ texts in the user's preferred language:

```sql
SELECT ID, localized.title, localized.descr from Books
```



### For Translation UIs

Translation UIs read and write texts in all languages, independent from the current user's preferred one. They use the to-many `texts` association, which is independent from [`$user.locale`].

Read texts in **different** translations:

```sql
SELECT ID, texts[locale='fr'].title, texts[locale='fr'].descr from Books
```

Read texts in **all** translations:

```sql
SELECT ID, texts.locale, texts.title, texts.descr from Books
```

## Serving Localized Data

The generic handlers of the service runtimes automatically serve read requests from `localized` views. Users see all texts in their preferred language or the fallback language.

[See also **Enabling Draft for Localized Data**.](../advanced/fiori#draft-for-localized-data){ .learn-more}

For example, given this service definition:

```cds
using { Books } from './books';
service CatalogService {
  entity BooksList as projection on Books { ID, title, price };
  entity BooksDetails as projection on Books;
  entity BooksShort as projection on Books { 
    ID, price,
    substr(title, 0, 10) as title : localized String(10), 
  };
}
```

### `localized.` Helper Views

For each exposed entity in a service definition, and all intermediate views, a corresponding `localized.` entity is created. It has the same query clauses and all annotations, except for the `from` clause being redirected to the underlying entity's `localized.` counterpart.  A helper view is only created if the corresponding entity contains at least one element with a `localized` property, or it exposes an association to an entity that is localized.  You may need to cast an element if that property is not propagated, for example for expressions such as in `CatalogService.BooksShort`.

```cds
using { localized.Books } from './books_localized';

entity localized.CatalogService.BooksList as
  SELECT from localized.Books { ID, title, price };

entity localized.CatalogService.BooksDetails as
  SELECT from localized.Books;
  
entity localized.CatalogService.BooksShort as
    SELECT from localized.Books { ID, price,
        substr(title, 0, 10) as title : localized String(10),
    };
```
::: warning Note:
Note that these `localized.` entities are not part of CSN and aren't exposed through OData.
They are only generated for SQL.
:::

### Read Operations

The generic handlers in the service framework will automatically redirect all incoming read requests to the `localized_` helper views in the SQL database, unless in SAP Fiori draft mode.

The `@cds.localized: false` annotation can be used to explicitly switch off the automatic redirection to the localized views. All incoming requests to an entity annotated with `@cds.localized: false` will directly access the base entity.

```cds
using { Books } from './books';
service CatalogService {
  @cds.localized: false //> direct access to base entity; all fields are non-localized defaults
  entity BooksDetails as projection on Books;
}
```
In Node.js applications, for requests with an `$expand` query option on entities annotated with `@cds.localized: false`, the expanded properties are not translated.

```http
GET /BooksDetails?$expand=authors //> all fields from authors are non-localized defaults, if BooksDetails is annotated with `@cds.localized: false`
```

### Write Operations

Since the corresponding text table is linked through composition, you can use deep inserts or upserts to fill in language-specific texts.

```http
POST <your_service_url>/Entity HTTP/1.1
Content-Type: application/json

{
  "name": "Some name",
  "description": "Some description",
  "texts": [ {"name": "Ein Name", "description": "Eine Beschreibung", "locale": "de"} ]
}
```

If you want to add a language-specific text to an existing entity, perform a `POST` request to the text table of the entity through navigation.

```http
POST <your_service_url>/Entity(<entity_key>)/texts HTTP/1.1
Content-Type: application/json

{
  {"name": "Ein Name", "description": "Eine Beschreibung", "locale": "de"}
}
```

### Update Operations

To update the language-specific texts of an entity along with the default fallback text, you can perform a deep update as a `PUT` or `PATCH` request to the entity through navigation.

```http
PUT/PATCH <your_service_url>/Entity(<entity_key>) HTTP/1.1
Content-Type: application/json

{
  "name": "Some new name",
  "description": "Some new description",
  "texts": [ {"name": "Ein neuer Name", "description": "Eine neue Beschreibung", "locale": "de"} ]
}
```

To update a single language-specific text field, perform a `PUT` or a `PATCH` request to the entity's text field via navigation.

```http
PUT/PATCH <your_service_url>/Entity(<entity_key>)/texts(ID=<entity_key>,locale='<locale>')/<field_name> HTTP/1.1
Content-Type: application/json

{
  {"name": "Ein neuer Name"} ]
}
```

::: warning *Note:* 
Accepted language codes in the `locale` property need to follow the [BCP 47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) standard but use __underscore__ (`_`) instead of __hyphen__ (`-`), for example `en_GB`.
:::

### Delete Operations

To delete a locale's language-specific texts of an entity, perform a `DELETE` request to the entity's texts table through navigation. Specify the entity's key and the locale that you want to delete.

```http
DELETE <your_service_url>/Entity(<entity_key>)/texts(ID=<entity_key>,locale='<locale>') HTTP/1.1
```

## Nested Localized Data

The definition of books has a `currency` element that is effectively an association to the `sap.common.Currencies` code list entity, which in turn has localized texts. Find the respective definitions in the reference docs for `@sap/cds/common`, in the section on [Common Code Lists](../cds/common#code-lists).

Upon unfolding, all associations to other entities with localized texts are automatically redirected as follows:

```cds
entity localized.Currencies as select from Currencies AS c {* /*...*/};
entity localized.Books as select from Books AS p mixin {
  // association is redirected to localized.Currencies
  country : Association to localized.Currencies on country = p.country;
} into {* /*...*/};
```

Given that, nested localized data can be easily read with independent fallback logic:

```sql
SELECT from localized.Books {
  ID, title, descr,
  currency.name as currency
} where title like '%pen%' or currency.name like '%land%'
```

In the result sets for this query, values for `title`, `descr`, as well as the `currency` name are localized.

## Adding Initial Data

To add initial data, two _.csv_ files are required. The first _.csv_ file, for example _Books.csv_, should contain all the data in the default language.
The second file, for example _Books_texts.csv_ (please note **_texts** in the file name) should contain the translated data in all other languages your application is using.

For example, _Books.csv_ can look as follows:

::: code-group
```csv [Books.csv]
ID;title;descr;author_ID;stock;price;currency_code;genre_ID
201;Wuthering Heights;Wuthering Heights, Emily Brontë's only novel ...;101;12;11.11;GBP;11
207;Jane Eyre;Jane Eyre is a novel by English writer ...;107;11;12.34;GBP;11
251;The Raven;The Raven is a narrative poem by ...;150;333;13.13;USD;16
252;Eleonora;Eleonora is a short story by ...;150;555;14;USD;16
271;Catweazle;Catweazle is a British fantasy ...;170;22;150;JPY;13
...
```
:::

This is the corresponding _Books_texts.csv_:

::: code-group
```csv [Books_texts.csv]
ID;locale;title;descr
201;de;Sturmhöhe;Sturmhöhe (Originaltitel: Wuthering Heights) ist der einzige Roman...
201;fr;Les Hauts de Hurlevent;Les Hauts de Hurlevent (titre original : Wuthering Heights)...
207;de;Jane Eyre;Jane Eyre. Eine Autobiographie (Originaltitel: Jane Eyre. An Autobiography)...
252;de;Eleonora;Eleonora ist eine Erzählung von Edgar Allan Poe. Sie wurde 1841...
...
```
:::



# Temporal Data

CAP provides out-of-the-box support for declaring and serving date-effective entities with application-controlled validity, in particular to serve as-of-now and time-travel queries.

Temporal data allows you to maintain information relating to past, present, and future application time.
Built-in support for temporal data follows the general principle of CDS to capture intent with models while staying conceptual, concise, and comprehensive, and minimizing pollution by technical artifacts.

> For an introduction to this topic, see [Temporal database](https://en.wikipedia.org/w/index.php?title=Temporal_database&oldid=911558203) (Wikipedia) and [Temporal features in SQL:2011](https://files.ifi.uzh.ch/dbtg/ndbs/HS17/SQL2011.pdf).


## Starting with 'Timeless' Models {#timeless-model}

For the following explanation, let's start with a base model to manage employees and their work assignments, which is free of any traces of temporal data management.

### Timeless Model

::: code-group
```cds [timeless-model.cds]
namespace com.acme.hr;
using { com.acme.common.Persons } from './common';

entity Employees : Persons {
  jobs : Composition of many WorkAssignments on jobs.empl=$self;
  job1 : Association to one /*of*/ WorkAssignments;
}

entity WorkAssignments {
  key ID  : UUID;
  role    : String(111);
  empl    : Association to Employees;
  dept    : Association to Departments;
}

entity Departments {
  key ID  : UUID;
  name    : String(111);
  head    : Association to Employees;
  members : Association to many Employees on members.jobs.dept = $self;
}

```
:::

> An employee can have several work assignments at the same time.
> Each work assignment links to one department.

### Timeless Data

A set of sample data entries for this model, which only captures the latest state, can look like this:

![Alice has the job a a developer and consultant. Bob is a builder. Alice works in her roles for the departments core development and app development. Bob's work assignment is linked to the construction department.](assets/temporal-data/timeless-data.drawio.svg)

> Italic titles indicate to-one associations; actual names of the respective foreign key columns in SQL are `job1_ID`, `empl_ID`, and `dept_ID`.


## Declaring Temporal Entities

_Temporal Entities_ represent _logical_ records of information for which we track changes over time by recording each change as individual _time slices_ in the database with valid from/to boundaries. For example, we could track the changes of Alice's primary work assignment _WA1_ over time:

![Alice progressed from developer to senior developer to architect.](assets/temporal-data/time-slices.drawio.svg)

::: tip
Validity periods are expected to be **non-overlapping** and **closed-open** intervals; same as in SQL:2011.
:::

### Using Annotations `@cds.valid.from/to`

To track temporal data, just add a pair of date/time elements to the respective entities annotated with `@cds.valid.from/to`, as follows:

```cds
entity WorkAssignments { //...
  start : Date @cds.valid.from;
  end   : Date @cds.valid.to;
}
```
::: tip
The annotation pair `@cds.valid.from/to` actually triggers the built-in mechanisms for [serving temporal data](#serving-temporal-data). It specifies which elements form the **application-time** period, similar to SQL:2011.
:::

### Using Common Aspect `temporal`

Alternatively, use the predefined aspect [`temporal`](../cds/common#aspect-temporal) to declare temporal entities:

```cds
using { temporal } from '@sap/cds/common';
entity WorkAssignments : temporal {/*...*/}
```

Aspect [`temporal`](../cds/common#aspect-temporal) is defined in _[@sap/cds/common](../cds/common)_ as follows:

```cds
aspect temporal {
  validFrom : Timestamp @cds.valid.from;
  validTo   : Timestamp @cds.valid.to;
}
```


### Separate Temporal Details

The previous samples would turn the whole _WorkAssignment_ entity into a temporal one. Frequently though, only some parts of an entity are temporal, while others stay timeless. You can reflect this by separating temporal elements from non-temporal ones:

```cds
entity WorkAssignments {          // non-temporal head entity
  key ID  : UUID;
  empl    : Association to Employees;
  details : Composition of WorkDetails on details.ID = $self.ID;
}
entity WorkDetails : temporal {   // temporal details entity
  key ID  : UUID;                 // logical record ID
  role    : String(111);
  dept    : Association to Departments;
}
```

The data situation would change as follows:

![Alice has two work assignments. Her first work assignment is stable but the roles in this assignment change over time. She progressed from developer to senior developer to architect. Each role has specific validity defined.](assets/temporal-data/temporal-details.drawio.svg)


## Serving Temporal Data

We expose the entities from the following timeless model in a service as follows:

::: code-group
```cds [service.cds]
using { com.acme.hr } from './temporal-model';
service HRService {
  entity Employees as projection on hr.Employees;
  entity WorkAssignments as projection on hr.WorkAssignments;
  entity Departments as projection on hr.Departments;
}
```
:::

> You can omit composed entities like _WorkAssignments_ from the service, as they would get
[auto-exposed](providing-services#auto-exposed-entities) automatically.

<div id="beforereadingtempdata" />
<Fragment target="#beforereadingtempdata">

### Adding Temporal Predicates <Concept />

When temporal entities are exposed through services — such as _WorkAssignments_ in the previous sample — their queries are **automatically enhanced** with a predicate that narrows results based on propagated validity as follows:

::: code-group
```cds [service-w-temporal-entities.cds]
using { com.acme.hr, sap } from './temporal-model';
service HRService { //...
  entity WorkAssignments as select from hr.WorkAssignments
  where validFrom < $valid.to and $valid.from < validTo;
  //> automatically added temporal predicate
}

```
:::

::: tip
These predicates are always active, that is, for direct requests as well as indirect access through associations and navigation.
:::


### Pseudo Variables `$valid.from/to`

The pseudo variables `$valid.from/to` used in the temporal predicates as shown in the previous sample, translate to a database-specific session context variable. For example, in SAP HANA the predicate translates to:


```cds
... where (
  validFrom < session_context('valid-to') and
  validTo > session_context('valid-from')
);
```
::: warning
Instances with `null` as their `validTo` are not found with the above where expression. Hence, please ensure that all `validTo` are set.
:::

### Propagating `$valid.from/to`

The service runtimes automatically set these session context variables for any READ request based on corresponding query parameters from inbound requests as follows:

| if query option contains | `$valid.from` = | `$valid.to` =     |
|--------------------------|-----------------|-------------------|
| _$from/to_               | _$from_         | _$to_             |
| _$at_                    | _$at_           | _$at +1ms_        |
| _else:_                  | _systime_       | _systime +1ms_    |

> If these query parameters aren't yet supported by a concrete OData implementation, respective fallback options are chosen, such as _sap-valid-from/to_ instead of _$from/to_.

In effect, `$at` can represent one of:

* The current point in time, that is, system time &rarr; [_As-of-now Queries_](#as-of-now-queries)
* A user-chosen future or past point in time &rarr;[_Time-travel Queries_](#time-travel-queries)
* A user-chosen period of time &rarr; [_Time-period Queries_](#time-period-queries)

In all cases, `$at` is canonicalized to a closed-open time period interval to streamline data processing.


</Fragment>

## Reading Temporal Data

### As-of-now Queries

READ requests without specifying any temporal query parameter will automatically return data valid _as of now_.

For example, assumed the following OData query to read all employees with their current work assignments is processed on March 2019:

```cds
GET Employees?
$expand=jobs($select=role&$expand=dept($select=name))
```

The values of `$at`, and so also the respective session variables, would be set to, for example:

|              |                                  |                            |
|--------------|----------------------------------|----------------------------|
| `$at.from` = | _session_context('valid-from')_= | _2019-03-08T22:11:00Z_     |
| `$at.to` =   | _session_context('valid-to')_ =  | _2019-03-08T22:11:00.001Z_ |

The result set would be:

```json
[
  { "ID": "E1", "name": "Alice", "jobs": [
    { "role": "Architect", "dept": {"name": "Core Development"}},
    { "role": "Consultant", "dept": {"name": "App Development"}}
  ]},
  { "ID": "E2", "name": "Bob", "jobs": [
    { "role": "Builder", "dept": {"name": "Construction"}}
  ]}
]
```

### Time-Travel Queries

We can run the same OData query as in the previous sample to read a snapshot data as valid on January 1, 2017 using the `sap-valid-at` query parameter:

```cds
GET Employees?sap-valid-at=date'2017-01-01'
$expand=jobs($select=role&$expand=dept($select=name))
```

The values of `$at` and hence the respective session variables would be set to, for example:

|              |                                  |                            |
|--------------|----------------------------------|----------------------------|
| `$at.from` = | _session_context('valid-from')_= | _2017-01-01T00:00:00Z_     |
| `$at.to` =   | _session_context('valid-to')_ =  | _2017-01-01T00:00:00.001Z_ |

The result set would be:

```json
[
    { "ID": "E1", "name": "Alice", "jobs": [
      { "role": "Developer", "dept": {"name": "Core Development"}},
      { "role": "Consultant", "dept": {"name": "App Development"}}
    ]}, ...
]
```
::: warning
Time-travel queries aren't supported on SQLite due to the lack of *session_context* variables.
:::

### Time-Period Queries

We can run the same OData query as in the previous sample to read all history of data as valid since 2016 using the `sap-valid-from` query parameter:

```cds
GET Employees?sap-valid-from=date'2016-01-01'
$expand=jobs($select=role&$expand=dept($select=name))
```

The result set would be:

```json
[
  { "ID": "E1", "name": "Alice", "jobs": [
    { "role": "Developer", "dept": {"name": "App Development"}},
    { "role": "Developer", "dept": {"name": "Core Development"}},
    { "role": "Senior Developer", "dept": {"name": "Core Development"}},
    { "role": "Consultant", "dept": {"name": "App Development"}}
  ]}, ...
]
```

> You would add `validFrom` in such time-period queries, for example:

```cds
GET Employees?sap-valid-from=date'2016-01-01'
$expand=jobs($select=validFrom,role,dept/name)
```
::: warning
Time-series queries aren't supported on SQLite due to the lack of *session_context* variables.
:::
::: tip
Writing temporal data must be done in custom handlers.
:::

### Transitive Temporal Data

The basic techniques and built-in support for reading temporal data serves all possible use cases with respect to as-of-now and time-travel queries. Special care has to be taken though if time-period queries transitively expand across two or more temporal data entities.

As an example, assume that both, _WorkAssignments_ and _Departments_ are temporal:

```cds
using { temporal } from '@sap/cds/common';
entity WorkAssignments : temporal {/*...*/
  dept : Association to Departments;
}
entity Departments : temporal {/*...*/}
```

When reading employees with all history since 2016, for example:

```cds
GET Employees?sap-valid-from=date'2016-01-01'
$expand=jobs(
  $select=validFrom,role&$expand=dept(
    $select=validFrom,name
  )
)
```

The results for `Alice` would be:

```json
[
  { "ID": "E1", "name": "Alice", "jobs": [
    { "validFrom":"2014-01-01", "role": "Developer", "dept": [
      {"validFrom":"2013-04-01", "name": "App Development"}
    ]},
    { "validFrom":"2017-01-01", "role": "Consultant", "dept": [
      {"validFrom":"2013-04-01", "name": "App Development"}
    ]},
    { "validFrom":"2017-01-01", "role": "Developer", "dept": [
      {"validFrom":"2014-01-01", "name": "Tech Platform Dev"},
      {"validFrom":"2017-07-01", "name": "Core Development"}
    ]},
    { "validFrom":"2017-04-01", "role": "Senior Developer", "dept": [
      {"validFrom":"2014-01-01", "name": "Tech Platform Dev"},
      {"validFrom":"2017-07-01", "name": "Core Development"}
    ]},
    { "validFrom":"2018-09-15", "role": "Architect", "dept": [
      {"validFrom":"2014-01-01", "name": "Tech Platform Dev"},
      {"validFrom":"2017-07-01", "name": "Core Development"}
    ]}
  ]}, ...
]
```

That is, all-time slices for changes to departments since 2016 are repeated for each time slice of work assignments in that time frame, which is a confusing and redundant piece of information. You can fix this by adding an alternative association to departments as follows:

```cds
using { temporal } from '@sap/cds/common';
entity WorkAssignments : temporal {/*...*/
  dept : Association to Departments;
  dept1 : Association to Departments on dept1.id = dept.id
    and dept1.validFrom <= validFrom and validFrom < dept1.validTo;
}
entity Departments : temporal {/*...*/}
```


## Primary Keys of Time Slices

While timeless entities are uniquely identified by the declared primary `key` — we call that the _conceptual_ key in CDS — time slices are uniquely identified by _the conceptual `key` **+** `validFrom`_.

In effect the SQL DDL statement for the _WorkAssignments_ would look like this:

```sql
CREATE TABLE com_acme_hr_WorkAssignments (
    ID : nvarchar(36),
    validFrom : timestamp,
    validTo : timestamp,
    -- ...
    PRIMARY KEY ( ID, validFrom )
)
```

In contrast to that, the exposed API preserves the timeless view, to easily serve as-of-now and time-travel queries out of the box [as described above](#serving-temporal-data):

```xml
<EntityType Name="WorkAssignments">
  <Key>
    <PropertyRef Name="ID"/>
  </Key>
  ...
</EntityType>
```

Reading an explicit time slice can look like this:

```sql
SELECT from WorkAssignments WHERE ID='WA1' and validFrom='2017-01-01'
```

Similarly, referring to individual time slices by an association:

```cds
entity SomeSnapshotEntity {
  //...
  workAssignment : Association to WorkAssignments { ID, validFrom }
}
```

<div id="afterprimarykeyof" />
<Fragment target="#afterprimarykeyof" >

### Adding Time Slice IDs <Concept />

As an alternative to using enhanced keys, you can introduce a new element to uniquely identify time slices and use that in references:

```cds
entity WorkAssignments : temporal { //...
  key ID : UUID;                // logical record ID
  slID : UUID @cds.valid.key;   // time slice ID
}
```

The annotation `@cds.valid.key` has precedence over standard keys with respect to the generation of SQL and OData output:

```sql
CREATE TABLE com_acme_hr_WorkAssignments (
    ...
    PRIMARY KEY ( slID )
    UNIQUE ( ID, validFrom )
)
```

OData EDMX:

```xml
<EntityType Name="WorkAssignments">
  <Key>
    <PropertyRef Name="slID"/>
  </Key>
  ...
</EntityType>
```

In addition, we would add the `ID` + `validFrom` combination as alternate keys to the OData model:

```xml
<Annotations Target="wbs.WorkAssignments">
  <Annotation Term="Core.AlternateKeys">
    <Collection>
      <Record Type="Core.AlternateKey">
        <PropertyValue Property="Key">
          <Collection>
            <Record Type="Core.PropertyRef">
              <PropertyValue Property="Name" PropertyPath="ID" />
              <PropertyValue Property="Alias" String="ID" />
            </Record>
            <Record Type="Core.PropertyRef">
              <PropertyValue Property="Name" PropertyPath="validFrom" />
              <PropertyValue Property="Alias" String="validFrom" />
            </Record>
          </Collection>
        </PropertyValue>
      </Record>
    </Collection>
  </Annotation>
</Annotations>
```


</Fragment>

<div id="secondary-file">guides/temporal-data.fragment.md</div>


# CAP Security Guide

This guide addresses

- Developers and operators
- User administrators
- Security experts

of CAP applications who need to understand how to develop, deploy and operate CAP applications in a secure way.



<br>
<IndexList :pages='pages' />







# CDS-based Authorization

Authorization means restricting access to data by adding respective declarations to CDS models, which are then enforced in service implementations. By adding such declarations, we essentially revoke all default access and then grant individual privileges.

## Authentication as Prerequisite { #prerequisite-authentication}

In essence, authentication verifies the user's identity and the presented claims such as granted roles and tenant membership. Briefly, **authentication** reveals _who_ uses the service. In contrast, **authorization** controls _how_ the user can interact with the application's resources according to granted privileges. As the access control needs to rely on verified claims, authentication is a prerequisite to authorization.

From perspective of CAP, the authentication method is freely customizable. For convenience, a set of authentication methods is supported out of the box to cover most common scenarios:

- [XS User and Authentication and Authorization service](https://help.sap.com/docs/CP_AUTHORIZ_TRUST_MNG) (XSUAA) is a full-fleged [OAuth 2.0](https://oauth.net/2/) authorization server which allows to protect your endpoints in productive environments. JWT tokens issued by the server not only contain information about the user for authentication, but also assigned scopes and attributes for authorization.
- [Identity Authentication Service](https://help.sap.com/docs/IDENTITY_AUTHENTICATION) (IAS) is an [OpenId Connect](https://openid.net/connect/) compliant service for next-generation identity and access management. As of today, CAP provides IAS authentication for incoming requests only. Authorization has to be explicitly managed by the application.
- For _local development_ and _test_ scenario mock user authentication is provided as built-in feature.

Find detailed instructions for setting up authentication in these runtime-specific guides:

- [Set up authentication in Node.js.](/node.js/authentication)
- [Set up authentication in Java.](/java/security#authentication)


In _productive_ environment with security middleware activated, **all protocol adapter endpoints are authenticated by default**<sup>1</sup>, even if no [restrictions](#restrictions) are configured. Multi-tenant SaaS-applications require authentication to provide tenant isolation out of the box. In case there is the business need to expose open endpoints for anonymous users, it's required to take extra measures depending on runtime and security middleware capabilities.

> <sup>1</sup> Starting with CAP Node.js 6.0.0 resp. CAP Java 1.25.0. _In previous versions endpoints without restrictions are public in single-tenant applications_.

### Defining Internal Services

CDS services which are only meant for *internal* usage, shouldn't be exposed via protocol adapters. In order to prevent access from external clients, annotate those services with `@protocol: 'none'`:

```cds
@protocol: 'none'
service InternalService {
  ...
}
```
The `InternalService` service can only receive events sent by in-process handlers.

## User Claims { #user-claims}

CDS authorization is _model-driven_. This basically means that it binds access rules for CDS model elements to user claims. For instance, access to a service or entity is dependent on the role a user has been assigned to. Or you can even restrict access on an instance level, for example, to the user who created the instance.<br>
The generic CDS authorization is built on a _CAP user concept_, which is an _abstraction_ of a concrete user type determined by the platform's identity service. This design decision makes different authentication strategies pluggable to generic CDS authorization.<br>
After successful authentication, a (CAP) user is represented by the following properties:

- Unique (logon) _name_ identifying the user. Unnamed users have a fixed name such as `system` or `anonymous`.
- _Tenant_ for multitenant applications.
- _Roles_ that the user has been granted by an administrator (see [User Roles](#roles)) or that are derived by the authentication level (see [Pseudo Roles](#pseudo-roles)).
- _Attributes_ that the user has been assigned by an administrator.

In the CDS model, some of the user properties can be referenced with the `$user` prefix:

| User Property                 | Reference           |
|-------------------------------|---------------------|
| Name                          | `$user`             |
| Attribute (name \<attribute>) | `$user.<attribute>` |

> A single user attribute can have several different values. For instance, the `$user.language` attribute can contain `['DE','FR']`.


### User Roles { #roles}

As a basis for access control, you can design conceptual roles that are application specific. Such a role should reflect how a user can interact with the application. For instance, the role `Vendor` could describe users who are allowed to read sales articles and update sales figures. In contrast, a `ProcurementManager` can have full access to sales articles. Users can have several roles, that are assigned by an administrative user in the platform's authorization management solution.
::: tip
CDS-based authorization deliberately refrains from using technical concepts, such as _scopes_ as in _OAuth_, in favor of user roles, which are closer to the conceptual domain of business applications. This also results in much **smaller JWT tokens**.
:::


### Pseudo Roles { #pseudo-roles}

It's frequently required to define access rules that aren't based on an application-specific user role, but rather on the _authentication level_ of the request. For instance, a service could be accessible not only for identified, but also for anonymous (for example, unauthenticated) users. Such roles are called pseudo roles as they aren't assigned by user administrators, but are added at runtime automatically.

The following predefined pseudo roles are currently supported by CAP:

* `authenticated-user` refers to named or unnamed users who have presented a valid authentication claim such as a logon token.
* [`system-user` denotes an unnamed user used for technical communication.](#system-user)
* [`internal-user` is dedicated to distinguish application internal communication.](#internal-user)
* `any` refers to all users including anonymous ones (that means, public access without authentication).

#### system-user
The pseudo role `system-user` allows you to separate access by _technical_ users from access by _business_ users. Note that the technical user can come from a SaaS or the PaaS tenant. Such technical user requests typically run in a _privileged_ mode without any restrictions on an instance level. For example, an action that implements a data replication into another system needs to access all entities of subscribed SaaS tenants and can’t be exposed to any business user. Note that `system-user` also implies `authenticated-user`.

::: tip
For XSUAA or IAS authentication, the request user is attached with the pseudo role `system-user` if the presented JWT token has been issued with grant type `client_credentials` or `client_x509` for a trusted client application.
:::

#### internal-user
Pseudo-role `internal-user` allows to define application endpoints that can be accessed exclusively by the own PaaS tenant (technical communication). The advantage is that similar to `system-user` no technical CAP roles need to be defined to protect such internal endpoints. However, in contrast to `system-user`, the endpoints protected by this pseudo-role do not allow requests from any external technical clients. Hence is suitable for **technical intra-application communication**, see [Security > Application Zone](/guides/security/overview#application-zone).

::: tip
For XSUAA or IAS authentication, the request user is attached with the pseudo role `internal-user` if the presented JWT token has been issued with grant type `client_credentials` or `client_x509` on basis of the **identical** XSUAA or IAS service instance.
:::

::: warning
All technical clients that have access to the application's XSUAA or IAS service instance can call your service endpoints as `internal-user`.
**Refrain from sharing this service instance with untrusted clients**, for instance by passing services keys or [SAP BTP Destination Service](https://help.sap.com/docs/connectivity/sap-btp-connectivity-cf/create-destinations-from-scratch) instances.
:::

### Mapping User Claims

Depending on the configured [authentication](#prerequisite-authentication) strategy, CAP derives a *default set* of user claims containing the user's name and attributes:

| CAP User Property   | XSUAA JWT Property               | IAS JWT Property        |
|---------------------|----------------------------------|-------------------------|
| `$user`             | `user_name`                      | `sub`                   |
| `$user.<attribute>` | `xs.user.attributes.<attribute>` | All non-meta attributes |

::: tip
CAP does not make any assumptions on the presented claims given in the token. String values are copied as they are.
:::

In most cases, CAP's default mapping will match your requirements, but CAP also allows you to customize the mapping according to specific needs. For instance, `user_name` in XSUAA tokens is generally not unique if several customer IdPs are connected to the underlying identity service.
Here a combination of `user_name` and `origin` mapped to `$user` might be a feasible solution that you implement in a custom adaptation. Similarly, attribute values can be normalized and prepared for [instance-based authorization](#instance-based-auth). Find details and examples how to programmatically redefine the user mapping here:

- [Set up Authentication in Node.js.](/node.js/authentication)
- [Custom Authentication in Java.](/java/security#custom-authentication)

::: warning Be very careful when redefining `$user`
The user name is frequently stored with business data (for example, `managed` aspect) and might introduce migration efforts. Also consider data protection and privacy regulations when storing user data.
:::

## Restrictions { #restrictions}

According to [authentication](#prerequisite-authentication), CAP endpoints are closed to anonymous users. But **by default, CDS services have no access control** which means that authenticated users are not restricted. To protect resources according to your business needs, you can define [restrictions](#restrict-annotation) that make the runtime enforce proper access control. Alternatively, you can add custom authorization logic by means of an [authorization enforcement API](#enforcement).

Restrictions can be defined on *different CDS resources*:

- Services
- Entities
- (Un)bound actions and functions

You can influence the scope of a restriction by choosing an adequate hierarchy level in the CDS model. For instance, a restriction on the service level applies to all entities in the service. Additional restrictions on entities or actions can further limit authorized requests. See [combined restrictions](#combined-restrictions) for more details.

Beside the scope, restrictions can limit access to resources with regards to *different dimensions*:

- The [event](#restricting-events) of the request, that is, the type of the operation (what?)
- The [roles](#roles) of the user (who?)
- [Filter-condition](#instance-based-auth) on instances to operate on (which?)

### @readonly and @insertonly { #restricting-events}

Annotate entities with `@readonly` or `@insertonly` to statically restrict allowed operations for **all** users as demonstrated in the example:

```cds
service BookshopService {
  @readonly entity Books {...}
  @insertonly entity Orders {...}
}
```

Note that both annotations introduce access control on an entity level. In contrast, for the sake of [input validation](/guides/providing-services#input-validation), you can also use `@readonly` on a property level.

In addition, annotation `@Capabilities` from standard OData vocabulary is enforced by the runtimes analogously:

```cds
service SomeService {
  @Capabilities: {
    InsertRestrictions.Insertable: true,
    UpdateRestrictions.Updatable: true,
    DeleteRestrictions.Deletable: false
  }
  entity Foo { key ID : UUID }
}
```

#### Events to Auto-Exposed Entities { #events-and-auto-expose}

In general, entities can be exposed in services in different ways: they can be **explicitly exposed** by the modeler (for example, by a projection), or they can be **auto-exposed** by the CDS compiler due to some reason.
Access to auto-exposed entities needs to be controlled in a specific way. Consider the following example:

```cds
context db {
  @cds.autoexpose
  entity Categories : cuid { // explicitly auto-exposed (by @cds.autoexpose)
    ...
  }

  entity Issues : cuid { // implicitly auto-exposed (by composition)
    category: Association to Categories;
    ...
  }

  entity Components : cuid { // explicitly exposed (by projection)
    issues: Composition of many Issues;
    ...
  }
}

service IssuesService {
  entity Components as projection on db.Components;
}
```

As a result, the `IssuesService` service actually exposes *all* three entities from the `db` context:
* `db.Components` is explicitly exposed due to the projection in the service.
* `db.Issues` is implicitly auto-exposed by the compiler as it is a composition entity of `Components`.
* `db.Categories` is explicitly auto-exposed due to the `@cds.autoexpose` annotation.

In general, **implicitly auto-exposed entities cannot be accessed directly**, that means, only access via a navigation path (starting from an explicitly exposed entity) is allowed.

In contrast, **explicitly auto-exposed entities can be accessed directly, but only as `@readonly`**. The rationale behind that is that entities representing value lists need to be readable at the service level, for instance to support value help lists.

See details about `@cds.autoexpose` in [Auto-Exposed Entities](/guides/providing-services#auto-exposed-entities).

This results in the following access matrix:

| Request                                                | `READ` | `WRITE` |
|--------------------------------------------------------|:------:|:-------:|
| `IssuesService.Components`                             |  <Y/>  |  <Y/>   |
| `IssuesService.Issues`                                 |  <X/>  |  <X/>   |
| `IssuesService.Categories`                             |  <Y/>  |  <X/>   |
| `IssuesService.Components[<id>].issues`                |  <Y/>  |  <Y/>   |
| `IssuesService.Components[<id>].issues[<id>].category` |  <Y/>  |  <X/>   |

::: tip
CodeLists such as `Languages`, `Currencies`, and `Countries` from `sap.common` are annotated with `@cds.autoexpose` and so are explicitly auto-exposed.
:::

### @requires { #requires}

You can use the `@requires` annotation to control which (pseudo-)role a user requires to access a resource:

```cds
annotate BrowseBooksService with @(requires: 'authenticated-user');
annotate ShopService.Books with @(requires: ['Vendor', 'ProcurementManager']);
annotate ShopService.ReplicationAction with @(requires: 'system-user');
```

In this example, the `BrowseBooksService` service is open for authenticated but not for anonymous users. A user who has the `Vendor` _or_ `ProcurementManager` role is allowed to access the `ShopService.Books` entity. Unbound action `ShopService.ReplicationAction` can only be triggered by a technical user.
::: tip
When restricting service access through `@requires`, the service's metadata endpoints (that means, `/$metadata` as well as the service root `/`) are restricted by default as well. If you require public metadata, you can disable the check with [a custom express middleware](../../node.js/cds-serve#add-mw-pos) using the [privileged user](../../node.js/authentication#privileged-user) (Node.js) or through config <Config java>cds.security.authentication.authenticateMetadataEndpoints = false</Config> (Java), respectively. Please be aware that the `/$metadata` endpoint is *not* checking for authorizations implied by `@restrict` annotation.
:::


### @restrict { #restrict-annotation}

You can use the `@restrict` annotation to define authorizations on a fine-grained level. In essence, all kinds of restrictions that are based on static user roles, the request operation, and instance filters can be expressed by this annotation.<br>
The building block of such a restriction is a single **privilege**, which has the general form:


```cds
{ grant:<events>, to:<roles>, where:<filter-condition> }
```

whereas the properties are:

* `grant`: one or more events that the privilege applies to
* `to`: one or more [user roles](#roles) that the privilege applies to (optional)
* `where`: a filter condition that further restricts access on an instance level (optional).

The following values are supported:
- `grant` accepts all standard [CDS events](../../about/best-practices#events) (such as `READ`, `CREATE`, `UPDATE`, and `DELETE`) as well as action and function names. `WRITE` is a virtual event for all standard CDS events with write semantic (`CREATE`, `DELETE`, `UPDATE`, `UPSERT`) and `*` is a wildcard for all events.

- The `to` property lists all [user roles](#roles) or [pseudo roles](#pseudo-roles) that the privilege applies to. Note that the `any` pseudo-role applies for all users and is the default if no value is provided.

- The `where`-clause can contain a Boolean expression in [CQL](/cds/cql)-syntax that filters the instances that the event applies to. As it allows user values (name, attributes, etc.) and entity data as input, it's suitable for *dynamic authorizations based on the business domain*. Supported expressions and typical use cases are presented in [instance-based authorization](#instance-based-auth).

A privilege is met, if and only if **all properties are fulfilled** for the current request. In the following example, orders can only be read by an `Auditor` who meets `AuditBy` element of the instance:

```cds
entity Orders @(restrict: [
    { grant: 'READ', to: 'Auditor', where: 'AuditBy = $user' }
  ]) {/*...*/}
```

If a privilege contains several events, only one of them needs to match the request event to comply with the privilege. The same holds, if there are multiple roles defined in the `to` property:

```cds
entity Reviews @(restrict: [
    { grant:['READ', 'WRITE'], to: ['Reviewer', 'Customer'] }
  ]) {/*...*/}
```

In this example, all users that have the `Reviewer` *or* `Customer` role can read *or* write to `Reviews`.

You can build restrictions based on *multiple privileges*:

```cds
entity Orders @(restrict: [
    { grant: ['READ','WRITE'], to: 'Admin' },
    { grant: 'READ', where: 'buyer = $user' }
  ]) {/*...*/}
```

A request passes such a restriction **if at least one of the privileges is met**. In this example, `Admin` users can read and write the `Orders` entity. But a user can also read all orders that have a `buyer` property that matches the request user.

Similarly, the filter conditions of matched privileges are combined with logical OR:

```cds
entity Orders @(restrict: [
    { grant: 'READ', to: 'Auditor', where: 'country = $user.country' },
    { grant: ['READ','WRITE'], where: 'CreatedBy = $user' },
  ]) {/*...*/}
```

Here an `Auditor` user can read all orders with matching `country` or that they have created.

> Annotations such as @requires or @readonly are just convenience shortcuts for @restrict, for example:
   - `@requires: 'Viewer'` is equivalent to `@restrict: [{grant:'*', to: 'Viewer'}]`
   - `@readonly` is the same as `@restrict: [{ grant:'READ' }]`

Currently, the security annotations **are only evaluated on the target entity of the request**. Restrictions on associated entities touched by the operation aren't regarded. This has the following implications:
- Restrictions of (recursively) expanded or inlined entities of a `READ` request aren't checked.
- Deep inserts and updates are checked on the root entity only.

See [solution sketches](#limitation-deep-authorization) for information about how to deal with that.{.learn-more}


#### Supported Combinations with CDS Resources

Restrictions can be defined on different types of CDS resources, but there are some limitations with regards to supported privileges:

| CDS Resource    | `grant` | `to` |      `where`      | Remark        |
|-----------------|:-------:|:----:|:-----------------:|---------------|
| service         |  <Na/>  | <Y/> |       <Na/>       | = `@requires` |
| entity          |  <Y/>   | <Y/> | <Y/><sup>1</sup>  |               |
| action/function |  <Na/>  | <Y/> | <Na/><sup>2</sup> | = `@requires` |

> <sup>1</sup>For bound actions and functions that aren't bound against a collection, Node.js supports instance-based authorization at the entity level. For example, you can use `where` clauses that *contain references to the model*, such as `where: CreatedBy = $user`. For all bound actions and functions, Node.js supports simple static expressions at the entity level that *don't have any reference to the model*, such as `where: $user.level = 2`.
> <sup>2</sup> For unbound actions and functions, Node.js supports simple static expressions that *don't have any reference to the model*, such as `where: $user.level = 2`.

Unsupported privilege properties are ignored by the runtime. Especially, for bound or unbound actions, the `grant` property is implicitly removed (assuming `grant: '*'` instead). The same also holds for functions:

```cds
service CatalogService {
  entity Products as projection on db.Products { ... }
  actions {
    @(requires: 'Admin')
    action addRating (stars: Integer);
  }
  function getViewsCount @(restrict: [{ to: 'Admin' }]) () returns Integer;
}
```


### Combined Restrictions { #combined-restrictions}

Restrictions can be defined on different levels in the CDS model hierarchy. Bound actions and functions refer to an entity, which in turn refers to a service. Unbound actions and functions refer directly to a service. As a general rule, **all authorization checks of the hierarchy need to be passed** (logical AND).
This is illustrated in the following example:

```cds
service CustomerService @(requires: 'authenticated-user') {
  entity Products @(restrict: [
    { grant: 'READ' },
    { grant: 'WRITE', to: 'Vendor' },
    { grant: 'addRating', to: 'Customer'}
  ]) {/*...*/}
  actions {
     action addRating (stars: Integer);
  }
  entity Orders @(restrict: [
    { grant: '*', to: 'Customer', where: 'CreatedBy = $user' }
  ]) {/*...*/}
  action monthlyBalance @(requires: 'Vendor') ();
}
```

> The privilege for the `addRating` action is defined on an entity level.


The resulting authorizations are illustrated in the following access matrix:

| Operation                            | `Vendor` |    `Customer`    | `authenticated-user` | not authenticated |
|--------------------------------------|:--------:|:----------------:|:--------------------:|-------------------|
| `CustomerService.Products` (`READ`)  |   <Y/>   |       <Y/>       |         <Y/>         | <X/>              |
| `CustomerService.Products` (`WRITE`) |   <Y/>   |       <X/>       |         <X/>         | <X/>              |
| `CustomerService.Products.addRating` |   <X/>   |       <Y/>       |         <X/>         | <X/>              |
| `CustomerService.Orders` (*)         |   <X/>   | <Y/><sup>1</sup> |         <X/>         | <X/>              |
| `CustomerService.monthlyBalance`     |   <Y/>   |       <X/>       |         <X/>         | <X/>              |

> <sup>1</sup> A `Vendor` user can only access the instances that they created. <br>

The example models access rules for different roles in the same service. In general, this is _not recommended_ due to the high complexity. See [best practices](#dedicated-services) for information about how to avoid this.


### Draft Mode {#restrictions-and-draft-mode}

Basically, the access control for entities in draft mode differs from the [general restriction rules](#restrict-annotation) that apply to (active) entities. A user, who has created a draft, should also be able to edit (`UPDATE`) or cancel the draft (`DELETE`). The following rules apply:

- If a user has the privilege to create an entity (`CREATE`), he or she also has the privilege to create a **new** draft entity and update, delete, and activate it.
- If a user has the privilege to update an entity (`UPDATE`), he or she also has the privilege to **put it into draft mode** and update, delete, and activate it.
- Draft entities can only be edited by the creator user.
  + In the Node.js runtime, this includes calling bound actions/functions on the draft entity.

::: tip
As a result of the derived authorization rules for draft entities, you don't need to take care of draft events when designing the CDS authorization model.
:::

### Auto-Exposed and Generated Entities { #autoexposed-restrictions}

In general, **a service actually exposes more than the explicitly modeled entities from the CDS service model**. This stems from the fact that the compiler auto-exposes entities for the sake of completeness, for example, by adding composition entities. Another reason is generated entities for localization or draft support that need to appear in the service. Typically, such entities don't have restrictions. The emerging question is, how can requests to these entities be authorized?

For illustration, let's extend the service `IssuesService` from [Events to Auto-Exposed Entities](#events-and-auto-expose) by adding a restriction to `Components`:

```cds
annotate IssuesService.Components with @(restrict: [
  { grant: '*', to: 'Supporter' },
  { grant: 'READ', to: 'authenticated-user' } ]);
```
Basically, users with the `Supporter` role aren't restricted, whereas authenticated users can only read the `Components`. But what about the auto-exposed entities such as `IssuesService.Issues` and `IssuesService.Categories`? They could be a target of an (indirect) request as outlined in [Events to Auto-Exposed Entities](#events-and-auto-expose), but none of them are annotated with a concrete restriction. In general, the same also holds for service entities, which are generated by the compiler, for example, for localization or draft support.

To close the gap with auto-exposed and generated entities, the authorization of such entities is delegated to a so-called **authorization entity**, which is the last entity in the request path, which bears authorization information, that means, which fulfills at least one of the following properties:
- Explicitly exposed in the service
- Annotated with a concrete restriction
- Annotated with `@cds.autoexpose`

So, the authorization for the requests in the example is delegated as follows:

| Request Target                                         |          Authorization Entity          |
|--------------------------------------------------------|:--------------------------------------:|
| `IssuesService.Components`                             |           <Na/><sup>1</sup>            |
| `IssuesService.Issues`                                 |           <Na/><sup>1</sup>            |
| `IssuesService.Categories`                             | `IssuesService.Categories`<sup>2</sup> |
| `IssuesService.Components[<id>].issues`                | `IssuesService.Components`<sup>3</sup> |
| `IssuesService.Components[<id>].issues[<id>].category` | `IssuesService.Categories`<sup>2</sup> |

> <sup>1</sup> Request is rejected.<br>
> <sup>2</sup> `@readonly` due to `@cds.autoexpose`<br>
> <sup>3</sup> According to the restriction. `<id>` is relevant for instance-based filters.

### Inheritance of Restrictions

Service entities inherit the restriction from the database entity, on which they define a projection. An explicit restriction defined on a service entity *replaces* inherited restrictions from the underlying entity.

Entity `Books` on a database level:

```cds
namespace db;
entity Books @(restrict: [
  { grant: 'READ', to: 'Buyer' },
]) {/*...*/}
```

Services `BuyerService` and `AdminService` on a service level:

```cds
service BuyerService @(requires: 'authenticated-user'){
  entity Books as projection on db.Books; /* inherits */
}

service AdminService @(requires: 'authenticated-user'){
  entity Books @(restrict: [
    { grant: '*', to: 'Admin'} /* overrides */
  ]) as projection on db.Books;
}
```

| Events                        | `Buyer` | `Admin` | `authenticated-user` |
|-------------------------------|:-------:|:-------:|:--------------------:|
| `BuyerService.Books` (`READ`) |  <Y/>   |  <X/>   |         <X/>         |
| `AdminService.Books` (`*`)    |  <X/>   |  <Y/>   |         <X/>         |

::: tip
We recommend defining restrictions on a database entity level only in exceptional cases. Inheritance and override mechanisms can lead to an unclear situation.
:::

::: warning _Warning_ 
A service level entity can't inherit a restriction with a `where` condition that doesn't match the projected entity. The restriction has to be overridden in this case.
:::

## Instance-Based Authorization { #instance-based-auth }

The [restrict annotation](#restrict-annotation) for an entity allows you to enforce authorization checks that statically depend on the event type and user roles. In addition, you can define a `where`-condition that further limits the set of accessible instances. This condition, which acts like a filter, establishes an *instance-based authorization*.

The condition defined in the `where`-clause typically associates domain data with static [user claims](#user-claims). Basically, it *either filters the result set in queries or accepts only write operations on instances that meet the condition*. This means that, the condition applies to following standard CDS events only<sup>1</sup>:
- `READ` (as result filter)
- `UPDATE` (as reject condition<sup>2</sup>)
- `DELETE` (as reject condition<sup>2</sup>)

 > <sup>1</sup> Node.js supports _static expressions_ that *don't have any reference to the model* such as `where: $user.level = 2` for all events.
 > <sup>2</sup> CAP Java uses a filter condition by default.

For instance, a user is allowed to read or edit `Orders` (defined with the `managed` aspect) that they have created:

```cds
annotate Orders with @(restrict: [
  { grant: ['READ', 'UPDATE', 'DELETE'], where: 'CreatedBy = $user' } ]);
```

Or a `Vendor` can only edit articles on stock (that means `Articles.stock` positive):

```cds
annotate Articles with @(restrict: [
  { grant: ['UPDATE'], to: 'Vendor',  where: 'stock > 0' } ]);
```

You can define `where`-conditions in restrictions based on [CQL](/cds/cql)-where-clauses.<br>
Supported features are:
* Predicates with arithmetic operators.
* Combining predicates to expressions with `and` and `or` logical operators.
* Value references to constants, [user attributes](#user-attrs), and entity data (elements including [paths](#association-paths))
* [Exists predicate](#exists-predicate) based on subselects.

::: info Avoid enumerable keys
In case the filter condition is not met in an `UPDATE` or `DELETE` request, the runtime rejects the request (response code 403) even if the user is not even allowed to read the entity. To avoid to disclosure the existence of such entities to unauthorized users, make sure that the key is not efficiently enumerable.
:::

### User Attribute Values { #user-attrs}

To refer to attribute values from the user claim, prefix the attribute name with '`$user.`' as outlined in [static user claims](#user-claims). For instance, `$user.country` refers to the attribute with the name `country`.

In general, `$user.<attribute>` contains a **list of attribute values** that are assigned to the user. The following rules apply:
* A predicate in the `where` clause evaluates to `true` if one of the attribute values from the list matches the condition.
* An empty (or not defined) list means that the user is fully restricted with regards to this attribute (that means that the predicate evaluates to `false`).

For example, the condition `where: $user.country = countryCode` will grant a user with attribute values `country = ['DE', 'FR']` access to entity instances that have `countryCode = DE` _or_ `countryCode = FR`. In contrast, the user has no access to any entity instances if the value list of country is empty or the attribute is not available at all.

#### Unrestricted XSUAA Attributes

By default, all attributes defined in [XSUAA instances](#xsuaa-configuration) require a value (`valueRequired:true`) which is well-aligned with the CAP runtime that enforces restrictions on empty attributes.
If you explicitly want to offer unrestricted attributes to customers, you need to do the following:

1. Switch your XSUAA configuration to `valueRequired:false`
2. Adjust the filter-condition accordingly, for example: `where: $user.country = countryCode or $user.country is null`.
  > If `$user.country` is undefined or empty, the overall expression evaluates to `true` reflecting the unrestricted attribute.

::: warning
Refrain from unrestricted XSUAA attributes as they need to be designed very carefully as shown in the following example.
:::

Consider this bad example with *unrestricted* attribute `country` (assuming `valueRequired:false` in XSUAA configuration):

```cds
service SalesService @(requires: ['SalesAdmin', 'SalesManager']) {
  entity SalesOrgs @(restrict: [
     { grant: '*',
       to: ['SalesAdmin', 'SalesManager'],
       where: '$user.country = countryCode or $user.country is null' } ]) {
     countryCode: String; /*...*/
  }
}
```
Let's assume a customer creates XSUAA roles `SalesManagerEMEA` with dedicated values (`['DE', 'FR', ...]`) and 'SalesAdmin' with *unrestricted* values.
As expected, a user assigned only to 'SalesAdmin' has access to all `SalesOrgs`. But when role `SalesManagerEMEA` is added, *only* EMEA orgs are accessible suddenly!

The preferred way is to model with restricted attribute `country` (`valueRequired:true`) and an additional grant:
```cds
service SalesService @(requires: ['SalesAdmin', 'SalesManager']) {
  entity SalesOrgs @(restrict: [
     { grant: '*',
       to: 'SalesManager',
       where: '$user.country = countryCode' },
     { grant: '*',
       to: 'SalesAdmin' } ]) {
     countryCode: String; /*...*/
  }
}
```



### Exists Predicate { #exists-predicate }

In many cases, the authorization of an entity needs to be derived from entities reachable via association path. See [domain-driven authorization](#domain-driven-authorization) for more details.
You can leverage the `exists` predicate in `where` conditions to define filters that directly apply to associated entities defined by an association path:

```cds
service ProjectService @(requires: 'authenticated-user') {
  entity Projects @(restrict: [
     { grant: ['READ', 'WRITE'],
       where: 'exists members[userId = $user and role = `Editor`]' } ]) {
    members: Association to many Members; /*...*/
  }
  @readonly entity Members {
    key userId  : User;
    key role: String enum { Viewer; Editor; }; /*...*/
  }
}
```

In the `ProjectService` example, only projects for which the current user is a member with role `Editor` are readable and editable. Note that with exception of the user ID (`$user`) **all authorization information originates from the business data**.

Supported features of `exists` predicate:
* Combine with other predicates in the `where` condition (`where: 'exists a1[...] or exists a2[...]`).
* Define recursively (`where: 'exists a1[exists b1[...]]`).
* Use target paths (`where: 'exists a1.b1[...]`).
* Usage of [user attributes](#user-attrs).
::: warning
Paths *inside* the filter (`where: 'exists a1[b1.c = ...]`) are not yet supported.
:::




The following example demonstrates the last two features:


```cds
service ProductsService @(requires: 'authenticated-user') {
 entity Products @(restrict: [
   { grant: '*',
     where: 'exists producers.division[$user.division = name]'}]): cuid {
    producers : Association to many ProducingDivisions
                on producers.product = $self;
  }
  @readonly entity ProducingDivisions {
    key product : Association to Products;
    key division : Association to Divisions;
  }
  @readonly entity Divisions : cuid {
    name : String;
    producedProducts : Association to many ProducingDivisions
                       on producedProducts.division = $self;
  }
}
```

Here, the authorization of `Products` is derived from `Divisions` by leveraging the _n:m relationship_ via entity `ProducingDivisions`. Note that the path `producers.division` in the `exists` predicate points to target entity `Divisions`, where the filter with the user-dependent attribute `$user.division` is applied.

::: warning Consider Access Control Lists
Be aware that deep paths might introduce a performance bottleneck. Access Control List (ACL) tables, managed by the application, allow efficient queries and might be the better option in this case.
:::

<div id="exists-subquery" />
<Fragment target="#exists-subquery" type="concept">

### Exists with Subquery { #exists-subquery .java}

Occasionally, the authorization information is not navigable from the target entity of the query and hence [exists predicates](#exists-predicate) don't help.
In particular this is true for Access Control Lists (ACL) that are maintained in the domain of the application like in the following example:

```cds
 entity AccessRules {
    userId  : User;
    objectId: UUID;
    role: String enum { Viewer; Editor; }; /*...*/
}

@restrict:[{
    grant: ['READ'],
    where: `exists (select 1 from AccessRules where userId = $user and
                    objectId = $outer.ID and role is not null)`}]
aspect AuthorizeReadAccess;

@restrict:[{
    grant: ['UPDATE', 'DELETE'],
    where: `exists (select 1 from AccessRules where userId = $user and
                    objectId = $outer.ID and role = 'Editor')`}, {
    grant: ['CREATE']} ]
aspect AuthorizeWriteAccess;

entity Projects : cuid, AuthorizeReadAccess, AuthorizeWriteAccess {
  /*...*/
}
```

Here, `AccessRules` is a central table with ACL semantics that allows to assign application roles to business users on specific objects.
Access rules for the different roles are expressed using restrictions and are generically shared via aspects `AuthorizeReadAccess` and `AuthorizeWriteAccess`.
Note the following:

- `$user` refers to the current request user.
- References in the subselect are in scope of the subquery by default (for example, `objectId` or `role`) .
- Properties prefixed with `$outer` refer to the root entity of the query (for example, `$outer.ID` to `Projects.ID`).

Column names are prefixed with view names, including the namespace.

- `where: 'exists (select 1 from entitycollection.View where entitycollection.View.ID = entitycollection.Entity.ID)'`

Columns are unambiguously defined. For example, the `NAME1` column only exists in the original entity, whereas the `NAME2` column only exists in the table/view from the subselect.

- `where: 'exists (select 1 from entitycollection.View where NAME1 = NAME2)'`

The `USER` column is unambiguously defined and `$user` refers to the logged in user.

- `where: 'exists (select 1 from entitycollection.View where USER = $user)'`

To apply the common roles, entity `Projects` is just decorated with the aspects.

[Learn more about programmatic exists clauses with subqueries](../../java/working-with-cql/query-api#exists-subquery){.learn-more}

> [Annotation expressions](/cds/cdl#cds-annotations) don't support exists clauses with subqueries yet.

</Fragment>


### Association Paths { #association-paths}

The `where`-condition in a restriction can also contain [CQL path expressions](/cds/cql#path-expressions) that navigate to elements of associated entities:

```cds
service SalesOrderService @(requires: 'authenticated-user') {
  entity SalesOrders @(restrict: [
     { grant: 'READ',
       where: 'product.productType = $user.productType' } ]) {
    product: Association to one Products;
  }
  entity Products {
    productType: String(32); /*...*/
  }
}
```

Paths on 1:n associations (`Association to many`) are only supported, _if the condition selects at most one associated instance_.
It's highly recommended to use the [exists](#exists-predicate) predicate instead.
::: tip
Be aware of increased execution time when modeling paths in the authorization check of frequently requested entities. Working with materialized views might be an option for performance improvement in this case.
:::

::: warning _Warning_ 
In Node.js association paths in `where`-clauses are currently only supported when using SAP HANA.
:::

## Best Practices

CAP authorization allows you to control access to your business data on a fine granular level. But keep in mind that the high flexibility can end up in security vulnerabilities if not applied appropriately. In this perspective, lean and straightforward models are preferred. When modeling your access rules, the following recommendations can support you to design such models.

### Choose Conceptual Roles

When defining user roles, one of the first options could be to align roles to the available _operations_ on entities, which results in roles such as `SalesOrders.Read`, `SalesOrders.Create`, `SalesOrders.Update`, and `SalesOrders.Delete`, etc. What is the problem with this approach? Think about the resulting number of roles that the user administrator has to handle when assigning them to business users. The administrator would also have to know the domain model precisely and understand the result of combining the roles. Similarly, assigning roles to operations only (`Read`, `Create`, `Update`, ...) typically doesn't fit your business needs.<br>
We strongly recommend defining roles that describe **how a business user interacts with the system**. Roles like `Vendor`, `Customer`, or `Accountant` can be appropriate. With this approach, the application developers define the set of accessible resources in the CDS model for each role - and not the user administrator.

### Prefer Single-Purposed, Use-Case Specific Services { #dedicated-services}

Have a closer look at this example:

```cds
service CatalogService @(requires: 'authenticated-user') {
   entity Books @(restrict: [
    { grant: 'READ' },
    { grant: 'WRITE', to: 'Vendor', where: '$user.publishers = publisher' },
    { grant: 'WRITE', to: 'Admin' } ])
  as projection on db.Books;
  action doAccounting @(requires: ['Accountant', 'Admin']) ();
}
```

Four different roles (`authenticated-user`, `Vendor`, `Accountant`, `Admin`) *share* the same service - `CatalogService`. As a result, it's confusing how a user can use `Books` or `doAccounting`. Considering the complexity of this small example (4 roles, 1 service, 2 resources), this approach can introduce a security risk, especially if the model is larger and subject to adaptation. Moreover, UIs defined for this service will likely appear unclear as well.<br>
The fundamental purpose of services is to expose business data in a specific way. Hence, the more straightforward way is to **use a service for each of the roles**:

```cds
@path:'browse'
service CatalogService @(requires: 'authenticated-user') {
  @readonly entity Books
  as select from db.Books { title, publisher, price };
}

@path:'internal'
service VendorService @(requires: 'Vendor') {
  entity Books @(restrict: [
    { grant: 'READ' },
    { grant: 'WRITE', to: 'vendor', where: '$user.publishers = publisher' } ])
  as projection on db.Books;
}

@path:'internal'
service AccountantService @(requires: 'Accountant') {
  @readonly entity Books as projection on db.Books;
  action doAccounting();
}
/*...*/
```
::: tip
You can tailor the exposed data according to the corresponding role, even on the level of entity elements like in `CatalogService.Books`.
:::

### Prefer Dedicated Actions for Specific Use-Cases { #dedicated-actions}

In some cases it can be helpful to restrict entity access as much as possible and create actions with dedicated restrictions for specific use cases, like in the following example:

```cds
service GitHubRepositoryService @(requires: 'authenticated-user') {
  @readonly entity Organizations as projection on GitHub.Organizations actions {
    @(requires: 'Admin') action rename(newName : String);
    @(requires: 'Admin') action delete();
  };
}
```

This service allows querying organizations for all authenticated users. In addition, `Admin` users are allowed to rename or delete. Granting `UPDATE` to `Admin` would allow administrators to change organization attributes that aren't meant to change.

### Think About Domain-Driven Authorization { #domain-driven-authorization}

Static roles often don't fit into an intuitive authorization model. Instead of making authorization dependent from static properties of the user, it's often more appropriate to derive access rules from the business domain. For instance, all users assigned to a department (in the domain) are allowed to access the data of the organization comprising the department. Relationships in the entity model (for example, a department assignment to organization), influence authorization rules at runtime. In contrast to static user roles, **dynamic roles** are fully domain-driven.

Revisit the [ProjectService example](#exists-predicate), which demonstrates how to leverage instance-based authorization to induce dynamic roles.

Advantages of dynamic roles are:
- The most flexible way to define authorizations
- Induced authorizations according to business domain
- Application-specific authorization model and intuitive UIs
- Decentralized role management for application users (no central user administrator required)

Drawbacks to be considered are:
- Additional effort for modeling and designing application-specific role management (entities, services, UI)
- Potentially higher security risk due to lower use of the framework functionality
- Sharing authorization management with other (non-CAP) applications is harder to achieve
- Dynamic role enforcement can introduce a performance penalty


### Control Exposure of Associations and Compositions { #limitation-deep-authorization}

Note that exposed associations (and compositions) can disclose unauthorized data. Consider the following scenario:

```cds
namespace db;
entity Employees : cuid { // autoexposed!
  name: String(128);
  team: Association to Teams;
  contract: Composition of Contracts;
}
entity Contracts @(requires:'Manager') : cuid { // autoexposed!
  salary: Decimal;
}
entity Teams : cuid {
  members: Composition of many Employees on members.team = $self;
}


service ManageTeamsService @(requires:'Manager') {
  entity Teams as projection on db.Teams;
}

service BrowseEmployeesService @(requires:'Employee') {
  @readonly entity Teams as projection on db.Teams; // navigate to Contracts!
}
```

A team (entity `Teams`) contains members of type `Employees`. An employee refers to a single contract (entity `Contracts`) which contains sensitive information that should be visible only to `Manager` users. `Employee` users should be able to browse the teams and their members, but aren't allowed to read or even edit their contracts.<br>
As `db.Employees` and `db.Contracts` are auto-exposed, managers can navigate to all instances through the `ManageTeamsService.Teams` service entity (for example, OData request `/ManageTeamsService/Teams?$expand=members($expand=contract)`).<br> It's important to note that this also holds for an `Employee` user, as **only the target entity** `BrowseEmployeesService.Teams` **has to pass the authorization check in the generic handler, and not the associated entities**.<br>

To solve this security issue, introduce a new service entity `BrowseEmployeesService.Employees` that removes the navigation to `Contracts` from the projection:

```cds
service BrowseEmployeesService @(requires:'Employee') {
  @readonly entity Employees
  as projection on db.Employees excluding { contracts }; // hide contracts!

  @readonly entity Teams as projection on db.Teams;
}
```

Now, an `Employee` user can't expand the contracts as the composition isn't reachable anymore from the service.
::: tip
Associations without navigation links (for example, when an associated entity isn't exposed) are still critical with regards to security.
:::

### Design Authorization Models from the Start

As shown before, defining an adequate authorization strategy has a deep impact on the service model. Apart from the fundamental decision, if you want to build your authorizations on [dynamic roles](#domain-driven-authorization), authorization requirements can result in rearranging service and entity definitions completely. In the worst case, this means rewriting huge parts of the application (including the UI). For this reason, it's *strongly* recommended to take security design into consideration at an early stage of your project.

### Keep it as Simple as Possible

* If different authorizations are needed for different operations, it's easier to have them defined at the service level. If you start defining them at the entity level, all possible operations must be specified, otherwise the not mentioned operations are automatically forbidden.
* If possible, try to define your authorizations either on the service or on the entity level. Mixing both variants increases complexity and not all combinations are supported either.

### Separation of Concerns

Consider using [CDS Aspects](/cds/cdl#aspects) to separate the actual service definitions from authorization annotations as follows:


::: code-group
```cds [services.cds]
service ReviewsService {
  /*...*/
}

service CustomerService {
  entity Orders {/*...*/}
  entity Approval {/*...*/}
}
```
:::


::: code-group
```cds [services-auth.cds]
service ReviewsService @(requires: 'authenticated-user'){
  /*...*/
}

service CustomerService @(requires: 'authenticated-user'){
  entity Orders @(restrict: [
    { grant: ['READ','WRITE'], to: 'admin' },
    { grant: 'READ', where: 'buyer = $user' },
  ]){/*...*/}
  entity Approval @(restrict: [
    { grant: 'WRITE', where: '$user.level > 2' }
  ]){/*...*/}
}
```
:::

This keeps your actual service definitions concise and focused on structure only. It also allows you to give authorization models separate ownership and lifecycle.


## Programmatic Enforcement { #enforcement}

The service provider frameworks **automatically enforce** restrictions in generic handlers. They evaluate the annotations in the CDS models and, for example:

* Reject incoming requests if static restrictions aren't met.
* Add corresponding filters to queries for instance-based authorization, etc.

If generic enforcement doesn't fit your needs, you can override or adapt it with **programmatic enforcement** in custom handlers:

- [Authorization Enforcement in Node.js](/node.js/authentication#enforcement)
- [Enforcement API & Custom Handlers in Java](/java/security#enforcement-api)

## Role Assignments with IAS and AMS

The Authorization Management Service (AMS) as part of SAP Cloud Identity Services (SCI) provides libraries and services for developers of cloud business applications to declare, enforce and manage instance based authorization checks. When used together with CAP the AMS  "Policies” can contain the CAP roles as well as additional filter criteria for instance based authorizations that can be defined in the CAP model. transformed to AMS policies and later on refined by customers user and authorization administrators in the SCI administration console and assigned to business users.

### Use AMS as Authorization Management System on SAP BTP

SAP BTP is currently replacing the authorization management done with XSUAA by an integrated solution with AMS. AMS is integrated into SAP Cloud Identity (SCI), which will offer authentication, authorization, user provisioning and management in one place.

For newly build applications the usage of AMS is generally recommended. The only constraint that comes with the usage of AMS is that customers need to copy their users to the Identity Directory Service as the central place to manage users for SAP BTP applications. This is also the general SAP strategy to simplify user management in the future.

### Case For XSUAA

There is one use case where currently an XSUAA based authorization management is preferable: When XSUAA based services to be consumed by a CAP application come with their own business user roles and thus make user role assignment in the SAP Cloud Cockpit necessary. This will be resolved in the future when the authorization management will be fully based on the SCI Admin console.

For example, SAP Task Center you want to consume an XSUAA-based service that requires own end user role. Apart from this, most services should be technical services that do not require an own authorization management that is not yet integrated in AMS.



[Learn more about using IAS and AMS with CAP Node.js](https://github.com/SAP-samples/btp-developer-guide-cap/blob/main/documentation/xsuaa-to-ams/README.md){.learn-more}


## Role Assignments with XSUAA { #xsuaa-configuration}

Information about roles and attributes has to be made available to the UAA platform service. This information enables the respective JWT tokens to be constructed and sent with the requests for authenticated users. In particular, the following happens automatically behind-the-scenes upon build:


### 1. Roles and Attributes Are Filled into the XSUAA Configuration

Derive scopes, attributes, and role templates from the CDS model:

```sh
cds add xsuaa
```

This generates an _xs-security.json_ file:

::: code-group
```json [xs-security.json]
{
  "scopes": [
    { "name": "$XSAPPNAME.admin", "description": "admin" }
  ],
  "attributes": [
    { "name": "level", "description": "level", "valueType": "s" }
  ],
  "role-templates": [
    { "name": "admin", "scope-references": [ "$XSAPPNAME.admin" ], "description": "generated" }
  ]
}
```
:::

For every role name in the CDS model, one scope and one role template are generated with the exact name of the CDS role.

::: tip Re-generate on model changes
You can have such a file re-generated via
```sh
cds compile srv --to xsuaa > xs-security.json
```
:::

See [Application Security Descriptor Configuration Syntax](https://help.sap.com/docs/HANA_CLOUD_DATABASE/b9902c314aef4afb8f7a29bf8c5b37b3/6d3ed64092f748cbac691abc5fe52985.html) in the SAP HANA Platform documentation for the syntax of the _xs-security.json_ and advanced configuration options.


::: warning Avoid invalid characters in your models
Roles modeled in CDS may contain characters considered invalid by the XSUAA service.
:::

If you modify the _xs-security.json_ manually, make sure that the scope names in the file exactly match the role names in the CDS model, as these scope names will be checked at runtime.

### 2. XSUAA Configuration Is Completed and Published

#### Through MTA Build

If there's no _mta.yaml_ present, run this command:

```sh
cds add mta
```

::: details See what this does in the background…

1. It creates an _mta.yaml_ file with an `xsuaa` service.
2. The created service added to the `requires` section of your backend, and possibly other services requiring authentication.
::: code-group
```yaml [mta.yaml]
modules:
  - name: bookshop-srv
    requires:
      - bookshop-auth # [!code ++]
resources:
  name: bookshop-auth # [!code ++]
  type: org.cloudfoundry.managed-service # [!code ++]
  parameters: # [!code ++]
    service: xsuaa # [!code ++]
    service-plan: application # [!code ++]
    path: ./xs-security.json # include cds managed scopes and role templates  [!code ++]
    config: # [!code ++]
      xsappname: bookshop-${org}-${space} # [!code ++]
      tenant-mode: dedicated # 'shared' for multitenant deployments  [!code ++]
```
:::


Inline configuration in the _mta.yaml_ `config` block and the _xs-security.json_ file are merged. If there are conflicts, the [MTA security configuration](https://help.sap.com/docs/HANA_CLOUD_DATABASE/b9902c314aef4afb8f7a29bf8c5b37b3/6d3ed64092f748cbac691abc5fe52985.html) has priority.

[Learn more about **building and deploying MTA applications**.](/guides/deployment/){ .learn-more}

### 3. Assembling Roles and Assigning Roles to Users

This is a manual step an administrator would do in SAP BTP Cockpit. See [Set Up the Roles for the Application](/node.js/authentication#auth-in-cockpit) for more details. If a user attribute isn't set for a user in the IdP of the SAP BTP Cockpit, this means that the user has no restriction for this attribute. For example, if a user has no value set for an attribute "Country", they're allowed to see data records for all countries.
In the _xs-security.json_, the `attribute` entity has a property `valueRequired` where the developer can specify whether unrestricted access is possible by not assigning a value to the attribute.


### 4. Scopes Are Narrowed to Local Roles

Based on this, the JWT token for an administrator contains a scope `my.app.admin`. From within service implementations of `my.app` you can reference the scope:

```js
req.user.is ("admin")
```
... and, if necessary, from others by:

```js
req.user.is ("my.app.admin")
```

<br>

> See the following sections for more details:
- [Developing Security Artifacts in SAP BTP](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/419ae2ef1ddd49dca9eb65af2d67c6ec.html)
- [Maintaining Application Security in XS Advanced](https://help.sap.com/docs/HANA_CLOUD_DATABASE/b9902c314aef4afb8f7a29bf8c5b37b3/35d910ee7c7a445a950b6aad989a5a26.html)

<div id="secondary-file">guides/security/authorization.fragment.md</div>


# Platform Security

This section provides an overview about the security architecture of CAP applications on different platforms.

## Platform Compliance { #platform-compliance }

CAP applications run in a certain environment, that is, in the context of some platform framework that has specific characteristics.
The underlying framework has a major impact on the security of the application,
regardless of whether it runs a [cloud](#cloud) environment or [local](#local) environment.
Moreover, CAP applications are tightly integrated with [platform services](#btp-services), in particular with identity and persistence service.

::: warning End-to-end security necessarily requires compliance with all security policies of all involved components.
CAP application security requires consistent security configuration of the underlying platform and all consumed services. Consult the relevant security documentation accordingly.
:::

### CAP in Cloud Environment { #cloud }

Currently, CAP supports to run on two cloud runtimes of [SAP Business Technology Platform](https://help.sap.com/docs/btp):

- [SAP BTP, Cloud Foundry Runtime](https://help.sap.com/docs/btp/sap-business-technology-platform/cloud-foundry-environment)
- [SAP BTP, Kyma Runtime](https://help.sap.com/docs/btp/sap-business-technology-platform/kyma-environment)

Application providers are responsible to ensure a **secure platform environment**.
In particular, this includes *configuring* [platform services](#btp-services) the application consumes.
For instance, the provider (user) administrator needs to configure the [identity service](#identity-service) to separate platform users from business users that come from different identity providers.
Likewise login policies (for example, multifactor authentication or single-sign-on) need to be aligned with company-specific requirements.

Note, that achieving production-ready security requires to meet all relevant aspects of the **development process** as well.
For instance, source code repositories need to be protected and may not contain any secrets or personal data.
Likewise, the **deployment process** needs to be secured. That includes not only setting up CI/CD pipelines running on technical platform users, but also defining integration tests to ensure properly secured application endpoints.

As part of **secure operations**, application providers need to establish a patch and vulnerability management, as well as a secure support process. For example, component versions need to be updated and credentials need to be rotated regularly.

::: warning
The application provider is responsible to **develop, deploy, and operate the application in a secure platform environment**.
CAP offers seamless integration into platform services and tools to help to meet these requirements.
:::

Find more about BTP platform security here:

[SAP BTP Security](https://help.sap.com/docs/btp/sap-business-technology-platform/security-e129aa20c78c4a9fb379b9803b02e5f6){.learn-more}
[SAP BTP Security Recommendations](https://help.sap.com/docs/btp/sap-btp-security-recommendations-c8a9bb59fe624f0981efa0eff2497d7d/sap-btp-security-recommendations){.learn-more}
[SAP BTP Security (Community)](https://pages.community.sap.com/topics/btp-security){.learn-more}


<div id="security-deploy-sap" />
<Fragment target="#security-deploy-sap">

#### Deploy with Confidence (DwC) <Internal /> { #dwc }

[DwC](https://pages.github.tools.sap/deploy-with-confidence/solar-system/) is a delivery management framework that helps to orchestrate and operate complex service meshes.
It's available on both cloud runtimes and adds services that act as proxies for CAP applications. Hence, DwC landscapes introduce specific security requirements.
Find more details in the corresponding documentation for [Node.js](https://pages.github.tools.sap/deploy-with-confidence/solar-system/how-to-guides/application-development/development/nodejs/?_highlight=secur#secure-unprotected-public-endpoints) resp.
[Java](https://pages.github.tools.sap/deploy-with-confidence/solar-system/how-to-guides/application-development/development/mta_java_cap/#enable-mtls-authentication).

</Fragment>

### CAP in Local Environment { #local }

Security not only plays a crucial role in [cloud](#cloud) environments, but also during local development.
Apparently the security requirements are different from cloud scenario as local endpoints are typically not exposed for remote clients.
But there are still a few things to consider because exploited vulnerabilities could be the basis for attacks on productive cloud services:

- Make sure that locally started HTTP endpoints are bound to `localhost`.
- In case you run your service in hybrid mode with bindings to cloud service instances,
use [cds bind](../../advanced/hybrid-testing) instead of copying bindings manually to `default-env.json` file.
`cds bind` avoids materialization of secrets to local disc, which is inherently dangerous.
- Don't write sensitive data to application logs, also not via debug logging.
- Don't test with real business data, for example, copied from a productive system.


### SAP BTP Services for Security { #btp-services}

SAP BTP provides a range of platform services that your CAP applications can utilize to meet production-grade security requirements. To ensure the security of your CAP applications, it's crucial to comply with the service level agreement (SLA) of these platform services. *As the provider of the application, you play a key role in meeting these requirements by correctly configuring and using these services.*

::: tip
SAP BTP services and the underlying platform infrastructure hold various certifications and attestations, which can be found under the naming of SAP Cloud Platform in the [SAP Trust Center](https://www.sap.com/about/trust-center/certification-compliance/compliance-finder.html?search=SAP%20Business%20Technology%20Platform%20ISO).
:::

The CAP framework offers flexible APIs that you can integrate with various services, including your custom services. If you replace platform services with your custom ones, it's important to ensure that the service level agreements (SLAs) CAP depends on are still met.

The most important services for security offered by the platform:

[Webcast SAP BTP Cloud Identity and Security Services](https://assets.dm.ux.sap.com/webinars/sap-user-groups-k4u/pdfs/221117_sap_security_webcast_series_sap_btp_cloud_identity_and_security_services.pdf){.learn-more}

#### [SAP Cloud Identity Services - Identity Authentication](https://help.sap.com/docs/IDENTITY_AUTHENTICATION) { #identity-service }

The Identity Authentication service defines the user base for (CAP) applications and services, and allows to control access.
Customers can integrate their 3rd party or on-premise identity provider (IdP) and harden security by defining multifactor authentication or by narrowing client IP ranges.
This service helps to introduce a strict separation between platform users (provider) and business users (subscribers), a requirement of CAP. It supports various authentication methods, including SAML 2.0 and [OpenID Connect](https://openid.net/connect/), and allows for the configuration of single sign-on access.

[Learn more in the security guide.](https://help.sap.com/docs/IDENTITY_AUTHENTICATION?#discover_task-security){.learn-more}

#### [SAP Authorization and Trust Management Service](https://help.sap.com/docs/CP_AUTHORIZ_TRUST_MNG)

The service lets customers manage user authorizations in technical roles at application level, which can be aggregated into business-level role collections for large-scale cloud scenarios.
Obviously, developers must define application roles carefully as they form basic access rules to business data.

#### [SAP Malware Scanning Service](https://help.sap.com/docs/MALWARE_SCANNING)

This service can be used to scan transferred business documents for malware and viruses.
Currently, there is no CAP integration. A scan needs to be triggered by the business application explicitly.

[Learn more in the security guide.](https://help.sap.com/docs/btp?#operate_task-security){.learn-more}

#### [SAP Credential Store](https://help.sap.com/docs/CREDENTIAL_STORE)

Credentials managed by applications need to be stored in a secure way.
This service provides a REST API for (CAP) applications to store and retrieve credentials at runtime.

[Learn more in the security guide.](https://help.sap.com/docs/CREDENTIAL_STORE?#discover_task-security){.learn-more}

#### [SAP BTP Connectivity](https://help.sap.com/docs/CP_CONNECTIVITY)

The connectivity service allows SAP BTP applications to securely access remote services that run on the Internet or on-premise.
It provides a way to establish a secure communication channel between remote endpoints that are connected via an untrusted network infrastructure.

[Learn more in the security guide.](https://help.sap.com/docs/CP_CONNECTIVITY/cca91383641e40ffbe03bdc78f00f681/cb50b6191615478aa11d2050dada467d.html){.learn-more}

## Architecture and Platform Requirements

As [pointed out](#platform-compliance), CAP cloud applications run in a specific context that has a major impact on the security [architecture](#architecture-overview).
CAP requires a dedicated [platform environment](#platform-environment) to integrate with, in order to ensure end-to-end security.

### Architecture Overview { #architecture-overview }

The following diagram provides a high-level overview about the security-relevant aspects of a deployed CAP application in a cloud environment:


![This TAM graphic is explained in the accompanying text.](./assets/cap-security-architecture-overview.png){}

To serve a business request, different runtime components are involved: a request, issued by a UI or technical client ([public zone](#public-zone)), is forwarded by a gateway or ingress router to the CAP application. In case of a UI request, an [Application Router](https://help.sap.com/docs/btp/sap-business-technology-platform/application-router) instance acts as a proxy. The CAP application might make use of a CAP sidecar. All application components ([application zone](#application-zone)) might make use of platform services such as database or identity service ([platform zone](#platform-zone)).

#### Public Zone { #public-zone }

From CAP's point of view, all components without specific security requirements belong to the public zone.
Therefore, you shouldn't rely on the behavior or structure of consumer components like browsers or technical clients for the security of server components.
The platform's gateway provides a single point of entry for any incoming call and defines the API visible to the public zone.
As malicious users have free access to the public zone, these endpoints need to be protected carefully.
Ideally, you should limit the number of exposed endpoints to a minimum, perhaps through proper network configuration.

#### Platform Zone { #platform-zone }

The platform zone contains all platform components and services that are *configured and maintained* by the application provider.
CAP applications consume these low-level [platform services](#btp-services) to handle more complex business requests.
For instance, persistence service to store business data and identity service to authenticate the business user play a fundamental role.

The platform zone also includes the gateway, which is the main entry point for external requests. Additionally, it may contain extra ingress routers.

#### Application Zone { #application-zone}

The application zone comprises all microservices that represent a CAP application. They are tightly integrated and form a unit of trust. The application provider is responsible to *develop, deploy and operate* these services:

- The [Application Router](https://help.sap.com/docs/btp/sap-business-technology-platform/application-router) acts as as an optional reverse proxy wrapping the application service and providing business-independent functionality required for UIs.
This includes serving UI content, providing a login flow as well as managing the session with the browser.
It can be deployed as application (reusable module) or alternatively consumed as a [service](https://help.sap.com/docs/btp/sap-business-technology-platform/managed-application-router).

- The CAP application service exposes the API to serve business requests. Usually, it makes use of lower-level platform services. As built on CAP, a significant number of security requirements is covered either out of the box or by adding minimal configuration.

- The optional CAP sidecar (reusable module) is used to outsource application-independent tasks such as providing multitenancy and extension support.

Application providers, that is platform users, have privileged access to the application zone.
In contrast, application subscribers, that is business users, are restricted to a minimal interface.

::: warning
❗ Application providers **may not share any secrets from the application zone** such as binding information with other components or persons.
In a productive environment, it is recommended to deploy and operate the application on behalf of a technical user.
:::

::: tip
Without limitation of generality, there may be multiple CAP services or sidecars according to common [microservice architecture pattern](https://microservices.io/patterns/microservices.html).
:::


### Required Platform Environment { #platform-environment }

There are several assumptions that a CAP application needs to make about the platform environment it is deployed to:

1. Application and (platform) service endpoints are exposed externally by the API gateway via TLS protocol.
Hence, the **CAP application can offer a pure HTTP endpoint** without having to enforce TLS and to deal with certificates.

2. The server certificates presented by the external endpoints are signed by a trusted certificate authority.
This **frees CAP applications from the need to manage trust certificates**. The underlying runtimes (Java or Node) can validate the server certificates by default.

3. **Secrets** that are required to protect the application or to consume other platform services **are injected by the platform** into the application in a secure way.

All supported [environments](overview#cloud) fulfill the given requirements. Additional requirements could be added in future.

::: tip
Custom domain certificates need to be signed by trusted certificate authority.
:::

::: warning
❗ **In general, application endpoints are visible to public zone**. Hence, CAP can't rely on private endpoints.
In particular, an application router does not prevent external access to the CAP application service.
As a consequence, **all CAP endpoints must be protected in an appropriate manner**.
:::

<div id="secondary-file">guides/security/overview.fragment.md</div>


# Security Aspects

This section describes in detail what CAP offers to protect your application.

<ImplVariantsHint />

## Secure Communications { #secure-communications }


### Encrypted Communication Channels { #encrypted-channels }


*Integrity* and *confidentiality* of data being transferred between any communication endpoints needs to be guaranteed.
In particular, this holds true for communication between client and server ([public zone](./overview#public-zone) resp. [platform zone](./overview#platform-zone)), but also for service-to-service communication (within a platform zone).
That means the communication channels are established in a way that rules out undetected data manipulation or disclosure.


#### Inbound Communication (Server) { #inbound }


[SAP BTP](https://help.sap.com/docs/btp/sap-business-technology-platform/btp-security) exclusively establishes encrypted communication channels based on HTTPS/TLS as shown in the [architecture overview](./overview#architecture-overview)
and hence fulfills the requirements out of the box.
For all deployed (CAP) applications and platform services, the platform's API gateway resp. ingress router provides TLS endpoints accepting incoming request and forwards to the backing services via HTTP.
The HTTP endpoints of microservices are only accessible for the router in terms of network technology (perimeter security) and therefore aren't visible for clients in public and platform zone.
Likewise microservices can only serve a single network port, which the platform has opened for the hosting container.

The router endpoints are configured with an up to date TLS protocol version containing a state-of-the-art cipher suite. Server authentication is given by X.509 server certificates signed by a trusted certificate authority.

::: tip
It's mandatory for public clients to authenticate the server and to verify the server's identity by matching the target host name with the host name in the server certificate.
:::

::: tip
Manually provided certificates for [custom domains](https://help.sap.com/docs/CUSTOM_DOMAINS/6f35a23466ee4df0b19085c9c52f9c29/4f4c3ff62fd2413089dce8a973620167.html) need to be signed by a [trusted certificate authority](https://help.sap.com/docs/btp/sap-business-technology-platform/trusted-certificate-authentication).
:::



#### Outbound Communication (Client) { #outbound }

As platform services and other applications deployed to BTP are only accessible via exposed TLS router endpoints, outbound connections are automatically secured as well.
Consequently, technical clients have to [validate the server certificate](#inbound) for proper server authentication.
Also here CAP application developers don't need to deal with HTTPS/TLS connection setup provided the client code is build on CAP offerings such as HANA Cloud Service or CloudSDK integration.

::: warning
The **CAP application needs to ensure adequate protection of secrets** that are injected into CAP microservices, for example:
- [mTLS authentication is enabled](https://help.sap.com/docs/btp/sap-business-technology-platform/enable-mtls-authentication-to-sap-authorization-and-trust-management-service-for-your-application) in the XSUAA service instance of your application and also for XSUAA reuse instances of platform services.
- Ensure that [service bindings and keys](https://help.sap.com/docs/btp/sap-business-technology-platform/using-services-in-cloud-foundry-environment) aren't compromised (rotate regularly).
- SAP BTP Connectivity services are maintained [securely](https://help.sap.com/docs/connectivity/sap-btp-connectivity-cf/connectivity-security).
:::

#### Internal Communication (Client and Server) { #internal }

Depending on the target platform, closely coupled microservices of the application zone might also communicate via trusted network channels instead of using [outbound connections](#outbound).
For instance, a CAP service could communicate to a CAP sidecar, which is deployed to the same container via localhost HTTP connection.

::: tip
CAP allows to use alternative communication channels, but application operators are responsible to set up them in a secure manner.
:::

::: tip
CAP applications don't have to deal with TLS, communication encryption, or certificates, for inbound as well as outbound connections.
:::


### Filtering Internet Traffic { #filtering }


Reducing attack surface by filtering communication from or to public zone increases the overall security protection level.
By default, the platform comes with a standard set of services and configurations to protect network communication building on security features of the underlying hyperscaler.

::: warning
Measures to further **restrict web access to your application** can be applied at platform level and aren't offered by CAP.
For instance, [CF Route service](https://docs.cloudfoundry.org/services/route-services.html) can be used to implement route-specific restriction rules.
:::

## Secure Authentication { #secure-authentication }

None-public resources may only be accessed by authenticated users. Hence, authentication plays a key role for product security on different levels:
- **Business users** consume the application via web interface. In multitenant applications, they come from different subscriber tenants that need to be isolated from each other.
- **Platform users** operate the application and have privileged access to its components on OS level (containers, configurations, logs etc.). Platform users come from the provider tenant.

Managing user pools, providing a logon flow, and processing authentication are complex and highly security-critical tasks **that shouldn't be tackled by applications**.
Instead, applications should rely on an identity service provided by the platform which is [seamlessly integrated by CAP](#authenticate-requests).

Find more about platform and business users:
[SAP BTP User and Member Management](https://help.sap.com/docs/btp/sap-business-technology-platform/user-and-member-management){.learn-more}


### Server Requests { #authenticate-requests }


SAP BTP offers central identity services [SAP Cloud Identity Services - Identity Authentication](https://help.sap.com/docs/IDENTITY_AUTHENTICATION) resp. [SAP Authorization and Trust Management Service](https://help.sap.com/docs/CP_AUTHORIZ_TRUST_MNG)
for managing and authenticating platform and business users providing:
- User authentication flows (OpenID connect), for example, multifactor authentication
- Federation of custom identity providers (IdPs)
- Single-sign on
- Principal propagation
- Password and session policies etc.

The central platform service provides applications with a large set of industry-proven security features, which is why applications don't have to develop their own extensions and run the risk of security flaws.

CAP doesn't require any specific authentication strategy, but it provides out of the box integration with the platform identity service.
On configured authentication, *all CAP endpoints are authenticated by default*.

::: warning
❗ **CAP applications need to ensure that an appropriate [authentication method](/guides/security/authorization#prerequisite-authentication) is configured**.
It's highly recommended to establish integration tests to safeguard a valid configuration.
:::

Learn more about user model and identity providers here:
[SAP BTP Security](https://help.sap.com/docs/btp/sap-business-technology-platform/btp-security){.learn-more}


### Remote Services { #authenticate-remote }


CAP microservices consume remote services and hence need to be authenticated as technical client as well.
Similar to [request authentication](#authenticate-requests), CAP saves applications from having to implement secure setup of service to service communication:
- CAP interacts with platform services such as [Event Mesh](../messaging/) or [SaaS Provisioning Service](../deployment/to-cf) on basis of platform-injected service bindings.
- CAP offers consumption of [Remote Services](../using-services) on basis of [SAP BTP destinations](../using-services#btp-destinations).

Note that the applied authentication strategy is specified by server offering and resp. configuration and not limited by CAP.

<div id="security-mtls" />
<Fragment target="#security-mtls">

#### mTLS Protection Given by Platform <Internal />

Internal application services (application zone) on [DwC](https://pages.github.tools.sap/deploy-with-confidence/solar-system/) are automatically mTLS-protected.
The same also holds for Kyma, which establishes an Istio service mesh by default, terminating mTLS at Pod level.

</Fragment>

### Maintaining Sessions { #sessions }


CAP microservices require [authentication](#authenticate-requests) of all requests, but they don't support logon flows for UI clients.
Being stateless, they neither establish a session with the client to store login information such as an OAuth 2 token that needs to be passed in each server request.

To close this gap, UI-based CAP applications can use an [Application Router](https://help.sap.com/docs/btp/sap-business-technology-platform/application-router) instance or service as reverse proxy as depicted in the [diagram](./overview#architecture-overview).
The Application Router redirects the login to the identity service, fetches an OAuth2 token, and stores it into a secure session cookie.

::: warning
❗ The **Application Router endpoints don't hide CAP endpoints** in the service backend.
Hence, authentication is still mandatory for CAP microservices.
:::

### Maintaining Secrets { #secrets }


To run a CAP application that authenticates users and consumes remote services, **it isn't required to manage any secrets such as keys, tokens, or passwords**.
Also CAP doesn't store any of them, but relies on platform [injection mechanisms](./overview#platform-environment) or [destinations](../using-services#btp-destinations).

::: tip
In case you still need to store any secrets, use a platform service [SAP Credential Store](https://help.sap.com/docs/CREDENTIAL_STORE).
:::

## Secure Authorization { #secure-authorization }


According to segregation of duties paradigm, user administrators need to control how different users may interact with the application.
Critical combinations of authorizations must be avoided. Basically, access rules for [business users](#business-authz) are different from [platform users](#platform-authz).


### Business Users { #business-authz }


To align with the principle of least privilege, applications need to enforce fine-grained access control for business users from the subscriber tenants.

Depending from the business scenario, users need to be restricted to operations they perform on server resources, for example, reading an entity collection.
Moreover, they might also be limited to a subset of data entries, that is, they may only operate on a filtered view on the data.
The set of rules that apply to a user reflects a specific conceptual role that describes the interaction with the application to fulfill a business scenario.
Obviously, the business roles are dependent from the scenarios and hence *need to be defined by the application developers*.

Enforcing authorization rules at runtime is highly security-critical and shouldn't be implemented by the application as this would introduce the risk of security flaws.
Instead, [CAP authorizations](/guides/security/authorization) follow a declarative approach allowing applications to design comprehensive access rules in the CDS model.

Resources in the model such as services or entities can be restricted to users that fulfill specific conditions as declared in `@requires` or `@restrict` [annotations](/guides/security/authorization#restrictions).
According to the declarations, server-side authorization enforcement is guaranteed for all requests. It's executed close before accessing the corresponding resources.

::: warning
❗ **By default, CAP services and entities aren't authorized**.
Application developers need to **design and test access rules** according to the business need.
:::

::: tip
To verify CAP authorizations in your model, it's recommended to use [CDS lint rules](../../tools/cds-lint/rules/).
:::

The rules prepared by application developers are applied to business users according to grants given by the subscribers user administrator, that is, they're applied tenant-specific.

CAP authorizations can be defined dependently from [user claims](/guides/security/authorization#user-claims) such as [XSUAA scopes or attributes](https://help.sap.com/docs/btp/sap-business-technology-platform/application-security-descriptor-configuration-syntax)
that are deployed by application developers and granted by the user administrator of the subscriber.
Hence, CAP provides a seamless integration of central identity service without technical lock-in.

::: tip
You can generate the `xs-security.json` [descriptor file](https://help.sap.com/docs/btp/sap-business-technology-platform/protecting-your-application) of the application's XSUAA instance by executing `cds add xsuaa` in the project root folder.
The XSUAA scopes, roles, and attributes are derived from the CAP authorization model.
:::

::: warning
CAP authorization enforcement doesn't automatically log successful and unsuccessful authorization checks.
Applications need to add corresponding custom handlers to support it.
:::

#### Authorization of CAP Endpoints { #cap-endpoints }


In general, responses created by *standard* CAP handlers and services are created on need-to-know basis.
This means, authorized users only receive server information according to their privilege.
Therefore, business users won't gain information about server host names, any version of application server component, generated queries etc.

Based on the CDS model and configuration of CDS services, the CAP runtime exposes following endpoints:

| Name              | Configuration    | URL                                       | Authorization                                 |
|-------------------|------------------|-------------------------------------------|-----------------------------------------------|
| CDS Service `Foo` | `service Foo {}` | `/<protocol-path>/Foo/**`<sup>1</sup>     | `@restrict`/`@requires`<sup>2</sup>           |
|                   | OData v2/v4      | `/<odata-path>/Foo/$metadata`<sup>1</sup> | See [here](/guides/security/authorization#requires) |
| Index page        |                  | `/index.html`                             | none, but disabled in production              |

> <sup>1</sup> See [protocols and paths](../../java/cqn-services/application-services#configure-path-and-protocol)

> <sup>2</sup> No authorization by default

Based on configured features, the CAP runtime exposes additional callback endpoints for specific platform service:

<div class="impl java">

| Platform service             | URL                         | Authorization                                                                                          |
|------------------------------|-----------------------------|--------------------------------------------------------------------------------------------------------|
| Multitenancy (SaaS Registry) | `/mt/v1.0/subscriptions/**` | Technical role `mtcallback`                     |



</div>

<div class="impl node">

| Platform service             | URL                     | Authorization |
|------------------------------|-------------------------|---------------|
| Multitenancy (SaaS Registry) | none so far for Node.js |               |

</div>

<div id="auth-callback-endpoints-more" />
<Fragment target="#auth-callback-endpoints-more">

In addition, these endpoints are available at SAP:

<div class="impl java">

| Platform service             | URL                         | Authorization                                                                                          |
|------------------------------|-----------------------------|--------------------------------------------------------------------------------------------------------|
| Messaging (Event Mesh, MT)   | `/messaging/v1.0/em`        | [Technical roles](../../guides/messaging/event-mesh#inbound-access-webhooks) `emcallback`, `emmanagement` |

</div>

<div class="impl node">

| Platform service           | URL                                      | Authorization                                                                          |
|----------------------------|------------------------------------------|----------------------------------------------------------------------------------------|
| Messaging (Event Mesh, MT) | `/messaging/enterprise-messaging`        | [Technical role](../../guides/messaging/event-mesh#inbound-access-webhooks) `emcallback`, |
|                            | `/messaging/enterprise-messaging/deploy` | Technical role`emmanagement`                                                           |

</div>

</Fragment>

Moreover, technical [MTXs CAP services](../multitenancy/mtxs) may be configured, for example, as sidecar microservice to support higher-level features such as Feature Toggles or Multitenancy:

| CAP service | URL | Authorization
| ----------- | --- | -------------
| [cds.xt.ModelProviderService](../multitenancy/mtxs#modelproviderservice) | `/-/cds/model-provider/**` | Internal, technical user<sup>1</sup>
| [cds.xt.DeploymentService](../multitenancy/mtxs#deploymentservice) | `/-/cds/deployment/**` | | Internal, technical user<sup>1</sup>, or technical role `cds.Subscriber`
| [cds.xt.SaasProvisioningService](../multitenancy/mtxs#saasprovisioningservice) | `/-/cds/saas-provisioning/**` | Internal, technical user<sup>1</sup>, or technical roles `cds.Subscriber` resp. `mtcallback`
| [cds.xt.ExtensibilityService](../multitenancy/mtxs#extensibilityservice) | `/-/cds/extensibility/**` | Internal, technical user<sup>1</sup>, or technical roles `cds.ExtensionDeveloper`
> <sup>1</sup> The microservice running the MTXS CAP service needs to be deployed to the [application zone](./overview#application-zone)
and hence has established trust with the CAP application client, for instance given by shared XSUAA instance.

Authentication for a CAP sidecar needs to be configured just like any other CAP application.

::: warning
❗ Ensure that technical roles such as `cds.Subscriber`, `mtcallback`, or `emcallback` **are never included in business roles**.
:::

### Platform Users { #platform-authz }


Similar to [business consumption](#business-authz), different scenarios apply on operator level that need to be separated by dedicated access rules: deployment resp. configuration, monitoring, support, audit logs etc.
*CAP doesn't cover authorization of platform users*. Please refer to security documentation of the underlying SAP BTP runtime environment:
- [Roles in the Cloud Foundry Environment](https://help.sap.com/docs/btp/sap-business-technology-platform/about-roles-in-cloud-foundry-environment)
- [Roles in the Kyma Environment](https://help.sap.com/docs/btp/sap-business-technology-platform/assign-roles-in-kyma-environment)

## Secure Multi-Tenancy { #secure-multitenancy }


Multitenant SaaS-applications need to take care for security aspects on a higher level.
Different subscriber tenants share the same runtime stack to interact with the CAP application.
Ideally, from perspective of a single tenant, the runtime should look like a self-contained virtual system that doesn't interfere with any other tenant.

All directly or indirectly involved services that process the business request require to isolate with regards to several dimensions:
- No breakout to [persisted data](#isolated-persistent-data)
- No breakout to [transient data](#isolated-transient-data)
- Limited [resource consumption](#limiting-resource-consumption)

The CAP runtime is designed from scratch to support tenant isolation:

### Isolated Persistent Data { #isolated-persistent-data }

Having configured [Multitenancy in CAP](../multitenancy/), when serving a business request, CAP automatically targets an isolated HDI container dedicated for the request tenant to execute DB statements.
Here, CAP's data query API based on [CQN](../../cds/cqn) is orthogonal to multitenancy, that is, custom CAP handlers can be implemented agnostic to MT.

During tenant onboarding process, CAP triggers the HDI container creation via [SAP HANA Cloud Services](https://help.sap.com/docs/HANA_SERVICE_CF/cc53ad464a57404b8d453bbadbc81ceb/f70399be7fca4508aa0e33e138dbd84d.html).
The containers have separated DB schemas and dedicated technical DB users for access.
CAP guarantees that code for business requests runs on a DB connection opened for the technical user of the tenant's container.

### Isolated Transient Data { #isolated-transient-data }

Although CAP microservices are stateless, the CAP Java runtime (generic handlers inclusive) needs to cache data in-memory for performance reasons.
For instance, filters for [instance-based authorization](/guides/security/authorization#instance-based-auth) are constructed only once and are reused in subsequent requests.

<div class="impl java">

To minimize risk of a data breach by exposing transient data at runtime, the CAP Java runtime explicitly refrains from declaring and using static mutable objects in Java heap.
Instead, request-related data such as the [EventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/EventContext.html) is provided via thread-local storage.
Likewise, data is stored in tenant-maps that are transitively referenced by the [CdsRuntime](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/CdsRuntime.html) instance.

::: warning
Make sure that custom code doesn't break tenant data isolation.
:::

</div>

<div class="impl node">

Request-related data is propagated down the call stack via the continuation-local variable [cds.context](../../node.js/events#cds-context).

::: warning
Make sure that custom code doesn't break tenant data isolation or leak data across concurrent requests.
:::

As a best practice, you should not put any non-static variables in the closures of your service implementations.

##### **Bad example:** {.bad}

::: code-group
```js [srv/cat-service.js]
module.exports = srv => {
  let books  // <- leaks data across tenants and concurrent requests // [!code error]
  srv.on('READ', 'Books', async function(req, next) {
    if (books) return books
    return books = await next()
  })
}
```
:::

</div>

### Limiting Resource Consumption { #limiting-resource-consumption }

Tenant-aware microservices also need to handle resource consumption of tenants, in particular with regards to CPU, memory, and network connections.
Excessive use of resources requested by a single tenant could cause runtime problems for other consumers (noisy neighbor problem).

CAP helps to control resource usage:

<div class="impl java">

- Business request run in isolated Java threads and hence OS thread scheduling ensures fair distribution of CPU shares.
- By default, tenants have dedicated DB connection pools.

</div>

<div class="impl node">

- Fine granular processing of request (CAP handlers) to avoid disproportionate blocking times of the event loop.
- Tenants have dedicated DB connection pools.

</div>

::: tip
Make sure that custom code doesn't introduce excessive memory or CPU consumption within a single request.
:::

Because OS resources are strictly limited in a virtualized environment, a single microservice instance can handle load of a limited set of tenants, only.
[**Adequate sizing**](#dos-attacks) of your microservice is mandatory, that is, adjusting memory settings, connection pool sizes, request size limits etc. according to the business needs.

Last but not least you need to implement a **scaling strategy** to meet increasing load requirements by additional microservice instances.

::: warning
❗ **Sizing and scaling** is up to application developers and operators. CAP default values aren't suitable for all applications.
:::

## Secure Against Untrusted Input { #secure-untrusted-input }

Without protection mechanism in place, a malicious user could misuse a valid (that is, authenticated) session with the server and attack valuable business assets.

### Injection Attacks { #injection-attacks }

Attackers can send malicious input data in a regular request to make the server perform unintended actions that can lead to serious data exploits.

#### Common Attack Patterns { #common-injection-attacks }


- CAP's intrinsic data querying engine is immune with regards to [SQL injections](https://owasp.org/www-community/attacks/SQL_Injection) that are introduced by query parameter values that are derived from malicious user input.
[CQL statements](../querying) are transformed into prepared statements that are executed in SQL databases such as SAP HANA.
Be aware that injections are still possible even via CQL when the query structure (target entity, columns and so on) is based on user input:

  <div class="impl java">

  ```java
  String entity = ...; // from user input;
  String column = ...; // from user input;
  validate(entity, column); // for example, by comparing with positive list
  Select.from(entity).columns(b -> b.get(column));
  ```

  </div>

  <div class="impl node">

  ```js
  const entity = <from user input>
  const column = <from user input>
  validate(entity, column) // for example, by comparing with positive list
  SELECT.from(entity).columns(column)
  ```

  </div>

  ::: warning
  Be careful with custom code when creating or modifying CQL queries. Additional input validation is needed when the query structure depends on the request's input.
  :::

- [Cross Site Scripting (XSS)](https://owasp.org/www-community/attacks/xss) is used by attackers to inject a malicious script, which is executed in the browser session of an unsuspecting user.
By default, there are some protection mechanisms in place.
For instance, CAP OData V4 adapter renders responses with HTTP, which prevents the browser from misinterpreting the context.
On the client side, SAPUI5 provides input validation for all typed element properties and automatic output encoding in all standard controls.

- Untrusted data being transferred may contain malware.
[SAP Malware Scanning Service](https://help.sap.com/docs/MALWARE_SCANNING) is capable to scan provided input streams for viruses and is regularly updated.

  ::: warning
  ❗ Currently, CAP applications need to add custom handlers to **scan data being uploaded or downloaded**.
  :::

- [Path traversal](https://owasp.org/www-community/attacks/Path_Traversal) attacks aim to access parts of the server's file system outside the web root folder.
As part of the [application zone](./overview#application-zone), an Application Router serves the static UI content of the application. The CAP microservice doesn't need to serve web content from file system.
Apart from that the used web server frameworks such as Spring or Express already have adequate protection mechanisms in place.

- [CLRF injections](https://owasp.org/www-community/vulnerabilities/CRLF_Injection) or [log injections](https://owasp.org/www-community/attacks/Log_Injection) can occur when untrusted user input is written to log output.

  <div class="impl node">

  CAP Node.js offers a CLRF-safe [logging API](../../node.js/cds-log#logging-in-production) that should be used for application logs.

  </div>

  <div class="impl java">

  ::: warning
  Currently, CAP applications need to care for escaping user data that is used as input parameter for application logging.
  It's recommended to make use of an existing Encoder such as OWASP [ESAPI](https://www.javadoc.io/doc/org.owasp.esapi/esapi/2.0.1/org/owasp/esapi/Encoder.html).
  :::

  </div>

- [Deserialization of untrusted data](https://owasp.org/www-community/vulnerabilities/Deserialization_of_untrusted_data) can lead to serious exploits including remote code execution.
The OData adapter converts JSON payload into an object representation. Here it follows a hardened deserialization process where the deserializer capabilities (for example, no default types in Jackson) are restricted to a minimum.
A strong input validation based on EDMX model is done as well.
Moreover, deserialization errors terminate the request and are tracked in the application log.


#### General Recommendations Against Injections { #general-injection-attacks }


In general, to achieve perfect injection resistance, applications should have input validation, output validation, and a proper Content-Security-Policy in place.

- CAP provides built-in support for **input validation**.
Developers can use the [`@assert`](../providing-services#input-validation) annotation to define field-specific input checks.

  ::: warning
  Applications need to validate or sanitize all input variables according to the business context.
  :::

- With respect to **output encoding**, CAP OData adapters have proper URI encoding for all resource locations in place.
Moreover, OData validates the JSON response according to the given EDMX schema.
In addition, client-side protection is given by [SAPUI5](https://pages.community.sap.com/topics/ui5) standard controls

- Applications should meet basic [Content Security Policy (CSP)](https://www.w3.org/TR/CSP2/) compliance rules to further limit the attack vector on client side.
CSP-compatible browsers only load resources from web locations that are listed in the allowlist defined by the server.
`Content-Security-Policy` header can be set as route-specific response header in the [Application Router](https://help.sap.com/docs/btp/sap-business-technology-platform/responseheaders).
SAPUI5 is [CSP-compliant](https://sapui5.hana.ondemand.com/sdk/#/topic/fe1a6dba940e479fb7c3bc753f92b28c.html) as well.

  ::: warning
  Applications have to **configure Content Security Policy** to meet basic compliance.
  :::

### Service Misuse Attacks { #misues-attacks }


- [Server Side Request Forgery (SSRF)](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery) abuses server functionality to read or update resources from a secondary system.
CAP microservices are protected from this kind of attack if they use the [CAP standard mechanisms](#authenticate-remote) for service to service communication.

- [Cross-Site Request Forgery (CSRF)](https://owasp.org/www-community/attacks/csrf) attacks make end users executing unwanted actions on the server while having established a valid web session.
By default, the Application Router, which manages the session with the client, enforces a CSRF token protection (on basis of `x-csrf-token` headers).
Hence, CAP services don't have to deal with CSRF protection as long as they don't maintain sessions with the client.
SAPUI5 supports CSRF tokens on client side out of the box.

- [Clickjacking](https://owasp.org/www-community/attacks/Clickjacking) is an attack on client side where end users are tricked to open foreign pages.
SAPUI5 provides [protection mechanisms](https://sapui5.hana.ondemand.com/sdk/#/topic/62d9c4d8f5ad49aa914624af9551beb7.html) against this kind of attack.

  ::: warning
  To protect SAPUI5 applications against clickjacking, configure `frame options`.
  :::

### Denial-of-Service Attacks { #dos-attacks }


[Denial-of-service (DoS)](https://owasp.org/www-community/attacks/Denial_of_Service) attacks attempt to reduce service availability for legitimate users.
This can happen by erroneous server behavior upon a single large or a few specially crafted malicious requests that bind an excessive amount of shared OS resources such as CPU, memory, or network connections.

Since OS resource allocations are distributed over the entire request, DoS-prevention needs to be addressed in all different layers of the runtime stack:

#### HTTP Server and CAP Protocol Adapter

The used web server frameworks such as [Spring/Tomcat](https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server) or [Express](https://expressjs.com/) start with reasonable default limits, for example:
- Maximum size of the HTTP request header.
- Maximum size of the HTTP request body.
- Maximum queue length for incoming connection requests
- Maximum number of connections that the server accepts and processes at any given time.
- Connection timeout.
Additional size limits and timeouts (request timeout) are established by the reverse proxy components, API Gateway and Application Router.

::: tip
If you want to apply an application-specific sizing, consult the corresponding framework documentation.

See section [Maximum Request Body Size](../../node.js/cds-server#maximum-request-body-size) to find out how to restrict incoming requests to a CAP Node.js application depending on the body size.
:::

Moreover, CAP adapters automatically introduce query results pagination in order to limit memory peaks (customize with [`@cds.query.limit`](../providing-services#annotation-cds-query-limit)).
The total number of request of OData batches can be limited by application configuration.

<div class="impl java">

Settings <Config java>cds.odataV4.batch.maxRequests</Config> resp. <Config java>cds.odataV2.batch.maxRequests</Config> specify the corresponding limits.

</div>

::: warning
❗ CAP applications have to limit the amount of `$expands` per request in a custom handler.
Also the maximum amount of requests per `$batch` request need to be configured as follows:
- Node.js: <Config>cds.odata.batch_limit = \<max_requests\></Config>
- Java: <Config java>cds.odataV4.batch.maxRequests = \<max_requests\></Config>
:::

::: tip
Design your CDS services exposed to web adapters on need-to-know basis. Be especially careful when exposing associations.
:::

#### CAP Service Runtime

Open transactions are expensive as they bind many resources such as a database connection as well as memory buffers.
To minimize the amount of time a transaction must be kept open, the CAP runtime offers an [Outbox Service](../../java/outbox) that allows to schedule asynchronous remote calls in the business transaction.
Hence, the request time to process a business query, which requires a remote call (such as to an audit log server or messaging broker), is minimized and independent from the response time of the remote service.

::: tip
Avoid synchronous requests to remote systems during a transaction.
:::

[See why CPU time is fairly distributed among business requests](#limiting-resource-consumption){.learn-more}


#### Database

As already outlined, database connections are a expensive resource.
To limit overall usage, by default, the CAP runtime creates connection pools per subscriber tenant.
Similarly, the DB driver settings such as SQL query timeout and buffer size have reasonable values.

::: tip
<div class="impl java">

In case the default setting doesn't fit, <a href="../../java/multitenancy#db-connection-pooling">connection pool properties</a> and <a href="../../java/cqn-services/persistence-services#datasource-configuration">driver settings</a> can be customized, respectively.

</div>

<div class="impl node">

In case the default setting doesn't fit, <a href="../../node.js/databases#pool">connection pool properties</a> and driver settings can be customized, respectively.


</div>
:::

::: warning
❗ Applications need to establish an adequate [Workload Management](https://help.sap.com/docs/HANA_CLOUD_DATABASE/f9c5015e72e04fffa14d7d4f7267d897/30f2e9cb92aa4f358dda4ac58e062d83.html) that controls DB resource usage.
:::


#### Supplementary Measures

As outlined before, a well-sized microservice instance doesn't help to protect from service downtimes when excessive workload initiated by an attacker exceeds the available capacity.
[Rate limiting](https://help.sap.com/docs/btp/developing-resilient-apps-on-sap-btp/rate-limiting-c56d72711eec41118f243054f2e92f94) is a possible counter measure to restrict the frequency of calls of a client.

::: warning
❗ Applications need to establish an adequate **rate limiting** strategy.
:::

There's also the possibility to introduce request filtering and rate limiting on platform level via [Route Service](https://docs.cloudfoundry.org/services/route-services.html).
It has the advantage that the requests can be controlled centrally before touching application service instances.

In addition, the number of instances need to be **scaled horizontally** according to current load requirements.
This can be achieved automatically by consuming [Application Autoscaler](https://help.sap.com/docs/Application_Autoscaler).


### Additional Protection Mechanisms { #additional-attacks }


There are additional attack vectors to consider. For instance, naive URL handling in the server endpoints frequently introduces security gaps.
Luckily, CAP applications don't have to implement HTTP/URL processing on their own as CAP offers sophisticated [protocol adapters](../../about/features#consuming-services) such as OData V2/V4 that have the necessary security validations in place.
The adapters also transform the HTTP requests into a corresponding CQN statement.
Access control is performed on basis of CQN level according to the CDS model and hence HTTP Verb Tampering attacks are avoided. Also HTTP method override, using `X-Http-Method-Override` or `X-Http-Method` header, is not accepted by the runtime.

The OData protocol allows to encode field values in query parameters of the request URL or in the response headers. This is, for example, used to specify:
- [Pagination (implicit sort order)](../providing-services#pagination-sorting)
- [Searching Data](../providing-services#searching-data)
- Filtering

::: warning
Applications need to ensure by means of CDS modeling that fields reflecting sensitive data are excluded and don't appear in URLs.
:::

::: tip
It's recommended to serve all application endpoints via CAP adapters.
Securing custom endpoints is left to the application.
:::

In addition, CAP runs on a virtual machine with a managed heap that protects from common memory corruption vulnerabilities such as buffer overflow or range overflows.

CAP also brings some tools to effectively reduce the attack vector of race condition vulnerabilities.
These might be exposed when the state of resources can be manipulated concurrently and a consumer faces an unexpected state.
CAP provides basic means of [concurrency control](../providing-services#concurrency-control) on different layers, for example [ETags](../providing-services#etag) and [pessimistic locks](../providing-services#select-for-update). Moreover, Messages received from the [message queue](../messaging/) are always in order.

::: tip
Applications have to ensure a consistent data processing taking concurrency into account.
:::


<div id="security-secure-storage" />
<Fragment target="#security-secure-storage">

## Secure Storage <Internal />{ #secure-storage }


Business data stored permanently requires special protection from unauthorized access.
CAP offers first-class citizen integration with [SAP HANA Cloud](https://help.sap.com/docs/HANA_CLOUD) that provides [separation](#storage-separation) and [encryption](#storage-encryption) of tenant data.

::: tip
CAP applications built on other DB systems such as Postgres need to provide a custom integration for security features.
:::

### Separation of Tenant Data { #storage-separation }

A prerequisite to a tenant-specific encryption is that the business data of subscriber tenants as well as the provider tenant is strictly separated.
CAP leverages [HDI containers](https://help.sap.com/docs/HANA_CLOUD_DATABASE/c2b99f19e9264c4d9ae9221b22f6f589/ebf0aa26958443f58f86b862056862d4.html) to provide a [strong data isolation](#isolated-persistent-data) out of the box.

During the tenant onboarding process, CAP delegates HDI container creation to Service Manager:

![This screenshot is explained in the accompanying text.](assets/cap-hana-secure-storage.png)

By default, HDI containers are strictly isolated at the database level and don't allow cross-container access.

::: tip
Applications can also create HDI containers at deployment time that are suitable for the provider tenant.
:::


### Encryption of Tenant Data { #storage-encryption }


SAP HANA Cloud offers strong server-side storage encryption that’s transparent for applications.
This holds for all business data permanently stored to the file system, including redo-log entries.

An SAP HANA Cloud service instance, which isn't MT-enabled per default, uses a common encryption key for all DB artifacts.
In contrast, a multitenancy-enabled SAP HANA Cloud instance](https://help.sap.com/docs/hana-cloud/sap-hana-cloud-multitenancy-guide-internal/sap-hana-cloud-multitenancy-guide-internal?state=DRAFT) allows encryption of artifacts (in particular HDI containers) with **dedicated** or even **managed** keys:

!["This screenshot is explained in the accompanying text."](./assets/hana-keys.png)

In `Customer-Specific Encryption Key (CSEK)` mode, the tenant-specific key is created by SAP HANA,
whereas in `Customer-Controlled Encryption Key (CCEK)` mode the customer (that is, SaaS subscriber) defines and controls the key in [SAP Data Custodian](https://help.sap.com/docs/SAP_DATA_CUSTODIAN).

Customer-specific keys need to be explicitly activated in the application configuration.

<div class="impl java">

Application property <Config java>cds.multitenancy.datasource.hanaEncryptionMode: AUTO_DETECT</Config> supports all encryption modes as described in the SAP HANA Cloud [documentation](https://help.sap.com/docs/hana-cloud/sap-hana-cloud-multitenancy-guide-internal/create-tenant?state=DRAFT).

</div>

<div class="impl node">

The cds configuration needs to contain the parameters as described in the SAP HANA Cloud [documentation](https://help.sap.com/docs/hana-cloud/sap-hana-cloud-multitenancy-guide-internal/create-tenant?state=DRAFT) in the Deployment Service configuration of the MTX sidecar.

::: code-group
```json [mtx/sidecar/package.json]
"requires": {
  ...
  "cds.xt.DeploymentService": {
    "hdi": {
      "create": {
        "dataEncryption": {
          "mode": "AUTO_DETECT"
        },
        "enableTenant": true
      }
    }
  }
}
```
</div>

:::
::: info AUTO_DETECT only with CCEK
Not all encryption modes are supported on all BTP landscapes. CCEK (Customer controlled encryption keys) are only supported in [certain landscapes](https://wiki.one.int.sap/wiki/display/Custodian/Deployment+Plan) and the AUTO_DETECT mode only works on these landscapes. Use DEDICATED_KEY mode on other landscapes, where only CSEK (Customer specific encryption keys) are supported.

::: tip Migration of existing containers
Currently, Customer Encryption Key mode is only activated for new HDI containers created for business tenants.
We recommend the community-provided [MTX Tool](https://github.com/cap-js-community/mtx-tool/) to handle the migration for all HDI containers. Use it as follows:

```sh
npx @cap-js-community/mtx-tool --hdi-enable-native
```

Alternatively, you can migrate existing containers [manually](https://help.sap.com/docs/hana-cloud/sap-hana-cloud-multitenancy-guide-internal/migrate-hdi-container-or-schema-to-tenant-cli?state=DRAFT), or using [SAP Automation Pilot](https://help.sap.com/docs/automation-pilot/automation-pilot/what-is-sap-automation-pilot?version=Cloud) along with a [migration script](https://github.tools.sap/sl-autopilot/community-commands/tree/main/HANA%20Cloud%20Management/Native%20Tenant%20Migration).
:::

::: warning
Consider that the SAP HANA native tenants created to support subscriber-specific encryption (CSEK or CCEK) introduce additional sizing limits on the SAP HANA Cloud instance as pointed out in [Tenants Supported Per Database Instance](https://help.sap.com/docs/hana-cloud/sap-hana-cloud-multitenancy-guide-internal/tenants-supported-per-database-instance?state=DRAFT).
:::

</Fragment>



<div id="hana-cmk-guide" />

## Secure by Default and by Design { #secure-by-default }

### Secure Default Configuration { #secure-default }


Where possible, CAP default configuration matches the secure by default principle:

- There's no need to provide any password, credentials, or certificates to [protect communication](#secure-communications).

- A CAP application bound to an XSUAA instance authenticates all endpoints [by default](#secure-authentication).
Developers have to explicitly configure public endpoints if necessary.

- Isolated multitenancy is provided out of the box.

- Application logging has `INFO` level to avoid potential information disclosures.

- CAP also has first-class citizen support for [Fiori UI](../../advanced/fiori) framework that brings a lot secure by default features in the UI client.

Of course, several security aspects need application-specific configuration.
For instance, this is true for [authorizations](#secure-authorization) or application [sizing](#dos-attacks).

::: tip
It's recommended to ensure security settings by automated integration tests.
:::


### Fail Securely { #fail-securely }


CAP runtime differentiates several types of error situations during request processing:
- Exceptions because of invalid user input (HTTP 4xx).
- Exceptions because of unexpected server behaviour, for example, network issues.
- Unrecoverable errors due to serious issues in the VM (for example, lack of memory) or program flaws.

In general, **exceptions immediately stop the execution of the current request**.

In Java, the thrown [ServiceException](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/EventContext.html) is automatically scoped to the current request by means of thread isolation.
{ .java }

CAP Node.js adds an exception wrapper to ensure that only the failing request is affected by the exception.
{ .node }

Customers can react in dedicated exception handlers if necessary.

In contrast, **errors stop the overall microservice** to ensure that security measures aren't weakened.

::: tip
Align the exception handling in your custom coding with the provided exception handling capabilities of the CAP runtime.
:::


<div id="security-secure-auditlogging" />
<Fragment target="#security-secure-auditlogging">

## Secure Audit Logging <Internal /> { #secure-auditlogging }


Writing audit logs of security-related events is mandatory, for example, to monitor administrative activities or detect intrusion attempts.
All affected components and services of the stack, including the application itself, need to write tenant-specific audit log events to provide an overall picture.

### Auditlog Service

CAP provides a technical [AuditlogService](../../java/auditlog#auditlog-service) that defines a high-level API to emit security events.
It helps to decouple business logic from the concrete audit log implementation. By default, it writes audit log events to the console.

::: warning
Currently, CAP doesn't automatically trigger an audit log for security-related events.
Custom handlers need to call the Auditlog Service API explicitly.
:::

### Auditlog

CAP integrates with SAP BTP Audit Log Service (version 2) in a resilient way.
Tenant logs are automatically separated.

</Fragment>

<div id="secondary-file">guides/security/aspects.fragment.md</div>


# Data Protection & Privacy

This section describes how you can make your CAP application compliant with data protection and privacy requirements.

## General Statement { #dpp-statement }

Governments place legal requirements on industry to protect data and privacy.

::: tip
No guide, including this one, concerning CAP attempts to give any advice on whether any features and functions are the best method to support company-, industry-, region-, or country-specific requirements. Furthermore, the information provided in this note does not give any advice or recommendations with regards to additional features that might be required in a particular environment. Decisions related to data protection must be made on a case-by-case basis, under consideration of the given system landscape and the applicable legal requirements.
:::

For general information about data protection and privacy (DPP) on SAP BTP, see the SAP BTP documentation under [Data Protection and Privacy](https://help.sap.com/docs/btp/sap-business-technology-platform/data-protection-and-privacy).


## Data Protection & Privacy in CAP { #dpp-cap }

CAP is a framework that provides modeling and runtime features to enable customers to build business applications on top.
As a framework, in general, CAP doesn't store or manage any personal data on its own with some exceptions:

- Application logging on detailed level written by CAP runtime might contain personal data such as user names and IP addresses. The logs are mandatory to operate the system.
Connect an adequate logging service to meet compliance requirements such as [SAP Application Logging Service](https://help.sap.com/docs/application-logging-service/sap-application-logging-service/sap-application-logging-service-for-cloud-foundry-environment).

- A draft-enabled service `Foo` has an entity `Foo.DraftAdministrativeData` with fields `CreatedByUser`, `InProcessByUser` and `LastChangedByUser` containing personal data for all draft entity instances in edit mode.

- Messages temporarily written to transaction outbox might contain personal data. The entries are mandatory to operate the system.
If necessary, applications can process these messages by standard CAP functionality (CDS model `@sap/cds/srv/outbox`).

- Be aware that personal data might be added automatically when using the [managed](../domain-modeling#managed-data) aspect.

Dependent on the business scenario, custom CDS models served by CAP runtime will most likely contain personal data that is also stored in a backing service.

CAP provides a [rich set of tools](aspects) to protect the application from unauthorized access to business data, including personal data.
Furthermore, it helps applications to provide [higher-level DPP-related functions](#dpp-support) such as data retrieval.

::: warning
❗ **Applications are responsible to implement compliance requirements with regards to data protection and privacy according to their specific use case**.
:::

Also refer to related guides of most important platform services:
[SAP Cloud Identity Services - Configuring Privacy Policies](https://help.sap.com/docs/IDENTITY_AUTHENTICATION/6d6d63354d1242d185ab4830fc04feb1/ed48466d770f4519aa23bba754851fbd.html){.learn-more}
[SAP HANA Cloud - Data Protection and Privacy](https://help.sap.com/docs/HANA_CLOUD_DATABASE/c82f8d6a84c147f8b78bf6416dae7290/ad9588189e844092910103f2f7b1c968.html){.learn-more}


## Data Protection & Privacy Supported by CAP { #dpp-support }


CAP provides several [features](../data-privacy/) to help applications meet DPP-requirements:

- The [Personal Data Management (PDM)](../data-privacy/pdm) integration has a configurable **retrieval function**, which can be used to inform data subjects about personal data stored related to them.
- CAP also provides a *fully model-driven* approach to track **changes in personal data** or **read access to sensitive personal data** in the audit log.
Having [declared personal data](../data-privacy/annotations) in your model, CAP automatically triggers corresponding [audit log events](../data-privacy/audit-logging).

::: warning
❗ So far, applications have to integrate [SAP Data Retention Manager](https://help.sap.com/docs/DATA_RETENTION_MANAGER) to implement an adequate **erasure function** for personal data out of retention period.
CAP will cover an out-of-the-box integration in the future.
:::






# Product Standard Security Compliance with CAP <Internal /> { #product-standard-security }

This section describes which requirements of the <a href="https://wiki.one.int.sap/wiki/pages/viewpage.action?pageId=4982897175" target="_blank" rel="noopener noreferrer">Product Standard Security</a> can be fulfilled with low or even zero effort by applications built on CAP.

### Legend

CAP has a lot in store to help applications to fulfill [SAP Product Standard Security](https://wiki.one.int.sap/wiki/pages/viewpage.action?pageId=3139383825):

| Tag   | Explanation                                         |
|-------|:----------------------------------------------------|
| <X/>  | Inherited by CAP                                    |
| <Xc/> | Inherited by CAP + application configuration/coding |
| <Na/> | Not inherited by CAP, but platform support          |

::: warning
❗ Applications benefit from CAP security capabilities only if they follow CAP features, APIs and recommendations (follow the corresponding links).
**Ensure that custom coding or configuration does not invalidate CAP security mechanisms.**
:::

Following table gives you an overview about the individual requirements of the standard sorted by the main categories:

### Secure Against Untrusted Input

| Requirement                                                                                                                                                                      |              Inherited by CAP?              |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:-------------------------------------------:|
| [SEC-100 - Protect against Injection attacks](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-100)                                                                               |    [<Xc/>](./aspects#injection-attacks)     |
| [SEC-235 - No memory corruption vulnerabilities](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-235)                                                                            |    [<X/>](./aspects#additional-attacks)     |
| [SEC-228 - Protect upload, download, and display functions of untrusted files against MIME-type sniffing and virus attacks](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-228) | [<Na/>](./aspects#common-injection-attacks) |
| [SEC-237 - Protect against Denial-of-Service attacks](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-237)                                                                       |       [<Xc/>](./aspects#dos-attacks)        |
| [SEC-238 - Protect against Verb Tampering and handle HTTP methods securely](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-238)                                                 |    [<X/>](./aspects#additional-attacks)     |
| [SEC-264 - No Clickjacking vulnerabilities](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-264)                                                                                 |      [<Xc/>](./aspects#misues-attacks)      |
| [SEC-278 - Handle URLs securely](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-278)                                                                                            |    [<X/>](./aspects#additional-attacks)     |
| [SEC-282 - Protect against Race Condition attacks](https://wiki.wdf.sap.corp/wiki/display/PSSEC/SEC-282)                                                                         |    [<Xc/>](./aspects#additional-attacks)    |
| [SEC-283 - Protect against Insecure Deserialization](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-283)                                                                        | [<X/>](./aspects#common-injection-attacks)  |
| [SEC-375 - Protect against Server Side Request Forgery (SSRF)](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-375)                                                              |      [<X/>](./aspects#misues-attacks)       |

### Secure Communications

| Requirement                                                                                                          |          Inherited by CAP?           |
|----------------------------------------------------------------------------------------------------------------------|:------------------------------------:|
| [SEC-218 - Provide and use encrypted communication connections](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-218) | [<X/>](./aspects#encrypted-channels) |
| [SEC-223 - No Cross-Site Request Forgery vulnerabilities](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-223)       |   [<X/>](./aspects#misues-attacks)   |
| [SEC-331- Apply filters on internet communication](https://wiki.wdf.sap.corp/wiki/display/PSSEC/SEC-331)             |     [<Na/>](./aspects#filtering)     |

### Secure Identity Management and Authentication

| Requirement                                                                                                                                          |            Inherited by CAP?            |
|------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------:|
| [SEC-230 - Provide standard identity management, authentication, and single sign-on mechanisms](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-230) | [<X/>](./aspects#authenticate-requests) |
| [SEC-231 - Provide secure User ID / Password authentication](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-231)                                    | [<X/>](./aspects#authenticate-requests) |
| [SEC-232 - Provide secure X.509 certificate authentication](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-232)                                     | [<X/>](./aspects#authenticate-requests) |
| [SEC-220 - Protect security sensitive cookies](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-220)                                                  |       [<X/>](./aspects#sessions)        |
| [SEC-221 - Manage security sessions securely](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-221)                                                   |       [<X/>](./aspects#sessions)        |
| [SEC-309 - Manage keys, tokens, and passwords securely](https://wiki.wdf.sap.corp/wiki/display/PSSEC/SEC-309)                                        |       [<Na/>](./aspects#secrets)        |
| [SEC-374 - Communicate reliably and securely over the network](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-374)                                  |  [<X/>](./aspects#authenticate-remote)  |

### Secure Authorizations

| Requirement                                                                                                                                       |            Inherited by CAP?            |
|---------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------:|
| [SEC-248 - Enforce a secure authorization concept](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-248)                                           | [<Xc/>](./aspects#secure-authorization) |
| [SEC-376 - Ensure server side authorization checks for each request to non-public resources](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-376) |    [<Xc/>](./aspects#business-authz)    |
| [SEC-250 - Provide administration of authorizations based on platform tools](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-250)                 |    [<Xc/>](./aspects#platform-authz)    |
| [SEC 236 - No information disclosure to unauthorized receivers](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-236)                              |     [<X/>](./aspects#cap-endpoints)     |

### Secure Storage

| Requirement                                                                                                                 |           Inherited by CAP?           |
|-----------------------------------------------------------------------------------------------------------------------------|:-------------------------------------:|
| [SEC-272 - Encrypt sensitive data when stored persistently](https://wiki.wdf.sap.corp/wiki/display/PSSEC/SEC-272)           | [<Xc/>](./aspects#storage-encryption) |
| [SEC-373 - Support strong data isolation with customer-specific keys](https://wiki.wdf.sap.corp/wiki/display/PSSEC/SEC-373) |   [<X/>](./aspects#secure-storage)    |


### Secure Multitenancy

| Requirement                                                                                                      |           Inherited by CAP?           |
|------------------------------------------------------------------------------------------------------------------|:-------------------------------------:|
| [SEC-378 - Implement multi-tenancy support in a secure way](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-378) | [<X/>](./aspects#secure-multitenancy) |

### Secure Audit Logging

| Requirement                                                                                   |                 Inherited by CAP?                  |
|-----------------------------------------------------------------------------------------------|:--------------------------------------------------:|
| [SEC-215 - Log security relevant events](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-215) | [<Xc/>](./aspects#secure-auditlogging)<sup>1</sup> |

> <sup>1</sup> planned

### Secure by Default & by Design

| Requirement                                                                                                  |         Inherited by CAP?         |
|--------------------------------------------------------------------------------------------------------------|:---------------------------------:|
| [SEC-239 - Fail securely](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-239)                               |  [<X/>](./aspects#fail-securely)   |
| [SEC-244 - Deliver with a secure default configuration](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-244) | [<Xc/>](./aspects#secure-default) |
| [SEC-281 - Make use of secure UI frameworks](https://wiki.one.int.sap/wiki/display/PSSEC/SEC-281)            | [<X/>](./aspects#secure-default)  |

### Data Protection & Privacy

| Requirement                                                                                                                             |                     Inherited by CAP?                      |
|-----------------------------------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------:|
| [DPP-254 - Log read access to sensitive personal data](https://wiki.one.int.sap/wiki/display/PSSEC/DPP-254)                             |       [<Xc/>](./data-protection-privacy#dpp-support)       |
| [DPP-255 - Provide a retrieval function](https://wiki.one.int.sap/wiki/display/PSSEC/DPP-255)                                           |       [<Xc/>](./data-protection-privacy#dpp-support)       |
| [DPP-256 - Erase personal data when all applicable retention periods have expired](https://wiki.one.int.sap/wiki/display/PSSEC/DPP-256) | [<Na/>](./data-protection-privacy#dpp-support)<sup>1</sup> |
| [DPP-265 - Log changes to personal data](https://wiki.one.int.sap/wiki/display/PSSEC/DPP-265)                                           |       [<Xc/>](./data-protection-privacy#dpp-support)       |

> <sup>1</sup> in progress





# Managing Data Privacy

CAP helps application projects to comply with data privacy regulations using SAP Business Technology Platform (BTP) services. Find a step-by-step guide to these hereinafter...

::: warning
SAP does not give any advice on whether the features and functions provided to facilitate meeting data privacy obligations are the best method to support company, industry, regional, or country/region-specific requirements. Furthermore, this information should not be taken as advice or a recommendation regarding additional features that would be required in specific IT environments. Decisions related to data protection must be made on a case-by-case basis, considering the given system landscape and the applicable legal requirements.
:::

## Introduction to Data Privacy


Data protection is associated with numerous legal requirements and privacy concerns, such as the EU's [General Data Protection Regulation](https://en.wikipedia.org/wiki/General_Data_Protection_Regulation). In addition to compliance with general data protection and privacy acts regarding [personal data](https://en.wikipedia.org/wiki/Personal_data), you need to consider compliance with industry-specific legislation in different countries/regions.

CAP supports applications in their obligations to comply to data privacy regulations, by automating tedious tasks as much as possible based on annotated models. That is, CAP provides easy ways to designate personal data, as well as out-of-the-box integration with SAP BTP services, which enable you to fulfill specific data privacy requirements in your application. This relieves application developers of these tedious tasks and related efforts.

![Shows with which solutions CAP annotations can be used out of the box, as described in the following table.](./assets/Data-Privacy.drawio.svg){}





### In a Nutshell

The most essential requests you have to answer are those in the following table. The table also shows the basis of the requirement and the corresponding discipline for the request:

| Question / Request                          | Obligation                                      | Solution                            |
| ------------------------------------------- | ----------------------------------------------- | ----------------------------------- |
| *What data about me do you have stored?*    | [Right of access](#right-of-access)             | [Personal Data Management](pdm.md)  |
| *Please delete all personal data about me!* | [Right to be forgotten](#right-to-be-forgotten) | [Data Retention Management](drm.md) |
| *When was personal data stored/changed?*    | [Transparency](#transparency)                   | [Audit Logging](audit-logging.md)   |



<span id="intro" />
<Fragment target="#intro">

### SAP Product Standards

The data privacy regulations and tasks described above relate to the following SAP Product Standards:


- [SEC-265](https://wiki.one.int.sap/wiki/x/nICvTw): **Audit-log** changes to personal data.
- [SEC-254](https://wiki.one.int.sap/wiki/x/tqHgMg): **Audit-log** read access to sensitive personal data.
- [SEC-255](https://wiki.one.int.sap/wiki/x/mwzGNQ): Retrieve data to inform data subjects about **personal data** stored about them.
- [SEC-256](https://wiki.one.int.sap/wiki/x/8gnqMg): Erase personal data when all applicable **retention** periods have expired.

</Fragment>





## Annotating Personal Data

The first and frequently only task to do as an application developer is to identify entities and elements (potentially) holding personal data using `@PersonalData` annotations. These are used to automate CAP-facilitated audit logging, personal data management, and data retention management as much as possible.

[Learn more in the *Annotating Personal Data* chapter](annotations) {.learn-more}



## Automatic Audit Logging {#transparency}

The **Transparancy** obligation, requests to be able to report with whom data stored about an individual is shared and where that came from (for example, [EU GDPR Article 15(1)(c,g)](https://eur-lex.europa.eu/legal-content/EN/TXT/HTML/?uri=CELEX:02016R0679-20160504&qid=1692819634946#tocId22)).

The [SAP Audit Log Service](https://help.sap.com/docs/btp/sap-business-technology-platform/audit-logging-in-cloud-foundry-environment) stores all audit logs for a tenant in a common, compliant data store and allows auditors to search through and retrieve the respective logs when necessary.

[Learn more in the *Audit Logging* guide](audit-logging) {.learn-more}



## Personal Data Management { #right-of-access }

The [**Right of Access** to personal data](https://en.wikipedia.org/wiki/Right_of_access_to_personal_data) "gives people the right to access their personal data and information about how this personal data is being processed".

The [SAP Personal Data Manager](https://help.sap.com/docs/personal-data-manager) allows you to inform individuals about the data you have stored regarding them.

[Learn more in the *Personal Data Management* guide](pdm) {.learn-more}



## Data Retention Management { #right-to-be-forgotten }

The [**Right to be Forgotten**](https://en.wikipedia.org/wiki/Right_to_be_forgotten) gives people "the right to request erasure of personal data related to them on any one of a number of grounds [...]".

The [SAP Data Retention Manager](https://help.sap.com/docs/data-retention-manager) allows you to manage retention and residence rules to block or destroy personal data.



<div id="secondary-file">guides/data-privacy/index.fragment.md</div>







# Annotating Personal Data

In order to automate audit logging, personal data management, and data retention management as much as possible, the first and frequently only task to do as an application developer is to identify entities and elements (potentially) holding personal data using `@PersonalData` annotations.

## Reference App Sample { #annotated-model }

In the remainder of this guide, we use the [Incidents Management reference sample app](https://github.com/cap-js/incidents-app) as the base to add data privacy and audit logging to.

![Shows the connections between the entities in the sample app.](./assets/Incidents-App.drawio.svg){}

So, let's annotate the data model to identify personal data.
In essence, in all our entities we search for elements which carry personal data, such as person names, birth dates, etc., and tag them accordingly.
All found entities are classified as either *Data Subjects*, *Subject Details* or *Related Data Objects*.

Following the [best practice of separation of concerns](../domain-modeling#separation-of-concerns), we annotate our domain model in a separate file *srv/data-privacy.cds*, which we add to our project and fill it with the following content:

> For the time beeing also replace the data in _data/sap.capire.incidents-Customers.csv_.

::: code-group

```cds [db/data-privacy.cds]
using { sap.capire.incidents as my } from '../db/schema';

extend my.Customers with {
    dateOfBirth : Date;
};

annotate my.Customers with @PersonalData : {
  DataSubjectRole : 'Customer',
  EntitySemantics : 'DataSubject'
} {
  ID           @PersonalData.FieldSemantics: 'DataSubjectID';
  firstName    @PersonalData.IsPotentiallyPersonal;
  lastName     @PersonalData.IsPotentiallyPersonal;
  email        @PersonalData.IsPotentiallyPersonal;
  phone        @PersonalData.IsPotentiallyPersonal;
  dateOfBirth  @PersonalData.IsPotentiallyPersonal;
  creditCardNo @PersonalData.IsPotentiallySensitive;
};

annotate my.Addresses with @PersonalData: {
  EntitySemantics : 'DataSubjectDetails'
} {
  customer      @PersonalData.FieldSemantics: 'DataSubjectID';
  city          @PersonalData.IsPotentiallyPersonal;
  postCode      @PersonalData.IsPotentiallyPersonal;
  streetAddress @PersonalData.IsPotentiallyPersonal;
};

annotate my.Incidents with @PersonalData : {
  EntitySemantics : 'Other'
} {
  customer @PersonalData.FieldSemantics: 'DataSubjectID';
};
```

```csv [data/sap.capire.incidents-Customers.csv]
ID,firstName,lastName,email,phone,dateOfBirth
1004155,Daniel,Watts,daniel.watts@demo.com,+44-555-123,1996-01-01
1004161,Stormy,Weathers,stormy.weathers@demo.com,,1981-01-01
1004100,Sunny,Sunshine,sunny.sunshine@demo.com,+01-555-789,1965-01-01
```
:::



## @PersonalData...

Let's break down the annotations to identify personal data, shown in the sample above. These annotations fall into three categories:

- **Entity-level annotations** signify relevant entities as *Data Subjects*, *Data Subject Details*, or *Related Data Objects* in data privacy terms, as depicted in the graphic below.
- **Key-level annotations** signify object primary keys, as well as references to data subjects (which have to be present on each object).
- **Field-level annotations** identify elements containing personal data.

Learn more about these annotations in the [@PersonalData OData vocabulary](https://github.com/SAP/odata-vocabularies/blob/main/vocabularies/PersonalData.md). {.learn-more}

### .EntitySemantics {.annotation}

The entity-level annotation `@PersonalData.EntitySemantics` signifies relevant entities as *Data Subject*, *Data Subject Details*, or *Other* in data privacy terms, as depicted in the following graphic.

![Shows the connections between the entities in the sample app. In addition via color coding it makes clear how entities are annotated: customers are data subject, addresses are data subject details and incidents are other.](./assets/Data-Subjects.drawio.svg){}

The following table provides some further details.

Annotation            | Description
--------------------- | -------------
`DataSubject`         | The entities of this set describe a data subject (an identified or identifiable natural person), for example, Customer or Vendor.
`DataSubjectDetails`  | The entities of this set contain details of a data subject (an identified or identifiable natural person) but do not by themselves identify/describe a data subject, for example, Addresses.
`Other`               | Entities containing personal data or references to data subjects, but not representing data subjects or data subject details by themselves. For example, customer quote, customer order, or purchase order with involved business partners. These entities are relevant for audit logging. There are no restrictions on their structure. The properties should be annotated suitably with `FieldSemantics`.

Hence, we annotate our model as follows:

```cds
annotate my.Customers with @PersonalData: {
  EntitySemantics: 'DataSubject' // [!code focus]
};

annotate my.Addresses with @PersonalData: {
  EntitySemantics: 'DataSubjectDetails' // [!code focus]
};

annotate my.Incidents with @PersonalData: {
  EntitySemantics: 'Other' // [!code focus]
};
```



### .DataSubjectRole {.annotation}

Can be added to `@PersonalData.EntitySemantics: 'DataSubject'`. It's a user-chosen string specifying the role name to use. If omitted, the default is the entity name. Use case is similar to providing user-friendly labels for the UI, although in this case there's no i18n.

In our model, we can add the `DataSubjectRole` as follows:

```cds
annotate my.Customers with @PersonalData: {
  EntitySemantics: 'DataSubject',
  DataSubjectRole: 'Customer' // [!code focus]
};
```



### .FieldSemantics: DataSubjectID {.annotation}

Use this annotation to identify data subject's unique key, or a reference to it. References are commonly associations or foreign keys in subject details entities, or related ones, referring to a subject entity.

- Each `@PersonalData` entity needs to identify a  the `DataSubjectID` element.
- For entities with `DataSubject` semantics, this is typically the primary key.
- For entities with `DataSubjectDetails` or `Other`  semantics, this is usually an association to the data subject.

Hence, we annotate our model as follows:

```cds
annotate my.Customers with {
  ID @PersonalData.FieldSemantics: 'DataSubjectID' // [!code focus]
};

annotate my.Addresses with {
  customer @PersonalData.FieldSemantics: 'DataSubjectID' // [!code focus]
};

annotate my.Incidents with {
  customer @PersonalData.FieldSemantics: 'DataSubjectID' // [!code focus]
};
```



### .IsPotentiallyPersonal {.annotation}

`@PersonalData.IsPotentiallyPersonal` tags which fields are personal and, for example, require audit logs if modified.

```cds
annotate my.Customers with {
  firstName @PersonalData.IsPotentiallyPersonal; // [!code focus]
  lastName  @PersonalData.IsPotentiallyPersonal; // [!code focus]
  email     @PersonalData.IsPotentiallyPersonal; // [!code focus]
  phone     @PersonalData.IsPotentiallyPersonal; // [!code focus]
};
```



### .IsPotentiallySensitive {.annotation}

`@PersonalData.IsPotentiallySensitive` tags which fields are sensitive and, for example, require audit logs in case of access.

```cds
annotate my.Customers with {
  creditCardNo @PersonalData.IsPotentiallySensitive; // [!code focus]
};
```





## Next Steps...

Having annotated your data model with `@PersonalData` annotations, you can now go on to the respective tasks that leverage these annotations to automate as much as possible:

- [*Automated Audit Logging*](audit-logging)
- [*Personal Data Management*](pdm)
- [*Data Retention Management*](drm)





# Audit Logging



The  [`@cap-js/audit-logging`](https://www.npmjs.com/package/@cap-js/audit-logging) plugin provides out-of-the box support for automatic audit logging of data privacy-related events, in particular changes to *personal data* and reads of *sensitive* data. Find here a step-by-step guide how to use it.

:::warning

_The following is mainly written from a Node.js perspective. For Java's perspective, please see [Java - Audit Logging](../../java/auditlog)._

:::



## Annotate Personal Data

First identify entities and elements (potentially) holding personal data using `@PersonalData` annotations, as explained in detail in the [*Annotating Personal Data* chapter](annotations) of these guides.

> We keep using the [Incidents Management reference sample app](https://github.com/cap-js/incidents-app).

## Add the Plugin { #setup }

To enable automatic audit logging simply add the  [`@cap-js/audit-logging`](https://www.npmjs.com/package/@cap-js/audit-logging) plugin package to your project like so:

```sh
npm add @cap-js/audit-logging
```

::: details Behind the Scenes…

[CDS Plugin Packages](../../node.js/cds-plugins) are self-contained extensions. They not only include the relevant code but also bring their own default configuration. In our case, next to bringing the respective code, the plugin does the following:

1. Sets <Config>cds.requires.audit-log: true</Config>

2. Which in turn activates the effective `audit-log` configuration via **presets**:
    ```jsonc
    {
      "audit-log": {
        "handle": ["READ", "WRITE"],
        "outbox": true,
        "[development]": { "kind": "audit-log-to-console" },
        "[hybrid]": { "kind": "audit-log-to-restv2" },
        "[production]": { "kind": "audit-log-to-restv2" }
      },
      "kinds": {
        "audit-log-to-console": {
          "impl": "@cap-js/audit-logging/srv/log2console"
        },
        "audit-log-to-restv2": {
          "impl": "@cap-js/audit-logging/srv/log2restv2",
          "vcap": { "label": "auditlog" }
        }
      }
    }
    ```

**The individual configuration options are:**

- `impl` — the service implementation to use
- `outbox` — whether to use transactional outbox or not
- `handle` — which events (`READ` and/or `WRITE`) to intercept and generate log messages from

**The preset uses profile-specific configurations** for (hybrid) development and production. Use the `cds env` command to find out the effective configuration for your current environment:

::: code-group
```sh [w/o profile]
cds env requires.audit-log
```

```sh [production profile]
cds env requires.audit-log --profile production
```
:::







## Test-drive Locally

The previous step is all we need to do to automatically log personal data-related events. Let's see that in action…

1. **Start the server** as usual:

    ```sh
    cds watch
    ```

2. **Send an update** request that changes personal data:
    ::: code-group
    ```http [test/audit-logging.http]
    PATCH http://localhost:4004/admin/Customers(2b87f6ca-28a2-41d6-8c69-ccf16aa6389d) HTTP/1.1
    Authorization: Basic alice:in-wonderland
    Content-Type: application/json

    {
      "firstName": "Jane",
      "lastName": "Doe"
    }
    ```
    :::

    [Find more sample requests in the Incident Management sample.](https://github.com/cap-js/incidents-app/blob/attachments/test/audit-logging.http){.learn-more}

3. **See the audit logs** in the server's console output:

    ```js
    {
      data_subject: {
        id: { ID: '2b87f6ca-28a2-41d6-8c69-ccf16aa6389d' },
        role: 'Customer',
        type: 'AdminService.Customers'
      },
      object: {
        type: 'AdminService.Customers',
        id: { ID: '2b87f6ca-28a2-41d6-8c69-ccf16aa6389d' }
      },
      attributes: [
        { name: 'firstName', old: 'Sunny', new: 'Jane' },
        { name: 'lastName', old: 'Sunshine', new: 'Doe' }
      ],
      uuid: '5cddbc91-8edf-4ba2-989b-87869d94070d',
      tenant: 't1',
      user: 'alice',
      time: 2024-02-08T09:21:45.021Z
    }
    ```





## Use SAP Audit Log Service

While we simply dumped audit log messages to stdout in local development, we'll be using the SAP Audit Log Service on SAP BTP in production. Following is a brief description of the necessary steps for setting this up.
A more comprehensive guide, incl. tutorials, is currently under development.

### Setup Instance and Deploy App

<span id="audit-logging-in-saas" />
<Fragment target="#audit-logging-in-saas">

:::details **SAP-internal Developments, incl. SaaS Applications**

Here is what you need to do in order to integrate with SAP Audit Log Service as an _SAP-internal project_:

1. In your space, create a service instance of service _Audit Log Service_ (`auditlog`) __of plan `oauth2`__.
2. Add the service instance as _existing resource_ to your `mta.yml` and bind to your application in its _requires_ section. Existing resources are defined like this:
      ```yml
      resources:
      - name: my-auditlog-service
        type: org.cloudfoundry.existing-service
      ```

When providing an **SaaS application**, return the `xsappname` of the service instance's UAA instance (<Config>cds.requires.audit-log.credentials.uaa.xsappname</Config>) as a dependency of your SaaS application, see [SaaS Service Dependencies](../deployment/to-cf#add-multitenancy).
> If you miss doing this, audit logs that are emitted via the persistent outbox (the default in production as it provides the ultimate resilience) will be lost in nirvana, as the sending effort will end in an unrecoverable error. As with all dependencies: If you add them later on, you'll need to update all subscriptions.

:::

</Fragment>

For deployment in general, please follow the [deployment guide](../deployment/). Check the rest of this guide before actually triggering the deployment (that is, executing `cf deploy`).

Here is what you need to do additionally,  to integrate with SAP Audit Log Service:

1. In your space, create a service instance of the _SAP Audit Log Service_ (`auditlog`) service with plan `premium`.
2. Add the service instance as _existing resource_ to your `mta.yml` and bind it to your application in its _requires_ section. Existing resources are defined like this:
      ```yml
      resources:
      - name: my-auditlog-service
        type: org.cloudfoundry.existing-service
      ```

[Learn more about *Audit Log Write API for Customers*](https://help.sap.com/docs/btp/sap-business-technology-platform/audit-log-write-api-for-customers?version=Cloud){.learn-more}


### Accessing Audit Logs

There are two options to access audit logs:

1. Create an instance of service `auditlog-management` to retrieve audit logs via REST API, see [Audit Log Retrieval API Usage for the Cloud Foundry Environment](https://help.sap.com/docs/btp/sap-business-technology-platform/audit-log-retrieval-api-usage-for-subaccounts-in-cloud-foundry-environment).
2. Use the SAP Audit Log Viewer, see [Audit Log Viewer for the Cloud Foundry Environment](https://help.sap.com/docs/btp/sap-business-technology-platform/audit-log-viewer-for-cloud-foundry-environment).





## Generic Audit Logging

### Behind the Scenes...

For all [defined services](../providing-services#service-definitions), the generic audit logging implementation does the following:

- Intercept all write operations potentially involving personal data.
- Intercept all read operations potentially involving sensitive data.
- Determine the affected fields containing personal data, if any.
- Construct log messages, and send them to the connected audit log service.
- All emitted log messages are sent through the [transactional outbox](#transactional-outbox).
- Apply resiliency mechanisms like retry with exponential backoff, and more.



## Custom Audit Logging { #custom-audit-logging }

In addition to the generic audit logging provided out of the box, applications can also log custom events with custom data using the programmatic API.

Connecting to the service:

```js
const audit = await cds.connect.to('audit-log')
```

Sending log messages:

```js
await audit.log('Foo', { bar: 'baz' })
```

::: tip Audit Logging as Just Another CAP Service
The Audit Log Service API is implemented as a CAP service, with the service API defined in CDS as shown in the next section. In effect, the common patterns of [*CAP Service Consumption*](../using-services) apply, as well as all the usual benefits like *mocking*, *late-cut µ services*, *resilience* and *extensibility*.
:::



### Service Definition

Below is the complete reference modeling as contained in `@cap-js/audit-logging`. The individual operations and events are briefly discussed in the following sections.

The service definition declares the generic `log` operation, which is used for all kinds of events, as well as the common type `LogEntry`, which declares the common fields of all log messages. These fields are filled in automatically by the base service and any values provided by the caller are ignored.

Further, the service has pre-defined event payloads for the four event types:
1. _Log read access to sensitive personal data_
1. _Log changes to personal data_
1. _Security event log_
1. _Configuration change log_

These payloads are based on [SAP Audit Log Service's REST API](https://help.sap.com/docs/btp/sap-business-technology-platform/audit-log-write-api-for-customers), which maximizes performance by omitting any intermediate data structures.

```cds
namespace sap.auditlog;

service AuditLogService {

  action log(event : String, data : LogEntry);

  event SensitiveDataRead : LogEntry {
    data_subject : DataSubject;
    object       : DataObject;
    attributes   : many {
      name       : String;
    };
    attachments  : many {
      id         : String;
      name       : String;
    };
    channel      : String;
  };

  event PersonalDataModified : LogEntry {
    data_subject :      DataSubject;
    object       :      DataObject;
    attributes   : many Modification;
    success      :      Boolean default true;
  };

  event ConfigurationModified : LogEntry {
    object     :      DataObject;
    attributes : many Modification;
  };

  event SecurityEvent : LogEntry {
    data : {};
    ip   : String;
  };

}

/** Common fields, filled in automatically */
type LogEntry {
  uuid   : UUID;
  tenant : String;
  user   : String;
  time   : Timestamp;
}

type DataObject {
  type : String;
  id   : {};
}

type DataSubject : DataObject {
  role : String;
}

type Modification {
  name : String;
  old  : String;
  new  : String;
}
```





### Sensitive Data Read

```cds
event SensitiveDataRead : LogEntry {
  data_subject : DataSubject;
  object       : DataObject;
  attributes   : many {
    name       : String;
  };
  attachments  : many {
    id         : String;
    name       : String;
  };
  channel      : String;
}

type DataObject {
  type : String;
  id   : {};
}

type DataSubject : DataObject {
  role : String;
}
```

Send `SensitiveDataRead` event log messages like that:

```js
await audit.log ('SensitiveDataRead', {
  data_subject: {
    type: 'sap.capire.bookshop.Customers',
    id: { ID: '1923bd11-b1d6-47b6-a91b-732e755fa976' },
    role: 'Customer',
  },
  object: {
    type: 'sap.capire.bookshop.BillingData',
    id: { ID: '399a2704-3d2d-4fa1-9e7d-a4e45c67749b' }
  },
  attributes: [
    { name: 'creditCardNo' }
  ]
})
```


### Personal Data Modified

```cds
event PersonalDataModified : LogEntry {
  data_subject :      DataSubject;
  object       :      DataObject;
  attributes   : many Modification;
  success      :      Boolean default true;
}

type Modification {
  name : String;
  old  : String;
  new  : String;
}
```

Send `PersonalDataModified` event log messages like that:

```js
await audit.log ('PersonalDataModified', {
  data_subject: {
    type: 'sap.capire.bookshop.Customers',
    id: { ID: '1923bd11-b1d6-47b6-a91b-732e755fa976' },
    role: 'Customer',
  },
  object: {
    type: 'sap.capire.bookshop.Customers',
    id: { ID: '1923bd11-b1d6-47b6-a91b-732e755fa976' }
  },
  attributes: [
    { name: 'emailAddress', old: 'foo@example.com', new: 'bar@example.com' }
  ]
})
```


### Configuration Modified

```cds
event ConfigurationModified : LogEntry {
  object     :      DataObject;
  attributes : many Modification;
}
```

Send `ConfigurationModified` event log messages like that:

```js
await audit.log ('ConfigurationModified', {
  object: {
    type: 'sap.common.Currencies',
    id: { ID: 'f79ba248-c348-4962-9fef-680c3b88807c' }
  },
  attributes: [
    { name: 'symbol', old: 'EUR', new: '€' }
  ]
})
```


### Security Events

```cds
event SecurityEvent : LogEntry {
  data : {};
  ip   : String;
}
```

Send `SecurityEvent` log messages like that:

```js
await audit.log ('SecurityEvent', {
  data: {
    user: 'alice',
    action: 'Attempt to access restricted service "PDMService" with insufficient authority'
  },
  ip: '127.0.0.1'
})
```

> In the SAP Audit Log Service REST API, `data` is a String. For ease of use, the default implementation stringifies `data`, if it is provided as an object. [Custom implementations](#custom-implementation) should also handle both.



## Custom Implementation { #custom-implementation }

In addition, everybody could provide new implementations in the same way as we implement the mock variant:

```js
const { AuditLogService } = require('@cap-js/audit-logging')
class MyAuditLogService extends AuditLogService {
  async init() {
    this.on('*', function (req) { // [!code focus]
      const { event, data } = req
      console.log(`[my-audit-log] - ${event}:`, data)
    })
    return super.init()
  }
}
module.exports = MyAuditLogService
```

As always, custom implementations need to be configured in `cds.requires.<>.impl`:

```json
{
  "cds": {
    "requires": {
      "audit-log": {
        "impl": "lib/MyAuditLogService.js"
      }
    }
  }
}
```



## Transactional Outbox { #transactional-outbox }

By default, all log messages are sent through a transactional outbox. This means, when sent, log messages are first stored in a local outbox table, which acts like a queue for outbound messages. Only when requests are fully and successfully processed, these messages are forwarded to the audit log service.

![This graphic is explained in the accompanying text.](./assets/Transactional-Outbox.drawio.svg)

This provides an ultimate level of resiliency, plus additional benefits:

- **Audit log messages are guaranteed to be delivered** &mdash; even if the audit log service should be down for a longer time period.

- **Asynchronous delivery of log messages** &mdash; the main thread doesn't wait for requests being sent and successfully processed by the audit log service.

- **False log messages are avoided** &mdash;  messages are forwarded to the audit log service on successfully committed requests; and skipped in case of rollbacks.

This transparently applies to all implementations, even [custom implementations](#custom-implementation). You can opt out of this default by configuring <Config>cds.audit-log.[development].outbox = false</Config>.

<div id="secondary-file">guides/data-privacy/audit-logging.fragment.md</div>




# Personal Data Management

Use the SAP Personal Data Manager (PDM) with a CAP application.

:::warning To follow this cookbook hands-on you need an enterprise account.
The SAP Personal Data Manager service is currently only available for [enterprise accounts](https://discovery-center.cloud.sap/missiondetail/3019/3297/). An entitlement in trial accounts is not possible.
:::

SAP BTP provides the [*SAP Personal Data Manager (PDM)*](https://help.sap.com/docs/PERSONAL_DATA_MANAGER) which allows administrators to respond to the question "What data of me do you have?". To answer this question, the PDM service needs to fetch all personal data using an OData endpoint. That endpoint has to be provided by the application as follows.

## Annotate Personal Data

First identify entities and elements (potentially) holding personal data using `@PersonalData` annotations, as explained in detail in the [*Annotating Personal Data* chapter](annotations) of these guides.

> We keep using the [Incidents Management reference sample app](https://github.com/cap-js/incidents-app).

## Provide a Service Interface to SAP Personal Data Manager

SAP Personal Data Manager needs to call into your application to read personal data so you have to define a respective service endpoint, complying to the interface required by SAP Personal Data Manager.
Following the CAP principles, we recommend adding a new dedicated CAP service that handles all the personal data manager requirements for you. This keeps the rest of your data model clean and enables reuse, just as CAP promotes it.



### CAP Service Model for SAP Personal Data Manager

Following the [best practice of separation of concerns](../domain-modeling#separation-of-concerns), we create a dedicated service for the integration with SAP Personal Data Manager:

::: code-group
```cds [srv/pdm-service.cds]
using {sap.capire.incidents as db} from '../db/schema';

@requires: 'PersonalDataManagerUser' // security check
service PDMService @(path: '/pdm') {

  // Data Privacy annotations on 'Customers' and 'Addresses' are derived from original entity definitions
  entity Customers                as projection on db.Customers;
  entity Addresses                as projection on db.Addresses;
  entity Incidents                as projection on db.Incidents

  // create view on Incidents and Conversations as flat projection
  entity IncidentConversationView as
      select from Incidents {
              ID,
              title,
              urgency,
              status,
          key conversation.ID        as conversation_ID,
              conversation.timestamp as conversation_timestamp,
              conversation.author    as conversation_author,
              conversation.message   as conversation_message,
              customer.ID            as customer_ID,
              customer.email         as customer_email
      };

  // annotate new view
  annotate PDMService.IncidentConversationView with @(PersonalData.EntitySemantics: 'Other') {
      customer_ID @PersonalData.FieldSemantics: 'DataSubjectID';
  };

  // annotations for Personal Data Manager - Search Fields
  annotate Customers with @(Communication.Contact: {
        n    : {
            surname: lastName,
            given  : firstName
        },
        bday : dateOfBirth,
        email: [{
          type   : #preferred,
          address: email}]
    });

  };


```
:::

::: tip
Make sure to have [indicated all relevant entities and elements in your domain model](annotations).
:::



### Provide Flat Projections

As an additional step, you have to create flat projections on the additional business data, like transactional data.

In our model, we have `Incidents` and `Conversations`, which are connected via a [composition](https://github.com/SAP-samples/cloud-cap-samples/blob/gdpr/orders/db/schema.cds). Since SAP Personal Data Manager needs flattened out structures, we define a helper view `IncidentConversationView` to flatten this out.

We have to then add data privacy-specific annotations to this new view as well. The `IncidentConversationView` as transactional data is marked as `Other`. In addition, it is important to tag the correct field, which defines the corresponding data subject, in our case that is `customer_ID @PersonalData.FieldSemantics: 'DataSubjectID';`



### Annotating Search Fields

In addition, the most important search fields of the data subject have to be annotated with the corresponding annotation `@Communication.Contact`.

To perform a valid search in the SAP Personal Data Manager application, you will need _Surname_, _Given Name_, and _Email_ or the _Data Subject ID_. Details about this annotation can be found in
[Communication Vocabulary](https://github.com/SAP/odata-vocabularies/blob/main/vocabularies/Communication.md).

Alternatively to the tuple _Surname_, _Given Name_, and _Email_, you can also use _Surname_, _Given Name_, and _Birthday_ (called `bday`), if available in your data model. Details about this can be found in
[SAP Personal Data Manager - Developer Guide](https://help.sap.com/docs/personal-data-manager/4adcd96ce00c4f1ba29ed11f646a5944/v4-annotations?q=Contact&locale=en-US).



### Restrict Access Using the `@requires` Annotation

To restrict access to this sensitive data, the `PDMservice` is protected by the `@requires: 'PersonalDataManagerUser'` annotation. Calling the `PDMservice` externally without the corresponding permission is forbidden. The Personal Data Manager service calls the `PDMservice` with the needed role granted. This is configured in the _xs-security.json_ file, which is explained later.

[Learn more about security configuration and the SAP Personal Data Manager.](https://help.sap.com/docs/PERSONAL_DATA_MANAGER/620a3ea6aaf64610accdd05cca9e3de2/4ee5705b8ded43e68bde610223722971.html#loio8eb6d9f889594a2d98f478bd57412ceb){.learn-more}




At this point, you are done with your application. Let's set up the SAP Personal Data Manager and try it out.


<span id="before-pdm" />
<Fragment target="#before-pdm" type="internal">

## Connecting SAP Data Privacy Integration NextGen

Next, we will briefly detail the integration to SAP Personal Data Manager.
A more comprehensive guide, incl. tutorials, is currently under development.
For further details, see the [SAP Data Privacy Integration Developer Guide](https://help.sap.com/docs/data-privacy-integration/development-for-data-privacy-integration/getting-started-data-privacy-integration-nextgen?state=DRAFT).

### Subscribe to SAP Data Privacy Integration

[Subscribe to the service](https://help.sap.com/docs/data-privacy-integration) from the _Service Marketplace_ in the SAP BTP cockpit.

![A screenshot of the tile in the cockpit for the SAP Data Privacy Integration service.](assets/dpiCockpit.png){}

Follow the wizard to create your subscription.

### Prepare for Deployment

The Personal Data Manager can't connect to your application running locally. Therefore, you need to deploy your application. Here's what you need to do in preparation.

1. Add SAP HANA Cloud configuration, an approuter, and an _mta.yaml_ to your project:

    ```sh
    cds add hana,approuter,mta
    ```

2. Add `@sap/xssec` library, to make the authentication work:

    ```sh
    npm install @sap/xssec
    ```

[Learn more about authorization in CAP using Node.js.](../../node.js/authentication#jwt){.learn-more}

### Enhance mta.yaml with DPI

Add the needed configuration to your _mta.yaml_ file:

::: code-group

```yaml [mta.yaml]
modules:
  - name: incidents-srv
    ...
    requires:
      ...
      - name: incidents-information # [!code ++]
...
resources:
  ...
  - name: incidents-information # [!code ++]
    type: org.cloudfoundry.managed-service # [!code ++]
    requires: # [!code ++]
      - name: srv-api # [!code ++]
    parameters: # [!code ++]
      service-name: incidents-information # [!code ++]
      service: data-privacy-integration-service # [!code ++]
      service-plan: data-privacy-internal # [!code ++]
      config: # [!code ++]
        xs-security: # [!code ++]
          xsappname: incidents-information-${org}-${space} # [!code ++]
          authorities: # [!code ++]
            - $ACCEPT_GRANTED_AUTHORITIES # [!code ++]
        dataPrivacyConfiguration: # [!code ++]
          configType: information # [!code ++]
          applicationConfiguration: # [!code ++]
            applicationName: incidents-information # [!code ++]
            applicationDescription: DPI NextGen Incidents CAP Reference Application # [!code ++]
            applicationTitle: DPI NextGen Incidents # [!code ++]
            enableAutoSubscription: true # [!code ++]
          informationConfiguration: # [!code ++]
            applicationConfiguration: # [!code ++]
              disableDataSubjectCorrection: true # [!code ++]
              cacheControl: no-cache # [!code ++]
            components: # [!code ++]
              - componentName: incidents-srv # [!code ++]
                componentBaseURL: ~{srv-api/srv-url} # [!code ++]
                serviceEndPoints: # [!code ++]
                  - serviceName: dpi-service # [!code ++]
                    serviceFormat: odata-v4 # [!code ++]
                    annotationFormat: v4 # [!code ++]
                    serviceEndPoint: /pdm # [!code ++]
                    appPaginationEnabled: true # [!code ++]
                    cacheControl: no-cache # [!code ++]

```

:::

### Activate Access Checks in _xs-security.json_

Because we protected the `PDMservice`, we need to establish the security check properly. In particular, you need the _xs-security.json_ file to make the security check active. Add the following scope:

```json
{
  "scopes": [
    { // [!code ++]
      "name": "$XSAPPNAME.PersonalDataManagerUser", // [!code ++]
      "description": "Authority for Personal Data Manager", // [!code ++]
      "grant-as-authority-to-apps": [ // [!code ++]
        "$XSSERVICENAME(incidents-information)" // [!code ++]
      ] // [!code ++]
    } // [!code ++]
  ]
}
```

Here you define that your data privacy integration service instance, called `incidents-information`, is allowed to access your CAP application granting the `PersonalDataManagerUser` role.

### Build and Deploy Your Application

:::details MT-scenario

```sh
cds add multitenancy
npm update --package-lock-only
npm update --package-lock-only --prefix mtx/sidecar
```

:::

The general deployment is described in detail in [Deploy to Cloud Foundry guide](../deployment/to-cf). Here's for short what you need to do.

[Freeze the npm dependencies](/guides/deployment/to-cf#freeze-dependencies):

```sh
npm update --package-lock-only
```

[Build and deploy](/guides/deployment/to-cf#add-mta-yaml):

```sh
mbt build -t gen --mtar mta.tar
cf deploy gen/mta.tar -f
```

### Assign Role Collections

SAP Data Privacy Integration comes with the following role collections:

- DPI_NextGen_Information_CustomerServiceRepresentative
- DPI_NextGen_Information_OperationsClerk
- DPI_NextGen_Information_DataPrivacy_Administrator

[Learn more about Assigning Role Collections to Users or User Groups](https://help.sap.com/docs/btp/sap-business-technology-platform/assigning-role-collections-to-users-or-user-groups){.learn-more}

## Using the SAP Personal Data Manager Application

Open the SAP Personal Data Manager application from the _Instances and Subscriptions_ page in the SAP BTP cockpit.

![To open the application, open the three dot menu and select "Go to Application".](assets/dpingCockpit.png){}

In the personal data manager application you can search for data subjects with _First Name_, _Last Name_, and _Date of Birth_, or alternatively with their _ID_.

![A screenshot of the SAP Personal Data Manager application.](assets/pdmApplication.png){}

</Fragment>

## Connecting SAP Personal Data Manager

Next, we will briefly detail the integration to SAP Personal Data Manager.
A more comprehensive guide, incl. tutorials, is currently under development.
For further details, see the [SAP Personal Data Manager Developer Guide](https://help.sap.com/docs/personal-data-manager/4adcd96ce00c4f1ba29ed11f646a5944/what-is-personal-data-manager).

### Activate Access Checks in _xs-security.json_

Because we protected the `PDMservice`, we need to establish the security check properly. In particular, you need the _xs-security.json_ file to make the security check active. The following _xs-security.json_ is from our sample.

```json
{
  "xsappname": "incidents-mgmt",
  "tenant-mode": "shared",
  "scopes": [
    {
      "name": "$XSAPPNAME.PersonalDataManagerUser",
      "description": "Authority for Personal Data Manager",
      "grant-as-authority-to-apps": [
        "$XSSERVICENAME(pdm)"
      ]
    }
  ]
}
```

Here you define that your personal data manager service instance, called `pdm`, is allowed to access your CAP application granting the `PersonalDataManagerUser` role.



### Add `@sap/xssec` Library

To make the authentication work, you have to enable the security strategy by installing the `@sap/xssec` package:

```sh
npm install @sap/xssec
```

[Learn more about authorization in CAP using Node.js.](../../node.js/authentication#jwt){.learn-more}

### Build and Deploy Your Application

The Personal Data Manager can't connect to your application running locally. Therefore, you first need to deploy your application. In our sample, we added two manifest files using `cds add cf-manifest` and SAP HANA configuration using `cds add hana`.

The general deployment is described in detail in [Deploy Using Manifest Files](../deployment/to-cf).

Make a production build:

```sh
cds build --production
```

Deploy your application:

```sh
cf create-service-push
```



### Subscribe to SAP Personal Data Manager Service

[Subscribe to the service](https://help.sap.com/docs/PERSONAL_DATA_MANAGER/620a3ea6aaf64610accdd05cca9e3de2/ef10215655a540b6ba1c02a96e118d66.html) from the _Service Marketplace_ in the SAP BTP cockpit.

![A screenshot of the tile in the cockpit for the SAP Personal Data Manager service.](assets/pdmCockpitCreate.png){}

Follow the wizard to create your subscription.



### Create Role Collections

SAP Personal Data Manager comes with the following roles:

Role Name | Role Template
----------|------
PDM_Administrator | PDM_Administrator
PDM_CustomerServiceRepresentative | PDM_CustomerServiceRepresentative
PDM_OperatorsClerk | PDM_OperatorsClerk

All of these roles have two different _Application Identifiers_.
::: tip
Application identifiers with **!b** are needed for the UI, and identifiers with **!t** are needed for executing the Postman collection.
:::

[Learn more about defining a role collection in SAP BTP cockpit](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/4b20383efab341f181becf0a947a5498.html){.learn-more}



### Create a Service Instance

You need a configuration file, like the following, to create a service instance for the Personal Data Manager.

`pdm-instance-config.json`
```json
{
  "xs-security": {
    "xsappname": "incidents-mgmt",
    "authorities": ["$ACCEPT_GRANTED_AUTHORITIES"]
  },
  "fullyQualifiedApplicationName": "incidents-mgmt",
  "appConsentServiceEnabled": true
}


```

Create a service instance using the SAP BTP cockpit or execute the following command:

```sh
cf create-service personal-data-manager-service standard incidents-mgmt-pdm -c ./pdm-instance-config.json
```



### Bind the Service Instance to Your Application.

With both the application deployed and the SAP Personal Data Manger service set up, you can now bind the service instance of the Personal Data Manager to your application. Use the URL of your application in a configuration file, such as the following example, which you need when binding a service instance.

`pdm-binding-config.json`
```json
{
  "fullyQualifiedApplicationName": "incidents-mgmt",
  "fullyQualifiedModuleName": "incidents-mgmt-srv",
  "applicationTitle": "PDM Incidents",
  "applicationTitleKey": "PDM Incidents",
  "applicationURL": "https://incidents-mgmt-srv.cfapps.eu10.hana.ondemand.com/", // get the URL from the CF CLI command: cf apps
  "endPoints": [
    {
      "type": "odatav4",
      "serviceName": "pdm-service",
      "serviceTitle": "Incidents Management",
      "serviceTitleKey": "IncidentsManagement",
      "serviceURI": "pdm",
      "hasGdprV4Annotations": true,
      "cacheControl": "no-cache"
    }
  ]
}
```

Here the `applicationURL`, the `fullyQualifiedModuleName`, and the `serviceURI` have to be those of your Cloud Foundry deployment and your CAP service definition (_services-manifest.yaml_).

Bind the service instance using the SAP BTP cockpit or execute the following command:

```sh
cf bind-service incidents-mgmt-srv incidents-mgmt-pdm -c ./pdm-binding-config.json
```



## Using the SAP Personal Data Manager Application

Open the SAP Personal Data Manager application from the _Instances and Subscriptions_ page in the SAP BTP cockpit.

![To open the application, open the three dot menu and select "Go to Application".](assets/pdmCockpit.png){}

In the personal data manager application you can search for data subjects with _First Name_, _Last Name_, and _Date of Birth_, or alternatively with their _ID_.

![A screenshot of the SAP Personal Data Manager application.](assets/pdmApplication.png){}
<div id="secondary-file">guides/data-privacy/pdm.fragment.md</div>




# Data Retention Management

Under construction.









# Deployment

Learn here about deployment options of a CAP application.



<IndexList :pages='pages' />



# Deploy to Cloud Foundry

A comprehensive guide on deploying applications built with SAP Cloud Application Programming Model (CAP)  to SAP BTP Cloud Foundry environment.

## Intro & Overview

After completing the functional implementation of your CAP application by following the [Getting Started](../../get-started/in-a-nutshell) or [Cookbook](../) guides, you would finally deploy it to the cloud for production. The essential steps are illustrated in the following graphic:

![First prepare for production (once) and then freeze your dependencies (once and on upgrades). Next build and assemble and then deploy.](assets/deploy-setps.drawio.svg){}

First, you apply these steps manually in an ad-hoc deployment, as described in this guide. Then, after successful deployment, you automate them using [CI/CD pipelines](cicd).

<ImplVariantsHint />

## Prerequisites

The following sections are based on a new project that you can create like this:

<div class="impl node">

```sh
cds init bookshop --add sample
cd bookshop
```

::: details Alternatively, download or clone the sample repository

Exercise the following steps in the `bookshop` subfolder of the [`cloud-cap-samples`](https://github.com/sap-samples/cloud-cap-samples) repo:

```sh
git clone https://github.com/sap-samples/cloud-cap-samples samples
cd samples/bookshop
```

:::

</div>

<div class="impl java">

```sh
cds init bookshop --java --add sample
cd bookshop
```

> If you want to use a ready-to-be-deployed sample, see our [java/samples](https://github.com/sap-samples/cloud-cap-samples-java).

[Learn more about Setting Up Local Development.](../../java/getting-started#local){.learn-more}
</div>

<br>

In addition, you need to prepare the following:

#### 1. SAP BTP with SAP HANA Cloud Database Up and Running {#btp-and-hana}

- Access to [SAP BTP, for example a trial](https://developers.sap.com/tutorials/hcp-create-trial-account.html)
- An [SAP HANA Cloud database running](https://help.sap.com/docs/hana-cloud/sap-hana-cloud-administration-guide/create-sap-hana-database-instance-using-sap-hana-cloud-central) in your subaccount 
- Entitlement for [`hdi-shared` service plan](https://help.sap.com/docs/hana-cloud/sap-hana-cloud-getting-started-guide/set-up-schema-or-hdi-container-cloud-foundry) for your subaccount
- A [Cloud Foundry space](https://help.sap.com/docs/btp/sap-business-technology-platform/create-spaces?version=Cloud)

::: tip Starting the SAP HANA database takes several minutes
Therefore, we recommend doing these steps early on. In trial accounts, you need to start the database **every day**.
:::

#### 2. Latest Versions of `@sap/cds-dk` {#latest-cds}

Ensure you have the latest version of `@sap/cds-dk` installed globally:

```sh
npm -g outdated       #> check whether @sap/cds-dk is listed
npm i -g @sap/cds-dk  #> if necessary
```

<div class="impl node">

Likewise, ensure the latest version of `@sap/cds` is installed in your project:

```sh
npm outdated          #> check whether @sap/cds is listed
npm i @sap/cds        #> if necessary
```

</div>

#### 3. Cloud MTA Build Tool {#mbt}

- Run `mbt` in a terminal to check whether you've installed it.
- If not, install it according to the [MTA Build Tool's documentation](https://sap.github.io/cloud-mta-build-tool/download).
- For macOS/Linux machines best is to install using `npm`:

  ```sh
  npm i -g mbt
  ```

- For Windows, [please also install `GNU Make`](https://sap.github.io/cloud-mta-build-tool/makefile/).

#### 4. Cloud Foundry CLI w/ MTA Plugins {#cf-cli}

- Run `cf -v` in a terminal to check whether you've installed version **8** or higher.
- If not, install or update it according to the [Cloud Foundry CLI documentation](https://github.com/cloudfoundry/cli#downloads).
- In addition, ensure to have the [MTA plugin for the Cloud Foundry CLI](https://github.com/cloudfoundry-incubator/multiapps-cli-plugin/tree/master/README.md) installed.

   ```sh
   cf add-plugin-repo CF-Community https://plugins.cloudfoundry.org
   cf install-plugin -f multiapps
   cf install-plugin -f html5-plugin
   ```

## Prepare for Production {#prepare-for-production}

If you followed CAP's grow-as-you-go approach, you've developed your application with an in-memory database and basic (mocked) authentication. In the cloud, you typically use production-grade services like SAP HANA and authentication providers.

The `cds add <facets>` command ensures required services are configured correctly and their dependencies are added to your _package.json_.

### 1. SAP HANA Database

<div class="impl node">

While we used SQLite as a low-cost stand-in during development, we're using an SAP HANA Cloud database for production:

</div>

<div class="impl java">

While we used SQLite or H2 as a low-cost stand-in during development, we're going to use an SAP HANA Cloud database for production:

</div>

```sh
cds add hana
```

[Learn more about using SAP HANA for production.](../databases-hana){.learn-more}

### 2. Authorization/Authentication

Configure your app for XSUAA-based authentication:

```sh
cds add xsuaa
```

::: tip This will also generate an `xs-security.json` file
The roles/scopes are derived from authorization-related annotations in your CDS models. Ensure to rerun `cds compile --to xsuaa`, as documented in the [_Authorization_ guide](/guides/security/authorization#xsuaa-configuration) whenever there are changes to these annotations.
:::

[Learn more about SAP Authorization and Trust Management/XSUAA.](https://discovery-center.cloud.sap/serviceCatalog/authorization-and-trust-management-service?region=all){.learn-more}

### 3. MTA-Based Deployment { #add-mta-yaml}

We'll be using the [Cloud MTA Build Tool](https://sap.github.io/cloud-mta-build-tool/) to execute the deployment. The modules and services are configured in an `mta.yaml` deployment descriptor file, which we generate with:

```sh
cds add mta
```

[Learn more about MTA-based deployment.](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/d04fc0e2ad894545aebfd7126384307c.html?locale=en-US){.learn-more}

### 4. App Router as Gateway { #add-app-router}

The _App Router_ acts as a single point-of-entry gateway to route requests to. In particular, it ensures user login and authentication in combination with XSUAA.

Two deployment options are available:

- **Managed App Router**: for SAP Build Work Zone, the Managed App Router provided by SAP Fiori Launchpad is available.
- **Custom App Router**: for custom scenarios without SAP Fiori Launchpad, the App Router needs to be deployed along with your application.
  In this case, use the following command to enhance the application configuration:

    ```sh
    cds add approuter
    ```

[Learn more about the SAP BTP Application Router.](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/01c5f9ba7d6847aaaf069d153b981b51.html?locale=en-US){.learn-more}

### 5. User Interfaces { #add-ui }

#### Option A: SAP Cloud Portal

If you intend to deploy user interface applications, you also need to set up the [HTML5 Application Repository](https://discovery-center.cloud.sap/serviceCatalog/html5-application-repository-service) in combination with the [SAP Cloud Portal service](https://discovery-center.cloud.sap/serviceCatalog/cloud-portal-service):

```sh
cds add portal
```

#### Option B: SAP Build Work Zone, Standard Edition <Beta />

For **single-tenant applications**, you can use [SAP Build Work Zone, Standard Edition](https://discovery-center.cloud.sap/serviceCatalog/sap-build-work-zone-standard-edition):

```sh
cds add workzone
```

**Important:** This also requires you to set up SAP Build Work Zone, Standard Edition [according to the SAP Learning tutorial](https://developers.sap.com/tutorials/spa-configure-workzone.html).

### 6. Optional: Multitenancy { #add-multitenancy }

To enable multitenancy for production, run the following command:

```sh
cds add multitenancy
```

[Learn more about MTX services.](../multitenancy/#behind-the-scenes){.learn-more}

<br>

::: tip You're set!
The previous steps are required _only once_ in a project's lifetime. With that done, we can repeatedly deploy the application.
:::

<br>


## Build and Deploy

Make sure you are logged in to Cloud Foundry and target the space you want to deploy to:
```sh
cf login --sso  # to log on with SAP Universal ID
cf target
```
[Learn more about `cf login`](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/7a37d66c2e7d401db4980db0cd74aa6b.html){.learn-more}

::: tip Prevent outdated lock file issues
If your project already includes a _package-lock.json_, run `npm update` to make sure it’s in sync with your _package.json_ before proceeding.
:::

You can now freeze dependencies, build, and deploy the application:

```sh
cds up
```

::: details Essentially, this automates the following steps...

```sh
# Installing app dependencies, e.g.
npm i app/browse
npm i app/admin-books

# If project is monorepo
ln -sf ../package-lock.json

# If project is multitenant
npm i --package-lock-only --prefix mtx/sidecar

# If package-lock.json doesn't exist
npm i --package-lock-only

# Final assembly and deployment...
mbt build -t gen --mtar mta.tar
cf deploy gen/mta.tar -f
```
:::

::: details Test with `cds build`

While `cds build` is already ran as part of `mbt build` in `cds up`, you can also run it standalone to inspect what is generated for production:

```sh
cds build --production
```

[Learn more about running and customizing `cds build`.](custom-builds){.learn-more}

:::

[Got errors? See the troubleshooting guide.](../../get-started/troubleshooting#mta){.learn-more}
[Learn how to reduce the MTA archive size **during development**.](../../get-started/troubleshooting#reduce-mta-size){.learn-more}

This process can take some minutes and finally logs an output like this:

```log
[…]
Application "bookshop" started and available at
"[org]-[space]-bookshop.<landscape-domain>.com"
[…]
```

You can use this URL to access the App Router as the entry point of your application.

For **multitenant applications**, you have to subscribe a tenant first. The application is accessible via a tenant-specific App Router URL after subscription.

::: info SaaS Extensibility
Share the generic App-Router URL with SaaS consumers for logging in as extension developers using `cds login` or other [extensibility-related commands](../extensibility/customization#prep-as-operator).
:::

::: tip No index page and SAP Fiori preview in the cloud
The default index page and [SAP Fiori preview](../../advanced/fiori#sap-fiori-preview), that you are used to seeing during local development, are only meant for the development profile and not available in the cloud. For productive applications, you should add a proper SAP Fiori elements application through on of the [user interface options](#add-ui) outlined before.
:::

### Inspect Apps in BTP Cockpit

Visit the "Applications" section in your [SAP BTP cockpit](https://help.sap.com/docs/BTP/65de2977205c403bbc107264b8eccf4b/144e1733d0d64d58a7176e817fa6aeb3.html) to see the deployed apps:

![The screenshot shows the SAP BTP cockpit, when a user navigates to his dev space in the trial account and looks at all deployed applications.](./assets/apps-cockpit.png)

::: tip Next up: Assign the _admin_ role
In order to access the admin APIs you need to assign the _admin_ role required by `AdminService`. Create a role collection and [assign the role and your user](https://developers.sap.com/tutorials/btp-app-role-assignment.html) to get access.
:::

[Got errors? See the troubleshooting guide.](../../get-started/troubleshooting#cflogs-recent){.learn-more}


## Keep Dependencies Up-to-date { #freeze-dependencies }

Deployed applications should freeze all their dependencies, including transient ones. Therefore, on first execution, `cds up` creates a _package-lock.json_ file for all application modules.

It is **essential to regularly update dependencies** to consume latest bug fixes and improvements. Not doing so will increase the risk of **security vulnerabilities**, expose your application to **known bugs**, and make future upgrades significantly harder and more time-consuming.

We recommend setting up [Dependabot](https://docs.github.com/en/code-security/dependabot), [Renovate](https://docs.renovatebot.com/) or similar automated solutions to update dependencies **one-by-one** to easily identify breaking changes, minimize risks, and ensure continuous compatibility and **stability of your application**.


## Upgrade Tenants {.java}

The CAP Java SDK offers `main` methods for Subscribe/Unsubscribe in the classes `com.sap.cds.framework.spring.utils.Subscribe/Unsubscribe` that can be called from the command line. This way, you can run the tenant subscribe/unsubscribe for the specified tenant. This would trigger also your custom handlers, which is useful for the local testing scenarios.

In order to register all handlers of the application properly during the execution of a tenant operation `main` method, the component scan package must be configured. To set the component scan, the property <Config java>cds.multitenancy.component-scan</Config> must be set to the package name of your application.

The handler registration provides additional information that is used for the tenant subscribe, for example, messaging subscriptions that are created.

::: warning The MTX sidecar must be running
You can stop the CAP Java backend when you call this method, but the MTX sidecar application must be running!
:::

This synchronization can also be automated, for example using [Cloud Foundry Tasks](https://docs.cloudfoundry.org/devguide/using-tasks.html) on SAP BTP and [Module Hooks](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/b9245ba90aa14681a416065df8e8c593.html) in your MTA.

The `main` method optionally takes tenant ID (string) as the first input argument and tenant options (JSON string) as the second input argument. Alternatively, you can use the environment variables `MTCOMMAND_TENANTS` and `MTCOMMAND_OPTIONS` instead of arguments. The command-line arguments have higher priority, so you can use them to override the environment variables.

The method returns the following exit codes.

| Exit Code  | Result                                                                                                              |
|-----------:|---------------------------------------------------------------------------------------------------------------------|
| 0          | Tenant subscribed/unsubscribed successfully.                                                                        |
| 3          | Failed to subscribe/unsubscribe the tenant. Rerun the procedure to make sure the tenant is subscribed/unsubscribed. |

To run this method locally, use the following command where `<jar-file>` is the one of your applications:

::: code-group

```sh [&gt;= Spring Boot 3.2.0]
java -cp <jar-file> -Dloader.main=com.sap.cds.framework.spring.utils.Subscribe/Unsubscribe org.springframework.boot.loader.launch.PropertiesLauncher <tenant> [<tenant options>]
```

```sh [&lt; Spring Boot 3.2.0]
java -cp <jar-file> -Dloader.main=com.sap.cds.framework.spring.utils.Subscribe/Unsubscribe org.springframework.boot.loader.PropertiesLauncher <tenant> [<tenant options>]
```

:::

In the SAP BTP, Cloud Foundry environment, it can be tricky to construct such a command. The reason is that the JAR file is extracted by the Java buildpack and the place of the Java executable isn't easy to determine. Also the place differs for different Java versions. Therefore, we recommend adapting the start command that is generated by the buildpack and run the adapted command:

::: code-group

```sh [&gt;= Spring Boot 3.2.0]
sed -i 's/org.springframework.boot.loader.launch.JarLauncher/org.springframework.boot.loader.launch.PropertiesLauncher/g' /home/vcap/staging_info.yml && sed -i 's/-Dsun.net.inetaddr.negative.ttl=0/-Dsun.net.inetaddr.negative.ttl=0 -Dloader.main=com.sap.cds.framework.spring.utils.Subscribe/Unsubscribe/g' /home/vcap/staging_info.yml && jq -r .start_command /home/vcap/staging_info.yml | sed 's/^/ MTCOMMAND_TENANTS=my-tenant [MTCOMMAND_TENANTS=<tenant options>]/' | bash
```

```sh [&lt; Spring Boot 3.2.0]
sed -i 's/org.springframework.boot.loader.JarLauncher/org.springframework.boot.loader.PropertiesLauncher/g' /home/vcap/staging_info.yml && sed -i 's/-Dsun.net.inetaddr.negative.ttl=0/-Dsun.net.inetaddr.negative.ttl=0 -Dloader.main=com.sap.cds.framework.spring.utils.Subscribe/Unsubscribe/g' /home/vcap/staging_info.yml && jq -r .start_command /home/vcap/staging_info.yml | sed 's/^/ MTCOMMAND_TENANTS=my-tenant [MTCOMMAND_TENANTS=<tenant options>]/' | bash
```

```sh [Java 8]
sed -i 's/org.springframework.boot.loader.JarLauncher/-Dloader.main=com.sap.cds.framework.spring.utils.Subscribe/Unsubscribe org.springframework.boot.loader.PropertiesLauncher/g' /home/vcap/staging_info.yml && jq -r .start_command /home/vcap/staging_info.yml | sed 's/^/ MTCOMMAND_TENANTS=my-tenant [MTCOMMAND_TENANTS=<tenant options>]/' | bash
```

:::








# Deploy to Kyma

You can run your CAP application in the [SAP BTP Kyma Runtime](https://discovery-center.cloud.sap/serviceCatalog/kyma-runtime?region=all), the SAP-managed offering for the [Kyma project](https://kyma-project.io/).

<ImplVariantsHint />

## Overview

Kyma is a Kubernetes-based runtime for deploying and managing containerized applications. Applications are packaged as container images—typically Docker images—and their deployment and operations are defined using Kubernetes resource configurations.

Deploying apps on the SAP BTP Kyma Runtime requires two main artifact types:

1. **Container Images** – Your application packaged in a container
2. **Kubernetes Resources** – Configurations for deployment and scaling

The following diagram illustrates the deployment workflow:

![A CAP Helm chart is added to your project. Then you build your project as container images and push those images to a container registry of your choice. As last step the Helm chart is deployed to your Kyma resources, where service instances of SAP BTP services are created and pods pull the previously created container images from the container registry.](assets/deploy-kyma.drawio.svg)


## Prerequisites {#prerequisites}

+ Use a Kyma-enabled [Trial Account](https://account.hanatrial.ondemand.com/) or purchase a Kyma cluster from SAP
+ You need a [Container Image Registry](#get-access-to-a-container-registry)
+ Get the required SAP BTP service entitlements
+ Install [Docker Desktop or Docker for Linux](https://docs.docker.com/get-docker/)
+ Download and install the following command line tools:
  + [`kubectl` command line client](https://kubernetes.io/docs/tasks/tools/) for Kubernetes
  + [`pack` command line tool](https://buildpacks.io/docs/tools/pack/)
  + [`helm` command line tool](https://helm.sh/docs/intro/install/)
  + [`ctz` command line tool](https://www.npmjs.com/package/ctz)
+ Make sure your SAP HANA Cloud is [mapped to your namespace](https://community.sap.com/t5/technology-blogs-by-sap/consuming-sap-hana-cloud-from-the-kyma-environment/ba-p/13552718#toc-hId-569025164)
+ Ensure SAP HANA Cloud is accessible from your Kyma cluster by [configuring trusted source IPs](https://help.sap.com/docs/HANA_CLOUD/9ae9104a46f74a6583ce5182e7fb20cb/0610e4440c7643b48d869a6376ccaecd.html)

#### Configure Kubernetes

Download the Kubernetes configuration from SAP BTP and move it to _$HOME/.kube/config_.

[Learn more in the SAP BTP Kyma documentation](https://help.sap.com/docs/btp/sap-business-technology-platform/access-kyma-instance-using-kubectl){.learn-more}

#### Get Access to a Container Registry

SAP BTP doesn't provide a container image registry (or container repository), but you can choose from offerings of hosted open source and private container image registries, as well as solutions that can be run on premise or in your own cloud infrastructure.

::: tip Ensure network access

Verify the Kubernetes cluster has network access to the container registry, especially if hosted behind a VPN or within a restricted network environment.

:::

#### Set Up Your Cluster for a Private Container Registry

To use a docker image from a private repository, you need to [create an image pull secret](https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/) and configure this secret for your containers.

::: details Use this script to create the docker pull secret...

```sh
echo -n "Your docker registry server: "; read YOUR_REGISTRY
echo -n "Your user: "; read YOUR_USER
echo -n "Your email: "; read YOUR_EMAIL
echo -n "Your API token: "; read -s YOUR_API_TOKEN
kubectl create secret docker-registry \
  docker-registry \
  "--docker-server=$YOUR_REGISTRY" \
  "--docker-username=$YOUR_USER" \
  "--docker-password=$YOUR_API_TOKEN" \
  "--docker-email=$YOUR_EMAIL"
# The 2nd 'docker-registry' above is our default secret name.
```
:::

::: warning Assign limited permissions to the technical user
It is recommended to use a technical user for this secret that has only read permission, because users with access to the Kubernetes cluster can reveal the password from the secret.
:::

<span id="afterprivatereg" />
<Fragment target="#afterprivatereg">

#### Use SAP Internet Facing Artifactory <Internal />

The [Internet Facing Artifactory](https://common.repositories.cloud.sap/) serves as an internet-accessible container registry for SAP.
For development purposes, you can [request a private **local** repository](https://selfservice.repositories.cloud.sap) for your development project with repository type "Docker".

Access to containers is limited to privileged users. You can change and inspect access rights within the Artifactory UI.

For pipeline setups, use a technical user according to the [internet-facing Artifactory documentation](https://pages.github.tools.sap/Common-Repository/Artifactory-Internet-Facing/commonrepo-auth/#technical-users) and assign required authorizations.

##### Generate an API Key

Pushing and pulling images from Artifactory requires an API Key. You can't and shouldn't use your SAP password for that.

1. Open [Internet Facing Artifactory](https://common.repositories.cloud.sap/)
2. Choose **SAML SSO**
3. Log in with your SAP user and password if required
4. Choose **User Menu** (letter in circle) in the top right corner of the page
5. Choose **Edit Profile**
6. Choose **Generate an Identity Token**
7. Give an optional description
8. Choose **Next**
9. Copy the Reference Token displayed using the copy icon, or keep the page open to copy it later.

##### Log in to SAP Internet Facing Artifactory

Prepend the repository name before the artifactory URL:

```sh
docker login YOUR_REPO.common.repositories.cloud.sap -u YOUR_SAP_USER_ID
```
> Use your API Key as the password.

</Fragment>

## Deploy to Kyma

Let's  start with a new sample project and prepare it for production using an SAP HANA database and XSUAA for authentication:

<div class="impl java">

```sh
cds init bookshop --java --add sample && cd bookshop
cds add hana,xsuaa
```

</div>
<div class="impl node">

```sh
cds init bookshop --add sample && cd bookshop
cds add hana,xsuaa
```

</div>


#### User Interfaces <Beta />

If you need a UI, you can also add SAP Build Work Zone support:

```sh
cds add workzone
```
> This is currently only supported for single-tenant scenarios.



#### Add CAP Helm Charts

CAP provides a configurable [Helm chart](https://helm.sh/) for Node.js and Java applications, which can be added like so:

```sh
cds add helm
```
> You will be asked to provide a Kyma domain, the secret name to pull images and your container registry name.

::: details Running `cds build` now creates a _gen_/_chart_ folder

This folder will have all the necessary files required to deploy the Helm chart. Files from the _chart_ folder are copied to _gen/chart_.
They support the deployment of your CAP service, database, UI content, and the creation of instances for BTP services.

:::

#### Build and Deploy

**First, ensure the Docker daemon** is running, for example by starting Docker Desktop.

You can now quickly deploy the application like so:

```sh
cds up -2 k8s
```

::: details Essentially, this automates the following steps...

```zsh
cds add helm,containerize # if not already done

# Installing app dependencies, e.g.
npm i app/browse
npm i app/admin-books

# If project is multitenant
npm i --package-lock-only mtx/sidecar

# If package-lock.json doesn't exist
npm i --package-lock-only

# Final assembly and deployment, e.g.
ctz containerize.yaml --log --push
helm upgrade --install bookshop ./gen/chart --wait --wait-for-jobs --set-file xsuaa.jsonParameters=xs-security.json
kubectl rollout status deployment bookshop-srv --timeout=8m
kubectl rollout status deployment bookshop-approuter --timeout=8m
kubectl rollout status deployment bookshop-sidecar --timeout=8m
```

:::

This process can take a few minutes to complete and logs output like this:

```log
[…]
The release bookshop is installed in namespace [namespace].

Your services are available at:
  [workload] - https://bookshop-[workload]-[namespace].[configured-domain]
[…]
```

You can use this URL to access the approuter as the entry point of your application.

For **multitenant applications**, you have to subscribe a tenant first. The application is accessible via a tenant-specific URL after subscription.

::: info SaaS Extensibility
Share the above App-Router URL with SaaS consumers for logging in as extension developers using `cds login` or other [extensibility-related commands](https://cap.cloud.sap/docs/guides/extensibility/customization#prep-as-operator).
:::



---
{}

## Deep Dives


<span id="aftercluster" />
<Fragment target="#aftercluster">

### SAP Gardener <Internal />

CAP is supported on [Gardener](https://gardener.cloud.sap/)-based Kubernetes clusters for **CAP applications operated by SAP** with these additional preconditions:
+ Install [SAP BTP Service Operator](https://blogs.sap.com/2021/05/27/introducing-sap-btp-service-operator/)
+ This guide assumes that your in-cluster service communication is secured, for example with [Istio](https://istio.io/)
+ Replace the Kyma API rule (`gen/chart/charts/web-application/templates/api-rule.yaml `) in your CAP Helm chart with an [Istio virtual service resource](https://istio.io/latest/docs/reference/config/networking/virtual-service/).

</Fragment>

<span id="beforeend" />
<Fragment target="#beforeend">

### Unified Runtime Charts <Internal />

`cds add` supports [Unified Runtime](https://pages.github.tools.sap/unified-runtime/) charts to describe deployments:

```sh
cds add helm-unified-runtime
```

> Note: This will require the `--force` flag to overwrite the existing chart files if you have followed this guide.

The resulting _chart/Chart.yaml_ file will look similar to this:

```yaml
apiVersion: v2
name: bookshop
type: application
version: 1.0.0
dependencies:
- alias: srv
  name: web-application
  repository: https://int.repositories.cloud.sap/artifactory/virtual-unified-runtime-helm-dmz/
  version: '>0.0.0'
- alias: hana-deployer
  name: content-deployment
  repository: https://int.repositories.cloud.sap/artifactory/virtual-unified-runtime-helm-dmz/
  version: '>0.0.0'
- alias: xsuaa
  name: service-instance
  repository: https://int.repositories.cloud.sap/artifactory/virtual-unified-runtime-helm-dmz/
  version: '>0.0.0'
```

::: tip Use fixed versions in production

By default, the added charts do reference to the _latest version_ of unified runtime charts. Since _latest version_ changes with every release, configuration files added by `cds add helm` might be incompatible. We recommend to select the specific version of runtime charts.

:::

[Learn more about Unified Runtime Versioning Policy](https://pages.github.tools.sap/unified-runtime/docs/appendix/versioning-policy){ .learn-more}

</Fragment>


### Configure Image Repository

Specify the repository where you want to push the images:

::: code-group

```yaml [containerize.yaml]
...
repository: <your-container-registry>
```

:::

Now, we use the `ctz` build tool to build all the images:

```sh
ctz containerize.yaml
```

This will start containerizing your modules based on the configuration in _containerize.yaml_. After finishing, it will ask whether you want to push the images or not. Type `y` and press enter to push your images. You can also use the above command with `--push` flag to auto-confirm. If you want more logs, you can use the `--log` flag with the above command.

[Learn more about the `ctz` build tool.](https://www.npmjs.com/package/ctz/){.learn-more}

### Customize Helm Chart {#customize-helm-chart}

#### About CAP Helm Charts {#about-cap-helm}

The following files are added to a _chart_ folder by executing `cds add helm`:

```zsh
chart/
├── values.yaml         # Default configuration of the chart
├── Chart.yaml          # Chart metadata
└── values.schema.json  # JSON Schema for values.yaml file
```

[Learn more about _values.yaml_.](https://helm.sh/docs/chart_template_guide/values_files/){.learn-more}
[Learn more about _Chart.yaml_.](https://helm.sh/docs/topics/charts/){.learn-more}

<br>

In addition, a `cds build` also puts some files to the _gen/chart_ folder:

```zsh
chart/
├── templates/
│   ├── NOTES.txt # Message printed after Helm upgrade
│   ├── *.tpl     # Template libraries used in template resources
│   ├── *.yaml    # Template files for Kubernetes resources
```

[Learn how to create a Helm chart from scratch.](https://helm.sh/docs){.learn-more}

#### Configure {#configure-helm-chart}

You can change the configuration of CAP Helm charts by editing the _chart/values.yaml_ file. The `helm` CLI also offers you other options to overwrite settings from _chart/values.yaml_ file:

+ Overwrite properties using the  `--set` parameter.
+ Overwrite properties from a YAML or JSON file using the `-f` parameter.

::: tip Multiple deployment types
It is recommended to do the main configuration in the _chart/values.yaml_ file and have additional YAML files for specific deployment types (dev, test, productive) and targets.
:::

#### Global Properties

::: code-group

```yaml [values.yaml]
# Secret name to access container registry, only for private registries
imagePullSecret:
  name: <docker-secret>

# Kubernetes cluster ingress domain (used for application URLs)
domain: <cluster-domain>

# Container image registry
image:
  registry: <registry-server>
```
:::

#### Deployment Properties

The following properties are available for the `srv` key:

::: code-group
```yaml [values.yaml]
srv:
  # [Service bindings](#configuration-options-for-service-bindings)
  bindings:

  # Kubernetes container resources
  # https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  resources:

  # Map of additional env variables
  env:
    MY_ENV_VAR: 1

  # Kubernetes Liveness, Readiness and Startup Probes
  # https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
  health:
    liveness:
      path: <endpoint>
    readiness:
      path: <endpoint>
    startupTimeout: <seconds>

  # Container image
  image:
```
:::

> You can explore more configuration options in the subchart's directory _gen/chart/charts/web-application_.

### SAP BTP Services

You can find a list of SAP BTP services in the [Discovery Center](https://discovery-center.cloud.sap/viewServices?provider=all&regions=all&showFilters=true). To find out if a service is supported in the Kyma and Kubernetes environment, go to the **Service Marketplace** of your Subaccount in the SAP BTP Cockpit and select Kyma or Kubernetes in the environment filter.

You can find information about planned SAP BTP, Kyma Runtime features in the [product road map](https://roadmaps.sap.com/board?PRODUCT=73554900100800003012&PRODUCT=73554900100800003012).

#### Built-in SAP BTP Services

The Helm chart supports creating service instances for commonly used services. Services are pre-populated in _chart/values.yaml_ based on the used services in the `requires` section of the CAP configuration.

You can use the following services in your configuration:

::: code-group
```yaml [values.yaml]
xsuaa:
  parameters:
    xsappname: <name>
    HTML5Runtime_enabled: true # for SAP Launchpad service
event-mesh: …
connectivity: …
destination: …
html5-apps-repo-host: …
hana: …
service-manager: …
saas-registry: …
```
:::

<span id="beforemodify" />
<Fragment target="#beforemodify">

#### Internal SAP BTP Services <Internal />

The following services are only available for SAP:

::: code-group
```yaml [values.yaml]
auditlog: …
```
:::

</Fragment>

#### Arbitrary BTP Services

These are the steps to create and bind to an arbitrary service, using the binding of the feature toggle service to the CAP application as an example:

1. In the _chart/Chart.yaml_ file, add an entry to the `dependencies` array.

    ```yaml
    dependencies:
      ...
      - name: service-instance
        alias: feature-flags
        version: 0.1.0
    ```

2. Add service configuration and binding in _chart/values.yaml_:

    ```yaml
    feature-flags:
      serviceOfferingName: feature-flags
      servicePlanName: lite
    ...
    srv:
       bindings:
         feature-flags:
            serviceInstanceName: feature-flags
    ```

    > The `alias` property in `dependencies` must match the property added in the root of _chart/values.yaml_ and the value of `serviceInstanceName` in the binding.

::: details Additional requirements for the SAP Connectivity service...

To access the SAP Connectivity service, add the following modules in your Kyma Cluster:

- connectivity-proxy
- transparent-proxy
- istio

You can do so using the `kubectl` CLI:

```sh
kubectl edit kyma default -n kyma-system
```

Then, add the three modules:
::: code-group
```yaml [editor]
spec:
  modules:
    - name: connectivity-proxy
    - name: transparent-proxy
    - name: istio
```
:::

Finally, you should see a success message as follows:

```sh
kyma.operator.kyma-project.io/default edited
```

[Learn more about adding modules from the Kyma Dashboard.](https://help.sap.com/docs/btp/sap-business-technology-platform/enable-and-disable-kyma-module?version=Cloud#loio1b548e9ad4744b978b8b595288b0cb5c){.learn-more}


#### Configuration Options for Services

_Services have the following configuration options:_

::: code-group
```yaml [values.yaml]
### Required ###
serviceOfferingName: my-service
servicePlanName: my-plan

### Optional ###

# Use instead of generated nname
fullNameOverride: <use instead of the generated name>

# Name for service instance in SAP BTP
externalName: <name for service instance in SAP BTP>

# List of tags describing service,
# copied to ServiceBinding secret in a 'tags' key
customTags:
  - foo
  - bar

# Some services support additional configuration,
# as found in the respective service offering
parameters:
  key: val
jsonParameters: {}

# List of secrets from which parameters are populated
parametersFrom:
  - secretKeyRef:
      name: my-secret
      key: secret-parameter
```
:::

The `jsonParameters` key can also be specified using the `--set file` flag while installing/upgrading Helm release. For example, `jsonParameters` for the `xsuaa` property can be defined using the following command:

```sh
helm install bookshop ./chart \
  --set-file xsuaa.jsonParameters=xs-security.json
```

> You can explore more configuration options in the subchart's directory _gen/chart/charts/service-instance_.

#### Configuration Options for Service Bindings

::: code-group
``` yaml [values.yaml]
<service name>:
  # Exactly one of these must be specified
  serviceInstanceName: my-service # within Helm chart
  serviceInstanceFullname: my-service-full-name # using absolute name
  # Additional parameters
  parameters:
    key: val
```
:::

#### Configuration Options for Container Images

::: code-group
``` yaml [values.yaml]
repository: my-repo.docker.io # container repo name
tag: latest # optional container image version tag
```
:::

#### HTML5 Applications

::: code-group
``` yaml [values.yaml]
html5-apps-deployer:
  image:
  bindings:
  resources:
  env:
    # Name of your business service (unique per subaccount)
    SAP_CLOUD_SERVICE: <service-name>
```
:::

[Container image]: #configuration-options-for-container-images
[HTML5 application deployer]: https://help.sap.com/docs/BTP/65de2977205c403bbc107264b8eccf4b/9b178ab3388c4647b0c52f2c85641844.html
[Kubernetes Container resources]: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/

#### Backend Destinations

Backend destinations maybe required for HTML5 applications or for App Router deployment. They can be configured using `backendDestinations`.

If you want to add an external destination, you can do so by providing the `external` property like this:

::: code-group
``` yaml [values.yaml]
...
srv: # Key is the target service, e.g. 'srv'
  backendDestinations:
    srv-api:
      service: srv
    ui5: # [!code ++]
      external: true # [!code ++]
      name: ui5 # [!code ++]
      Type: HTTP # [!code ++]
      proxyType: Internet # [!code ++]
      url: https://ui5.sap.com # [!code ++]
      Authentication: NoAuthentication # [!code ++]
```
:::

> Our Helm chart will remove the `external` key and add the rest of the keys as-is to the environment variable.

### Modify

Modifying the Helm chart allows you to customize it to your needs. However, this has consequences if you want to update with the latest changes from the CAP template.

You can run `cds add helm` again to update your Helm chart. It has the following behavior for modified files:

1. Your changes of the _chart/values.yaml_ and _chart/Chart.yaml_ will not be modified. Only new or missing properties will be added by `cds add helm`.
2. To modify any of the generated files such as templates or subcharts, copy the files from _gen/chart_ folder and place it in the same level inside the _chart_ folder. After the next `cds build` executions the generated chart will have the modified files.
3. If you want to have some custom files such as templates or subcharts, you can place them in the _chart_ folder at the same level where you want them to be in _gen/chart_ folder. They will be copied as is.

### Extend

Instead of modifying consider extending the CAP Helm chart. Just make sure adding new files to the Helm chart does not conflict with `cds add helm`.

::: tip Consider Kustomize
A modification-free approach to change files is to use [Kustomize](https://kustomize.io/) as a [post-processor](https://helm.sh/docs/topics/advanced/#post-rendering) for your Helm chart. This might be usable for small changes if you don't want to branch-out from the generated `cds add helm` content.
:::


### Services from Cloud Foundry

To bind service instances created on Cloud Foundry (CF) to a workload (`srv`, `hana-deployer`, `html5-deployer`, `approuter` or `sidecar`) in the Kyma environment, do the following:

1. Create a secret with credentials from the service key of that instance.

2. Use the `fromSecret` property inside the `bindings` key of the workload.

For example, if you want to use an `hdi-shared` instance created on CF:

1. [Create a Kubernetes secret](https://kubernetes.io/docs/concepts/configuration/secret/#creating-a-secret) with service key credentials from CF
2. Add additional properties to the Kubernetes secret:

    ```yaml
    stringData:
      # <…>
      .metadata: |
        {
          "credentialProperties":
            [
              { "name": "certificate", "format": "text"},
              { "name": "database_id", "format": "text"},
              { "name": "driver", "format": "text"},
              { "name": "hdi_password", "format": "text"},
              { "name": "hdi_user", "format": "text"},
              { "name": "host", "format": "text"},
              { "name": "password", "format": "text"},
              { "name": "port", "format": "text"},
              { "name": "schema", "format": "text"},
              { "name": "url", "format": "text"},
              { "name": "user", "format": "text"}
            ],
          "metaDataProperties":
            [
              { "name": "plan", "format": "text" },
              { "name": "label", "format": "text" },
              { "name": "type", "format": "text" },
              { "name": "tags", "format": "json" }
            ]
        }
      type: hana
      label: hana
      plan: hdi-shared
      tags: '[ "hana", "database", "relational" ]'
    ```

    > Update the values of the properties accordingly.

3. Change `serviceInstanceName` to `fromSecret` for each workload with that service instance in `bindings` in _chart/values.yaml_:

    ```yaml [values.yaml]
    …
    srv:
      bindings:
        db:
            serviceInstanceName: ## [!code --]
            fromSecret: <your secret> ## [!code ++]
    hana-deployer:
      bindings:
        hana:
          serviceInstanceName: ## [!code --]
          fromSecret: <your secret> ## [!code ++]
    ```

4. Delete `hana` in _chart/values.yaml_:

      ```yaml
      …
      hana: ## [!code --]
        serviceOfferingName: hana ## [!code --]
        servicePlanName: hdi-shared ## [!code --]
      …
      ```

5. Make the following changes to _chart/Chart.yaml_:

      ```yaml
      …
      dependencies:
        …
        - name: service-instance ## [!code --]
          alias: hana ## [!code --]
          version: ">0.0.0" ## [!code --]
        …
      ```

### Cloud Native Buildpacks

Cloud Native Buildpacks provide advantages like embracing [best practices](https://buildpacks.io/features/) and secure standards such as:

+ Resulting images use an unprivileged user
+ Builds are [reproducible](https://buildpacks.io/docs/features/reproducibility/)
+ [Software Bill of Materials](https://buildpacks.io/docs/features/bill-of-materials/) (SBoM) baked into the image
+ Auto-detection of base images

Additionally Cloud Native Buildpacks can be easily plugged together to fulfill more complex requirements. For example the [ca-certificates](https://github.com/paketo-buildpacks/ca-certificates) enables adding additional certificates to the system trust-store at build and runtime. When using Cloud Native Buildpacks you can continuously benefit from best practices coming from the community without any changes required.

[Learn more about Cloud Native Buildpacks Concepts.](https://buildpacks.io/docs/concepts/){ .learn-more}

<div id="aftercloudnative" />
<Fragment target="#aftercloudnative">

Furthermore, some required SAP compliance steps are fulfilled that way.

[Learn more about How to Build Enterprise-Grade Container Images](https://pages.github.tools.sap/unified-runtime/blog/2022/01/26/how-to-build-enterprise-grade-container-images/){ .learn-more}

</Fragment>

<div id="secondary-file">guides/deployment/to-kyma.fragment.md</div>


# Deploy using CI/CD Pipelines
A comprehensive guide to implementing continuous integration and continuous deployment (CI/CD) for CAP projects using best practices, tools, and services.

<span id="afterstart" />
<Fragment target="#afterstart">

## Hyperspace <Internal />

[Hyperspace](https://sap.sharepoint.com/sites/124706) provides centrally operated state-of-the-art tools and services, which can be used by teams to create or enhance their custom-made software development and delivery process. All Hyperspace offerings comply with SAP-specific requirements such as Products Standards, Corporate Requirements, and others.

Hyperspace provides CI/CD for the [Golden Path](https://pages.github.tools.sap/cap/golden-path/deploy/with-ci-cd/via-cicd).
There are dedicated [templates for CAP applications](https://hyperspace.tools.sap/docs/features_and_use_cases/use_cases/pipeline-template/full-stack-applications.html), both for Node.js and for Java.

</Fragment>

<span id="beforecicd" />
<Fragment target="#beforecicd">

## Deploy With Confidence <Internal />

Using [Deploy with Confidence](https://pages.github.tools.sap/deploy-with-confidence/solar-system/documentation/) you can assure consistent deployment and activation of large microservice-based SaaS applications. This includes:

- End-to-End testing in contrast to unit testing.
- Feature toggling based on single trunk master versions only.
- High resiliency and robustness by assuring that the vector of individual units remains immutable for all requests
- True-zero downtime, which assures that users stay on the same (immutable) vector of service versions for the duration of their session.
- and more

See the examples:
- [Develop and deploy a Java Spring Boot service.](https://pages.github.tools.sap/deploy-with-confidence/solar-system/how-to-guides/application-development/development/java_spring_boot_mta_cap/)
- [Develop an MTA Java CAP service with MTXS sidecar.](https://pages.github.tools.sap/deploy-with-confidence/solar-system/how-to-guides/application-development/development/mta_java_cap_mtxs)

[Learn more in the Deploy with Confidence (Java) guide.](dwc){.learn-more}
[Check out the integration into Hyperspace](https://pages.github.tools.sap/hyperspace/academy/pavedroad/BTP_DwC/){.learn-more}

</Fragment>

## SAP Continuous Integration and Delivery

[SAP Continuous Integration and Delivery](https://help.sap.com/viewer/SAP-Cloud-Platform-Continuous-Integration-and-Delivery) lets you configure and run predefined continuous integration and delivery pipelines. It connects with your Git SCM repository and in its user interface, you can easily monitor the status of your builds and detect errors as soon as possible, which helps you prevent integration problems before completing your development.

SAP Continuous Integration and Delivery has a ready-to-use pipeline for CAP, that is applicable to Node.js, Java and multitarget application (MTA) based projects. It does not require you to host your own Jenkins instance and it provides an easy, UI-guided way to configure your pipelines.

Try the tutorial [Get Started with SAP Continuous Integration and Delivery](https://developers.sap.com/tutorials/cicd-start-cap.html) to configure a CI/CD pipeline that builds, tests, and deploys your code changes.

## CI/CD Pipelines with SAP Piper

For more flexibility you can set up continuous delivery in your software development project, applicable to both SAP Business Technology Platform (BTP) and SAP on-premise platforms. SAP implements tooling for continuous delivery in project [Piper](https://www.project-piper.io/).

Try the tutorial [Create Automated System Tests for SAP Cloud Application Programming Model Projects](https://developers.sap.com/tutorials/cicd-wdi5-cap.html) to create system tests against a CAP-based sample application and automate your tests through a CI/CD pipeline.

[See a comparison with SAP Continuous Integration and Delivery Service.](https://www.project-piper.io/){.learn-more}

## GitHub Actions

GitHub offers continuous integration workflows using [GitHub Actions](https://docs.github.com/en/actions/automating-builds-and-tests/about-continuous-integration). In our [SFlight sample,](https://github.com/SAP-samples/cap-sflight) we use GitHub Actions in two simple workflows to test our samples on [current Node.js and Java versions](https://github.com/SAP-samples/cap-sflight/tree/main/.github/workflows).


<div id="secondary-file">guides/deployment/cicd.fragment.md</div>


# Health Checks

On both Cloud Foundry and Kubernetes, it is possible to provide two separate endpoints for liveness checks ("are you alive?") and readiness checks ("are you ready for more requests?").
A failure on the former leads to a restart, whereas a failure on the latter temporarily takes the app instance out of the request dispatching rotation until a subsequent readiness probe is successful.

[Learn more about health checks on Cloud Foundry.](https://docs.cloudfoundry.org/devguide/deploy-apps/healthchecks.html) {.learn-more}

[Learn more about health checks on Kubernetes.](https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes) {.learn-more}

::: warning Limited support for readiness checks on CF
Although supported by the Cloud Foundry core, readiness checks are not yet supported by the Cloud Foundtry CLI as well as the Cloud MTA Build Tool (MBT).
:::

The Node.js runtime provides an out-of-the-box endpoint for liveness and readiness checks at `/health`.
Requests that reach this public endpoint are answered with the status code 200 and the body `{ status: 'UP' }`.

For CAP Java, the `cds add` facets `mta`, `cf-manifest`, `helm`, and `helm-unified-runtime` add the necessary dependencies and configuration for the publicly available probe endpoints `/actuator/health/liveness` and `/actuator/health/readiness`.
For more details on adding Spring Boot health checks to your CAP Java app, please see [Spring Boot Health Checks](../../java/operating-applications/observability#spring-health-checks).



For deployment to Kyma/ Kubernetes, `@sap/cds-dk` adds the necessary configurations to Helm charts to make the setup complete.
Once supported, `@sap/cds-dk` will also add the necessary configurations to MTA deployment descriptors.

::: tip
Don't forget to adjust the values in your deployment descriptors in case you add different Spring Boot health check endpoints or use a _fully custom_ `server.js`.
:::

[Learn more about availability checks in Node.js.](../../node.js/best-practices#availability-checks) {.learn-more}

[Learn more about availability checks in Java.](../../java/operating-applications/observability#availability) {.learn-more}



# Multitenancy

## Introduction & Overview

CAP has built-in support for multitenancy with [the `@sap/cds-mtxs` package](https://www.npmjs.com/package/@sap/cds-mtxs).

Essentially, multitenancy is the ability to serve multiple tenants through single clusters of microservice instances, while strictly isolating the tenants' data. Tenants are clients using SaaS solutions.

In contrast to single-tenant mode, applications wait for tenants to subscribe before serving any end-user requests.

[Learn more about SaaS applications.](#about-saas-applications){.learn-more}

<ImplVariantsHint />

## Prerequisites

Make sure you have the latest version of `@sap/cds-dk` installed:

```sh
npm update -g @sap/cds-dk
```

## Jumpstart with an application

To get a ready-to-use _bookshop_ application you can modify and deploy, run:

::: code-group

```sh [Node.js]
cds init bookshop --add sample
cd bookshop
```

```sh [Java]
cds init bookshop --java --add tiny-sample
cd bookshop
```

:::

## Enable Multitenancy {#enable-multitenancy}

Now, you can run this to enable multitenancy for your CAP application:

```sh
cds add multitenancy
```

<div class="impl node">

::: details See what this adds to your Node.js project…

1. Adds package `@sap/cds-mtxs` to your project:

   ```jsonc
   {
      "dependencies": {
         "@sap/cds-mtxs": "^3"
      },
   }
   ```

2. Adds this configuration to your _package.json_ to enable multitenancy with sidecar:

   ```jsonc
   {
     "cds": {
       "profile": "with-mtx-sidecar",
        "requires": {
          "[production]": {
            "multitenancy": true
          }
       }
     }
   }
   ```

3. Adds a sidecar subproject at `mtx/sidecar` with this _package.json_:

   ```json
   {
     "name": "bookshop-mtx",
     "dependencies": {
       "@cap-js/hana": "^2",
       "@sap/cds": "^9",
       "@sap/cds-mtxs": "^3",
       "@sap/xssec": "^4",
       "express": "^4"
     },
     "devDependencies": {
       "@cap-js/sqlite": "^2"
     },
     "engines": {
       "node": ">=20"
     },
     "scripts": {
       "start": "cds-serve"
     },
     "cds": {
       "profile": "mtx-sidecar"
     }
   }
   ```

4. If necessary, modifies deployment descriptors such as `mta.yaml` for Cloud Foundry and Helm charts for Kyma.

:::

</div>

<div class="impl java">

::: details See what this adds to your Java project…

1. Adds the following to _.cdsrc.json_ in your app:

   ```jsonc
   {
     "profiles": [
       "with-mtx-sidecar",
       "java"
     ],
     "requires": {
       "[production]": {
         "multitenancy": true
       }
     }
   }
   ```

2. Adds the following to your _srv/pom.xml_ in your app:

    ```xml
    <dependency>
        <groupId>com.sap.cds</groupId>
        <artifactId>cds-feature-mt</artifactId>
        <scope>runtime</scope>
    </dependency>
    ```

3. Adds the following to your _srv/src/java/resources/application.yaml_:

    ```yml
    ---
    spring:
      config.activate.on-profile: cloud
    cds:
      multi-tenancy:
        mtxs.enabled: true

    ```

1. Adds a sidecar subproject at `mtx/sidecar` with this _package.json_:

   ```json
   {
     "name": "bookshop-mtx",
     "dependencies": {
       "@cap-js/hana": "^2",
       "@sap/cds": "^9",
       "@sap/cds-mtxs": "^3",
       "@sap/xssec": "^4",
       "express": "^4"
     },
     "devDependencies": {
       "@cap-js/sqlite": "^2"
     },
     "scripts": {
       "start": "cds-serve",
       "build": "cds build ../.. --for mtx-sidecar --production && npm ci --prefix gen"
     },
     "cds": {
       "profile": "mtx-sidecar"
     }
   }
   ```

:::

</div>

::: details Profile-based configuration presets

   The profiles `with-mtx-sidecar` and `mtx-sidecar` activate pre-defined configuration presets, which are defined as follows:

   ```js
   {
     "[with-mtx-sidecar]": { // [!code focus]
       requires: {
         db: {
           '[development]': {
              kind: 'sqlite',
              credentials: { url: 'db.sqlite' },
              schema_evolution: 'auto',
            },
           '[production]': {
              kind: 'hana',
              'deploy-format': 'hdbtable',
              'vcap': {
                'label': 'service-manager'
              }
            },
         },
         "[java]": {
           "cds.xt.ModelProviderService": { kind: 'rest', model:[] },
           "cds.xt.DeploymentService": { kind: 'rest', model:[] },
         },
         "cds.xt.SaasProvisioningService": false,
         "cds.xt.DeploymentService": false,
         "cds.xt.ExtensibilityService": false,
       }
     },
     "[mtx-sidecar]": { // [!code focus]
       requires: {
         db: {
           "[development]": {
              kind: 'sqlite',
              credentials: { url: "../../db.sqlite" },
              schema_evolution: 'auto',
            },
           "[production]": {
              kind: 'hana',
              'deploy-format': 'hdbtable',
              'vcap': {
                'label': 'service-manager'
              }
            },
         },
         "cds.xt.ModelProviderService": {
           "[development]": { root: "../.." }, // sidecar is expected to reside in ./mtx/sidecar
           "[production]": { root: "_main" },
           "[prod]": { root: "_main" } // for simulating production in local tests
         },
         "cds.xt.SaasProvisioningService": true,
         "cds.xt.DeploymentService": true,
         "cds.xt.ExtensibilityService": true,
       },
       "[development]": {
         server: { port: 4005 }
       }
     },
     …
   }
   ```

  ::: tip Inspect configuration
  You can always inspect the _effective_ configuration with `cds env`.
  :::

## Install Dependencies

<div class="impl node">

After adding multitenancy, install your application dependencies:

```sh
npm i
```

</div>

<div class="impl java">

After adding multitenancy, Maven build should be used to generate the model related artifacts:

```sh
mvn install
```

:::warning Error message: 'Invalid MTX sidecar configuration'
If you get the message 'Invalid MTX sidecar configuration', you need to add the dependency to `@sap/cds-mtxs` also to the `package.json` in your project root.
This is a known issue in CDS 9.
:::

</div>

## Test-Drive Locally {#test-locally}

For local testing, create a new profile that contains the multitenancy configuration:

```sh
cds add multitenancy --for local-multitenancy
```

<div class="impl java">

  For multitenancy you need additional dependencies in the _pom.xml_ of the `srv` directory. To support mock users in the local test scenario add `cds-starter-cloudfoundry`:

  ```xml
  <dependency>
    <groupId>com.sap.cds</groupId>
    <artifactId>cds-starter-cloudfoundry</artifactId>
  </dependency>
  ```

  Then you add additional mock users to the spring-boot profile:

  ::: code-group

  ```yaml [application.yaml]
  ---
  spring:
    config.activate.on-profile: local-multitenancy
  #...
  cds:
    multi-tenancy:
      mtxs.enabled: true
    security.mock.users: // [!code focus]
      - name: alice // [!code focus]
        tenant: t1
        roles: [ admin ]
      - name: bob // [!code focus]
        tenant: t1
        roles: [ cds.ExtensionDeveloper ]
      - name:  erin // [!code focus]
        tenant: t2
        roles: [ admin, cds.ExtensionDeveloper ]
  ```

  :::

Configure the sidecar to use dummy authentication.

::: code-group

```json [mtx/sidecar/package.json]
{
  "cds": {
    "profile": "mtx-sidecar",
    "[development]": {
      "requires": {
        "auth": "dummy"
      }
    }
  }
}
```

:::

</div>

Before deploying to the cloud, you can test-drive common SaaS operations with your app locally, including SaaS startup, subscribing tenants, and upgrading tenants.

::: details Using multiple terminals…
In the following steps, we start two servers, the main app and MTX sidecar, and execute some CLI commands. So, you need three terminal windows.
:::

### 1. Start MTX Sidecar

   ```sh
   cds watch mtx/sidecar
   ```

   ::: details  Trace output explained

   In the trace output, we see several MTX services being served; most interesting for multitenancy: the _ModelProviderService_ and the _DeploymentService_.

   ```log
   [cds] - connect using bindings from: { registry: '~/.cds-services.json' }
   [cds] - connect to db > sqlite { url: '../../db.sqlite' }
   [cds] - serving cds.xt.ModelProviderService { path: '/-/cds/model-provider' } // [!code focus]
   [cds] - serving cds.xt.DeploymentService { path: '/-/cds/deployment' } // [!code focus]
   [cds] - serving cds.xt.SaasProvisioningService { path: '/-/cds/saas-provisioning' }
   [cds] - serving cds.xt.ExtensibilityService { path: '/-/cds/extensibility' }
   [cds] - serving cds.xt.JobsService { path: '/-/cds/jobs' }
   ```

   In addition, we can see a `t0` tenant being deployed, which is used by the MTX services for book-keeping tasks.

   ```log
   [cds] - loaded model from 1 file(s):

     ../../db/t0.cds

   [mtx|t0] - (re-)deploying SQLite database for tenant: t0 // [!code focus]
   /> successfully deployed to db-t0.sqlite // [!code focus]
   ```

   With that, the server waits for tenant subscriptions, listening on port 4005 by default in development mode.

   ```log
   [cds] - server listening on { url: 'http://localhost:4005' } // [!code focus]
   [cds] - launched at 3/5/2023, 1:49:33 PM, version: 7.0.0, in: 1.320s
   [cds] - [ terminate with ^C ]
   ```

   :::

   [If you get an error on server start, read the troubleshooting information.](/get-started/troubleshooting#why-do-i-get-an-error-on-server-start){.learn-more}

### 2. Launch App Server

<div class="impl node">

   ```sh
   cds watch --profile local-multitenancy
   ```

   ::: details  Persistent database

   The server starts as usual, but automatically uses a persistent database instead of an in-memory one:

   ```log
   [cds] - loaded model from 6 file(s):

     db/schema.cds
     srv/admin-service.cds
     srv/cat-service.cds
     srv/user-service.cds
     ../../../cds-mtxs/srv/bootstrap.cds
     ../../../cds/common.cds

   [cds] - connect using bindings from: { registry: '~/.cds-services.json' }
   [cds] - connect to db > sqlite { url: 'db.sqlite' } // [!code focus]
   [cds] - serving AdminService { path: '/odata/v4/admin', impl: 'srv/admin-service.js' }
   [cds] - serving CatalogService { path: '/odata/v4/catalog', impl: 'srv/cat-service.js' }
   [cds] - serving UserService { path: '/user', impl: 'srv/user-service.js' }

   [cds] - server listening on { url: 'http://localhost:4004' }
   [cds] - launched at 3/5/2023, 2:21:53 PM, version: 6.7.0, in: 748.979ms
   [cds] - [ terminate with ^C ]
   ```

   :::

</div>

  <div class="impl java">

  ```sh
  cd srv
  mvn cds:watch -Dspring-boot.run.profiles=local-multitenancy
  ```

  ::: details  Persistent database

  The server starts as usual, with the difference that a persistent database is used automatically instead of an in-memory one:

  ```log
  2023-03-31 14:19:23.987  INFO 68528 --- [  restartedMain] c.s.c.bookshop.Application               : The following 1 profile is active: "local-mtxs"
  ...
  2023-03-31 14:19:23.987  INFO 68528 --- [  restartedMain] c.s.c.services.impl.ServiceCatalogImpl   : Registered service ExtensibilityService$Default
  2023-03-31 14:19:23.999  INFO 68528 --- [  restartedMain] c.s.c.services.impl.ServiceCatalogImpl   : Registered service CatalogService
  2023-03-31 14:19:24.016  INFO 68528 --- [  restartedMain] c.s.c.f.s.c.runtime.CdsRuntimeConfig     : Registered DataSource 'ds-mtx-sqlite'// [!code focus]
  2023-03-31 14:19:24.017  INFO 68528 --- [  restartedMain] c.s.c.f.s.c.runtime.CdsRuntimeConfig     : Registered TransactionManager 'tx-mtx-sqlite'// [!code focus]
  2023-03-31 14:19:24.554  INFO 68528 --- [  restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)
  2023-03-31 14:19:24.561  INFO 68528 --- [  restartedMain] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
  2023-03-31 14:19:24.561  INFO 68528 --- [  restartedMain] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.71]
  ```

  :::

  </div>

### 3. Subscribe Tenants

In the third terminal, subscribe to two tenants using one of the following methods.

   ::: code-group

   ```sh [CLI]
   cds subscribe t1 --to http://localhost:4005 -u yves:
   cds subscribe t2 --to http://localhost:4005 -u yves:
   ```

   ```http
   POST http://localhost:4005/-/cds/deployment/subscribe HTTP/1.1
   Content-Type: application/json
   Authorization: Basic yves:

   { "tenant": "t1" }
   ```

   ```js [JavaScript]
   const ds = await cds.connect.to('cds.xt.DeploymentService')
   await ds.subscribe('t1')
   ```

   :::

   > Run `cds help subscribe` to see all available options.



   ::: details  `cds subscribe` explained

   1. Be reminded that these commands are only relevant for local testing. For a deployed app, [subscribe to your tenants](#subscribe) through the BTP cockpit.

   2. In the CLI commands, we use the pre-defined mock user `yves`, see [pre-defined mock users](../../node.js/authentication#mock-users).

   3. The subscription is sent to the MTX sidecar process (listening on port **4005**)

   4. The sidecar reacts with trace outputs like this:

      ```log
      [cds] - POST /-/cds/deployment/subscribe
      ...
      [mtx] - successfully subscribed tenant t1 // [!code focus]
      ```

   5. In response to each subscription, the sidecar creates a new persistent tenant database per tenant, keeping tenant data isolated:

      ```log
      [cds] - POST /-/cds/deployment/subscribe
      [mtx] - (re-)deploying SQLite database for tenant: t1 // [!code focus]
      > init from db/init.js // [!code focus]
      > init from db/data/sap.capire.bookshop-Authors.csv // [!code focus]
      > init from db/data/sap.capire.bookshop-Books.csv // [!code focus]
      > init from db/data/sap.capire.bookshop-Books_texts.csv // [!code focus]
      > init from db/data/sap.capire.bookshop-Genres.csv // [!code focus]
      /> successfully deployed to ./../../db-t1.sqlite  // [!code focus]

      [mtx] - successfully subscribed tenant t1
      ```

   6. To unsubscribe a tenant, run:

      ```sh
      cds unsubscribe ‹tenant› --from http://localhost:4005 -u ‹user›
      ```

        > Run `cds help unsubscribe` to see all available options.
  :::

#### Test with Different Users/Tenants {.node}

Open the _Manage Books_ app at <http://localhost:4004/#Books-manage> and log in with `alice`. Select **Wuthering Heights** to open the details, edit here the title and save your changes. You've changed data in one tenant.

To see requests served in tenant isolation, that is, from different databases, check that it's not visible in the other one. Open a private/incognito browser window and log in as `erin` to see that the title still is _Wuthering Heights_.

In the following example, _Wuthering Heights (only in t1)_ was changed by _alice_.  _erin_ doesn't see it, though.

![A screenshot of the bookshop application showing the effect of tenant isolation logged in as _alice_, as described in the previous sentence.](assets/book-changed-t1.png){}

   ::: details Use private/incognito browser windows to test with different tenants...

   Do this to force new logins with different users, assigned to different tenants:

   1. Open a new _private_ / _incognito_ browser window.
   2. Open <http://localhost:4004/#Books-manage> in it &rarr; log in as `alice`.
   3. Repeat that with `erin`, another pre-defined user, assigned to tenant `t2`.

   :::

   ::: details Note tenants displayed in trace output...

   We can see tenant labels in server logs for incoming requests:

   ```log
   [cds] - server listening on { url: 'http://localhost:4004' }
   [cds] - launched at 3/5/2023, 4:28:05 PM, version: 6.7.0, in: 736.445ms
   [cds] - [ terminate with ^C ]

   ...
   [odata|t1] - POST /adminBooks { '$count': 'true', '$select': '... } // [!code focus]
   [odata|t2] - POST /adminBooks { '$count': 'true', '$select': '... }  // [!code focus]
   ...
   ```

   :::

   ::: details Pre-defined users in `mocked-auth`

   How users are assigned to tenants and how tenants are determined at runtime largely depends on your identity providers and authentication strategies. The `mocked` authentication strategy, used by default with `cds watch`, has a few [pre-defined users](../../node.js/authentication#mock-users) configured. You can inspect these by running `cds env requires.auth`:

   ```js
   [bookshop] cds env requires.auth
   {
    kind: 'basic-auth',
    strategy: 'mock',
    users: {
      alice: { tenant: 't1', roles: [ 'admin' ] },
      bob:   { tenant: 't1', roles: [ 'cds.ExtensionDeveloper' ] },
      carol: { tenant: 't1', roles: [ 'admin', 'cds.ExtensionDeveloper' ] },  // [!code focus]
      dave:  { tenant: 't1', roles: [ 'admin' ], features: [] },
      erin:  { tenant: 't2', roles: [ 'admin', 'cds.ExtensionDeveloper' ] },  // [!code focus]
      fred:  { tenant: 't2', features: ... },
      me:    { tenant: 't1', features: ... },
      yves:  { roles: [ 'internal-user' ] }
      '*':     true //> all other logins are allowed as well
    },
    tenants: { t1: { features: … }, t2: { features: '*' } }
   }
   ```

   You can also add or override users or tenants by adding something like this to your _package.json_:

   ```jsonc
   "cds":{
    "requires": {
      "auth": {
        "users": {
          "u2": { "tenant": "t2" }, // [!code focus]
          "u3": { "tenant": "t3" } // [!code focus]
        }
      }
    }
   }
   ```

   :::

### 4. Upgrade Your Tenant

When deploying new versions of your app, you also need to upgrade your tenants' databases. For example, open `db/data/sap.capire.bookshop-Books.csv` and add one or more entries in there. Then upgrade tenant `t1` as follows:

   ::: code-group

   ```sh [CLI]
   cds upgrade t1 --at http://localhost:4005 -u yves:
   ```

   ```http
   POST http://localhost:4005/-/cds/deployment/upgrade HTTP/1.1
   Content-Type: application/json
   Authorization: Basic yves:

   { "tenant": "t1" }
   ```

   ```js [JavaScript]
   const ds = await cds.connect.to('cds.xt.DeploymentService')
   await ds.upgrade('t1')
   ```

   :::



<div class="impl node">

Now, open or refresh <http://localhost:4004/#Books-manage> again as _alice_ and _erin_ &rarr; the added entries are visible for _alice_, but still missing for _erin_, as `t2` has not yet been upgraded.

</div>

## Deploy to Cloud

### Cloud Foundry / Kyma

In order to get your multitenant application deployed, follow this excerpt from the [deployment to CF](../deployment/to-cf) and [deployment to Kyma](../deployment/to-kyma) guides.

Once: Add SAP HANA Cloud, XSUAA, and [App Router](../deployment/to-cf#add-app-router) configuration. The App Router acts as a single point-of-entry gateway to route requests to. In particular, it ensures user login and authentication in combination with XSUAA.

```sh
cds add hana,xsuaa
```

If you intend to serve UIs you can easily set up the SAP Cloud Portal service:

```sh
cds add portal
```

Once: add a **deployment descriptor**:

::: code-group

```sh [Cloud Foundry]
cds add mta
```

```sh [Kyma]
cds add helm,containerize
```

:::

::: details Add xsuaa redirect for trial / extension landscapes
Add the following snippet to your _xs-security.json_ and adapt it to the landscape you're deploying to:

```json
  "oauth2-configuration": {
    "redirect-uris": ["https://*.cfapps.us10-001.hana.ondemand.com/**"]
  }
```

:::

[Learn more about configured BTP services for SaaS applications.](#behind-the-scenes){.learn-more}


::: code-group

```sh [Cloud Foundry]
cds up
```

```sh [Kyma]
cds up --to k8s
```

:::

### Subscribe

**Create a BTP subaccount** to subscribe to your deployed application. This subaccount has to be in the same region as the provider subaccount, for example, `us10`.

See the [list of all available regions](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/f344a57233d34199b2123b9620d0bb41.html). {.learn-more}

![Global Account view to create a subaccount.](assets/create-subaccount.png){.mute-dark}

In your **subscriber account** go to _Instances and Subscription_ and select _Create_.

![The screenshot is explained in the accompanying text.](assets/sub-account.png){.mute-dark}

Select _bookshop_ and use the only available plan _default_.

![The screenshot is explained in the accompanying text.](assets/subscribe-bookshop.png){.mute-dark}

[Learn more about subscribing to a SaaS application using the SAP BTP cockpit.](https://help.sap.com/docs/btp/sap-business-technology-platform/subscribe-to-multitenant-applications-using-cockpit?version=Cloud#procedure){.learn-more}
[Learn more about subscribing to a SaaS application using the `btp` CLI.](https://help.sap.com/docs/btp/btp-cli-command-reference/btp-subscribe-accounts-subaccount?locale=en-US){.learn-more}

You can now access your subscribed application via _Go to Application_.

![The screenshot is explained in the accompanying text.](assets/go-to-app.png){.mute-dark}

As you can see, your route doesn't exist yet. You need to create and map it first.

> If you're deploying to Kyma, your application will load and you won't get the below error. You can skip the step of exposing the route.

```log
404 Not Found: Requested route ('...') does not exist.
```

> Leave the window open. You need the information to create the route.

#### Cloud Foundry

Use the following command to create and map a route to your application:

```sh
cf map-route ‹app› ‹paasDomain› --hostname ‹subscriberSubdomain›-‹saasAppName›
```

In our example, let's assume our `saas-registry` is configured in the _mta.yaml_ like this:

```yaml
- name: bookshop-registry
  type: org.cloudfoundry.managed-service
  parameters:
    service: saas-registry
    service-plan: application
    config:
      appName: bookshop-${org}-${space} // [!code focus]
```

Let's also assume we've deployed to our app to Cloud Foundry org `myOrg` and space `mySpace`. This would be the full command to create a route for the subaccount with subdomain `subscriber1`:

```sh
cf map-route bookshop cfapps.us10.hana.ondemand.com --hostname subscriber1-myOrg-mySpace-bookshop
```

::: details Learn how to do this in the BTP cockpit instead…

Switch to your **provider account** and go to your space → Routes. Click on _New Route_.

![The screenshot is explained in the accompanying text.](assets/cockpit-routes.png){.mute-dark}

Here, you need to enter a _Domain_ and _Host Name_.

![The screenshot is explained in the accompanying text.](assets/cockpit-routes-new.png){.mute-dark}

Let's use this route as example:

_<https://subscriber1-bookshop.cfapps.us10.hana.ondemand.com>_

- The **Domain** here is _cfapps.us10.hana.ondemand.com_
- The **Host Name** here is _subscriber1-bookshop_

Hit _Save_ to create the route.

You can now see the route is created but not mapped to an application yet.

![The screenshot is explained in the accompanying text.](assets/cockpit-routes-new-overview.png){.mute-dark}

Click on _Map Route_, choose your App Router module and hit _Save_.

![The screenshot is explained in the accompanying text.](assets/cockpit-routes-new-map.png){.mute-dark}

You should now see the route mapped to your application.

![Overview in your dev space with the newly mapped route.](assets/cockpit-routes-new-mapped-overview.png){.mute-dark}

:::

### Update Database Schema

<div class="impl java">

[Learn best practices for schema updates in the Java Guide](/java/multitenancy#database-update){.learn-more}

</div>

<div class="impl node">

There are several ways to run the update of the database schema.

#### MTX Sidecar API

Please check the [Upgrade API](./mtxs#upgrade-tenants-→-jobs) to see how the database schema update can be run for single or all tenants using the API endpoint.

#### `cds-mtx upgrade` Command

The database schema upgrade can also be run using `cds-mtx upgrade <tenant|*>`. The command must be run in the MTX sidecar root directory.

##### Run as Cloud Foundry hook

Example definition for a [module hook](https://help.sap.com/docs/btp/sap-business-technology-platform/module-hooks):

```yaml
hooks:
  - name: upgrade-all
    type: task
    phases:
    # - blue-green.application.before-start.idle
      - deploy.application.before-start
    parameters:
      name: upgrade
      memory: 512M
      disk-quota: 768M
      command: cds-mtx upgrade '*'
```

[Blue-green deployment strategy for MTAs](https://help.sap.com/docs/btp/sap-business-technology-platform/blue-green-deployment-strategy){.learn-more}

##### Manually run as Cloud Foundry Task

You can also invoke the command manually using `cf run-task`:

```sh
cf run-task <app> --name "upgrade-all" --command "cds-mtx upgrade '*'"
```

</div>

### Test-Drive with Hybrid Setup

For faster turnaround cycles in development and testing, you can run the app locally while binding it to remote service instances created by a Cloud Foundry deployment.

To achieve this, bind your SaaS app and the MTX sidecar to its required cloud services, for example:

```sh
cds bind --to-app-services bookshop-srv
```

For testing the sidecar, make sure to run the command there as well:

```sh
cd mtx/sidecar
cds bind --to-app-services bookshop-srv
```

To generate the SAP HANA HDI files for deployment, go to your project root and run the build:

```sh
cds build --production
```

::: warning Run `cds build` after model changes
Each time you update your model or any SAP HANA source file, you need repeat the build.
:::

> Make sure to stop any running CAP servers left over from local testing.

By passing `--profile hybrid` you can now run the app with cloud bindings and interact with it as you would while [testing your app locally](#test-locally). Run this in your project root:

```sh
cds watch mtx/sidecar --profile hybrid
```

And in another terminal:

<div class="impl java">

```sh
cd srv
mvn cds:watch -Dspring-boot.run.profiles=hybrid
```

</div>

<div class="impl node">

```sh
cds watch --profile hybrid
```

</div>

Learn more about [Hybrid Testing](../../advanced/hybrid-testing).{.learn-more}

::: tip Manage multiple deployments
Use a dedicated profile for each deployment landscape if you are using several, such as `dev`, `test`, `prod`. For example, after logging in to your `dev` space:

```sh
cds bind -2 bookshop-db --profile dev
cds watch --profile dev
```

:::

## SaaS Dependencies {#saas-dependencies}
Some of the xsuaa-based services your application consumes need to be registered as _reuse services_ to work in multitenant environments. This holds true for the usage of both the SaaS Registry service and the Subscription Manager Service (SMS).

CAP Java as well as `@sap/cds-mtxs`, each offer an easy way to integrate these dependencies. They support some services out of the box and also provide a simple API for applications. Most notably, you need such dependencies for the following SAP BTP services: [Audit Log](https://discovery-center.cloud.sap/serviceCatalog/audit-log-service), [Event Mesh](https://discovery-center.cloud.sap/serviceCatalog/event-mesh), [Destination](https://discovery-center.cloud.sap/serviceCatalog/destination), [HTML5 Application Repository](https://discovery-center.cloud.sap/serviceCatalog/html5-application-repository-service), and [Cloud Portal](https://discovery-center.cloud.sap/serviceCatalog/cloud-portal-service).

For CAP Java, all these services are supported natively and SaaS dependencies are automatically created if such a service instance is bound to the CAP Java application, that is, the `srv` module.

:::tip Explicitly activate the Destination service
SaaS dependency for Destination service needs to be activated explicitly in the `application.yaml` due to security reasons. SaaS dependencies for some of the other services can be **de**activated by setting the corresponding property to `false` in the `application.yaml`.

Refer to the `cds.multiTenancy.dependencies` section in the [CDS properties](/java/developing-applications/properties#cds-properties).
:::

For CAP Node.js, all these services are supported natively and can be activated individually by providing configuration in `cds.requires`. In the most common case, you simply activate service dependencies like so:

::: code-group

```json [mtx/sidecar/package.json]
"cds": {
  "requires": {
    "audit-log": true,
    "connectivity": true,
    "destinations": true,
    "html5-repo": true,
    "portal": true
  }
}
```

:::

::: details Defaults provided by `@sap/cds-mtxs`...

The Boolean values in the _mtx/sidecar/package.json_ activate the default configuration in `@sap/cds-mtxs`:

```json
"cds": {
  "requires": {
    "connectivity": {
      // Uses credentials.xsappname
      "vcap": { "label": "connectivity" },
      "subscriptionDependency": "xsappname"
    },
    "portal": {
      "vcap": { "label": "portal" },
      // Uses credentials.uaa.xsappname
      "subscriptionDependency": {
        "uaa": "xsappname"
      }
    },
    ...
  }
}
```

:::

### Additional Services

In **CAP Java**, if your application uses a service that isn't supported out of the box, you can define dependencies by providing a custom handler.

[Learn more about defining dependent services](../../java/multitenancy#define-dependent-services){.learn-more}

In **CAP Node.js**, you can use a custom `subscriptionDependency` entry in your application's or CAP plugin's _package.json_:

```json [package.json]
"cds": {
  "requires": {
    "my-service": {
      "subscriptionDependency": "xsappname"
    }
  }
}
```

> The `subscriptionDependency` specifies the property name of the credentials value with the desired `xsappname`, starting from `cds.requires['my-service'].credentials`. Usually it's just `"xsappname"`, but JavaScript objects interpreted as a key path are also allowed, such as `{ "uaa": "xsappname" }` in the defaults example for `portal`.

Alternatively, overriding the [`dependencies`](./mtxs#get-dependencies) handler gives you full flexibility for any custom implementation.

<div id="subscriptiondashboard" />
<Fragment target="#subscriptiondashboard">

### Tenant Update

If your application integrates a new service that requires a new SaaS dependency, the dependency is only added for newly subscribed tenants. This handling applies to dependencies automatically added by CAP as well as custom-added dependencies by the application. A manual update of existing tenants is required and can be accomplished by using the API of the SaaS Registry or SMS service. Alternatively, you can use the [Subscription Management Dashboard](https://int.controlcenter.ondemand.com/index.html#/knowledge_center/articles/83aa3c1c02c34586a7e66c07019d0ccb).

</Fragment>

## Add Custom Handlers

MTX services are implemented as standard CAP services, so you can register for events just as you would for any application service.

### In the Java Main Project {.java}

For Java, you can add custom handlers to the main app as described in the [documentation](/java/multitenancy#custom-logic):

```java
@After
private void subscribeToService(SubscribeEventContext context) {
   String tenant = context.getTenant();
   Map<String, Object> options = context.getOptions();
}

@On
private void upgradeService(UpgradeEventContext context) {
   List<String> tenants = context.getTenants();
   Map<String, Object> options = context.getOptions();
}

@Before
private void unsubscribeFromService(UnsubscribeEventContext context) {
   String tenant = context.getTenant();
   Map<String, Object> options = context.getOptions();
}
```

### In the Sidecar Subproject

You can add custom handlers in the sidecar project, implemented in Node.js.

```js
cds.on('served', () => {
  const { 'cds.xt.DeploymentService': ds } = cds.services
  ds.before('subscribe', async (req) => {
    // HDI container credentials are not yet available here
    const { tenant } = req.data
  })
  ds.before('upgrade', async (req) => {
    // HDI container credentials are not yet available here
    const { tenant } = req.data
  })
  ds.after('deploy', async (result, req) => {
    const { container } = req.data.options
    const { tenant } = req.data
    ...
  })
  ds.after('unsubscribe', async (result, req) => {
    const { container } = req.data.options
    const { tenant } = req.data
  })
})

```



## Configuring the Java Service { #binding-it-together .java}

`cds add multitenancy` added configuration similar to this:

::: code-group

```yaml [mta.yaml (Cloud Foundry)]
modules:
  - name: bookshop-srv
    type: java
    path: srv
    parameters:
      ...
    provides:
      - name: srv-api # required by consumers of CAP services (e.g. approuter)
        properties:
          srv-url: ${default-url}
    requires:
      - name: app-api
        properties:
          CDS_MULTITENANCY_APPUI_URL: ~{url}
          CDS_MULTITENANCY_APPUI_TENANTSEPARATOR: "-"
      - name: bookshop-auth
      - name: bookshop-db
      - name: mtx-api
        properties:
          CDS_MULTITENANCY_SIDECAR_URL: ~{mtx-url}
      - name: bookshop-registry
```

```yaml [values.yaml (Kyma)]
...
srv:
  bindings:
    ...
  image:
    repository: bookshop-srv
  env:
    SPRING_PROFILES_ACTIVE: cloud
    CDS_MULTITENANCY_APPUI_TENANTSEPARATOR: "-"
    CDS_MULTITENANCY_APPUI_URL: https://{{ .Release.Name }}-srv-{{ .Release.Namespace }}.{{ .Values.global.domain }}
    CDS_MULTITENANCY_SIDECAR_URL: https://{{ .Release.Name }}-sidecar-{{ .Release.Namespace }}.{{ .Values.global.domain }}
  ...
```
:::

- `CDS_MULTITENANCY_SIDECAR_URL` sets the application property <Config java>cds.multitenancy.sidecar.url</Config>. This URL is required by the CAP Java runtime to connect to the MTX Sidecar application and is derived from the property `mtx-url` of the mtx-sidecar module.
- `CDS_MULTITENANCY_APPUI_URL` sets the entry point URL that is shown in the SAP BTP Cockpit.
- `CDS_MULTITENANCY_APPUI_TENANTSEPARATOR` is the separator in generated tenant-specific URL.

The tenant application requests are separated by the tenant-specific app URL:

```http
https://<subaccount subdomain><CDS_MULTITENANCY_APPUI_TENANTSEPARATOR><CDS_MULTITENANCY_APPUI_URL>
```

::: tip Use MTA extensions for landscape-specific configuration

You can define the environment variable `CDS_MULTITENANCY_APPUI_TENANTSEPARATOR` in an MTA extension descriptor:

::: code-group

```yaml [mt.mtaext]
_schema-version: "3.1"
extends: my-app
ID: my-app.id
modules:
  - name: srv
    properties:
      CDS_MULTITENANCY_APPUI_TENANTSEPARATOR: "-"
  - name: app
    properties:
      TENANT_HOST_PATTERN: ^(.*)-${default-uri}
```

[Learn more about _Defining MTA Extension Descriptors_](https://help.sap.com/docs/btp/sap-business-technology-platform/defining-mta-extension-descriptors?q=The%20MTA%20Deployment%20Extension%20Descriptor){.learn-more}


:::

#### Option: Provisioning Only { #provisioning-only-mtx-sidecar .java}

Under certain conditions it makes a lot of sense to use the MTX Sidecar only for tenant provisioning. This configuration can be used in particular when the application doesn't offer (tenant-specific) model extensions and feature toggles. In such cases, business requests can be served by the Java runtime without interaction with the sidecar, for example to fetch an extension model.

Use the following MTX Sidecar configuration to achieve this:

::: code-group

```json [.cdsrc.json]
{
    "requires": {
        "multitenancy": true,
        "extensibility": false, // [!code focus]
        "toggles": false // [!code focus]
    },
    "build": {
        ...
    }
}
```

:::

In this case, the application can use its static local model without requesting the MTX sidecar for the model. This results in a significant performance gain because CSN and EDMX metadata are loaded from the JAR instead of the MTX Sidecar. To make the Java application aware of this setup as well, set the following properties:

::: code-group

```yaml [application.yaml]
cds:
  model:
    provider:
      extensibility: false // [!code focus]
      toggles: false // [!code focus]

```

:::
::: tip Enable only the features that you need
You can also selectively use these properties to enable only extensibility or feature toggles, thus decreasing the dimensions when looking up dynamic models.

:::

<div id="subscriptionmanager" />
<Fragment target="#subscriptionmanager">

## IAS with Subscription Manager <Internal /> { #subscription-manager }

::: warning Prerequisite: Multitenant IAS Configuration
Make sure to set up trust between your BTP subaccount providing the application and a multitenant-enabled IAS tenant.
[Learn more about IAS broker preconditions](https://github.wdf.sap.corp/pages/CPSecurity/sci-dev-guide/docs/BTP/identity-broker#preconditions){.learn-more}
:::

In order to subscribe Identity Authentication service (IAS) tenants to your application, an IAS and Subscription Manager Service (SMS) service are required to connect your application to the SAP BTP Provisioning Service.

Configure IAS like so:

```sh
cds add ias
```

<div class="impl java">

::: details This adds the following config...

::: code-group

```yaml [mta.yaml]
resources:
  - name: bookshop-ias # [!code ++]
    type: org.cloudfoundry.managed-service # [!code ++]
    parameters: # [!code ++]
      service: identity # [!code ++]
      service-plan: application # [!code ++]
      config: # [!code ++]
        multi-tenant: true # [!code ++]
        xsuaa-cross-consumption: true # for XSUAA cross-consumption
  - name: bookshop-sms # [!code ++]
    type: org.cloudfoundry.managed-service # [!code ++]
    parameters: # [!code ++]
      service: subscription-manager # [!code ++]
      service-plan: provider # [!code ++]
      config: # [!code ++]
        iasServiceInstanceName: bookshop-ias # [!code ++]
        saasManagerServiceInstanceName: bookshop-saas # for XSUAA cross-consumption
        applicationType: application # [!code ++]
        appName: <appname> # [!code ++]
        appCallbacks: # [!code ++]
            dependenciesCallbacks: # [!code ++]
              url: ~{srv-api/mesh-url}/mt/sms/subscriptions/tenants/{app_tid}/dependencies # [!code ++]
            subscriptionCallbacks: # [!code ++]
              url: ~{srv-api/mesh-url}/mt/sms/subscriptions/tenants/{app_tid} # [!code ++]
              async: # [!code ++]
                subscribeEnable: true # [!code ++]
                unSubscribeEnable: true # [!code ++]
                timeoutInMillis: 60000 # [!code ++]
        displayName: <name displayed in the subscription manager dashboard> # [!code ++]
        description: "<description displayed in subscription manager dashboard>" # [!code ++]
        category: "<category displayed in subscription manager dashboard>" # [!code ++]
    requires: # [!code ++]
      - name: srv # [!code ++]
    processed-after: [bookshop-saas, bookshop-ias] # [!code ++]
  ...
  - name: bookshop-saas
    type: org.cloudfoundry.managed-service
    parameters:
      service: saas-registry
      service-plan: application
      ...
  ...
```

:::

</div>

<div class="impl node">

::: details This adds the following config...

::: code-group

```yaml [mta.yaml]
resources:
  ...
  - name: bookshop-saas
    type: org.cloudfoundry.managed-service
    parameters:
      service: saas-registry
      service-plan: application
      ...
  ...
  - name: bookshop-ias # [!code ++]
    type: org.cloudfoundry.managed-service # [!code ++]
    parameters: # [!code ++]
      service: identity # [!code ++]
      service-plan: application # [!code ++]
      config: # [!code ++]
        multi-tenant: true # [!code ++]
        xsuaa-cross-consumption: true # for XSUAA cross-consumption
  - name: bookshop-sms # [!code ++]
    type: org.cloudfoundry.managed-service # [!code ++]
    parameters: # [!code ++]
      service: subscription-manager # [!code ++]
      service-plan: provider # [!code ++]
      config: # [!code ++]
        iasServiceInstanceName: bookshop-ias # [!code ++]
        saasManagerServiceInstanceName: bookshop-saas # for XSUAA cross-consumption
        applicationType: application # [!code ++]
        appName: <appname> # [!code ++]
        appCallbacks: # [!code ++]
            dependenciesCallbacks: # [!code ++]
              url: ~{mtx-api/mesh-url}/-/cds/sms-provisioning/dependencies/{app_tid} # [!code ++]
            subscriptionCallbacks: # [!code ++]
              url: ~{mtx-api/mesh-url}/-/cds/sms-provisioning/tenant/{app_tid} # [!code ++]
              async: # [!code ++]
                subscribeEnable: true # [!code ++]
                unSubscribeEnable: true # [!code ++]
                timeoutInMillis: 60000 # [!code ++]
        displayName: <name displayed in the subscription manager dashboard> # [!code ++]
        description: "<description displayed in subscription manager dashboard>" # [!code ++]
        category: "<category displayed in subscription manager dashboard>" # [!code ++]
    requires: # [!code ++]
      - name: bookshop-srv # [!code ++]
    processed-after: [bookshop-saas, bookshop-ias] # [!code ++]
```

:::

</div>

::: tip In an XSUAA cross-consumption scenario...

... the SMS instance depends on a SaaS registry instance (`saas-registry`).
See the comments in the previous _mta.yaml_ sample for the required additions.

:::

#### Sidecar configuration {.node}

Enable callback endpoints provided by the sidecar by adding an additional profile to the MTX sidecar configuration:

::: code-group

```json [mtx/sidecar/package.json]
 "cds": {
    "profiles": [
      "mtx-sidecar",
      "subscription-manager" // [!code ++]
    ]
    ...
  }
```

:::

#### Security Aspects

The trust between the Subscription Manager service and the CAP application callbacks is based on X.509 client certificates.
CAP callback endpoints assume the client certificate with issuer and subject name as specified in the SMS binding.

**CAP relies on a platform mechanism that puts a X.509 client certificate in a dedicated propagation header if and only if it has been successfully validated before**.

::: warning CAP expects `X-Forwarded-Client-Cert` header by default

This header is used by the **SAP BTP, Cloud Foundry Environment** to send the client certificate.

For **other environments** it might be required to configure the header name:

<div class="impl java">

```yaml [srv/src/main/resources/application.yaml]
# srv/src/main/resources/application.yaml
cds:
  security:
    authentication:
      clientCertificateHeader: <header-field>
```

</div>

<div class="impl node">

```jsonc
// mtx/sidecar/package.json
"cds": {
    "requires": {
     ...
      "cds.xt.SmsProvisioningService": {
        "clientCertificateHeader": "<header-field>"
      }
    }
  }
```

</div>

:::

For the SAP BTP, Cloud Foundry Environment to ensure that the SMS client certificate is propagated, `mesh-url` used for the callbacks needs to point to a `*.mesh.cf.<landscape-domain>` URI.

::: details This is set up by `cds add ias`...

::: code-group

```yaml [mta.yaml]
modules:
  ...
  - name: bookshop-srv
    ...
    parameters:
      ...
      routes: # [!code ++]
        - route: '${default-url}' # [!code ++]
        - route: '${default-host}.mesh.cf.<landscape-domain>' # [!code ++]
    provides:
      - name: srv-api
        properties:
          cert-url: '${protocol}://${default-host}.mesh.cf.<landscape-domain>' # [!code ++]
```

:::

::: code-group


The parameter `<landscape-domain>` needs to be replaced with the actual domain of the landscape (for example, `eu10.hana.ondemand.com`).
The `.mesh.cf`-domain is not visible by default in a subaccount. It needs to be explicitly enabled as described in [
Crown Jewels #3.2 mTLS enabling via mesh.cf domain](https://github.tools.sap/cloudfoundry/custom-domain-selfservice/tree/master/docs/mesh#non-core-services).

::: tip Configure Callback URLs
If you don't configure the callback urls in the `.mesh.cf`-domain, **CF will not forward the SMS client certificate** in the HTTP header.
:::

#### Tenant Provider Service { #tenant-provider .java}

If the application is bound to both SaaS registry and SMS, the `TenantProviderService` returns a combined list of `TenantInfo` objects from both services. `TenantInfo` objects from the SaaS registry have structural differences in the underlying map compared to `TenantInfo` objects from the SMS. If the same tenant is listed in both services, the corresponding `TenantInfo` objects from both are merged with the SMS `TenantInfo` as a top level object. Then the SaaS registry `TenantInfo` is  embedded in the combined list under a key `saasRegistry` in the SMS `TenantInfo` object's underlying map.


#### Hybrid Mode { #hybrid-mode .java}

Even though not recommended, subscribing the same tenant via SaaS registry and SMS is technically possible. The same tenant is then maintained in both services under unique subscription IDs.

However, when unsubscribing that tenant from just one of these services while keeping the subscription of the other, a full unsubscription flow is processed. If you have such a scenario you need to handle tenant offboarding with custom logic in the application to avoid removal of resources still in use by the other subscription (for example, HDI containers, messaging queues, etc.)

See [Skipping Deletion of Tenant Containers During Tenant Unsubscription](/java/multitenancy#skipping-deletion-of-tenant-data) for an example of controlling the removal of tenant-specific resources.

::: warning Beware of side-effects in hybrid mode
If you don't explicitly handle tenant offboarding when using hybrid mode, unsubscribing a tenant removes resources that the remaining subscription of the same tenant still needs.

As a result the remaining subscription is in a broken state and unusable.
:::

</Fragment>

## Appendix

### About SaaS Applications

Software-as-a-Service (SaaS) solutions are deployed once by a SaaS provider, and then used by multiple SaaS customers subscribing to the software.

SaaS applications need to register with the [_SAP BTP SaaS Provisioning service_](https://discovery-center.cloud.sap/serviceCatalog/saas-provisioning-service) to handle `subscribe` and `unsubscribe` events. In contrast to [single-tenant deployments](../deployment/to-cf), databases or other _tenant-specific_ resources aren't created and bootstrapped upon deployment, but upon subscription per tenant.

CAP includes the **MTX services**, which provide out-of-the-box handlers for `subscribe`/`unsubscribe` events, for example to manage SAP HANA database containers.


If everything is set up, the following graphic shows what's happening when a user subscribes to a SaaS application:

![The graphic is explained in the following text.](assets/saas-overview.drawio.svg){}

1. The SaaS Provisioning Service sends a `subscribe` event to the CAP application.
2. The CAP application delegates the request to the MTX services.
3. The MTX services use Service Manager to create the database tenant.
4. The CAP Application connects to this tenant at runtime using Service Manager.

<div class="impl java">

In CAP Java, tenant provisioning is delegated to CAP Node.js based services. This has the following implications:

- Java applications need to run and maintain the [_cds-mtxs_ module](../multitenancy/#enable-multitenancy) as a sidecar application (called _MTX sidecar_ in this documentation).
- But multitenant CAP Java applications automatically expose the tenant provisioning API called by the SaaS Provisioning service so that [custom logic during tenant provisioning](/java/multitenancy#custom-logic) can be written in Java.

</div>

### About Sidecar Setups

The SaaS operations `subscribe` and `upgrade` tend to be resource-intensive. Therefore, it's recommended to offload these tasks onto a separate microservice, which you can scale independently of your main app servers.

Java-based projects even require such a sidecar, as the MTX services are implemented in Node.js.

In these MTX sidecar setups, a subproject is added in _./mtx/sidecar_, which serves the MTX Services as depicted in the illustration below.

![The main app serves the CAP services and the database. The sidecar serves the Deployment service and the Model Provider service. The Deployment service receives upgrade and subscribe request and sends deploy requests to the database of the main app. The Deployment service and the CAP services get the model from the Model Provider service to keep all layers in sync.](./assets/mtx-sidecar.drawio.svg)

The main task for the MTX sidecar is to serve `subscribe` and `upgrade` requests.

The CAP services runtime requests models from the sidecar only when you apply tenant-specific extensions. For Node.js projects, you have the option to run the MTX services embedded in the main app, instead of in a sidecar.


### Behind the Scenes { #behind-the-scenes}

With adding the MTX services, your project configuration is adapted at all relevant places.

Configuration and dependencies are added to your _package.json_ and an _xs-security.json_ containing MTX-specific scopes and roles is created. {.node}

Configuration and dependencies are added to your _.cdsrc.json_ and an _xs-security.json_ containing MTX-specific scopes and roles is created. {.java}

For the MTA deployment service dependencies are added to the _mta.yaml_ file. Each SaaS application will have bindings to at least three SAP BTP service instances.

| Service                                                      | Description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [Service Manager](https://help.sap.com/docs/SERVICEMANAGEMENT/09cc82baadc542a688176dce601398de/4e19b11211fe4ca2a266d3fdd4a72188.html) (`service-manager`) | CAP uses this service for creating a new SAP HANA Deployment Infrastructure (HDI) container for each tenant and for retrieving tenant-specific database connections. |
| [SaaS Provisioning Service](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/3971151ba22e4faa9b245943feecea54.html) (`saas-registry`)                  | To make a SaaS application available for subscription to SaaS consumer tenants, the application provider must register the application in the SAP BTP Cloud Foundry environment through the SaaS Provisioning Service. |
| [User Account and Authentication Service](https://help.sap.com/docs/CP_AUTHORIZ_TRUST_MNG) (`xsuaa`)            | Binding information contains the OAuth client ID and client credentials. The XSUAA service can be used to validate the JSON Web Token (JWT) from requests and to retrieve the tenant context from the JWT.|






## Next Steps

- See the [MTX Services Reference](./mtxs) for details on service and configuration options, in particular about sidecar setups.
- See our guide on [Extending and Customizing SaaS Solutions](../extensibility/).

<div id="secondary-file">guides/multitenancy/index.fragment.md</div>


# MTX Services Reference

{{$frontmatter?.synopsis}}



## Introduction & Overview

The `@sap/cds-mtxs` package provides a set of CAP services which implement _**multitenancy**_, _[features toggles](../extensibility/feature-toggles)_ and _[extensibility](../extensibility/)_ (_'MTX'_ stands for these three functionalities). These services work in concert as depicted in the following diagram:

![The graphic depicting the MTX infrastructure as described in the following guide.](./assets/mtx-overview.drawio.svg)

MTX services are implemented in Node.js and can run in the same Node.js server as your application services or in separate micro services called _sidecars_. All services can be consumed via REST APIs.

As the services are defined and implemented as standard CAP services, with definitions in CDS and implementations based on the CAP Node.js framework, application projects can hook into all events to add custom logic using CAP Node.js.

## Getting Started…

### Add `@sap/cds-mtxs` Package Dependency

```sh
npm add @sap/cds-mtxs
```

### Enable MTX Functionality

Add one or more of the following convenience configuration flags, for example, to your `package.json` in a Node.js-based project:

```json
  "cds": {
    "requires": {
      "multitenancy": true,
      "extensibility": true,
      "toggles": true
    }
  }
```

[Java-based projects require a sidecar setup.](#sidecars){.learn-more}

### Test-Drive Locally

After enabling MTX features, you can test MTX functionality with local development setups and in-memory databases as usual:

```sh
cds watch
```

This shows the MTX services being served in addition to your app services:

```log{6-8,11-15}
[cds] - loaded model from 6 file(s):

  db/schema.cds
  srv/admin-service.cds
  srv/cat-service.cds
  ../../db/extensions.cds
  ../../srv/deployment-service.cds
  ../../srv/bootstrap.cds

[cds] - connect to db > sqlite { url: ':memory:' }
[cds] - serving cds.xt.SaasProvisioningService { path: '/-/cds/saas-provisioning' }
[cds] - serving cds.xt.DeploymentService { path: '/-/cds/deployment' }
[cds] - serving cds.xt.ModelProviderService { path: '/-/cds/model-provider' }
[cds] - serving cds.xt.ExtensibilityService { path: '/-/cds/extensibility' }
[cds] - serving cds.xt.JobsService { path: '/-/cds/jobs' }
[cds] - serving AdminService { path: '/admin' }
[cds] - serving CatalogService { path: '/browse', impl: 'srv/cat-service.js' }

[cds] - server listening on { url: 'http://localhost:4004' }
[cds] - launched at 5/6/2023, 9:31:11 AM, in: 863.803ms
```


## Grow As You Go

Follow CAP principles of _'Grow as you go...'_  to minimize complexity of setups, stay in [inner loops](https://www.getambassador.io/docs/telepresence/latest/concepts/devloop) with fast turnarounds, and hence minimize costs and accelerate development.

### Enable MTX Only if Required

During development you rarely need to run your servers with MTX functionality enabled. Only do so when you really need it. For example, in certain tests or by using configuration profiles.

 This configuration would have development not use MTX by default. You could still run with MTX enabled on demand and have it always active in production:


```jsonc
  "cds": {
    "requires": {
      "[local-multitenancy]": {
         "multitenancy": true,
         "extensibility": true,
         "toggles": true
      },
      "[production]": {
         "multitenancy": true,
         "extensibility": true,
         "toggles": true
      }
    }
  }
```

During development you could occasionally run with MTX:

```sh
cds watch --profile local-multitenancy
```

### Testing With Minimal Setup

When designing test suites that run frequently in CI/CD pipelines, you can shorten runtimes and reduce costs. First run a set of functional tests which use MTX in minimized setups – that is, with local servers and in-memory databases as introduced in the [_Multitenancy_ guide](../multitenancy/#test-locally).

Only in the second and third phases, you would then run the more advanced hybrid tests. These hybrid tests could include testing tenant subscriptions with SAP HANA, or integration tests with the full set of required cloud services.

## Sidecar Setups {#sidecars}

In the minimal setup introduced in the _[Getting Started...](#getting-started)_ chapter, we had the MTX services being served embedded with our main app, that is, in the same server as our application services. While this is possible for Node.js and even recommended to reduce complexity during development, quite frequently, we'd want to run them in a separate micro service. Reasons for that include:

- **For Java-based projects** — As these services are implemented in Node.js we need to run them separately and consume them remotely for Java-based apps.
- **To scale independently** — As some operations, especially `upgrade`, are very resource-intensive, we want to scale these services separate from our main application.

As MTX services are built and consumed as CAP services, we benefit from CAP's agnostic design and can easily move them to separate services.

### Create Sidecar as a Node.js Subproject

An MTX sidecar is a standard, yet minimal Node.js CAP project. By default it's added to a subfolder `mtx/sidecar` within your main project, containing just a _package.json_ file.

::: code-group

```json [mtx/sidecar/package.json]
{
  "name": "bookshop-mtx", "version": "0.0.0",
  "dependencies": {
    "@sap/cds": "^9",
    "@cap-js/hana": "^2",
    "@sap/cds-mtxs": "^3",
    "@sap/xssec": "^4",
    "express": "^4"
  },
  "devDependencies": {
    "@cap-js/sqlite": "^2"
  },
  "scripts": {
    "start": "cds-serve"
  },
  "cds": {
    "profile": "mtx-sidecar"
  }
}
```

:::

The only configuration necessary for the project is the `mtx-sidecar` profile.

::: details Let's have a look at what this profile provides...

#### Required MTX Services

```jsonc
...
"cds": {
  "requires": {
    "cds.xt.ModelProviderService": "in-sidecar",
    "cds.xt.DeploymentService": true,
    "cds.xt.SaasProvisioningService": true,
    "cds.xt.ExtensibilityService": true
    ...
  }
}
```

Here we enable all MTX services in a standard configuration. Of course, you can choose to only serve some of which, according to your needs, using [individual configuration](#conf-individual).

#### Using Shared Database

```jsonc
...
"[development]": {
  "db": { "kind": "sqlite", "credentials": {
    "url": "../../db.sqlite"
  }}
}
...
```

With multitenancy the _[DeploymentService](#deploymentservice)_ needs to deploy the very database instances which are subsequently used by the main application. This setting ensures that for local development with SQLite.

#### Additional `[development]` Settings

```jsonc
...
"[development]": {
  "requires": { "auth": "mocked" },
  "server": { "port": 4005 }
}
...
```

These additional settings for profile `[development]` are to support local tests with default values for the server port (different from the default port `4004` of the main app), and to allow mock authentication in the sidecar (secured by default in production).

:::

### Testing Sidecar Setups

With the above setup in place, we can test-drive the sidecar mode locally. To do so, we'll simply start the sidecar and main app in separate shells.

1. Run sidecar in first shell:

   ```sh
   cds watch mtx/sidecar
   ```

   ::: details You see the sidecar starting on port 4005...

   ```log
   cd mtx/sidecar

   cds serve all --with-mocks --in-memory?
   live reload enabled for browsers

           ___________________________

   [cds] - loaded model from 3 file(s):

     ../cds-mtxs/srv/model-provider.cds
     ../cds-mtxs/srv/deployment-service.cds
     ../cds-mtxs/db/t0.cds

   [cds] - connect using bindings from: { registry: '~/.cds-services.json' }
   [cds] - connect to db > sqlite { url: '../../db.sqlite' }
   [cds] - using authentication: { kind: 'mocked' }

   [cds] - serving cds.xt.ModelProviderService { path: '/-/cds/model-provider' }
   [cds] - serving cds.xt.DeploymentService { path: '/-/cds/deployment' }
   [cds] - loaded model from 1 file(s):

     ../cds-mtxs/db/t0.cds

   [mtx] - (re-)deploying SQLite database for tenant: t0
   /> successfully deployed to db-t0.sqlite


   [cds] - server listening on { url: 'http://localhost:4005' } // [!code highlight]
   [cds] - launched at 5/6/2023, 1:08:33 AM, version: 7.3.0, in: 772.25ms
   [cds] - [ terminate with ^C ]
   ```

   :::

2. Run the main app as before in a second shell:

   ```sh
   cds watch
   ```

#### _ModelProviderService_ serving models from main app

When we use our application, we can see `model-provider/getCsn` requests in the sidecar's trace log. In response to those requests, the sidecar reads and returns the main app's models, that is, the models from two levels up the folder hierarchy as is the default with the `mtx-sidecar` profile.

#### Note: Service Bindings by `cds watch`

Required service bindings are done automatically by `cds watch`'s built-in runtime service registry. This is how it works:

1. Each server started using `cds watch` registers all served services in `~/cds-services.json`.

2. Every subsequently started server binds automatically all `required` remote services, to equally named services already registered in `~/cds-services.json`.

In our case: The main app's `ModelProviderService` automatically receives the service binding credentials, for example `url`, to talk to the one served by the sidecar.

### Build Sidecar for Production

When deploying a sidecar for production, it doesn't have access to the main app's models two levels up the deployed folder hierarchy. Instead we have to prepare deployment by running `cds build` in the project's root:

```sh
cds build
```

One of the build tasks that are executed is the `mtx-sidecar` build task. It generates log output similar to the following:

```log
[cds] - the following build tasks will be executed
  {"for":"mtx-sidecar", "src":"mtx/sidecar", "options":... }
[cds] - done > wrote output to:
   gen/mtx/sidecar/_main/fts/isbn/csn.json
   gen/mtx/sidecar/_main/fts/reviews/csn.json
   gen/mtx/sidecar/_main/resources.tgz
   gen/mtx/sidecar/_main/srv/_i18n/i18n.json
   gen/mtx/sidecar/_main/srv/csn.json
   gen/mtx/sidecar/package.json
   gen/mtx/sidecar/srv/_i18n/i18n.json
   gen/mtx/sidecar/srv/csn.json
[cds] - build completed in 687 ms
```

The outcome of that build task is a compiled and deployable version of the sidecar in the _gen/mtx/sidecar_ staging areas:

```zsh{6-17}
bookshop/
├─ _i18n/
├─ app/
├─ db/
├─ fts/
├─ gen/mtx/sidecar/
│   ├─ _main/
│   │   ├── fts/
│   │   │   ├── isbn/
│   │   │   │   └── csn.json
│   │   │   └── reviews/
│   │   │       └── csn.json
│   │   ├── srv/
│   │   │   ├── _i18n
│   │   │   └── csn.json
│   │   └── resources.tgz
│   └─ package.json
├─ mtx/sidecar/
├─ ...
```

In essence, the `mtx-sidecar` build task does the following:

1. It runs a standard Node.js build for the sidecar.
2. It pre-compiles the main app's models, including all features into respective _csn.json_ files, packaged into the `_main` subfolder.
3. It collects all additional sources required for subsequent deployments to `resources.tgz`. For example, these include _.csv_ and _i18n_ files.

### Test-Drive Production Locally

We can also test-drive the production-ready variant of the sidecar locally before actual deployment, again using two separate shells.

1. **First, start sidecar** from `gen/mtx/sidecar` in `prod` simulation mode:

   ```sh
   cds watch gen/mtx/sidecar --profile development,prod
   ```

2. **Second, start main** app as usual:

   ```sh
   cds watch
   ```

#### _ModelProviderService_ serving models from main app

When we now use our application again, and inspect the sidecar's trace logs, we see that the sidecar reads and returns the main app's precompiled models from `_main` now:

```log
[cds] – POST /-/cds/model-provider/getCsn
[cds] – model loaded from 3 file(s):

  gen/mtx/sidecar/_main/srv/csn.json
  gen/mtx/sidecar/_main/fts/isbn/csn.json
  gen/mtx/sidecar/_main/fts/reviews/csn.json
```

## Configuration {#conf}

### Shortcuts `cds.requires.multitenancy / extensibility / toggles` {#conf-shortcuts}

The easiest way to enable multitenancy, extensibility, and feature toggles is as follows:

```json
  "cds": {
    "requires": {
      "multitenancy": true,
      "extensibility": true,
      "toggles": true
    }
  }
```

On the one hand, these settings are interpreted by the CAP runtime to support features such as tenant-specific database connection pooling when `multitenancy` is enabled.

On the other hand, these flags are checked during server bootstrapping to ensure the required combinations of services are served by default. The following tables shows which services are enabled by one of the shortcuts:

|                                                       | `multitenancy` | `extensibility` | `toggles` |
| ----------------------------------------------------- | :------------: | :-------------: | :-------: |
| _[SaasProvisioningService](#saasprovisioningservice)_ |      yes       |       no        |    no     |
| _[DeploymentService](#deploymentservice)_             |      yes       |       no        |    no     |
| _[ExtensibilityService](#extensibilityservice)_       |      no        |       yes       |    no     |
| _[ModelProviderService](#modelproviderservice)_       |      yes       |       yes       |    yes    |

### Configuring Individual Services {#conf-individual}

In addition or alternatively to the convenient shortcuts above you can configure each service individually, as shown in the following examples:

```jsonc
  "cds": {
    "requires": {
      "cds.xt.DeploymentService": true
    }
  }
```

The names of the service-individual configuration options are:

- `cds/requires/<service definition name>`

##### Allowed Values

- `false` — deactivates the service selectively
- `true` — activates the service with defaults for embedded usage
- `<preset name>` — uses [preset](#presets), for example, with defaults for sidecar usage
- `{ ...options }` — add/override individual configuration options

##### Common Config Options

- `model` — specifies/overrides the service model to be used
- `impl` — specifies/overrides the service implementation to be used
- `kind` — the kind of service/consumption, for example, `rest` for remote usage

> These options are supported by all services.

#### Combined with Convenience Flags

```json
  "cds": {
    "requires": {
      "multitenancy": true,
      "cds.xt.SaasProvisioningService": false,
      "cds.xt.DeploymentService": false,
      "cds.xt.ModelProviderService": { "kind": "rest" }
    }
  }
```

This tells the CAP runtime to enable multitenancy, but neither serve the _DeploymentService_, nor the _SaasProvisioningService_, and to use a remote _ModelProviderService_ via REST protocol.

#### Individual Configurations Only

We can also use only the individual service configurations:

```json
  "cds": {
    "requires": {
      "cds.xt.DeploymentService": true,
      "cds.xt.ModelProviderService": { "root": "../.." }
    }
  }
```

In this case, the server will **not** run in multitenancy mode. Also, extensibility and feature toggles are not supported. Yet, the _DeploymentService_ and the _ModelProviderService_ are served selectively. For example, this kind of configuration can be used in [sidecars](#sidecars).

### Using Configuration Presets {#presets}

#### Profile-based configuration

The simplest and for most projects sufficient configuration is the profile-based one, where just these two entries are necessary:

::: code-group

```json [package.json]
"cds": {
  "profile": "with-mtx-sidecar"
}
```

:::

::: code-group

```json [mtx/sidecar/package.json]
"cds": {
  "profile": "mtx-sidecar"
}
```

:::


#### Preset-based configuration

Some MTX services come with pre-defined configuration presets, which can easily be used by referring to the preset suffixes. For example, to simplify and standardize sidecar configuration, _[ModelProviderService](#modelproviderservice)_ supports the `in-sidecar` preset which can be used like that:

```json
  "cds": {
    "requires": {
      "cds.xt.ModelProviderService": "in-sidecar"
    }
  }
```

These presets are actually configured in `cds.env` defaults like that:

```js
cds: {
  requires: {
    // Configuration Presets (in cds.env.requires.kinds)
    kinds: {
      "cds.xt.ModelProviderService-in-sidecar": {
        "[development]": { root: "../.." },
        "[production]": { root: "_main" },
      },
      "cds.xt.ModelProviderService": {
        model: "@sap/cds/srv/model-provider"
      },
      // ...
    }
  }
}
```

[Learn more about `cds.env`](../../node.js/cds-env){.learn-more}

### Inspecting Effective Configuration

You can always inspect the effective configuration by executing this in the _mtx/sidecar_ folder:

```sh
cds env get requires
```

This will give you an output like this:

```js
{
  auth: { strategy: 'dummy', kind: 'dummy' },
  'cds.xt.ModelProviderService': {
    root:'../..',
    model:'@sap/cds/srv/model-provider',
    kind:'in-sidecar'
  }
}
```

Add CLI option `--profile` to inspect configuration in different profiles:

```sh
cds env get requires --profile development
cds env get requires --profile production
```

## Customization

All services are defined and implemented as standard CAP services, with service definitions in CDS, and implementations based on the CAP Node.js framework. Thus, you can easily do both, adapt service definitions, as well as hook into all events to add custom logic using CAP Node.js.

### Customizing Service Definitions

For example, you could override the endpoints to serve a service:

```cds
using { cds.xt.ModelProviderService } from '@sap/cds-mtxs';
annotate ModelProviderService with @path: '/mtx/mps';
```

For sidecar scenarios, define the annotations in the Node.js sidecar application and not as part of the main application.

### Adding Custom Lifecycle Event Handlers

Register handlers in `server.js` files:

::: code-group

```js [mtx/sidecar/server.js]
const cds = require('@sap/cds')
cds.on('served', ()=>{
  const { 'cds.xt.ModelProviderService': mps } = cds.services
  const { 'cds.xt.DeploymentService': ds } = cds.services
  ds.before ('upgrade', (req) => { ... })
  ds.after ('subscribe', (_,req) => { ... })
  mps.after ('getCsn', (csn) => { ... })
})
```

:::

::: tip Custom hooks for CLI usage
For CLI usage via `cds subscribe|upgrade|unsubscribe` you can create a `mtx/sidecar/cli.js` file, which works analogously to a `server.js`.
:::

## Consumption

### Via Programmatic APIs

Consume MTX services using standard [Service APIs](../../node.js/core-services). For example, in `cds repl`:

```js
await cds.test()
var { 'cds.xt.ModelProviderService': mps } = cds.services
var { 'cds.xt.DeploymentService': ds } = cds.services
var db = await ds.subscribe ('t1')
var csn = await mps.getCsn('t1')
cds.context = { tenant:'t1' }
await db.run('SELECT type, name from sqlite_master')
```

### Via REST APIs

Common usage of the MTX services is through REST APIs. Here's an example:

1. Start the server

   ```sh
   cds watch
   ```

2. Subscribe a tenant

   ```http
   POST /-/cds/deployment/subscribe HTTP/1.1
   Content-Type: application/json

   {
     "tenant": "t1"
   }
   ```

3. Get CSN from `ModelProviderService`

   ```http
   POST /-/cds/model-provider/getCsn HTTP/1.1
   Content-Type: application/json

   {
     "tenant": "t1",
     "toggles": ["*"]
   }
   ```

## ModelProviderService

The _ModelProviderService_ serves model variants, which may include tenant-specific extensions and/or feature-toggled aspects.

|                         |                                    |
| ----------------------- | ---------------------------------- |
| Service Definition      | `@sap/cds-mtxs/srv/model-provider` |
| Service Definition Name | `cds.xt.ModelProviderService`      |
| Default HTTP Endpoint   | `/-/cds/model-provider`            |

### Configuration {#model-provider-config}

```json
"cds.xt.ModelProviderService": {
  "root": "../../custom/path"
}
```

- [Common Config Options](#common-config-options)
- `root` — a directory name, absolute or relative to the _package.json_'s location, specifying the location to search for models and resources to be served by the model provider services. Default is undefined, for embedded usage of model provider. In case of a sidecar, it refers to the main app's model; usually `"../.."` during development, and `"_main"` in production.

##### Supported Presets {#model-provider-presets}

- `in-sidecar` — provides defaults for usage in sidecars
- `from-sidecar` — shortcut for `{ "kind": "rest" }`

### `getCsn` _(tenant, toggles) → CSN_

Returns the application's effective CSN document for the given tenant + feature toggles vector. CAP runtimes call that method to obtain the effective models to serve.

| Arguments |  Description                                                |
| --------- | ----------------------------------------------------------- |
| `tenant`  | A string identifying the tenant                             |
| `toggles` | An array listing toggled features; `['*']` for all features |

#### Example Usage {#example-get-csn }

```http
POST /-/cds/model-provider/getCsn HTTP/1.1
Content-Type: application/json

{
  "tenant": "t1",
  "toggles": ["*"]
}
```

The response is a CSN in JSON representation.

[Learn more about **CSN**](http://localhost:5173/docs/cds/csn) {.learn-more}

### `getEdmx` _(tenant, toggles, service, locale) → EDMX_

Returns the EDMX document for a given service in context of the given tenant and feature toggles vector. CAP runtimes call this to get the EDMX document they return in response to OData `$metadata` requests.

| Arguments |  Description                                                |
| --------- | ----------------------------------------------------------- |
| `tenant`  | A string identifying the tenant                             |
| `toggles` | An array listing toggled features; `['*']` for all features |
| `service` | Fully-qualified name of a service definition                |
| `locale`  | Requested locale, that is, as from `accept-language` header     |

#### Example Usage {#example-get-edmx}

```http
POST /-/cds/model-provider/getEdmx HTTP/1.1
Content-Type: application/json

{
  "tenant": "t1",
  "toggles": ["*"],
  "service": "CatalogService",
  "locale": "en"
}
```

### `getResources` _() → TAR_

Returns a _.tar_ archive containing CSV files, I18n files, as well as native database artifacts, required for deployment to databases. `DeploymentService` calls that whenever it receives a `subscribe` or `upgrade` event.

### `getExtensions` _(tenant) → CSN_ {get-extensions}

Returns a _parsed_ CSN document containing all the extensions stored in `cds.xt.Extensions` for the given tenant.

| Arguments |  Description                    |
| --------- | ------------------------------- |
| `tenant`  | A string identifying the tenant |

### `isExtended` _(tenant) → true|false_

Returns `true` if the given `tenant` has extensions applied.

| Arguments |  Description                    |
| --------- | ------------------------------- |
| `tenant`  | A string identifying the tenant |

## ExtensibilityService

The _ExtensibilityService_ allows to add and activate tenant-specific extensions at runtime.

|                         |                                           |
| ----------------------- | ----------------------------------------- |
| Service Definition      | `@sap/cds-mtxs/srv/extensibility-service` |
| Service Definition Name | `cds.xt.ExtensibilityService`             |
| Default HTTP Endpoint   | `/-/cds/extensibility`                    |

[See the extensibility guide for more context](../extensibility/customization){.learn-more}

### Configuration {#extensibility-config}

```jsonc
"cds.xt.ExtensibilityService": {
  // fields must start with x_ or xx_
  "element-prefix": ["x_", "xx_"],
   // namespaces starting with com.sap or sap. can't be extended
  "namespace-blocklist": ["com.sap.", "sap."],
  "extension-allowlist": [
    {
      // at most 2 new fields in entities from the my.bookshop namespace
      "for": ["my.bookshop"],
      "kind": "entity",
      "new-fields": 2,
      // allow extensions for field "description" only
      "fields": ["description"]
    },
    {
      // at most 2 new entities in CatalogService
      "for": ["CatalogService"],
      "new-entities": 2,
      // allow @readonly annotations in CatalogService
      "annotations": ["@readonly"]
    }
  ]
}
```

- [Common Config Options](#common-config-options)
- `element-prefix` — restrict field names to prefix
- `namespace-blocklist` — restrict namespaces to be extended
- `extension-allowlist` — allow certain entities to be extended

> Without `extension-allowlist` configured, extensions are forbidden.

Using `"for": ["*"]` applies the rules to all possible values.

See the [list of possible `kind` values](../../cds/csn#def-properties).{.learn-more}

- `new-fields` specifies the maximum number of fields that can be added.
- `fields` lists the fields that are allowed to be extended. If the list is omitted, all fields can be extended.
- `new-entities` specifies the maximum number of entities that can be added to a service.

### GET `Extensions/<ID>` _→ [{ ID, csn, timestamp }]_ {#get-extensions}

Returns a list of all tenant-specific extensions.

<div class="cols-2">

<div>

#### Request Format

| **Parameters** | Description |
| - | - |
| `ID`  | String uniquely identifying the extension |

> Omitting `ID` will return all extensions.

</div>

<div>

#### Response Format

| **Body** | Description |
| - | - |
| `ID`  | String uniquely identifying the extension |
| `csn` | Compiled extension CSN |
| `timestamp` | Timestamp of activation date |

</div>

</div>

#### Example Request

##### Get a specific extension {#get-extension}

::: code-group

```http [Request]
GET /-/cds/extensibility/Extensions/isbn-extension HTTP/1.1
Content-Type: application/json
```

```json [Response]
{
    "ID": "isbn-extension",
    "csn": "{\"extensions\":[{\"extend\":\"my.bookshop.Books\",\"elements\":{\"Z_ISBN\":{\"type\":\"cds.String\"}}}],\"definitions\":{}}",
    "timestamp": "2023-01-01T01:01:01.111Z"
}
```

:::

##### Get all extensions {#get-all-extensions}

::: code-group

```http [Request]
GET /-/cds/extensibility/Extensions HTTP/1.1
Content-Type: application/json
```

```json [Response]
[
  {
    "ID": "isbn-extension",
    "csn": "{\"extensions\":[{\"extend\":\"my.bookshop.Books\",\"elements\":{\"Z_ISBN\":{\"type\":\"cds.String\"}}}],\"definitions\":{}}",
    "timestamp": "2023-01-01T01:01:01.111Z"
  },
  {
    "ID": "rental-extension",
    "csn": "{\"extensions\":[{\"extend\":\"my.bookshop.Books\",\"elements\":{\"Z_rentalPrice\":{\"type\":\"cds.Integer\"}}}],\"definitions\":{}}",
    "timestamp": "2023-01-01T01:02:01.111Z"
  }
]
```

:::

### PUT `Extensions/<ID>` (\[csn\]) _→ \[{ ID, csn, timestamp }\]_ {#put-extensions}

Creates a new tenant-specific extension.

#### HTTP Request Options

| Request Header        |  Example Value                                         | Description  |
| ----------------      | -------------------------------------------------------|--------------|
| `prefer`              | `respond-async`                                        | Trigger asynchronous extension activation |

<div class="cols-2">

<div>

#### Request Format

| **Parameters** | Description |
| - | - |
| `ID`  | String uniquely identifying the extension |
| **Body**
| `csn` | Array of extension CDL or CSN to apply |
| `i18n` | Texts and translations |

</div>

<div>

#### Response Format

| **Body** | Description |
| - | - |
| `ID`  | String uniquely identifying the extension |
| `csn` | Compiled extension CSN |
| `i18n` | Texts and translations |
| `timestamp` | Timestamp of activation date |

</div>

</div>

#### Example Request

::: code-group

```http [Request]
PUT /-/cds/extensibility/Extensions/isbn-extension HTTP/1.1
Content-Type: application/json

{
  "csn": ["using my.bookshop.Books from '_base/db/data-model';
           extend my.bookshop.Books with { Z_ISBN: String };"],
  "i18n": [{ "name": "i18n.properties", "content": "Books_stock=Stock" },
           { "name": "i18n_de.properties", "content": "Books_stock=Bestand" }]
}
```

```json [Response]
{
    "ID": "isbn-extension",
    "csn": "{\"extensions\":[{\"extend\":\"my.bookshop.Books\",\"elements\":{\"Z_ISBN\":{\"type\":\"cds.String\"}}}],\"definitions\":{}}",
    "i18n": "{\"\":{\"Books_stock\":\"Stock\"},\"de\":{\"Books_stock\":\"Bestand\"}}",
    "timestamp": "2023-09-07T22:31:28.246Z"
}
```

:::

The request can also be triggered asynchronously by setting the `Prefer: respond-async` header.
You can use the URL returned in the `Location` response header to poll the job status.

In addition, you can poll the status for individual tenants using its individual task ID:

```http
GET /-/cds/jobs/pollTask(ID='<taskID>') HTTP/1.1
```

The response is similar to the following:

```js
{
  "status": "FINISHED",
  "op": "activateExtension"
}
```

The job and task status can take on the values `QUEUED`, `RUNNING`, `FINISHED` and `FAILED`.


> By convention, custom (tenant-specific) fields are usually prefixed with `Z_`.

The i18n data can also be passed in JSON format:
```json
"i18n": [{
  "name": "i18n.json",
  "content": "{\"\":{\"Books_stock\":\"Stock\"},\"de\":{\"Books_stock\":\"Bestand\"}}"
}]
```
You also get this JSON in the response body of PUT or [GET](#get-extensions) requests.
In this example, the text with key "Books_stock" from the base model is replaced.




### DELETE `Extensions/<ID>` {#delete-extensions}

Deletes a tenant-specific extension.

#### HTTP Request Options

| Request Header        |  Example Value                                         | Description  |
| ----------------      | -------------------------------------------------------|--------------|
| `prefer`              | `respond-async`                                        | Trigger asynchronous extension activation |


<div class="cols-2">

<div>

#### Request Format

| **Parameters** | Description |
| - | - |
| `ID`  | String uniquely identifying the extension |

</div>

</div>

#### Example Usage

```http [Request]
DELETE /-/cds/extensibility/Extensions/isbn-extension HTTP/1.1
Content-Type: application/json
```

The request can also be triggered asynchronously by setting the `Prefer: respond-async` header.
You can use the URL returned in the `Location` response header to poll the job status.

In addition, you can poll the status for individual tenants using its individual task ID:

```http
GET /-/cds/jobs/pollTask(ID='<taskID>') HTTP/1.1
```

The response is similar to the following:

```js
{
  "status": "FINISHED",
  "op": "activateExtension"
}
```

The job and task status can take on the values `QUEUED`, `RUNNING`, `FINISHED` and `FAILED`.

## DeploymentService

The _DeploymentService_ handles `subscribe`, `unsubscribe`, and `upgrade` events for single tenants and single apps or micro services. Actual implementation is provided through internal plugins, for example, for SAP HANA and SQLite.

|                         |                                        |
| ----------------------- | -------------------------------------- |
| Service Definition      | `@sap/cds-mtxs/srv/deployment-service` |
| Service Definition Name | `cds.xt.DeploymentService`             |
| Default HTTP Endpoint   | `/-/cds/deployment`                    |

### Configuration {#deployment-config}

```jsonc
"cds.xt.DeploymentService": {
  "hdi": {
    "deploy": {
      ...
    },
    "create": {
      "database_id": "<SAP HANA Cloud instance ID>",
      ...
    },
    "bind": {
      ...
    }
  }
}
```

- [Common Config Options](#common-config-options)
- `hdi` — bundles HDI-specific settings
  - `deploy` — [HDI deployment parameters](https://www.npmjs.com/package/@sap/hdi-deploy#supported-features)
  - `create` — tenant creation parameters (≈ [`cf create-service`](https://help.sap.com/docs/BTP/65de2977205c403bbc107264b8eccf4b/a36df26b36484129b482ae20c3eb8004.html))
    - `database_id` — SAP HANA Cloud instance ID
  - `bind` — binding parameters (≈ [`cf bind-service`](https://help.sap.com/docs/BTP/65de2977205c403bbc107264b8eccf4b/c7b09b79d3bb4d348a720ba27fe9a2d5.html))

<span id="internal-lmlmthc" />
<Fragment target="#internal-lmlmthc">

[Learn more about how to configure secure multitenancy with SAP HANA Cloud.](../security/aspects#storage-encryption){.learn-more}

</Fragment>

##### Supported Presets {#deployment-presets}

- `in-sidecar` — provides defaults for usage in sidecars
- `from-sidecar` — shortcut for `{ "kind": "rest" }`

### `subscribe` _(tenant)_

Received when a new tenant subscribes.

The implementations create and initialize required resources, that is, creating and initializing tenant-specific HDI containers in case of SAP HANA, or tenant-specific databases in case of SQLite.

### `upgrade` _(tenant)_

Used to upgrade a subscribed tenant.

Implementations read the latest models and content from the latest deployed version of the application and re-deploy that to the tenant's database.

##### Drop-Creating Databases for SQLite

In case of SQLite, especially in case of in-memory databases, an upgrade will simply drop and create a new tenant-specific database. Which means all data is lost.

##### Schema Evolution for SAP HANA

In case of SAP HANA, the delta to the former database layout will be determined, and corresponding CREATE TABLE, DROP-CREATE VIEW, and ALTER TABLE statements will eventually be executed without any data loss.

### `unsubscribe` _(tenant)_

Received when a tenant is deleted.

The implementations free required resources, that is, dispose tenant-specific HDI containers in case of SAP HANA, or tenant-specific databases in case of SQLite.

## SaasProvisioningService

The _SaasProvisioningService_ is a façade for the _DeploymentService_ to adapt to the API expected by [SAP BTP's SaaS Provisioning service](https://discovery-center.cloud.sap/serviceCatalog/saas-provisioning-service), hence providing out-of-the-box integration.

|                         |                                                  |
| ----------------------- | ------------------------------------------------ |
| Service Definition      | `@sap/cds-mtxs/srv/cf/saas-provisioning-service` |
| Service Definition Name | `cds.xt.SaasProvisioningService`                 |
| Default HTTP Endpoint   | `/-/cds/saas-provisioning`                       |

### Configuration {#saas-provisioning-config}

```jsonc
"cds.xt.SaasProvisioningService": {
  "jobs": {
    "queueSize": 5, // default: 100
    "workerSize": 5, // default: 1
    "clusterSize": 5, // default: 1
  }
}
```

- [Common Config Options](#common-config-options)
- `jobs` — settings of the built-in job orchestrator
  - `workerSize` — max number of parallel asynchronous jobs per database
  - `clusterSize` — max number of database clusters, running `workerSize` jobs each
  - `queueSize` — max number of jobs waiting to run in the job queue

#### HTTP Request Options

| Request Header        |  Example Value                                         | Description  |
| ----------------      | -------------------------------------------------------|--------------|
| `prefer`              | `respond-async`                                        | Trigger subscription, upgrade or unsubscription request asynchronously. |
| `status_callback`     | `/saas-manager/v1/subscription-callback/123456/result` | Callback path for SAP BTP SaaS Provisioning service. Set automatically if asynchronous subscription is configured for `saas-registry` service. |


::: tip No `prefer: respond-async` needed with callback
Requests are implicitly asynchronous when `status_callback` is set.
:::

##### Example Usage

With `@sap/hdi-deploy` [parameters](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-developer-guide-for-cloud-foundry-multitarget-applications-sap-business-app-studio/deployment-options-in-hdi) `trace` and `version`:

```http
POST /-/cds/saas-provisioning/upgrade HTTP/1.1
Content-Type: application/json

{
    "tenants": ["t1"],
    "options": {
        "_": {
            "hdi": {
                "deploy": {
                    "trace": "true",
                    "version": "true"
                }
            }
        }
    }
}
```

### GET `tenant/<tenant>` {#get-tenant}

Returns tenant-specific metadata if `<tenant>` is set, and a list of all tenants' metadata if omitted.

| Parameters |  Description                                                |
| ---------------- | ----------------------------------------------------------- |
| `tenant`         | A string identifying the tenant.                            |

#### Example Usage {#example-tenant-metadata}

##### Get Metadata for a Specific Tenant {#example-get-tenant-metadata}

::: code-group

```http [Request]
GET /-/cds/saas-provisioning/tenant/t1 HTTP/1.1
Content-Type: application/json
```

```json [Response]
{
    "subscribedTenantId": "tenant-1",
    "eventType": "CREATE",
    "subscribedSubdomain": "subdomain-1",
    "subscriptionAppName": "app-1",
    "subscribedSubaccountId": "subaccount-1",
    "createdAt": "2023-11-10T14:36:22.639Z",
    "modifiedAt": "2023-13-10T15:16:22.802Z"
}
```

:::

##### Get Metadata for All Tenants

::: code-group

```http [Request]
GET /-/cds/saas-provisioning/tenant HTTP/1.1
Content-Type: application/json
```

```json [Response]
[
  {
    "subscribedTenantId": "tenant-1",
    "eventType": "CREATE",
    "subscribedSubdomain": "subdomain-1",
    "subscriptionAppName": "app-1",
    "subscribedSubaccountId": "subaccount-1",
    "createdAt": "2023-11-10T14:36:22.639Z",
    "modifiedAt": "2023-13-10T15:16:22.802Z"
  },
  {
    "subscribedTenantId": "tenant-2",
    "eventType": "CREATE",
    "subscribedSubdomain": "subdomain-2",
    "subscriptionAppName": "app-2",
    "subscribedSubaccountId": "subaccount-2",
    "createdAt": "2023-11-11T14:36:22.639Z",
    "modifiedAt": "2023-11-12T12:14:45.452Z"
  }
]
```

:::

### PUT `tenant/<tenant>` (...) {#put-tenant}

Creates tenant resources required for onboarding.

Learn about query parameters, arguments, and their description in the following table:

| Parameters |                                                                         |
| ---------------- | ------------------------------------------------------------------------ |
| `tenant`         | A string identifying the tenant                                          |
| <span>Arguments</span>    |
| `subscribedTenantId`  | A string identifying the tenant                                     |
| `subscribedSubdomain` | A string identifying the tenant-specific subdomain                   |
| `eventType`           | The `saas-registry` event (`CREATE` or `UPDATE`)                    |

#### Example Usage {#example-post-tenant}

::: code-group

```http [Request]
PUT /-/cds/saas-provisioning/tenant/t1 HTTP/1.1
Content-Type: application/json

{
  "subscribedTenantId": "t1",
  "subscribedSubdomain": "subdomain1",
  "eventType": "CREATE"
}
```

```txt [Response]
https://my.app.url
```

:::

### DELETE `tenant/<tenant>` {#delete-tenant}

Deletes all tenant resources.

### GET `dependencies` _→ [{ xsappname }]_ {#get-dependencies}

Returns configured SAP BTP SaaS Provisioning service dependencies.

[Learn how to configure SaaS dependencies](./#saas-dependencies){.learn-more}

### `upgrade` _[tenants] → Jobs_

Use the `upgrade` endpoint to upgrade tenant base models.

| Arguments |  Description                                                |
| --------- | ----------------------------------------------------------- |
| `tenants` | A list of tenants, or `[*]` for all tenants                 |
| `options` | Additional options, including HDI deployment options, see [DeploymentService](#deployment-config), prefixed with `_` |

#### Example Usage {#example-upgrade}

##### Asynchronously Upgrade a List of Tenants

::: code-group

```http [Request]
POST /-/cds/saas-provisioning/upgrade HTTP/1.1
Content-Type: application/json
Prefer: respond-async

{
  "tenants": ["t1", "t2"],
  "options": {
      "_": {
          "hdi": {
              "deploy": {
                  "trace": "true",
                  "version": "true"
              }
          }
      }
    }
}
```

```json [Response]
{
  "ID": "<jobID>",
  "createdAt": "<timestamp>",
  "op": "upgrade",
  "tenants": {
    "t1": {
      "ID": "<taskID>"
    }
  }
}
```

:::

##### Asynchronously Upgrade All Tenants

::: code-group

```http [Request]
POST /-/cds/saas-provisioning/upgrade HTTP/1.1
Content-Type: application/json
Prefer: respond-async

{
  "tenants": ["*"]
}
```

```json [Response]
{
  "ID": "<jobID>",
  "createdAt": "<timestamp>",
  "op": "upgrade",
  "tenants": {
    "t1": {
      "ID": "<taskID>"
    }
  }
}
```

:::

We recommended to execute the upgrades asynchronously by setting the `Prefer: respond-async` header.
You can use the URL returned in the `Location` response header to poll the job status.

In addition, you can poll the status for individual tenants using its individual task ID:

```http
GET /-/cds/jobs/pollTask(ID='<taskID>') HTTP/1.1
```

The response is similar to the following:

```js
{
  "status": "FINISHED",
  "op": "upgrade"
}
```

The job and task status can take on the values `QUEUED`, `RUNNING`, `FINISHED` and `FAILED`.

<span id="sms-provisioning-service" />
<Fragment target="#sms-provisioning-service">

## SmsProvisioningService <Internal />

The _SmsProvisioningService_ is a façade for the _DeploymentService_ to adapt to the API expected by [SAP BTP's Subscription Manager Service](https://int.controlcenter.ondemand.com/index.html#/knowledge_center/articles/7961284168e848efb9e0462e38b4075d), hence providing out-of-the-box integration.

|                         |                                                  |
| ----------------------- | ------------------------------------------------ |
| Service Definition      | `@sap/cds-mtxs/srv/cf/sms-provisioning-service`  |
| Service Definition Name | `cds.xt.SmsProvisioningService`                  |
| Default HTTP Endpoint   | `/-/cds/sms-provisioning`                        |

### Configuration {#sms-provisioning-config}

To enable the _SmsProvisioningService_, you need to add an additional profile

```jsonc
 "cds": {
    "profiles": [
      "mtx-sidecar",
      "subscription-manager" // [!code ++]
    ]
    ...
  }
```

```jsonc
"cds.xt.SmsProvisioningService": {
  "dependencies": ["xsappname-1", "xsappname-2"]
}
```

- [Common Config Options](#common-config-options)
- `dependencies` — XSUAA-based dependencies (hybrid mode using Subscription Manager and SaaS Provisioning)

#### HTTP Request Options

| Request Header        |  Example Value                                         | Description  |
| ----------------      | -------------------------------------------------------|--------------|
| `prefer`              | `respond-async`                                        | Trigger subscription, upgrade or unsubscription request asynchronously. |
| `status_callback`     | `<subscription-manager callback url>`                  | Callback path for SAP BTP Subscription Manager service. Set automatically if asynchronous subscription is configured for `subscription-manager` service. |

### GET `tenant/<tenant>` {#get-tenant-sms}

Returns tenant-specific metadata if `<tenant>` is set, and a list of all tenants' metadata if omitted.

| Parameters |  Description                                                |
| ---------------- | ----------------------------------------------------------- |
| `tenant`         | A string identifying the tenant.                            |

#### Example Usage {#example-tenant-metadata-sms}

##### Get Metadata for a Specific Tenant {#example-get-tenant-metadata-sms}

::: code-group

```http [Request]
GET /-/cds/sms-provisioning/tenant/t1 HTTP/1.1
Content-Type: application/json
```

```json [Response]
{
    "subscribedTenantId": "54c71ff3-5d66-4453-b7a1-e803647c7d1a",
    "subscriber": {
        ...
    },
    "rootApplication": {
       ...
    },
    "ownServiceInstance": {
        ...
    },
    "eventType": "CREATE",
    "createdAt": "2024-01-24T16:17:48.079Z",
    "modifiedAt": "2024-01-24T16:17:48.079Z"
}
```

The response contains the [metadata that was sent by the Subscription Manager](https://int.controlcenter.ondemand.com/index.html#/knowledge_center/articles/7961284168e848efb9e0462e38b4075d) on subscription.

:::

##### Get Metadata for All Tenants

::: code-group

```http [Request]
GET /-/cds/sms-provisioning/tenant HTTP/1.1
Content-Type: application/json
```

```json [Response]
[
  {
    "subscribedTenantId": "54c71ff3-5d66-4453-b7a1-e803647c7d1a",
    "subscriber": {
        ...
    },
    "rootApplication": {
       ...
    },
    "ownServiceInstance": {
        ...
    },
    "eventType": "CREATE",
    "createdAt": "2024-01-24T16:17:48.079Z",
    "modifiedAt": "2024-01-24T16:17:48.079Z"
  },
  {
    ...
  }
]
```

:::

### PUT `tenant/<tenant>` (...) {#put-tenant-sms}

Creates tenant resources required for onboarding.

Learn about query parameters, arguments, and their description in the following table:

| Parameters |                                                                                |
| ---------------- | ------------------------------------------------------------------------ |
| `tenant`         | A string identifying the tenant                                          |
| <span>Arguments</span>    |
| `subscriber`     | An object identifying the tenant and subdomain                           |
| `eventType`      | The `subscription-manager` event (`CREATE` or `UPDATE`)                  |

#### Example Usage {#example-post-tenant-sms}

::: code-group

```http [Request]
PUT /-/cds/sms-provisioning/tenant/t1 HTTP/1.1
Content-Type: application/json

{
  "subscriber": {
    "subaccountSubdomain": "cap-zone-sub",
    "app_tid": "84d5da18-26e7-47df-b7a8-3c941761444c"
  },
  "eventType": "CREATE"
}
```

```txt [Response]
https://my.app.url
```

:::

### DELETE `tenant/<tenant>` {#delete-tenant-sms}

Deletes all tenant resources.

### GET `dependencies` _→ [{ xsappname }]_ {#get-dependencies-sms}

Lets you specify XSUAA-based dependencies for hybrid mode. If they are static, they can also be defined in the [service configuration](#sms-provisioning-config).

</Fragment>

## [Old MTX Reference](old-mtx-apis) {.toc-redirect}

[See Reference docs for former 'old' MTX Services.](old-mtx-apis){.learn-more}

<div id="secondary-file">guides/multitenancy/mtxs.fragment.md</div>


# Migration from Old MTX {#migration}

Towards new multitenancy capabilities
{.subtitle}

<div v-html="$frontmatter?.synopsis" />

<ImplVariantsHint />

::: warning Separate model changes from migration
We strongly recommended to separate any model changes from the migration. If you need to do model changes for the migration, please deploy the application
based on `@sap/cds-mtx` and upgrade all tenants using the [upgrade endpoint](./old-mtx-apis.md#upgrade-base-model-from-filesystem-asynchronous) before you do the migration.
:::
::: warning Deprecated! Update all modules
Make sure that you always use the latest version of the CAP modules using `npm outdated`. For Java, also check the versions configured in `pom.xml` files. Since
`@sap/cds-mtx` is deprecated for quite some time now and will no longer run with, for example, the latest version of `@sap/cds`, updating the versions and adapting your application to it
can only be done together with the migration to `@sap/cds-mtxs`. Please also read all release notes carefully and check it for changes that need to be made to the configuration.
:::

## Functional Differences

Before you start to migrate to `@sap/cds-mtxs`, read about the differences compared to the old MTX.

### Persistence Changes

With `@sap/cds-mtxs`, the persistence has been simplified. There's no second container needed (META-tenant) any longer. Instead, tenant-specific metadata, such as extensions, are stored in the same container as the application data.

![This screenshot is explained in the accompanying text.](assets/persistence-overview.drawio.svg)

In addition, `@sap/cds-mtxs` also uses a dedicated tenant `t0` to store some runtime data, such as job logs.

### Extensibility

#### Changes of Extension Persistence

In contrast to `@sap/cds-mtx`, with `@sap/cds-mtxs`, the extensions are no longer stored as sources, but only as compiled `csn` files. Instead of running a build on the server with each extension activation, the build is now run locally _before_ the extension is deployed. The extensions are then stored as `csn` files with a `tag` as key. When using [`cds push`](../extensibility/customization#push-extension), the `tag` is derived from the name of the extension project in `package.json`.

Example `package.json` of extension project:

```json
{
  "name": "@capire/orders-ext",
  "extends": "@capire/orders",
  ...
}

```

When the extension is pushed, it is stored with the tag `@capire/orders-ext`.

Also check the [Push API](mtxs#extensibilityservice). 

#### Handling of extension sources

As mentioned previously, `cds push` only uploads compiled extensions as CSN files. Thus, it's no longer possible to download the CDS sources from the server. Source control is expected to be done by the SaaS application provider using his own repository.

### Security

Some of the roles have changed with `@sap/cds-mtxs`.

| @sap/cds-mtx      | @sap/cds-mtxs            |
| ----------------- | ------------------------ |
| `ExtendCDS`       | `cds.ExtensionDeveloper` |
| `ExtendCDSdelete` | w/o replacement          |

## Permanent and Temporary Limitations

### Temporary Limitations

- Diagnose API isn't available.

### Permanent Limitations

- Scopes aren't configurable.
  <span id="afterpermanentlimitations" />
<Fragment target="#afterpermanentlimitations">

- `@sap/instance-manager` service is not supported.

</Fragment>

- It isn't possible to have tenant-specific model versions.
- Use of SAP HANA hdbmigrationtable is only possible for entities that aren't to be extended.
- Upload of arbitrary custom files together with extensions is no longer available.

## Migration Steps

To switch to `@sap/cds-mtxs`, you need to change your project configuration, your custom handlers, and you might need to update the database content.

![A decision tree covering the following steps.](assets/migration-steps.drawio.svg){}

### Adapt Project Configuration

<div class="impl node">

#### Switch to `@sap/cds-mtxs`

To switch your Node.js project to `@sap/cds-mtxs`, perform the following steps:

1. Remove `@sap/cds-mtx`:
   ```sh
   npm remove @sap/cds-mtx
   ```
2. Add `@sap/cds-mtxs`:
   ```sh
   npm add @sap/cds-mtxs
   ```
3. Open your _package.json_ and add the following:

   ```json
   "cds": {
       "requires": {
           "multitenancy": true
       }
   }

   ```

#### Enable Extensibility

If your project supports extensibility, you need to enable extensibility in your configuration.
To do so, you only need to add `extensibility: true` to your cds configuration in `.cdsrc.json` or `package.json`.

```json
"requires": {
  "multitenancy": true,
  "extensibility": true
}
```

</div>

<div class="impl java">

#### Create New Sidecar and Adapt mta.yaml

To create a sidecar based on `@sap/cds-mtxs`, you can use the following command:

```sh
cds add multitenancy
```

It creates a new sidecar folder _mtx/sidecar_ and also modifies other files, including _mta.yaml_.
Currently, as `cds add multitenancy` is meant to be used with new projects, the best way is to **revert** the changes that have been made to _mta.yaml_ and to make a few manual changes instead.

##### Remove Global Build Section

The global build section can be removed. The necessary build script has moved to the sidecar module.

```yaml
# build-parameters:
#   before-all:
#     - builder: custom
#       commands:
#         - npm install --production
#         - npx -p @sap/cds-dk cds build --production
```

##### Add MTXS Flag to Java Module

To switch the runtime module to `@sap/cds-mtxs`, you need to add the corresponding environment variable:

```yaml
requires:
  ...
  - name: mtx-sidecar
    properties:
      CDS_MULTITENANCY_MTXS_ENABLED: true # Only required for cds-services version 2
      CDS_MULTITENANCY_SIDECAR_URL: ~{url}
```

#### Adapt _mta.yaml_ to Use New Sidecar

To enable the newly created sidecar, you need to change the path of your existing sidecar to the new path.
You only need to adapt the path to `mtx/sidecar` and add a custom build section.

::: code-group

```yaml [mta.yaml]
modules:
  - name: bookshop-mtx
    type: nodejs
    path: mtx/sidecar # adapted path
    build-parameters: # added build section
      builder: custom
      build-result: gen
      commands:
        - npm run build
      requires:
        - name: bookshop-srv
    parameters:
      memory: 256M
      disk-quota: 1G
    requires:
      - name: bookshop-auth
      - name: bookshop-db
    provides:
      - name: mtx-api
        properties:
          mtx-url: ${default-url}
```

:::

#### Add Workspace for Sidecar in Root package.json

To make the `@sap/cds-mtxs` models part of the installation, add a workspace to the root `package.json` to include the sidecar dependencies.

```json
"workspaces": [
  "mtx/sidecar"
]
```

::: tip Freeze Sidecar Dependencies
To prepare the build of the MTA archive (`mbt build`), you need to generate a <nobr>`package-lock.json`</nobr> for the sidecar by executing this in the project root:

```sh
npm i --package-lock-only --prefix mtx/sidecar
```

:::

#### Adapt Build Tasks

`cds add multitenancy` also adapts the build tasks in `.cdsrc.json` or `package.json`.
You only need to remove the `mtx` build task.

If your project uses the default project layout, all build tasks can be removed from the build configuration as follows:

```json
{
  "build": {
    "target": "."
  },
  "profiles": ["with-mtx-sidecar", "java"],
  "requires": {
    "multitenancy": true
  }
}
```

#### Enable Extensibility

If your project supports extensibility, you need to enable extensibility in your configuration.
To do so, you only need to add `extensibility: true` to your cds configuration in `.cdsrc.json` or `package.json`.

```json
"requires": {
    "multitenancy": true,
    "extensibility": true
  }
```

</div>

#### Security Adaptations

The scopes needed by extension developers have changed.
Scopes `ExtendCDS` and `ExtendCDSdelete` have changed to `cds.ExtensionDeveloper`.
Make sure to adapt all occurrences in your security configuration (`xs-security.json`).

Communicate to customer admins and extension developers to add the new scope to their role collection.
Also adjust the documentation for the SaaS application accordingly if available.

<div class="impl node">

#### Handler Registration

A typical handler registration in `server.js` now looks like

```js
cds.on('served', async () => {
  const { 'cds.xt.SaasProvisioningService': provisioning } = cds.services
  const { 'cds.xt.DeploymentService': deployment } = cds.services

  await provisioning.prepend(() => {
    provisioning.on('UPDATE', 'tenant', async (req, next) => { ... })
    provisioning.on('dependencies', async (req, next) => { ... })
    ...
  })
  await deployment.prepend(() => {
    // previously this was `upgradeTenant`
    deployment.on('upgrade', async (req) => {
      // HDI container credentials are not yet available here
    })
    // previously this was `deployToDb`
    deployment.on('deploy', async (req) => {
      const { tenant, options: { container } } = req.data
      ...
    })
    ...
  })
})
```

Here's what has changed:

- `ProvisioningService` changed to `cds.xt.SaasProvisioningService`
- `DeploymentService` changed to `cds.xt.DeploymentService`
- Use `cds.on('served')` instead of `cds.on('mtx')`.

For Node.js, the `saas-registry` endpoints in `mta.yaml` need to be changed to `.../-/cds/saas-provisioning/...`:

```yaml
parameters:
  service: saas-registry
  config:
    appUrls:
      getDependencies: ~{mtx-api/mtx-url}/-/cds/saas-provisioning/dependencies
      onSubscription: ~{mtx-api/mtx-url}/-/cds/saas-provisioning/tenant/{tenantId}
```

</div>

#### Miscellaneous Configuration

`@sap/cds-mtx` offers some additional configuration that you can also set in `@sap/cds-mtxs`.

##### HDI Container Configuration

In `@sap/cds-mtx`, you can configure the HDI container creation as follows:

```json
"mtx": {
  "provisioning": {
      "lazymetadatacontainercreation": true,
      "container": {
          "provisioning_parameters": {
              "database_id": "<ID>"
          },
          "binding_parameters": {
            "key": "value"
          }
      },
      "metadatacontainer": {
        "provisioning_parameters": {
              "database_id": "<ID_META>"
          }
      }
  }
}
```

In `@sap/cds-mtxs`, you can do the same configuration for the `cds.xt.DeploymentService`:

```json
"requires": {
  "cds.xt.DeploymentService": {
    "lazyT0": true,
    "hdi": {
      "create": {
          "database_id": "<ID>"
      },
      "bind": {
        "key": "value"
      }
    },
    "for": {
      "t0": {
        "hdi": {
          "create": {
            "database_id": "<ID_META>"
          }
        }
      }
    }
  },
}
```
See also [Deployment configuration](./mtxs.md#deployment-config)

##### Extension Restrictions

This configuration allows to set what extensions are allowed.

With `@sap/cds-mtx`:

```json
"mtx" : {
  "extension-allowlist": [
    {
        "for": ["my.bookshop.Authors", "my.bookshop.Books"],
        "new-fields": 2
    },
    {
        "for": ["CatalogService"]
    }
  ]
}
```

With `@sap/cds-mtxs`, the same configuration has moved to the `cds.xt.ExtensibilityService` configuration:

```json
"requires": {
  "cds.xt.ExtensibilityService": {
    "extension-allowlist": [
      {
          "for": ["my.bookshop.Authors", "my.bookshop.Books"],
          "new-fields": 2
      },
      {
          "for": ["CatalogService"]
      }]
  }
}
```

See also [Extensibility configuration](./mtxs.md#extensibility-config)

### Verify Application Locally

As first verification of your configuration changes, you can try to run your application locally in [hybrid mode](../../advanced/hybrid-testing#run-with-service-bindings). To bind all the service
that are bound to your existing application, you can call `cds bind --to-app-services <your application>`. Afterwards, you can run `cds run --profile hybrid --resolve-bindings`.

### Migrate Tenant Content of Existing Applications

Depending on the MTX features that your existing application has used, you need to execute some steps to move your data to the persistence used by `@sap/cds-mtxs`.

#### Multitenancy Only

In case you only used the multitenancy features such as subscription/unsubscription, you just need to make the [configuration changes described earlier](#adapt-project-configuration).

::: tip When does this scenario apply?

- Your application doesn't support extensibility.
- You don't need to read all tenant IDs or the tenant metadata using
  <br>`GET /-/cds/saas-provisioning/tenant/` or
  <br>`GET /-/cds/saas-provisioning/tenant/<tenantId>`.

The tenant metadata is the data that is sent to the MTX API by the SAP BTP SaaS Provisioning Service on subscription, similar to this:

```json
{
    "subscriptionAppId": "...",
    "subscriptionAppName": "..." ,
    "subscribedTenantId": "...",
    ...
}
```

:::

See [project configuration](#adapt-project-configuration).

#### Saving Subscription Metadata

If your application needs access to the tenant list or tenant metadata, you need to update this data for `@sap/cds-mtxs`.

::: tip When does this scenario apply?

- Your application doesn't support extensibility.
- Your application needs to read all tenant IDs or the tenant metadata using <br>`GET /-/cds/saas-provisioning/tenant/` or
  <br>`GET /-/cds/saas-provisioning/tenant/<tenantId>`.
  :::

In order to copy the metadata from existing subscriptions to the new persistence of `@sap/cds-mtxs`, you need to run [a migration script](#run-the-migration-script) that comes with `@sap/cds-mtxs`.

#### Migration of Extensions

If your application supports extensibility, you also need to update the existing extensions for `@sap/cds-mtxs`. You can do this with the [same migration script](#run-the-migration-script).

::: tip When does this scenario apply?

- Your application supports extensibility.
  :::

#### Run the Migration Script

The migration script is part of `@sap/cds-mtxs`. You can run it locally or during application deployment. Before running the script, you need to make the [configuration changes](#adapt-project-configuration) mentioned earlier.

##### Run the Migration Script Locally

The script has to run in the (Node.js) application environment resulting from `cds build --production` to correctly simulate the execution in the deployment environment.
For Node.js applications, this result is the `gen/srv` folder generated in the application root, for Java applications, this result is the `gen` folder of the new `@sap/cds-mtxs` sidecar (`mtx/sidecar/gen`).

It also needs access to the application bindings. That means, when running locally, it has to [run in hybrid mode](../../advanced/hybrid-testing#run-with-service-bindings).

You also need to add the `production` profile to ensure that the models are resolved correctly.

::: tip
Make sure, that the sources you want to migrate have the exact same version on your local machine as the sources that are deployed to the `@sap/cds-mtx` application .
:::

Example:

```sh
cds migrate "*" --dry --profile hybrid,production --resolve-bindings
```

##### Options

To run the migration for all or a set of tenants, you need to run:

```sh
cds migrate <tenant>[,<tenant>]|"*"
```

The option `--dry` allows you to perform a dry run, without changing the database content.

Keep in mind that, depending on the number of tenants, the script requires some time to run. This is important when you consider to run it in combination with the application deployment.

If the migration was successful, tenants are marked as migrated. When running the migration a second time, these tenants are ignored. If you want to rerun the migration also for the already migrated tenants, you can do so by using parameter `--force`.

##### Save Existing Extension Projects

You can use the migration script to save the content of the subscribers' extension projects.

With parameter `-d`, you can specify a directory that is used by the script to store the existing, migrated extension projects.

```sh
cds migrate <tenant>[,<tenant>]|"*" -d <your directory>
```

To really access the saved extension projects, you need access to the file system, of course. So, the easiest way is to run the script locally for that.

##### Add the Migration Script as Cloud Foundry Task to mta.yaml

You can add the migration script as a `hook` to your Node.js server module (application or sidecar) in _mta.yaml_.
For that, you can use the script `cds-mtx-migrate` that also comes with the `@sap/cds-mtxs` but doesn't require `@sap/cds-dk` to be installed.
Example:

```yaml
- name: bookshop-mt-sidecar
  type: nodejs
  path: mtx/sidecar
  ...
  hooks:
    - name: migrate-tenants
      type: task
      phases:
      #  - blue-green.application.before-start.idle
        - deploy.application.before-start
      parameters:
        name: migration
        memory: 512M
        disk-quota: 768M
        command: cds-mtx-migrate "*"
```

See also [Module Hooks](https://help.sap.com/docs/btp/sap-business-technology-platform/module-hooks)
::: warning
Warning: In case you already run an upgrade as task and your project supports extensions, make sure that the upgrade is run **AFTER** the migration. Otherwise, the content of extended tables can get lost.
:::

##### Advanced: Separate Extensions Based on Extension File Names

The concept of extensions has slightly changed with `@sap/cds-mtxs`. Extensions sources are no longer stored in the backend. Instead, each extension gets a _tag_ and the extension is stored as `csn` with the _tag_ as key.
When running the migration script, all extension files are compiled to one `csn` and are stored with a default _tag_: `migrated`.

You can change the _default tag_ by passing your _own tag_ using the `--tag` parameter:

```sh
cds migrate "*" -d migrated_projects --tag "mytag"
```

In addition, you can separate your extensions into several `csn`-files with different tags. For example, if your original extension files follow a pattern, you can do so by passing parameter `--tagRule` with a regular expression.

Let's use the following extension project structure:

```zsh
old-bookshop-ext/
├── db/
│   ├── extension_id_1.cds
│   └── extension_id_2.cds
│   └── order_ext_id_1.cds
│   └── order_ext_id_2.cds
├── srv/
└── package.json
```

You can split your extensions as follows:

```sh
cds migrate "*" -d migrated_projects --tagRule "(?:ext_|extension_)(.*)\.cds"
```

As a result, you get two extensions with tags `id_1` and `id_2`. The _tag_ is taken from the first captured group of the regular expression.

::: tip Find the right regular expression
To verify if the result meets your expectations, you can make a dry run:

```sh
cds migrate "*" -d migrated_projects --tagRule "(?:ext_|extension_)(.*)\.cds" --dry
```

You can find the result in the folder _migrated_projects_.
:::

<span id="afterseparateextensions" />
<Fragment target="#afterseparateextensions">

#### Metatenant Cleanup <Beta />

With `@sap/mtx`, the metadata and extensions are stored in a separate container. After switching to `@sap/cds-mtxs`, these containers are not needed any longer.

The unused containers can be deleted in a separate step as follows:
```sh
cds migrate "*" --cleanup
```
The command only deletes the additional containers for tenants that have been successfully migrated.
The cleanup can only be run as a separate step. If `--cleanup` is added, no migration is performed.

</Fragment>

### Check Migration Result

To verify the result of the migration script, check the tenant's content of the HDI container. You can use any database client that can access SAP HANA databases.

#### Check Content Using SAP HANA Database Explorer

To see the content of an HDI Container, you can [add the tenant container to the SAP HANA Database Explorer](https://help.sap.com/docs/HANA_CLOUD/a2cea64fa3ac4f90a52405d07600047b/4e2e8382f8484edba31b8b633005e937.html).

You can find the migrated extensions in table `CDS_XT_EXTENSIONS`. The table contains:

- extensions parsed as `csn` strings in column **csn**
- key column **tag**

![The screenshot shows the table that is explained in the accompanying text.](assets/db_explorer.png){ .adapt}

## Migrated Extension Projects

As mentioned in [Save Existing Extension Projects](#save-existing-extension-projects), you can store existing extension projects locally.
We recommend to upload the projects to a source repository (e. g. github), because with `@sap/cds-mtxs` the content of extension projects is no longer stored in the tenant database. With that setup you can change and push the extension again later.

The content of extension projects is usually the property of the customer (subscriber). So, alternatively, the customer can [download](#download-of-migrated-extension-projects) the extension projects himself and upload them to his own source repository.

### Adapt for Streamlined MTX

As described in the [extensibility guide](../extensibility/customization##start-ext-project), you usually start with an empty extension project and pull the base model of the application using [`cds pull`](../extensibility/customization#pull-base).

When starting with a migrated extension project, you need to make some adaptations after running [`cds pull`](../extensibility/customization#pull-base). Previously, extension projects were using the full set of CDS files whereas extension projects based on `@sap/cds-mtxs` are using a compiled `index.csn` of the base model. This affects the references in the extension sources of the migrated project. So these references need to be adapted.

Recommended steps:

- Run [`cds pull`](../extensibility/customization#pull-base) to fetch the latest version of the base model as `index.csn`.
- Fix the references in your extension sources. All references to the base model must use the name specified in the `cds.extends` entry of the extension _package.json_, omitting any additional subfolders.
  Example: `using sap.capire.bookshop from '_base/db/schema';` must be replaced by `using sap.capire.bookshop from 'base-model';`
  <br>You can see all broken references as error messages when using the CDS Editor.

### Download of Migrated Extension Projects

As long as the metadata containers (`TENANT-<id>-META`) created by `@sap/cds-mtx` still exist, the customer extension projects can be downloaded using the CDS client. The [user](../extensibility/customization#cds-login) running the download command needs to have the scope `cds.ExtensionDeveloper` assigned:

```sh
cds extend <url> --download-migrated-projects
```
The command downloads an archive named `migrated_projects.tgz` that contains the existing extensions that are ready to be used with `@sap/cds-mtxs`.<br>

<span id="dynamicdeployer" />
<Fragment target="#dynamicdeployer">

## Migration of Projects Based on `@sap/hdi-dynamic-deploy` <Internal />

Projects that aren't using `@sap/cds-mtx` but deploy using the [Dynamic Deployer](https://www.npmjs.com/package/@sap/hdi-dynamic-deploy) can also be adapted to use `@sap/cds-mtxs`.

To fully enable `@sap/cds-mtxs`, you first need to add it to your project using

```sh
cds add multitenancy
```

In addition, you need to fill the internal tenant list by running

```sh
cds-mtx-migrate '*' --init-tenant-list
```

You can also run the command as Cloud Foundry Task as described [before](#add-the-migration-script-as-cloud-foundry-task-to-mta-yaml).

It is possible to fill the list with a given set of tenants:

```sh
cds-mtx-migrate ‹t1›,‹t2› --init-tenant-list
```

</Fragment>

<div id="secondary-file">guides/multitenancy/old-mtx-migration.fragment.md</div>


# Extensibility

Learn here about intrinsic capabilities to extend your applications in verticalization and customization scenarios.

Extensibility of CAP applications is greatly fueled by **CDS Aspects**, which allow to easily extend existing models with new fields, entities, relationships, or new or overridden annotations [&rarr; Learn more about using CDS Aspects in the Domain Modeling guide](../domain-modeling#separation-of-concerns).

![This screenshot is explained in the accompanying text.](assets/extensibility.drawio.svg)

As illustrated in the graphic above, different parties can build and deploy CDS Aspects-based extensions:

- **Customizations** – Customers/Subscribers of SaaS solutions need options to tailor these to their needs, again using CDS Aspects to add custom fields and entities.

- **Toggled Features** – SaaS providers can offer pre-built enhancement features, which can be switched on selectively per tenant using Feature Toggles, for example, specialization for selected industries.

- **Composition** – Finally, 3rd parties can provide pre-built extension packages for reuse, which customers can pick and compose into own solutions.

- **Verticalization** – 3rd parties can provide verticalized versions of a given base application, which they can in turn operate as verticalized SaaS apps.

<br>

The following guides give detailed information to each of these options.



<IndexList :pages='pages' />



# Extending SaaS Applications

## Introduction & Overview

Subscribers (customers) of SaaS solutions frequently need to tailor these to their specific needs, for example, by adding specific extension fields and entities. All CAP-based applications intrinsically support such **SaaS extensions** out of the box.

The overall process is depicted in the following figure:

![The graphic shows the three parts that are also discussed in this guide. Each part has it's steps. The first part is the one of the SaaS provider. As SaaS provider you need to deploy an extensible application and provide a guide that explains how to extend your application. In addition the SaaS provider should provide a project template for extension projects. The next part is for the SaaS customer. In this role you need to setup a tenant landscape for your extension, subscribe to the application you want to extend and authorize the extension developers. The last part is for the extension developer. As such, you start an extension project, develop and test your extension and then activate it.](assets/process_SAP_BTP.drawio.svg)

In this guide, you will learn the following:

- How to enable extensibility as a **SaaS provider**.
- How to develop SaaS extensions as a **SaaS customer**.


## Prerequisites {#prerequisites}

Before we start, you'll need a **CAP-based [multitenant SaaS application](../multitenancy/)** that you can modify and deploy.


::: tip Jumpstart
You can download the ready-to-use [Orders Management application](https://github.com/SAP-samples/cloud-cap-samples/tree/main/orders):

```sh
git clone https://github.com/SAP-samples/cloud-cap-samples
cd cloud-cap-samples/orders
cds add multitenancy
```

Also, ensure you have the latest version of `@sap/cds-dk` installed globally:

```sh
npm update -g @sap/cds-dk
```

:::

## As a SaaS Provider { #prep-as-provider }

CAP provides intrinsic extensibility, which means all your entities and services are extensible by default.

Your SaaS app becomes the **base app** for extensions by your customers, and your data model the **base model**.

### 1. Enable Extensibility

Extensibility is enabled by running this command in your project root:

```sh
cds add extensibility
```

::: details Essentially, this automates the following steps…

1. It adds an `@sap/cds-mtxs` package dependency:

```sh
npm add @sap/cds-mtxs
```

2. It switches on <Config>cds.requires.extensibility: true</Config> in your _package.json_:

::: code-group

```json [package.json]
{
  "name": "@capire/orders",
  "version": "1.0.0",
  "dependencies": {
    "@capire/common": "*",
    "@sap/cds": ">=9",
    "@sap/cds-mtxs": "^3"
  },
  "cds": {
    "requires": {
      "extensibility": true // [!code focus]
    }
  }
}
```

:::

If `@sap/cds-mtxs` is newly added to your project install the dependencies:

```sh
npm i
```

### 2. Restrict Extension Points { #restrictions }

Normally, you'll want to restrict which services or entities your SaaS customers are allowed to extend and to what degree they may do so. Take a look at the following configuration:

::: code-group

```jsonc [mtx/sidecar/package.json]
{
  "cds": {
    "requires": {
      "cds.xt.ExtensibilityService": {
        "element-prefix": ["x_"],
        "extension-allowlist": [
          {
            "for": ["sap.capire.orders"],
            "kind": "entity",
            "new-fields": 2
          },
          {
            "for": ["OrdersService"],
            "new-entities": 2
          }
        ]
      }
    }
  }
}
```

:::

This enforces the following restrictions:

- All new elements have to start with `x_` → to avoid naming conflicts.
- Only entities in namespace `sap.capire.orders` can be extended, with a maximum 2 new fields allowed.
- Only the `OrdersService` can be extended, with a maximum of 2 new entities allowed.

[Learn more about extension restrictions.](../multitenancy/mtxs#extensibility-config){.learn-more}

### 3. Provide Template Projects {#templates}

To jumpstart your customers with extension projects, it's beneficial to provide a template project. Including this template with your application and making it available as a downloadable archive not only simplifies their work but also enhances their experience.

#### Create an Extension Project (Template)

Extension projects are standard CAP projects extending the SaaS application. Create one for your SaaS app following these steps:

1. Create a new CAP project — `orders-ext` in our walkthrough:

   ```sh
   cd ..
   cds init orders-ext
   code orders-ext # open in VS Code
   ```

2. Add this to your _package.json_:

    ::: code-group

    ```jsonc [package.json]
    {
      "name": "@capire/orders-ext",
      "extends": "@capire/orders",
      "workspaces": [ ".base" ]
    }
    ```

    :::

- `name` identifies the extension within a SaaS subscription; extension developers can choose the value freely.
- `extends` is the name by which the extension model will refer to the base model. This must be a valid npm package name as it will be used by `cds pull` as a package name for the base model. It doesn't have to be a unique name, nor does it have to exist in a package registry like npmjs, as it will only be used locally.
- `workspaces` is a list of folders including the one where the base model is stored. `cds pull` will add this property automatically if not already present.

::: details Uniqueness of base-model name…

You use the `extends` property as the name of the base model in your extension project. Currently, it's not an issue if the base model name isn't unique. However, to prevent potential conflicts, we recommend using a unique name for the base model.

:::

#### Add Sample Content

Create a new file _app/extensions.cds_ and fill in this content:


::: code-group

```cds [app/extensions.cds]
namespace x_orders.ext; // only applies to new entities defined below
using { OrdersService, sap.capire.orders.Orders } from '@capire/orders';

extend Orders with {
  x_new_field : String;
}

// -------------------------------------------
// Fiori Annotations

annotate Orders:x_new_field with @title: 'New Field';
annotate OrdersService.Orders with @UI.LineItem: [
  ... up to { Value: OrderNo },
  { Value : x_new_field },
  ...
];
```

:::

The name of the _.cds_ file can be freely chosen. Yet, for the build system to work out of the box, it must be in either the `app`, `srv`, or `db` folder.

[Learn more about project layouts.](../../get-started/#project-structure){.learn-more}

::: tip Keep it simple
We recommend putting all extension files into `./app` and removing `./srv` and `./db` from extension projects.

You may want to consider [separating concerns](../domain-modeling#separation-of-concerns) by putting all Fiori annotations into a separate _./app/fiori.cds_.
:::

#### Add Test Data

To support [quick-turnaround tests of extensions](#test-locally) using `cds watch`, add some test data. In your template project, create a file _test/data/sap.capire.orders-Orders.csv_ like that:

::: code-group

```csv [test/data/sap.capire.orders-Orders.csv]
ID;createdAt;buyer;OrderNo;currency_code;
7e2f2640-6866-4dcf-8f4d-3027aa831cad;2019-01-31;john.doe@test.com;1;EUR
64e718c9-ff99-47f1-8ca3-950c850777d4;2019-01-30;jane.doe@test.com;2;EUR
```

:::

#### Add a Readme

Include additional documentation for the extension developer in a _README.md_ file inside the template project.
::: code-group

```md [README.md]
# Getting Started

Welcome to your extension project to  `@capire/orders`.

It contains these folders and files, following our recommended project layout:

| File or Folder | Purpose                        |
|----------------|--------------------------------|
| `app/`         | all extensions content is here |
| `test/`        | all test content is here       |
| `package.json` | project configuration          |
| `readme.md`    | this getting started guide     |


## Next Steps

- `cds pull` the latest models from the SaaS application
- edit [`./app/extensions.cds`](./app/extensions.cds) to add your extensions
- `cds watch` your extension in local test-drives
- `cds push` your extension to **test** tenant
- `cds push` your extension to **prod** tenant


## Learn More

Learn more at https://cap.cloud.sap/docs/guides/extensibility/customization.
```

:::

### 4. Provide Extension Guides {#guide}

You should provide documentation to guide your customers through the steps to add extensions. This guide should provide application-specific information along the lines of the walkthrough steps presented in this guide.

Here's a rough checklist what this guide should cover:


- [How to set up test tenants](#prepare-an-extension-tenant) for extension projects
- [How to assign requisite roles](#prepare-an-extension-tenant) to extension developers
- [How to start extension projects](#start-ext-project) from [provided templates](#templates)
- [How to find deployed app urls](#pull-base) of test and prod tenants
- [What can be extended?](#about-extension-models) → which services, entities, ...
- [With enclosed documentation](../../cds/cdl#doc-comment) to the models for these services and entities.

### 5. Deploy Application

Before deploying your SaaS application to the cloud, you can [test-drive it locally](../multitenancy/#test-locally).
Prepare this by going back to your app with `cd orders`.

With your application enabled and prepared for extensibility, you are ready to deploy the application as described in the  [Deployment Guide](../deployment/).

## As a SaaS Customer {#prep-as-operator}

The following sections provide step-by-step instructions on adding extensions.
All steps are based on our Orders Management sample which can be [started locally for testing](../multitenancy/#test-locally).

::: details On BTP…

To extend a SaaS app deployed to BTP, you'll need to subscribe to it [through the BTP cockpit](../multitenancy/#subscribe).

Refer to the [Deployment Guide](../deployment/to-cf) for more details on remote deployments.

Also, you have to replace local URLs used in `cds` commands later with the URL of the deployed App Router.
Use a passcode to authenticate and authorize you.
Refer to the section on [`cds login`](#cds-login) for a simplified workflow.

:::

### 1. Subscribe to SaaS App

It all starts with a customer subscribing to a SaaS application. In a productive application this is usually triggered by the platform to which the customer is logged on. The platform is using a technical user to call the application subscription API.
In your local setup, you can simulate this with a [mock user](../../node.js/authentication#mock-users) `yves`.

1. In a new terminal, subscribe as tenant `t1`:

    ```sh
    cds subscribe t1 --to http://localhost:4005 -u yves:
    ```

  Please note that the URL used for the subscription command is the sidecar URL, if a sidecar is used.
  Learn more about tenant subscriptions [via the MTX API for local testing](../multitenancy/mtxs#put-tenant).{.learn-more}

2. Verify that it worked by opening the [Orders Management Fiori UI](http://localhost:4004/orders/index.html#manage-orders) in a **new private browser window** and log in as `carol`, which is assigned to tenant `t1`.

![A screenshot of an SAP Fiori UI on the orders management example. It shows a table with the columns order number, customer, currency and date. The table contains two orders.](assets/image-20221004054556898.png){.mute-dark}

### 2. Prepare an Extension Tenant {#prepare-an-extension-tenant}

In order to test-drive and validate the extension before activating to production, you'll first need to set up a test tenant. This is how you simulate it in your local setup:

1. Set up a **test tenant** `t1-ext`

    ```sh
    cds subscribe t1-ext --to http://localhost:4005 -u yves:
    ```

2. Assign **extension developers** for the test tenant.

    > As you're using mocked auth, simulate this step by adding the following to the SaaS app's _package.json_, assigning user `bob` as extension developer for tenant `t1-ext`:

  ::: code-group

  ```json [package.json]
  {
    "cds": {
      "requires": {
        "auth": {
          "users": {
            "bob": {
              "tenant": "t1-ext",
              "roles": ["cds.ExtensionDeveloper"]
            }
          }
        }
      }
    }
  }
  ```

  :::

### 3. Start an Extension Project {#start-ext-project}

Extension projects are standard CAP projects extending the subscribed application. SaaS providers usually provide **application-specific templates**, which extension developers can download and open in their editor.

You can therefore use the extension template created in your walkthrough [as SaaS provider](#templates).
Open the `orders-ext` folder in your editor. Here's how you do it using VS Code:

```sh
code ../orders-ext
```

![A screenshot of a readme.md file as it's described in the previous "Add a readme" section of this guide.](assets/orders-ext.png){.ignore-dark}

### 4. Pull the Latest Base Model {#pull-base}

Next, you need to download the latest base model.

```sh
cds pull --from http://localhost:4005 -u bob:
```

> Run `cds help pull` to see all available options.

This downloads the base model as a package into an npm workspace folder `.base`. The actual folder name is taken from the `workspaces` configuration. It also prepares the extension _package.json_ to reference the base model, if the extension template does not already do so.

::: details See what `cds pull` does…

1. Gets the base-model name from the extension _package.json_, property `extends`.

   If the previous value is not a valid npm package name, it gets changed to `"base-model"`. In this case, existing source files may have to be manually adapted. `cds pull` will notify you in such cases.

2. It fetches the base model from the SaaS app.
3. It saves the base model in a subdirectory `.base` of the extension project.

   This includes file _.base/package.json_ describing the base model as an npm package, including a `"name"` property set to the base-model name.

4. In the extension _package.json_:

    - It configures `.base` as an npm workspace folder.
    - It sets the `extends` property to the base-model name.

:::

### 5. Install the Base Model

To make the downloaded base model ready for use in your extension project, install it as a package:

```sh
npm install
```

This will link the base model in the workspace folder to the subdirectory `node_modules/@capire/orders` (in this example).

### 6. Write the Extension {#write-extension }

Edit the file _app/extensions.cds_ and replace its content with the following:

::: code-group

```cds [app/extensions.cds]
namespace x_orders.ext; // for new entities like SalesRegion below
using { OrdersService, sap, sap.capire.orders.Orders } from '@capire/orders';

extend Orders with { // 2 new fields....
  x_priority    : String enum {high; medium; low} default 'medium';
  x_salesRegion : Association to x_SalesRegion;
}

entity x_SalesRegion : sap.common.CodeList { // Value Help
  key code : String(11);
}


// -------------------------------------------
// Fiori Annotations

annotate Orders:x_priority with @title: 'Priority';
annotate x_SalesRegion:name with @title: 'Sales Region';

annotate OrdersService.Orders with @UI.LineItem: [
  ... up to { Value: OrderNo },
  { Value: x_priority },
  { Value: x_salesRegion.name },
  ...
];
```

:::

[Learn more about what you can do in CDS extension models](#about-extension-models){.learn-more}


::: tip
Make sure **no syntax errors** are shown in the [CDS editor](../../tools/cds-editors#vscode) before going on to the next steps.
:::

### 7. Test-Drive Locally {#test-locally }

To conduct an initial test of your extension, run it locally with `cds watch`:

```sh
cds watch --port 4006
```

> This starts a local Node.js application server serving your extension along with the base model and supplied test data stored in an in-memory database.<br>
> It does not include any custom application logic though.

#### Add Local Test Data

To improve local test drives, you can add _local_ test data for extensions.

Edit the template-provided file `test/data/sap.capire.orders-Orders.csv` and add data for the new fields as follows:

::: code-group

```csv [test/data/sap.capire.orders-Orders.csv]
ID;createdAt;buyer;OrderNo;currency_code;x_priority;x_salesRegion_code
7e2f2640-6866-4dcf-8f4d-3027aa831cad;2019-01-31;john.doe@test.com;1;EUR;high;EMEA
64e718c9-ff99-47f1-8ca3-950c850777d4;2019-01-30;jane.doe@test.com;2;EUR;low;APJ
```

:::

Create a new file `test/data/x_orders.ext-x_SalesRegion.csv` with this content:

::: code-group

```csv [test/data/x_orders.ext-x_SalesRegion.csv]
code;name;descr
AMER;Americas;North, Central and South America
EMEA;Europe, the Middle East and Africa;Europe, the Middle East and Africa
APJ;Asia Pacific and Japan;Asia Pacific and Japan
```

:::

#### Verify the Extension

Verify your extensions are applied correctly by opening the [Orders Fiori Preview](http://localhost:4006/$fiori-preview/OrdersService/Orders#preview-app) in a **new private browser window**, log in as `bob`, and see columns _Priority_ and _Sales Region_ filled as in the following screenshot:

![This screenshot is explained in the accompanying text.](assets/image-20221004080722532.png){.mute-dark}

> Note: the screenshot includes local test data, added as explained below.

This test data will only be deployed to the local sandbox and not be processed during activation to the productive environment.

### 8. Push to Test Tenant {#push-extension }

Let's push your extension to the deployed application in your test tenant for final verification before pushing to production.

```sh
cds push --to http://localhost:4005 -u bob:
```

::: tip
`cds push` runs a `cds build` on your extension project automatically.
:::

::: details Prepacked extensions
To push a ready-to-use extension archive (.tar.gz or .tgz), run `cds push <archive or URL>`. The argument can be a local path to the archive or a URL to download it from.
Run `cds help push` to see all available options.
:::

> You pushed the extension with user `bob`, which in your local setup ensures they are sent to your test tenant `t1-ext`, not the production tenant `t1`.

::: details Building extensions

`cds build` compiles the extension model and validates the constraints defined by the SaaS application, for example, it checks if the entities are extendable.
It will fail in case of compilation or validation errors, which will in turn abort `cds push`.

_Warning_ messages related to the SaaS application base model are reclassified as _info_ messages. As a consequence they will not be shown by default.
Execute `cds build --log-level info` to display all messages, although they should not be of interest for the extension developer.

:::

#### Verify the Extension {#test-extension }

Verify your extensions are applied correctly by opening the [Order Management UI](http://localhost:4004/orders/index.html#manage-orders) in a **new private browser window**, log in as `bob`, and check that columns _Priority_ and _Sales Region_ are displayed as in the following screenshot. Also, check that there's content with a proper label in the _Sales Region_ column.

![The screenshot is explained in the accompanying text.](assets/image-20221004081826167.png){.mute-dark}

### 9. Add Data {#add-data}

After pushing your extension, you have seen that the column for _Sales Region_ was added, but is not filled.
To change this, you need to provide initial data with your extension. Copy the data file that you created before from `test/data/` to `db/data/` and push the extension again.

[Learn more about adding data to extensions](#add-data-to-extensions) {.learn-more}

### 10. Activate the Extension {#push-to-prod}

Finally, after all tests, verifications and approvals are in place, you can push the extension to your production tenant:

```sh
cds push --to http://localhost:4005 -u carol:
```

> You pushed the extension with [mock user](../../node.js/authentication#mock-users) `carol`, which in your local setup ensures they are sent to your **production** tenant `t1`.

::: tip Simplify your workflow with `cds pull` and `cds push`

Particularly when extending deployed SaaS apps, refer to [`cds login`](#cds-login) to save project settings and authentication data for later reuse.

:::

# Appendices



## Configuring App Router {#app-router}

In a deployed multitenant SaaS application, you need to set up the App Router correctly. This setup lets the CDS command-line utilities connect to the MTX Sidecar without needing to authenticate again. If you haven't used both the `cds add multitenancy` and `cds add approuter` commands, it's likely that you'll need to tweak the App Router configuration. You can do this by adding a route to the MTX Sidecar.

```json [app/router/xs-app.json]
{
  "routes": [
    {
      "source": "^/-/cds/.*",
      "destination": "mtx-api",
      "authenticationType": "none"
    }
  ]
}
```

This ensures that the App Router doesn't try to authenticate requests to MTX Sidecar, which would fail. Instead, the Sidecar authenticates requests itself.

## About Extension Models

This section explains in detail about the possibilities that the _CDS_ languages provides for extension models.

All names are subject to [extension restrictions defined by the SaaS app](../multitenancy/mtxs#extensibility-config).

### Extending the Data Model

Following [the extend directive](../../cds/cdl#extend) it is pretty straightforward to extend the application with the following new artifacts:

- Extend existing entities with new (simple) fields.
- Create new entities.
- Extend existing entities with new associations.
- Add compositions to existing or new entities.
- Supply new or existing fields with default values, range checks, or value list (enum) checks.
- Define a mandatory check on new or existing fields.
- Define new unique constraints on new or existing entities.

```cds
using {sap.capire.bookshop, sap.capire.orders} from '@capire/fiori';
using {
  cuid, managed, Country, sap.common.CodeList
} from '@sap/cds/common';

namespace x_bookshop.extension;

// extend existing entity
extend orders.Orders with {
  x_Customer    : Association to one x_Customers;
  x_SalesRegion : Association to one x_SalesRegion;
  x_priority    : String @assert.range enum {high; medium; low} default 'medium';
  x_Remarks     : Composition of many x_Remarks on x_Remarks.parent = $self;
}
// new entity - as association target
entity x_Customers : cuid, managed {
  email        : String;
  firstName    : String;
  lastName     : String;
  creditCardNo : String;
  dateOfBirth  : Date;
  status       : String   @assert.range enum {platinum; gold; silver; bronze} default 'bronze';
  creditScore  : Decimal  @assert.range: [ 1.0, 100.0 ] default 50.0;
  PostalAddresses : Composition of many x_CustomerPostalAddresses on PostalAddresses.Customer = $self;
}

// new unique constraint (secondary index)
annotate x_Customers with @assert.unique: { email: [ email ] } {
  email @mandatory;  // mandatory check
}

// new entity - as composition target
entity x_CustomerPostalAddresses : cuid, managed {
  Customer     : Association to one x_Customers;
  description  : String;
  street       : String;
  town         : String;
  country      : Country;
}

// new entity - as code list
entity x_SalesRegion: CodeList {
  key regionCode : String(11);
}

// new entity - as composition target
entity x_Remarks : cuid, managed {
  parent      : Association to one orders.Orders;
  number      : Integer;
  remarksLine : String;
}
```

::: tip
This example provides annotations for business logic handled automatically by CAP as documented in [_Providing Services_](../providing-services#input-validation).
:::
Learn more about the [basic syntax of the `annotate` directive](../../cds/cdl#annotate) {.learn-more}

### Extending the Service Model

In the existing in `OrdersService`, the new entities `x_CustomerPostalAddresses` and `x_Remarks` are automatically included since they are targets of the corresponding _compositions_.

The new entities `x_Customers` and `x_SalesRegion` are [autoexposed](../providing-services#auto-exposed-entities) in a read-only way as [CodeLists](../../cds/common#aspect-codelist).  Only if wanted to _change_ it, you would need to expose them explicitly:

```cds
using { OrdersService } from '@capire/fiori';

extend service OrdersService with {
  entity x_Customers   as projection on extension.x_Customers;
  entity x_SalesRegion as projection on extension.x_SalesRegion;
}
```

### Extending UI Annotations

The following snippet demonstrates which UI annotations you need to expose your extensions to the SAP Fiori elements UI.

Add UI annotations for the completely new entities `x_Customers, x_CustomerPostalAddresses, x_SalesRegion, x_Remarks`:

```cds
using { OrdersService } from '@capire/fiori';

// new entity -- draft enabled
annotate OrdersService.x_Customers with @odata.draft.enabled;

// new entity -- titles
annotate OrdersService.x_Customers with {
  ID           @(
    UI.Hidden,
    Common : {Text : email}
  );
  firstName    @title : 'First Name';
  lastName     @title : 'Last Name';
  email        @title : 'Email';
  creditCardNo @title : 'Credit Card No';
  dateOfBirth  @title : 'Date of Birth';
  status       @title : 'Status';
  creditScore  @title : 'Credit Score';
}

// new entity -- titles
annotate OrdersService.x_CustomerPostalAddresses with {
  ID          @(
    UI.Hidden,
    Common : {Text : description}
  );
  description @title : 'Description';
  street      @title : 'Street';
  town        @title : 'Town';
  country     @title : 'Country';
}

// new entity -- titles
annotate x_SalesRegion : regionCode with @(
  title : 'Region Code',
  Common: { Text: name, TextArrangement: #TextOnly }
);


// new entity in service -- UI
annotate OrdersService.x_Customers with @(UI : {
  HeaderInfo       : {
    TypeName       : 'Customer',
    TypeNamePlural : 'Customers',
    Title          : { Value : email}
  },
  LineItem         : [
    {Value : firstName},
    {Value : lastName},
    {Value : email},
    {Value : status},
    {Value : creditScore}
  ],
  Facets           : [
  {$Type: 'UI.ReferenceFacet', Label: 'Main', Target : '@UI.FieldGroup#Main'},
  {$Type: 'UI.ReferenceFacet', Label: 'Customer Postal Addresses', Target: 'PostalAddresses/@UI.LineItem'}
],
  FieldGroup #Main : {Data : [
    {Value : firstName},
    {Value : lastName},
    {Value : email},
    {Value : status},
    {Value : creditScore}
  ]}
});

// new entity -- UI
annotate OrdersService.x_CustomerPostalAddresses with @(UI : {
  HeaderInfo       : {
    TypeName       : 'CustomerPostalAddress',
    TypeNamePlural : 'CustomerPostalAddresses',
    Title          : { Value : description }
  },
  LineItem         : [
    {Value : description},
    {Value : street},
    {Value : town},
    {Value : country_code}
  ],
  Facets           : [
    {$Type: 'UI.ReferenceFacet', Label: 'Main', Target : '@UI.FieldGroup#Main'}
  ],
  FieldGroup #Main : {Data : [
    {Value : description},
    {Value : street},
    {Value : town},
    {Value : country_code}
  ]}
}) {};

// new entity -- UI
annotate OrdersService.x_SalesRegion with @(
  UI: {
    HeaderInfo: {
      TypeName       : 'Sales Region',
      TypeNamePlural : 'Sales Regions',
      Title          : { Value : regionCode }
    },
    LineItem: [
      {Value: regionCode},
      {Value: name},
      {Value: descr}
    ],
    Facets: [
      {$Type: 'UI.ReferenceFacet', Label: 'Main', Target: '@UI.FieldGroup#Main'}
    ],
    FieldGroup#Main: {
      Data: [
        {Value: regionCode},
        {Value: name},
        {Value: descr}
      ]
    }
  }
) {};

// new entity -- UI
annotate OrdersService.x_Remarks with @(
  UI: {
    HeaderInfo: {
      TypeName       : 'Remark',
      TypeNamePlural : 'Remarks',
      Title          : { Value : number }
    },
    LineItem: [
      {Value: number},
      {Value: remarksLine}
    ],
    Facets: [
      {$Type: 'UI.ReferenceFacet', Label: 'Main', Target: '@UI.FieldGroup#Main'}
    ],
    FieldGroup#Main: {
      Data: [
          {Value: number},
          {Value: remarksLine}
      ]
    }
  }
) {};
```

#### Extending Array Values

Extend the existing UI annotation of the existing `Orders` entity with new extension fields and new facets using the special [syntax for array-valued annotations](../../cds/cdl#extend-array-annotations).

```cds
// extend existing entity Orders with new extension fields and new composition
annotate OrdersService.Orders with @(
  UI: {
    LineItem: [
      ... up to { Value: OrderNo },                             // head
      {Value: x_Customer_ID,            Label:'Customer'},     //> extension field
      {Value: x_SalesRegion.regionCode, Label:'Sales Region'}, //> extension field
      {Value: x_priority,               Label:'Priority'},     //> extension field
      ...,                                                     // rest
    ],
    Facets: [...,
      {$Type: 'UI.ReferenceFacet', Label: 'Remarks', Target: 'x_Remarks/@UI.LineItem'} // new composition
    ],
    FieldGroup#Details: {
      Data: [...,
        {Value: x_Customer_ID,            Label:'Customer'},      // extension field
        {Value: x_SalesRegion.regionCode, Label:'Sales Region'},  // extension field
        {Value: x_priority,               Label:'Priority'}       // extension field
      ]
    }
  }
);

```

The advantage of this syntax is that you do not have to replicate the complete array content of the existing UI annotation, you only have to add the delta.

#### Semantic IDs

Finally, exchange the display ID (which is by default a GUID) of the new `x_Customers` entity with a human readable text which in your case is given by the unique property `email`.

```cds
// new field in existing service -- exchange ID with text
annotate OrdersService.Orders:x_Customer with @(
  Common: {
    //show email, not id for Customer in the context of Orders
    Text: x_Customer.email  , TextArrangement: #TextOnly,
    ValueList: {
      Label: 'Customers',
      CollectionPath: 'x_Customers',
      Parameters: [
        { $Type: 'Common.ValueListParameterInOut',
          LocalDataProperty: x_Customer_ID,
          ValueListProperty: 'ID'
        },
        { $Type: 'Common.ValueListParameterDisplayOnly',
          ValueListProperty: 'email'
        }
      ]
    }
  }
);
```

### Localizable Texts

To externalize translatable texts, use the same approach as for standard applications, that is, create a _i18n/i18n.properties_ file:

::: code-group

```properties [i18n/i18n.properties]
SalesRegion_name_col = Sales Region
Orders_priority_col = Priority
...
```

:::

Then replace texts with the corresponding `{i18n>...}` keys from the properties file.
Make sure to run `cds build` again.

Properties files must be placed in the `i18n` folder.  If an entry with the same key exists in the SaaS application, the translation of the extension has preference.

> This feature is available with `@sap/cds` 6.3.0 or higher.

[Learn more about localization](../i18n){.learn-more}

## Simplify Your Workflow With `cds login` {#cds-login}

As a SaaS extension developer, you have the option to log in to the SaaS app and thus authenticate only once.
This allows you to re-run `cds pull` and `cds push` against the app without repeating the same options over and over again – and you can avoid generating a passcode every time.

Achieve this by running `cds login` once. This command fetches tokens using OAuth2 from XSUAA and saves them for later use. For convenience, further settings for the current project are also stored, so you don't have to provide them again (such as the app URL and tenant subdomain).

### Where Tokens Are Stored

Tokens are saved in the desktop keyring by default
(libsecret on Linux, Keychain Access on macOS, or Credential Vault on Windows).

Using the keyring is more secure because, depending on the platform, you can lock and unlock it, and data saved by `cds login` may be inaccessible to other applications you run.

> For details, refer to the documentation of the keyring implementation used on your development machine.

`cds login` therefore uses the keyring by default. To enable this, you need to install an additional Node.js module, [_keytar_](https://www.npmjs.com/package/keytar):

```sh
npm i -g keytar
```

If you decide against using the keyring, you can request `cds login` to write to a plain-text file by appending `--plain`.

::: tip Switching to and from plain-text
Once usage of the `--plain` option changes for a given SaaS app, `cds login` migrates pre-existing authentication data from the previous storage to the new storage.
:::

::: warning Handle secrets with caution
Local storage of authentication data incurs a security risk: a potential malicious, local process might be able to perform actions you're authorized for, with the SaaS app, as your tenant.
:::

> In SAP Business Application Studio, plain-text storage is enforced when using `cds login`, since no desktop keyring is available. The plain-text file resides in encrypted storage.

### How to Login

If you work with Cloud Foundry (CF) and you have got the `cf` client installed, you can call `cds login` with just a passcode. The command runs the `cf` client to determine suitable apps from the org and space that you're logged in to. This allows you to interactively choose the login target from a list of apps and their respective URLs.

To log in to the SaaS app in this way, first change to the folder you want to use for your extension project. Then run the following command (the one-time passcode will be prompted interactively if omitted):

```sh
cds login [-p <passcode>]
```

:::details Advanced options

If you need to call `cds login` automatically without user interaction, you may use the [Client Credentials](https://www.oauth.com/oauth2-servers/access-tokens/client-credentials/) grant, which does not require a passcode.

You can then omit the `-p <passcode>` option but will instead have to provide the Client ID and a specific form of client secret to authenticate.

Obtain these two from the `VCAP_SERVICES` environment variable in your deployed MTX server (`@sap/cds-mtxs`). In the JSON value, navigate to `xsuaa[0].credentials`.

- If you find a `key` property (Private Key of the Client Certificate), XSUAA is configured to use X.509 (mTLS). Use this Private Key by specifying `cds login … -m <clientid>[:key]`.

- Otherwise, find the Client Secret in the `clientsecret` property and use `cds login … -c <clientid>[:<clientsecret>]` in an analogous way.

**Note:** The `key` and `clientsecret` properties are secrets that should not be stored in an unsafe location in productive scenarios!

[Learn more about environment variables / `VCAP_Services`.](/node.js/cds-connect#bindings-in-cloud-platforms){.learn-more}

If you leave out the respective secret (enclosed in square brackets above), you will be prompted to enter it interactively.
This can be used to feed the secret from the environment to `cds login` via standard input, like so:

```sh
echo $MY_KEY | cds login … -m <clientid>
```

:::

For a synopsis of all options, run `cds help login`.

:::details Login without CF CLI

If you don't work with CF CLI, additionally provide the application URL and the subdomain as these can't be determined automatically:

```sh
cds login [<auth-options>] -s <subdomain> <app-url>
```

The `<app-url>` is the URL that you get in your subscriber account when you subscribe to an application. You find the `<subdomain>` in the overview page of your subaccount in the SAP BTP Cockpit:

![Simplified UI, showing where to find the subdomain in the SAP BTP cockpit.](assets/subdomain-cockpit-sui.png)

:::

::: tip Multiple targets
Should you later want to extend other SaaS applications, you can log in to them as well, and it won't affect your other logins.
Logins are independent of each other, and `cds pull` etc. will be authenticated based on the requested target.
:::

### Simplified Workflow

Once you've logged in to the SaaS app, you can omit the passcode, the app URL, and the tenant subdomain, so in your development cycle you can run:

```sh
cds pull
# develop your extension
cds push
# develop your extension
cds push
# …
```

::: tip Override saved values with options
For example, run `cds push -s <otherSubdomain> -p <otherPasscode>` to activate your extension in another subdomain.
This usage of `cds push` may be considered a kind of cross-client transport mechanism.
:::

### Refreshing Tokens

Tokens have a certain lifespan, after which they lose validity. To save you the hassle, `cds login` also stores the refresh token sent by XSUAA alongside the token (depending on configuration) and uses it to automatically renew the token after it has expired. By default, refresh tokens expire much later than the token itself, allowing you to work without re-entering passcodes for multiple successive days.

### Cleaning Up

To remove locally saved authentication data and optionally, the project settings, run `cds logout` inside your extension project folder.

Append `--delete-settings` to include saved project settings for the current project folder as well.

`cds help logout` is available for more details.

::: tip
When your role-collection assignments have changed, run `cds logout` followed by `cds login` in order to fetch a token containing the new set of scopes.
:::

### Debugging

In case something unexpected happens, set the variable `DEBUG=cli` in your shell environment before re-running the corresponding command.

::: code-group

```sh [Mac/Linux]
export DEBUG="cli"
```

```cmd [Windows]
set DEBUG=cli
```

```powershell [Powershell]
Set-Variable -Name "DEBUG" -Value "cli"
```

:::

## Add Data to Extensions

As described in [Add Data](#add-data), you can provide local test data and initial data for your extension. In this guide we copied local data from the `test/data` folder into the `db/data` folder. When using SQLite, this step can be further simplified. For `sap.capire.orders-Orders.csv`, just add the _new_ columns along with the primary key:
`
::: code-group

```csv [sap.capire.orders-Orders.csv]
ID;x_priority;x_salesRegion_code
7e2f2640-6866-4dcf-8f4d-3027aa831cad;high;EMEA
64e718c9-ff99-47f1-8ca3-950c850777d4;low;APJ
```

:::

::: warning _❗ Warning_ 
Adding data only for the missing columns doesn't work when using SAP HANA as a database. With SAP HANA, you always have to provide the full set of data.
:::

<span id="afterAddingData" />
<Fragment target="#afterAddingData">

## Create Data in Production <Concept />



Since the `x_Customers` entity *is* draft enabled, this would *not* directly create an active record, but a new draft record.

To activate this draft record, you have to call the corresponding draft activation action with an OData POST request:
```http
POST  https://<ExtensionURL>.<Domain>/orders/x_Customers(ID=66e718c9-ff99-47f1-8ca3-950c850777d4,IsActiveEntity=false)/OrdersService.draftActivate HTTP/1.1
```

</Fragment>

<div id="secondary-file">guides/extensibility/customization.fragment.md</div>


# Feature Toggles

{{$frontmatter?.synopsis}}

<ImplVariantsHint />

## Introduction and Overview

CAP feature-toggled aspects allow SaaS providers to create pre-built features as CDS models, extending the base models with new fields, entities, as well as annotations for SAP Fiori UIs. These features can be assigned to individual SaaS customers (tenants), users, and requests and are then activated dynamically at runtime, as illustrated in the following figure.

![This graphic shows an inbound request passing authentication and then the CAP runtime queries the database as well as the model provider service to know which features belong to the inbound request.](./assets/feature-toggles.drawio.svg)

### Get `cloud-cap-samples-java` for step-by-step Exercises {.java}

The following steps will extend the [CAP samples for Java](https://github.com/SAP-samples/cloud-cap-samples-java) app to demonstrate how features can extend data models, services, as well as SAP Fiori UIs. If you want to exercise these steps, get [cloud-cap-samples-java](https://github.com/SAP-samples/cloud-cap-samples-java) before, and prepare to extend the *Fiori* app:

<div class="impl java">

```sh
git clone https://github.com/SAP-samples/cloud-cap-samples-java
cd cloud-cap-samples-java
mvn clean install
```

</div>

Now, open the app in your editor, for example, for VS Code type:

```sh
code .
```

### Get `cap/samples` for Step-By-Step Exercises {.node}

The following steps will extend the [cap/samples/fiori](https://github.com/sap-samples/cloud-cap-samples/blob/main/fiori) app to demonstrate how features can extend data models, services, as well as SAP Fiori UIs. If you want to exercise these steps, get [cap/samples](https://github.com/sap-samples/cloud-cap-samples) before, and prepare to extend the *fiori* app:

```sh
git clone https://github.com/sap-samples/cloud-cap-samples samples
cd samples
npm install
```

Now, open the `fiori` app in your editor, for example, by this if you're using VS Code on macOS:

```sh
code fiori
```

## Enable Feature Toggles {.node}

### Add `@sap/cds-mtxs` Package Dependency

For example, like this:

```sh
npm add @sap/cds-mtxs
```

### Switch on `cds.requires.toggles`

Switch on feature toggle support by adding <Config>cds.requires.toggles: true</Config>.

## Adding Features in CDS

Add a subfolder per feature to folder *fts* and put `.cds` files into it. The name of the folder is the name you later on use in feature toggles to switch the feature on/off. In our samples app, we add two features `isbn` and `reviews` as depicted in the following screenshot:

![This screenshot is explained in the accompanying text.](./assets/image-20220628101642511.png){.ignore-dark}

> The name of the *.cds* files within the *fts/* subfolders can be freely chosen. All *.cds* files found in there will be served, with special handling for *index.cds* files, as usual.

### Feature *fts/isbn*

Create a file *fiori/fts/isbn/schema.cds* with this content:

```cds
using { CatalogService, sap.capire.bookshop.Books }
from '../../app/browse/fiori-service';

// Add new field `isbn` to Books
extend Books with {
  isbn : String @title:'ISBN';
}

// Display that new field in list on Fiori UI
annotate CatalogService.Books with @(
  UI.LineItem: [... up to {Value:author}, {Value:isbn}, ...]
);
```

This feature adds a new field `isbn` to entity `Books` and extends corresponding SAP Fiori annotations to display this field in the *Browse Books* list view.

::: tip
Note that all features will be deployed to each tenant database in order to allow toggling per user/request.
:::

### Feature *fts/reviews*

Create a file *fiori/fts/reviews/schema.cds* with this content:

```cds
using { CatalogService } from '../../app/browse/fiori-service';

// Display existing field `rating` in list on Fiori UI
annotate CatalogService.Books with @(
  UI.LineItem: [... up to {Value:author}, {Value:rating}, ...]
);
```

This feature extends corresponding SAP Fiori annotations to display already existing field `rating` in the *Browse Books* list view.

### Limitations

::: warning
Note the following limitations for `.cds` files in features:

- no `.cds` files in subfolders, for example, `fts/isbn/sub/file.cds`
- no `using` dependencies between features, any entity, service or type that you refer to or extend needs to be part of the base model
- further limitations re `extend aspect` → to be documented
:::

## Toggling Features

In principle, features can be toggled per request, per user, or per tenant; most commonly they'll be toggled per tenant, as demonstrated in the following.

### In Development

<div class="impl node">

CAP Node.js' `mocked-auth` strategy has built-in support for toggling features per tenant, per user, or per request. To demonstrate toggling features per tenant, or user, you can add these lines of configuration to our `package.json` of the SAP Fiori app:

```json
{"cds":{
  "requires": {
    "auth": {
      "users": {
        "carol": { "tenant": "t1" },
        "erin":  { "tenant": "t2" },
        "fred":  { "tenant": "t2", "features":[] }
      },
      "tenants": {
        "t1": { "features": ["isbn"] },
        "t2": { "features": "*" }
      }
    }
  }
}}
```

</div>

<div class="impl java">

CAP Java's [Mock User Authentication with Spring Boot](../../java/security#mock-users) allows to assign feature toggles to users based on the mock user configuration. To demonstrate toggling features per user, you can add these lines to the mock user configuration in the `srv/src/main/resources/application.yaml` file:

```yaml
cds:
  security.mock.users:
    - name: carol
      features:
      - isbn
    - name: erin
      features:
      - isbn
      - reviews
    - name: fred
      features:
```

</div>

In effect of this, for the user `carol` the feature `isbn` is enabled, for `erin`, the features `isbn` and `reviews` are enabled, and for the user `fred` all features are disabled.

### In Production

<div class="impl node">

::: warning No features toggling for production yet
Note that the previous sample is only for demonstration purposes. As user and tenant management is outside of CAP's scope, there's no out-of-the-box feature toggles provider for production yet. → Learn more about that in the following section [*Feature Vector Providers*](#feature-vector-providers).
:::

<div id="toggle-production-node-end" />
<Fragment target="#toggle-production-node-end">

::: info DwC supports feature toggles <Internal />

You can use [Deploy with Confidence](../deployment/dwc) for feature toggles in production.

[Learn more about Deploy with Confidence and Feature Toggles.](https://pages.github.tools.sap/deploy-with-confidence/solar-system/explanations/feature-toggle-lifecycle){.learn-more}

:::

</Fragment>

</div>

<div class="impl java">

For productive use, the mock user configuration must not be used. The set of active features is determined per request by the [Feature Toggles Info Provider](../../java/reflection-api#feature-toggles-info-provider).

You can register a [Custom Implementation](../../java/reflection-api#custom-implementation) as a Spring bean that computes the active feature set based on the request's `UserInfo` and `ParameterInfo`.

<div id="toggle-production-java-end" />
<Fragment target="#toggle-production-java-end">

Or, if your app productively runs on [Deploy with Confidence (DwC)](../../java/reflection-api#deploy-with-confidence) you can leverage the [util-cap](https://github.tools.sap/deploy-with-confidence/spring-utils) library, which brings an implementation of `FeatureTogglesInfoProvider` that determines the feature set based on DwC headers.

</Fragment>

</div>

## Test-Drive Locally {.node}

To test feature toggles, just run your CAP server as usual, then log on with different users, assigned to different tenants, to see the effects.

### Run `cds watch`

Start the CAP server with `cds watch` as usual:

```sh
cds watch
```

→ in the log output, note the line reporting:

```js
[cds] - serving cds.xt.ModelProviderService {
  path: '/-/cds/model-provider',
  impl: '@sap/cds/srv/model-provider.js'
}
```

> The `ModelProviderService` is used by the runtime to get feature-enhanced models.

### See Effects in SAP Fiori UIs {#test-fiori-node}

To see the effects in the UIs open three anonymous browser windows, one for each user to log in, and:

1. [Open SAP Fiori app in browser](http://localhost:4004/fiori-apps.html) and go to [Browse Books](http://localhost:4004/fiori-apps.html#Books-display).
2. Log in as `carol` and see `ISBN` column in list.
3. Log in as `erin` and see `Ratings` and `ISBN` columns in list.
4. Log in as `fred` and no features for *Fred*, even though same tenant as *Erin*.

For example the displayed UI should look like that for `erin`:

![A standard SAP Fiori UI including the new columns ratings and isbn that are available to erin.](assets/image-20220630132726831.png)

## Model Provider in Sidecar

The `ModelProviderService`, which is used for toggling features, is implemented in Node.js only. To use it with CAP Java apps, you run it in a so-called *MTX sidecar*. For a CAP Node.js project, this service is always run embedded with the main application.

### Create Sidecar as Node.js Project

An MTX sidecar is a standard, yet minimalistic Node.js CAP project. By default it's added to a subfolder *mtx/sidecar* within your main project, containing just a *package.json* file:

::: code-group

```json [mtx/sidecar/package.json]
{
  "name": "mtx-sidecar", "version": "0.0.0",
  "dependencies": {
    "@sap/cds": "^9",
    "@sap/cds-mtxs": "^3",
    "express": "^4"
  },
  "cds": {
    "profile": "mtx-sidecar"
  }
}
```

:::

[Learn more about setting up **MTX sidecars**.](../multitenancy/mtxs#sidecars){.learn-more}

### Add Remote Service Link to Sidecar

<div class="impl node">

::: tip
In Node.js apps you usually don't consume services from the sidecar. The *ModelProviderService* is served both, embedded in the main app as well as in the sidecar. The following is documented for the sake of completeness only...
:::

You can use the `from-sidecar` preset to tell the CAP runtime to use the remote model provider from the sidecar:

```json
"cds":{
  "requires": {
    "toggles": true,
    "cds.xt.ModelProviderService": "from-sidecar"
  }
}
```

[Learn more about configuring ModelProviderService.](../multitenancy/mtxs#model-provider-config){.learn-more}

</div>

<div class="impl java">

You need to configure the CAP Java application to request the CDS model from the Model Provider Service.
This is done in the `application.yaml` file of your application.
To enable the Model Provider Service for local development, add the following configuration to the `default` profile:

```yaml
cds:
  model:
    provider:
      url: http://localhost:4005
      # remove, in case you need tenant extensibility
      extensibility: false
```

</div>

### Test-Drive Sidecar Locally

With the setup as described in place, you can run the main app locally with the Model Provider as sidecar. Simply start the main app and the sidecar in two separate shells:

**First, start the sidecar** as the main app now depends on the sidecar:

```sh
cds watch mtx/sidecar
```

**Then, start the main app** in the second shell:

<div class="impl node">

```sh
cds watch
```

</div>

<div class="impl java">

```sh
mvn spring-boot:run
```

</div>

#### Remote `getCsn()` Calls to Sidecar at Runtime {.node}

When you now run and use our application again as described in the previous section [See Effects in SAP Fiori UIs](#test-fiori-node), you can see in the trace logs that the main app sends `getCsn` requests to the sidecar, which in response to that reads and returns the main app's models. That means, the models from two levels up the folder hierarchy as configured by `root: ../..` for development.

### See Effects in SAP Fiori UIs {#test-fiori-java .java}

To see the effects in the UIs open three anonymous browser windows, one for each user to log in, and:

1. [Open SAP Fiori app in browser](localhost:8080/fiori.html) and go to [Browse Books](localhost:8080/fiori.html#browse-books).
2. Log in as `carol` and see `ISBN` column in list.
3. Log in as `erin` and see `Ratings` and `ISBN` columns in list.
4. Log in as `fred` and no features for *Fred*, even though same tenant as *Erin*.

For example the displayed UI should look like that for `erin`:

![A standard SAP Fiori UI including the new columns ratings and isbn that are available to erin.](assets/image-20220630132726831.png)

## Feature Vector Providers {.node}

In principle, features can be toggled *per request* using the `req.features` property (`req` being the standard HTTP req object here, not the CAP runtimes `req` object). This property is expected to contain one of the following:

- An array with feature names, for example, `['isbn','reviews']`.
- A string with comma-separated feature names, for example, `'isbn,reviews'`.
- An object with keys being feature names, for example, `{isbn:true,reviews:true}`.

So, to add support for a specific feature toggles management you can add a simple Express.js middleware as follows, for example, in your `server.js`:

```js
const cds = require ('@sap/cds')
cds.on('bootstrap', app => app.use ((req,res,next) => {
  req.features = req.headers.features || 'isbn'
  next()
}))
```

## Feature-Toggled Custom Logic

<div class="impl java">

[Evaluate the `FeatureTogglesInfo` in custom code](../../java/reflection-api#using-feature-toggles-in-custom-code) to check if a feature is enabled:

```java
@Autowired FeatureTogglesInfo features;

...

if (features.isEnabled("discount")) {
  // specific coding when feature 'discount' is enabled...
}
```

</div>

<div class="impl node">

Within your service implementations, you can react on feature toggles by inspecting `cds.context.features` like so:

```js
const { features } = cds.context
if ('isbn' in features) {
  // specific coding when feature 'isbn' is enabled...
}
if ('reviews' in features) {
  // specific coding when feature 'reviews' is enabled...
}
// common coding...
```

Or alternatively:

```js
const { isbn, reviews } = cds.context.features
if (isbn) {
  // specific coding when feature 'isbn' is enabled...
}
if (reviews) {
  // specific coding when feature 'reviews' is enabled...
}
// common coding...
```

</div>

<div id="secondary-file">guides/extensibility/feature-toggles.fragment.md</div>


# Reuse and Compose

{{$frontmatter?.synopsis}}

## Introduction and Overview

CAP promotes reuse and composition by importing content from reuse packages. Reused content, shared and imported that way, can comprise models, code, initial data, and i18n bundles.


### Usage Scenarios

By applying CAP's techniques for reuse, composition, and integration, you can address several different usage scenarios, as depicted in the following illustration.


![This graphic is explained in the accompanying text.](assets/scenarios.drawio.svg)


1. **Verticalized/Composite Solutions** — Pick one or more reuse packages/services. Enhance them, mash them up into a composite solution, and offer this as a new packaged solution to clients.

2. **Prebuilt Extension Packages** — Instead of offering a new packaged solution, you could also just provide your enhancements as a prebuilt extension package, for example, for **verticalization**, which you in turn offer to others as a reuse package.

3. **Prebuilt Integration Packages** — Prebuilt extension packages could also involve prefabricated integrations to services in back-end systems, such as S/4HANA and SAP SuccessFactors.

4. **Prebuilt Business Data Packages** — A variant of prebuilt integration packages, in which you would provide a reuse package that provides initial data for certain entities, like a list of *Languages*, *Countries*, *Regions*, *Currencies*, etc.

5. **Customizing SaaS Solutions** — Customers, who are subscribers of SaaS solutions, can apply the same techniques to adapt SaaS solutions to their needs. They can use prebuilt extension or business data packages, or create their own custom-defined ones.


### Examples from [cap/samples](https://github.com/sap-samples/cloud-cap-samples)

In the following sections, we frequently refer to examples from [cap/samples](https://github.com/sap-samples/cloud-cap-samples):

![The screenshot is explained in the following text.](assets/cap-samples.drawio.svg)


- **[@capire/bookshop](https://github.com/sap-samples/cloud-cap-samples/tree/main/bookshop)** provides a basic bookshop app and **reuse services** .
- **[@capire/common](https://github.com/sap-samples/cloud-cap-samples/tree/main/common)** is a **prebuilt extension** and **business data** package for *Countries*, *Currencies*, and *Languages*.
- **[@capire/reviews](https://github.com/sap-samples/cloud-cap-samples/tree/main/reviews)** provides an independent **reuse service**.
- **[@capire/orders](https://github.com/sap-samples/cloud-cap-samples/tree/main/orders)** provides another independent **reuse service**.
- **[@capire/bookstore](https://github.com/sap-samples/cloud-cap-samples/tree/main/bookstore)** combines all of the above into a **composite application**.


### Preparation for Exercises

If you want to exercise the code snippets in following sections, do the following:

**1)** &nbsp; Get cap/samples:

```sh
git clone https://github.com/sap-samples/cloud-cap-samples samples
cd samples
npm install
```

**2)** &nbsp; Start a sample project:

```sh
cds init sample
cd sample
npm i
# ... run the upcoming commands in here
```

## Importing Reuse Packages { #import}

CAP and CDS promote reuse of prebuilt content based on `npm` or `Maven` techniques. The following figure shows the basic procedure for `npm`.

![This graphic shows how packages are used, provided, and deployed. ALl the details around that are explained in the following sections.](assets/reuse-overview.drawio.svg)

> We use `npm` and `Maven` as package managers simply because we didn't want to reinvent the wheel here.

### Using `npm add/install` from _npm_ Registries

Use _`npm add/install`_ to import reuse packages to your project, like so:

```sh
npm add @capire/bookshop @capire/common
```


This installs the content of these packages into your project's `node_modules` folder and adds corresponding dependencies:

::: code-group
```json [package.json]
{
  "name": "sample", "version": "1.0.0",
  "dependencies": {
    "@capire/bookshop": "^1.0.0",
    "@capire/common": "^1.0.0",
    ...
  }
}
```
:::

> These dependencies allow you to use `npm outdated`, `npm update`, and `npm install` later to get the latest versions of imported packages.


### Importing from Other Sources

In addition to importing from _npm_ registries, you can also import from local sources. This can be other CAP projects that you have access to, or tarballs of reuse packages, for example, downloaded from some marketplace.

```sh
npm add ~/Downloads/@capire-bookshop-1.0.0.tgz
npm add ../bookshop
```

> You can use `npm pack` to create tarballs from your projects if you want to share them with others.


### Importing from Maven Dependencies

Add the dependency to the reuse package to your `pom.xml`:

::: code-group
```xml [pom.xml]
<dependency>
  <groupId>com.sap.capire</groupId>
  <artifactId>bookshop</artifactId>
  <version>1.0.0</version>
</dependency>
```
:::

As Maven dependencies are - in contrast to `npm` packages - downloaded into a global cache, you need to make the artifacts from the reuse package available in your project locally.
The CDS Maven Plugin provides a simple goal named `resolve`, that performs this task for you and extracts reuse packages into the `target/cds/` folder of the Maven project.
Include this goal into the `pom.xml`, if not already present:

::: code-group
```xml [pom.xml]
<plugin>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-maven-plugin</artifactId>
  <version>${cds.services.version}</version>
  <executions>
    ...
    <execution>
      <id>cds.resolve</id>
      <goals>
        <goal>resolve</goal>
      </goals>
    </execution>
    ...
  </executions>
</plugin>
```
:::

### Embedding vs. Integrating Reuse Services { #embedding-vs-integration}

By default, when importing reuse packages, all imported content becomes an integral part of your project, it literally becomes **embedded** in your project. This applies to all the things an imported package can contain, such as:

- Domain models
- Service definitions
- Service implementations
- i18n bundles
- Initial data

[See an example for a data package for `@sap/cds/common`](../../cds/common#prebuilt-data){ .learn-more}

However, you decide which parts to actually use and activate in your project by means of model references as shown in the following sections.

Instead of embedding reuse content, you can also **integrate** with remote services, deployed as separate microservices as outlined in [*Service Integration*](#service-integration).



## Reuse & Extend Models {#reuse-models}

Even though all imported content is embedded in your project, you decide which parts to actually use and activate by means of model references. For example, if an imported package comes with three service definitions, it's still you who decides which of them to serve as part of your app, if any. The rule is:

::: tip Active by Reachability
Everything that you are referring to from your own models is served.
Everything outside of your models is ignored.
:::

### Via `using from` Directives

Use the definitions from imported models through [`using` directives](../../cds/cdl#model-imports) as usual. For example, like in [@capire/bookstore](https://github.com/SAP-samples/cloud-cap-samples/blob/7b7686cb29aa835e17a95829c56dc3285e6e23b5/bookstore/srv/mashup.cds), simply add all:

::: code-group
```cds [bookstore/srv/mashup.cds]
using from '@capire/bookshop';
using from '@capire/common';
```
:::

The `cds` compiler finds the imported content in `node_modules` when processing imports with absolute targets as shown previously.

### Using _index.cds_ Entry Points {#index-cds}

The above `using from` statements assume that the imported packages provide _index.cds_ in their roots as [public entry points](#entry-points), which they do. For example see [@capire/bookshop/index.cds](https://github.com/SAP-samples/cloud-cap-samples/blob/7b7686cb29aa835e17a95829c56dc3285e6e23b5/bookshop/index.cds):

::: code-group
```cds [bookshop/index.cds]
// exposing everything...
using from './db/schema';
using from './srv/cat-service';
using from './srv/admin-service';
```
:::

This _index.cds_ imports and therefore activates everything. Running `cds watch` in your project would show you this log output, indicating that all initial data and services from your imported packages are now embedded and served from your app:

```log
[cds] - connect to db > sqlite { database: ':memory:' }
 > filling sap.common.Currencies from common/data/sap.common-Currencies.csv
 > filling sap.common.Currencies_texts from common/data/sap.common-Currencies_texts.csv
 > filling sap.capire.bookshop.Authors from bookshop/db/data/sap.capire.bookshop-Authors.csv
 > filling sap.capire.bookshop.Books from bookshop/db/data/sap.capire.bookshop-Books.csv
 > filling sap.capire.bookshop.Books_texts from bookshop/db/data/sap.capire.bookshop-Books_texts.csv
 > filling sap.capire.bookshop.Genres from bookshop/db/data/sap.capire.bookshop-Genres.csv
/> successfully deployed to sqlite in-memory db

[cds] - serving AdminService { at: '/admin', impl: 'bookshop/srv/admin-service.js' }
[cds] - serving CatalogService { at: '/browse', impl: 'bookshop/srv/cat-service.js' }
```



### Using Different Entry Points

If you don't want everything, but only a part, you can change your `using from` directives like this:

```cds
using { CatalogService } from '@capire/bookshop/srv/cat-service';
```

 The output of `cds watch` would reduce to:

```log
[cds] - connect to db > sqlite { database: ':memory:' }
 > filling sap.capire.bookshop.Authors from bookshop/db/data/sap.capire.bookshop-Authors.csv
 > filling sap.capire.bookshop.Books from bookshop/db/data/sap.capire.bookshop-Books.csv
 > filling sap.capire.bookshop.Books_texts from bookshop/db/data/sap.capire.bookshop-Books_texts.csv
 > filling sap.capire.bookshop.Genres from bookshop/db/data/sap.capire.bookshop-Genres.csv
/> successfully deployed to sqlite in-memory db

[cds] - serving CatalogService { at: '/browse', impl: 'bookshop/srv/cat-service.js' }
```


> Only the CatalogService is served now.
::: tip
Check the _readme_ files that come with reuse packages for information about which entry points are safe to use.
:::


### Extending Imported Definitions

You can freely use all definitions from the imported models in the same way as you use definitions from your own models. This includes using declared types, adding associations to imported entities, building views on top of imported entities, and so on.

You can even extend imported definitions, for example, add elements to imported entities, or add/override annotations, without limitations.

Here's an example from the [@capire/bookstore](https://github.com/SAP-samples/cloud-cap-samples/blob/7b7686cb29aa835e17a95829c56dc3285e6e23b5/bookstore/srv/mashup.cds):

::: code-group
```cds [bookstore/srv/mashup.cds]
using { sap.capire.bookshop.Books } from '@capire/bookshop';
using { ReviewsService.Reviews } from '@capire/reviews';

// Extend Books with access to Reviews and average ratings
extend Books with {
  reviews : Composition of many Reviews on reviews.subject = $self.ID;
  rating  : Decimal;
}
```
:::


## Reuse & Extend Code {#reuse-code}


Service implementations, in particular custom-coding, are also imported and served in embedding projects. Follow the instructions if you need to add additional custom handlers.

### In Node.js

One way to add your own implementations is to replace the service implementation as follows:

1. Add/override the `@impl` annotation
    ```cds
    using { CatalogService } from '@capire/bookshop';
    annotate CatalogService with @impl:'srv/my-cat-service-impl';
    ```

2. Place your implementation in `srv/my-cat-service-impl.js`:
    ::: code-group
    ```js [srv/my-cat-service-impl.js]
    module.exports = cds.service.impl (function(){
      this.on (...) // add your event handlers
    })
    ```
    :::

3. If the imported package already had a custom implementation, you can include that as follows:
    ::: code-group
    ```js [srv/my-cat-service-impl.js]
    const base_impl = require ('@capire/bookshop/srv/cat-service')
    module.exports = cds.service.impl (async function(){
      this.on (...) // add your event handlers
      await base_impl.call (this,this)
    })
    ```
    :::
    > Make sure to invoke the base implementation exactly like that, with `await`. And make sure to check the imported package's readme to check whether access to that implementation module is safe.


### In Java

You can provide your own implementation in the same way, as you do for your own services:

1. Import the service in your CDS files
    ```cds
    using { CatalogService } from 'com.sap.capire/bookshop';
    ```

2. Add your own implementation next to your other event handler classes:
    ```java
    @Component
    @ServiceName("CatalogService")
    public class CatalogServiceHandler implements EventHandler {

      @On(/* ... */)
      void myHandler(EventContext context) {
        // ...
      }

    }
    ```

## Reuse & Extend UIs {#reuse-uis}

If imported packages provide UIs, you can also serve them as part of your app — for example, using standard [express.js](https://expressjs.com) middleware means in Node.js.

The *@capire/bookstore* app has this [in its `server.js`](https://github.com/SAP-samples/cloud-cap-samples/blob/7b7686cb29aa835e17a95829c56dc3285e6e23b5/bookstore/server.js) to serve [the Vue.js app imported with *@capire/bookshop*](https://github.com/SAP-samples/cloud-cap-samples/tree/7b7686cb29aa835e17a95829c56dc3285e6e23b5/bookshop/app/vue) using the `app.serve(<endpoint>).from(<source>)` method:

::: code-group
```js [bookstore/server.js]
const express = require('express')
const cds = require('@sap/cds')

// Add routes to UIs from imported packages
cds.once('bootstrap',(app)=>{
  app.serve ('/bookshop') .from ('@capire/bookshop','app/vue')
  app.serve ('/reviews') .from ('@capire/reviews','app/vue')
  app.serve ('/orders') .from('@capire/orders','app/orders')
})
```
:::

[More about Vue.js in our _Getting Started in a Nutshell_](../../get-started/in-a-nutshell#uis){.learn-more} [Learn more about serving Fiori UIs.](../../advanced/fiori){.learn-more}

This ensures all static content for the app is served from the imported package.

In both cases, all dynamic requests to the service endpoint anyways reach the embedded service, which is automatically served at the same endpoint it was served in the bookshop.

In case of Fiori elements-based UIs, the reused UIs can be extended by [extending their models as decribed above](#reuse-models), in this case overriding or adding Fiori annotations.



## Service Integration

Instead of embedding and serving imported services as part of your application, you can decide to integrate with them, having them deployed and run as separate microservices.




### Import the Remote Service's APIs

This is described in the [Import Reuse Packages section](#import)  &rarr; for example using `npm add`.

Here's the effect of this step in [@capire/bookstore](https://github.com/SAP-samples/cloud-cap-samples/blob/7b7686cb29aa835e17a95829c56dc3285e6e23b5/bookstore/package.json):

::: code-group
```json [bookstore/package.json]
  "dependencies": {
    "@capire/bookshop": "^1.0.0",
    "@capire/reviews": "^1.0.0",
    "@capire/orders": "^1.0.0",
    "@capire/common": "^1.0.0",
    ...
  },
```
:::

### Configuring Required Services

To configure required remote services in Node.js, simply add the respective entries to the [`cds.requires` config option](../../node.js/cds-env). You can see an example in [@capire/bookstore/package.json](https://github.com/SAP-samples/cloud-cap-samples/blob/7b7686cb29aa835e17a95829c56dc3285e6e23b5/bookstore/package.json), which integrates [@capire/reviews](https://github.com/SAP-samples/cloud-cap-samples/tree/7b7686cb29aa835e17a95829c56dc3285e6e23b5/reviews) and [@capire/orders](https://github.com/SAP-samples/cloud-cap-samples/tree/7b7686cb29aa835e17a95829c56dc3285e6e23b5/orders) as remote service:

::: code-group
```json [bookstore/package.json]
"cds": {
  "requires": {
    "ReviewsService": {
      "kind": "odata", "model": "@capire/reviews"
    },
    "OrdersService": {
      "kind": "odata", "model": "@capire/orders"
    },
  }
}
```
:::

> Essentially, this tells the service loader to not serve that service as part of your application, but expects a service binding at runtime in order to connect to the external service provider.

#### Restricted Reuse Options

Because models of integrated services only serve as imported APIs, you're restricted with respect to how you can use the models of services to integrate with. For example, only adding fields is possible, or cross-service navigation and expands.

Yet, there are options to make some of these work programmatically. This is explained in the [next section](#delegating-calls) based on the integration of [@capire/reviews](https://github.com/SAP-samples/cloud-cap-samples/tree/7b7686cb29aa835e17a95829c56dc3285e6e23b5/reviews) in [@capire/bookstore](https://github.com/SAP-samples/cloud-cap-samples/tree/7b7686cb29aa835e17a95829c56dc3285e6e23b5/bookstore).



### Delegating Calls to Remote Services { #delegating-calls}

Let's start from the following use case: The bookshop app exposed through [@capire/bookstore](https://github.com/SAP-samples/cloud-cap-samples/tree/7b7686cb29aa835e17a95829c56dc3285e6e23b5/bookstore) will allow end users to see the top 10 book reviews in the details page.

To avoid [CORS issues](https://developer.mozilla.org/de/docs/Web/HTTP/CORS), the request from the UI goes to the main `CatalogService` serving the end user's UI and is delegated from that to the remote `ReviewsService`, as shown in this sequence diagram:

 ![This TAM graphic shows how the requests are routed between services.](assets/delegate-requests.drawio.svg)

And this is how we do that in [@cap/bookstore](https://github.com/SAP-samples/cloud-cap-samples/blob/7b7686cb29aa835e17a95829c56dc3285e6e23b5/bookstore/srv/mashup.js):

::: code-group
```js [bookstore/srv/mashup.js]
const CatalogService = await cds.connect.to ('CatalogService')
const ReviewsService = await cds.connect.to ('ReviewsService')
CatalogService.prepend (srv => srv.on ('READ', 'Books/reviews', (req) => {
  console.debug ('> delegating request to ReviewsService')
  const [id] = req.params, { columns, limit } = req.query.SELECT
  return ReviewsService.tx(req).read ('Reviews',columns).limit(limit).where({subject:String(id)})
}))
```
:::

Let's look at that step by step:

1. We connect to both the `CatalogService` (local) and the `ReviewsService` (remote) to mash them up.
2. We register an `.on` handler with the `CatalogService`, which delegates the incoming request to the `ReviewsService`.
3. We wrap that into a call to `.prepend` because the  `.on` handler needs to supersede the default generic handlers provided by the CAP runtime → see [ref docs for `srv.prepend`.](../../node.js/core-services#srv-prepend)



### Running with Mocked Remote Services {#mocking-required-services}

If you start [@capire/bookstore](https://github.com/SAP-samples/cloud-cap-samples/tree/7b7686cb29aa835e17a95829c56dc3285e6e23b5/bookstore) locally with `cds watch`, all [required services](https://github.com/SAP-samples/cloud-cap-samples/blob/7b7686cb29aa835e17a95829c56dc3285e6e23b5/bookstore/package.json#L15-L22) are automatically mocked, as you can see in the log output when the server starts:

```log
[cds] - serving AdminService { at: '/admin', impl: 'bookshop/srv/admin-service.js' }
[cds] - serving CatalogService { at: '/browse', impl: 'bookshop/srv/cat-service.js' }
[cds] - mocking OrdersService { at: '/orders', impl: 'orders/srv/orders-service.js' }
[cds] - mocking ReviewsService { at: '/reviews', impl: 'reviews/srv/reviews-service.js' }
```

> &rarr; `OrdersService` and `ReviewsService` are mocked, that is, served in the same process, in the same way as the local services.

This allows development and testing functionality with minimum complexity and overhead in fast, closed-loop dev cycles.


As all services are co-located in the same process, sharing the same database, you can send requests like this, which join/expand across *Books* and *Reviews*:
```http
GET http://localhost:4004/browse/Books/201?
&$expand=reviews
&$select=ID,title,rating
```


### Testing Remote Integration Locally {#testing-locally}

As a next step, following CAP's [Grow-as-you-go](../../about/#grow-as-you-go) philosophy, we can run the services as separate processes to test the remote integration, but still locally in a low-complexity setup. We use the [_automatic binding by `cds watch`_](#bindings-via-cds-watch) as follows:

1. Start the three servers separately, each in a separate shell (from within the root folder in your cloned _[cap/samples]( https://github.com/sap-samples/cloud-cap-samples)_ project):
    ```sh
    cds watch orders --port 4006
    ```
    ```sh
    cds watch reviews --port 4005
    ```
    ```sh
    cds watch bookstore --port 4004
    ```

2. Send a few requests to the reviews service (port 4005) to add `Reviews`:
    ```http
    POST http://localhost:4005/Reviews
    Content-Type: application/json;IEEE754Compatible=true
    Authorization: Basic itsme:secret
    {"subject":"201", "title":"boo", "rating":3 }
    ```

3. Send a request to bookshop (port 4004) to fetch reviews via `CatalogService`:
    ```http
    GET http://localhost:4004/browse/Books/201/reviews?
    &$select=rating,date,title
    &$top=3
    ```

    > You can find a script for this in [@capire/bookstore/test/requests.http](https://github.com/SAP-samples/cloud-cap-samples/blob/7b7686cb29aa835e17a95829c56dc3285e6e23b5/bookstore/test/requests.http).




### Binding Required Services

Service bindings provide the details about how to reach a required service at runtime, that is, providing the necessary credentials, most prominently the target service's `url`.



#### Basic Mechanism Using `cds.env` and Process env Variables {#bindings-via-cds-env}


At the end of the day, the CAP Node.js runtime expects to find the service bindings in the respective entries in `cds.env.requires`:

1. Configured required services constitute endpoints for service bindings:

    ::: code-group
    ```json [package.json]
    "cds": {
      "requires": {
        "ReviewsService": {...},
      }
    }
    ```
    :::

2. These are made available to the runtime via `cds.env.requires`.

    ```js
    const { ReviewsService } = cds.env.requires
    ```

3. Service bindings essentially fill in `credentials` to these entries.

    ```js
    const { ReviewsService } = cds.env.requires
    //> ReviewsService.credentials = {
    //>  url: "http://localhost:4005/reviews"
    //> }
    ```

While you could do the latter in test suites, you would never provide credentials in a hard-coded way like that in productive code. Instead, you'd use one of the options presented in the following sections.



#### Automatic Bindings by `cds watch` {#bindings-via-cds-watch}

When running separate services locally as described [in the previous section](#testing-locally), this is done automatically by `cds watch`, as indicated by this line in the bootstrapping log output:

```log
[cds] - using bindings from: { registry: '~/.cds-services.json' }
```

You can cmd/ctrl-click or double click on that to see the file's content, and find something like this:

::: code-group
```json [~/.cds-services.json]
{
  "cds": {
    "provides": {
      "OrdersService": {
        "kind": "odata",
        "credentials": {
          "url": "http://localhost:4006/orders"
        }
      },
      "ReviewsService": {
        "kind": "odata",
        "credentials": {
          "url": "http://localhost:4005/reviews"
        }
      },
      "AdminService": {
        "kind": "odata",
        "credentials": {
          "url": "http://localhost:4004/admin"
        }
      },
      "CatalogService": {
        "kind": "odata",
        "credentials": {
          "url": "http://localhost:4004/browse"
        }
      }
    }
  }
}
```
:::

Whenever you start a CAP server with `cds watch`, this is what happens automatically:

1. For all *provided* services, corresponding entries are written to _~/cds-services.json_ with respective `credentials`, namely the `url`.

2. For all *required* services, corresponding entries are fetched from _~/cds-services.json_. If found, the `credentials` are filled into the respective entry in `cds.env.requires.<service>`  [as introduced previously](#bindings-via-cds-env).

In effect, all the services that you start locally in separate processes automatically receive their required bindings so they can talk to each other out of the box.



#### Through Process Environment Variables {#bindings-via-process-env}

You can pass credentials as process environment variables, for example in ad-hoc tests from the command line:

```sh
export cds_requires_ReviewsService_credentials_url=http://localhost:4005/reviews
cds watch bookstore
```

... or add them to a local `.env` file for repeated local tests:

::: code-group
```properties [.env]
cds.requires.ReviewsService.credentials = { "url": "http://localhost:4005/reviews" }
```
:::
> Note: never check in or deploy these `.env` files!



#### Through `VCAP_SERVICES` {#bindings-via-vcap_services}

When deploying to Cloud Foundry, service bindings are provided in `VCAP_SERVICES` process environment variables [as documented here](../../node.js/cds-connect#vcap_services).



#### In Target Cloud Environments {#bindings-in-cloud-environments}

Find information about how to do so in different environment under these links:

- [Deploying Services using MTA Deployer](https://help.sap.com/docs/HANA_CLOUD_DATABASE/c2b99f19e9264c4d9ae9221b22f6f589/33548a721e6548688605049792d55295.html)
- [Service Bindings in SAP BTP Cockpit](https://help.sap.com/docs/SERVICEMANAGEMENT/09cc82baadc542a688176dce601398de/0e6850de6e7146c3a17b86736e80ee2e.html)
- [Service Bindings using the Cloud Foundry CLI](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/296cd5945fd84d7d91061b2b2bcacb93.html)
- [Service Binding in Kyma](hhttps://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/d1aa23c492694d669c89a8d214f29147.html)






## Providing Reuse Packages

In general, every CAP-based product can serve as a reuse package consumed by others. There's actually not much to do. Just create models and implementations as usual. The following sections are about additional things to consider as a provider of a reuse package.

### Considerations for Maven-based reuse packages

When providing your reuse package as a Maven dependency you need to ensure that the CDS, CSV and i18n files are included into the JAR.
Place them in a `cds` folder in your `resources` folder under a unique module directory (for example, leveraging group ID and artifact ID):

```txt
src/main/resources/cds/
  com.sap.capire/bookshop/
    index.cds
    CatalogService.cds
    data/
      com.sap.capire.bookshop-Books.csv
    i18n/
      i18n.properties
```

This structure ensures that the CDS Maven Plugin `resolve` goal extracts these files correctly to the `target/cds/` folder.

>Note that `com.sap.capire/bookshop` is used when importing the models with a `using` directive.

### Provide Public Entry Points {#entry-points}

Following the Node.js approach, there's no public/private mechanism in CDS.
Instead, it's good and proven practice to add an _index.cds_ in the root folder of reuse packages, similar to the use of _index.js_ files in Node.

For example:

::: code-group
```cds [provider/index.cds]
namespace my.reuse.package;
using from './db/schema';
using from './srv/cat-service';
using from './srv/admin-service';
```
:::

This allows your users to refer to your models in `using` directives using just the package name, like so:

::: code-group
```cds [consumer/some.cds]
using { my.thing } from 'my-reuse-package';
```
:::

In addition, you might want to provide other entry points to ease partial usage options. For example, you could provide a _schema.cds_ file in your root, to allow using the domain model without services:

::: code-group
```cds [consumer/more.cds]
using { my.domain.entity } from 'my-reuse-package/schema';
using { my.service } from 'my-reuse-package/services';
```
:::

### Provide Custom Handlers

#### In Node.js

In general, custom handlers can be placed in files matching the naming of the _.cds_ files they belong to. In a reuse package, you have to use the `@impl` annotation to make it explicit which custom handler to use. In addition you need to use the fully qualified module path inside the `@impl` annotation.

Imagine that our bookshop is an _@sap_-scoped reuse module and the _CatalogService_ has a custom handler. This is how the service definition would look:

::: code-group
```cds [bookshop/srv/cat-service.cds]
service CatalogService @(impl: '@sap/bookshop/srv/cat-service.js') {...}
```
:::

#### In Java

If your reuse project is Spring Boot independent, register your custom event handler classes in a `CdsRuntimeConfiguration`:

::: code-group
```java [src/main/java/com/sap/capire/bookshop/BookshopConfiguration.java]
package com.sap.capire.bookshop;

public class BookshopConfiguration implements CdsRuntimeConfiguration {

	@Override
	public void eventHandlers(CdsRuntimeConfigurer configurer) {
		configurer.eventHandler(new CatalogServiceHandler());
	}
}
```
:::

Additionally, register the `CdsRuntimeConfiguration` class in a `src/main/resources/META-INF/services/com.sap.cds.services.runtime.CdsRuntimeConfiguration` file to be detected by CAP Java:

::: code-group
``` txt [src/main/resources/META-INF/services/com.sap.cds.services.runtime.CdsRuntimeConfiguration]
com.sap.capire.bookshop.BookshopConfiguration
```
:::

Alternatively, if your reuse project is Spring Boot-based, define your event handler classes as Spring beans.
Then use Spring Boot's [auto-configuration mechanism](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.developing-auto-configuration) to ensure that your classes are registered automatically when importing the reuse package as a dependency.

### Add a Readme

You should inform potential consumers about the recommended ways to reuse content provided by your package. At least provide information about:

- What is provided – schemas, services, data, and so on
- What are the recommended, stable entry points



### Publish/Share with Consumers

The preferred way to share reuse packages is by publishing to registries, like _npmjs.org_, _pkg.github.com_ or _Maven Central_. This allows consumers to apply proper version management.

However, at the end of the day, any other way to share packages, which you create with `npm pack` or `mvn package` would work as well.



## Customizing SaaS Usage


Subscribers of SaaS solutions can use the same *reuse and extend* techniques to tailor the application to their requirements, for example by:

- Adding/overriding annotations
- Adding custom fields and entities
- Adding custom data
- Adding custom i18n bundles
- Importing prebuilt extension packages

The main difference is how and from where the import happens:

1. The reuse package, in this case, is the subscribed SaaS application.
2. The import happens via `cds pull`.
3. The imported package is named according to the `cds.extends` entry in package.json
4. The extensions are applied via `cds push`.

[Learn more in the **SaaS Extensibility** guide.](customization){.learn-more}



# Core Data Services (CDS)
Language Reference Documentation
{ .subtitle}

CDS is the backbone of the SAP Cloud Application Programming Model (CAP). It provides the means to declaratively capture service definitions and data models, queries, and expressions. The CDS toolkit allows to parse from a variety of source languages into a uniform format and to compile it into various target languages.

!["The graphic is explained in the accompanying text."](./assets/csn.drawio.svg)

At runtime, CDS models are plain JavaScript objects complying to the _[Core Schema Notation (CSN)](./csn)_, an open specification derived from [JSON Schema](https://json-schema.org/). You can easily create or interpret these models, which foster extensions by 3rd-party contributions. Models are processed dynamically at runtime and can also be created dynamically.

> We use the terms _CDS_ or _CDS models_ as synonym to your models written in CDL.

[See the Nature of Models for more details](models){.learn-more}



<br>
<IndexList :pages='pages' />




# Conceptual Definition Language (CDL)



The *Conceptual Definition Language (CDL)* is a human-readable language for defining CDS models. Sources are commonly provided in files with`.cds` extensions and get compiled into [CSN representations](csn). Following sections provide a reference of all language constructs in CDL, which also serves as a reference of all corresponding CDS concepts and features.



## Language Preliminaries



- [Keywords & Identifiers](#keywords-identifiers)
- [Built-in Types](#built-in-types)
- [Literals](#literals)
- [Model Imports](#model-imports)
- [Namespaces](#namespaces)
- [Comments](#comments)



### Keywords & Identifiers

*Keywords* in CDL are used to prelude statements, such as imports and namespace directives as well as entity and type declarations. *Identifiers* are used to refer to definitions.

```cds
namespace capire.bookshop;
using { managed } from `@sap/cds/common`;
aspect entity : managed { key ID: Integer }

entity Books : entity {
  title  : String;
  author : Association to Authors;
}

entity Authors : entity {
  name   : String;
}
```

::: details Noteworthy...
In the example above `entity` shows up as a keyword, as well as an identifier of an aspect declaration and references to that.
:::

Keywords are *case-insensitive*, but are most commonly used in lowercase notation.

Identifiers are *case-significant*, that is, `Foo` and `foo` would identify different things.

Identifiers have to comply to `/[$A-Za-z_]\w*/` or be enclosed in `![`...`]` like that:

```cds
type ![Delimited Identifier] : String;
```

::: warning Avoid using delimited identifiers
Delimited identifiers in general, but in particular non-ASCII characters, or keywords as identifiers should be avoided as much as possible, for reasons of interoperability.
:::



### Built-in Types



The following table lists the built-in types available to all CDS models, and can be used to define entity elements or custom types as follows:

```cds
entity Books {
  key ID : UUID;
  title  : String(111);
  stock  : Integer;
  price  : Price;
}
type Price : Decimal;
```

These types are used to define the structure of entities and services, and are mapped to respective database types when the model is deployed.

| CDS Type | Remarks | ANSI SQL <sup>(1)</sup> |
| --- | --- | --- |
| `UUID` | CAP generates [RFC 4122](https://tools.ietf.org/html/rfc4122)-compliant UUIDs <sup>(2)</sup> | _NVARCHAR(36)_  |
| `Boolean` | Values: `true`, `false`, `null`, `0`, `1` | _BOOLEAN_  |
| `Integer` | Same as `Int32` by default | _INTEGER_  |
| `Int16` | Signed 16-bit integer, range *[ -2<sup>15</sup> ... +2<sup>15</sup> )* | _SMALLINT_  |
| `Int32` | Signed 32-bit integer, range *[ -2<sup>31</sup> ... +2<sup>31</sup> )* | _INTEGER_  |
| `Int64` | Signed 64-bit integer, range *[ -2<sup>63</sup> ... +2<sup>63</sup> )* | _BIGINT_  |
| `UInt8` | Unsigned 8-bit integer, range *[ 0 ... 255 ]* | _TINYINT_ <sup>(3)</sup> |
| `Decimal` (`prec`, `scale`) | A *decfloat* type is used if arguments are omitted | _DECIMAL_  |
| `Double` | Floating point with binary mantissa | _DOUBLE_  |
| `Date` | e.g. `2022-12-31` | _DATE_  |
| `Time` | e.g. `24:59:59` | _TIME_  |
| `DateTime` | _sec_ precision | _TIMESTAMP_  |
| `Timestamp` | _µs_ precision, with up to 7 fractional digits |  _TIMESTAMP_  |
| `String` (`length`) | Default *length*: 255; on HANA: 5000 <sup>(4)</sup> | _NVARCHAR_  |
| `Binary` (`length`) | Default *length*: 255; on HANA: 5000 <sup>(5)</sup> |  _VARBINARY_  |
| `LargeBinary` | Unlimited data, usually streamed at runtime | _BLOB_ |
| `LargeString` | Unlimited data, usually streamed at runtime | _NCLOB_  |
| `Map` | Mapped to *NCLOB* for HANA. | *JSON* type |
| `Vector` (`dimension `) | Requires SAP HANA Cloud QRC 1/2024, or later |  _REAL_VECTOR_  |

```cds
entity Books {
  key ID : UUID;
  title  : String(111);
  stock  : Integer;
  price  : Price;
}
type Price : Decimal;
```

These types are used to define the structure of entities and services, and are mapped to respective database types when the model is deployed.

> <sup>(1)</sup> Concrete mappings to specific databases may differ.
>
> <sup>(2)</sup> See also [Best Practices](../guides/domain-modeling#don-t-interpret-uuids).
>
> <sup>(3)</sup> Not available on PostgreSQL and H2.
>
> <sup>(4)</sup> Configurable through `cds.cdsc.defaultStringLength`.
>
> <sup>(5)</sup> Configurable through `cds.cdsc.defaultBinaryLength`.

#### See also...

[Additional Reuse Types and Aspects by `@sap/cds/common`](common) {.learn-more}

[Mapping to OData EDM types](../advanced/odata#type-mapping) {.learn-more}

[HANA-native Data Types](../advanced/hana#hana-types){.learn-more}






### Literals

The following literals can be used in CDL (mostly as in JavaScript, Java, and SQL):


```cds
true , false , null        // as in all common languages
11 , 2.4 , 1e3, 1.23e-11   // for numbers
'A string''s literal'      // for strings
`A string\n paragraph`     // for strings with escape sequences
{ foo:'boo', bar:'car' }   // for records
[ 1, 'two', {three:4} ]    // for arrays
```

[Learn more about literals and their representation in CSN.](./csn#literals) {.learn-more}

#### Date & Time Literals

In addition, type-keyword-prefixed strings can be used for date & time literals:


```cds
date'2016-11-24'
time'16:11:32'
timestamp'2016-11-24T12:34:56.789Z'
```




#### Multiline String Literals {#multiline-literals}

Use string literals enclosed in **single or triple backticks** for multiline strings:

```cds
@escaped: `OK Emoji: \u{1f197}`
@multiline: ```
    This is a CDS multiline string.
    - The indentation is stripped.
    - \u{0055}nicode escape sequences are possible,
      just like common escapes from JavaScript such as
      \r \t \n and more! ```
@data: ```xml
    <main>
      The tag is ignored by the core-compiler but may be
      used for syntax highlighting, similar to markdown.
    </main> ```
entity DocumentedEntity {
  // ...
}
```

Within those strings, escape sequences from JavaScript, such as `\t` or `\u0020`, are supported. Line endings are normalized. If you don't want a line ending at that position, end a line with a backslash (`\`). For string literals inside triple backticks, indentation is stripped and tagging is possible.





### Model Imports




#### The `using` Directive {#using}

Using directives allows to import definitions from other CDS models. As shown in line three below you can specify aliases to be used subsequently. You can import single definitions as well as several ones with a common namespace prefix. Optional: Choose a local alias.

::: code-group

```cds [using-from.cds]
using foo.bar.scoped.Bar from './contexts';
using foo.bar.scoped.nested from './contexts';
using foo.bar.scoped.nested as specified from './contexts';

entity Car : Bar {}            //> : foo.bar.scoped.Bar
entity Moo : nested.Zoo {}     //> : foo.bar.scoped.nested.Zoo
entity Zoo : specified.Zoo {}  //> : foo.bar.scoped.nested.Zoo
```

:::

Multiple named imports through ES6-like deconstructors:

```cds
using { Foo as Moo, sub.Bar } from './base-model';
entity Boo : Moo { /*...*/ }
entity Car : Bar { /*...*/ }
```

> Also in the deconstructor variant of `using` shown in the previous example, specify fully qualified names.




#### Model Resolution

Imports in `cds` work very much like [`require` in Node.js](https://nodejs.org/api/modules.html#requireid) and `import`s in [ES6](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import).
In fact, we reuse **[Node's module loading mechanisms](https://nodejs.org/api/modules.html#modules_all_together)**.
Hence, the same rules apply:

- Relative path resolution<br>
  Names starting with `./` or `../` are resolved relative to the current model.
- Resolving absolute references<br>
  Names starting with `/` are resolved absolute to the file system.
- Resolving module references<br>
  Names starting with neither `.` nor `/` such as `@sap/cds/common` are fetched for in `node_modules` folders:
   - Files having _.cds_, _.csn_, or _.json_ as suffixes, appended in order
   - Folders, from either the file set in `cds.main` in the folder's _package.json_ or `index.<cds|csn|json>` file.

::: tip
To allow for loading from precompiled _.json_ files it's recommended to **omit _.cds_ suffixes** in import statements, as shown in the provided examples.
:::





### Namespaces


#### The `namespace` Directive

To prefix the names of all subsequent definitions, place a `namespace` directive at the top of a model. This is comparable to other languages, like Java.

::: code-group

```cds[namespace.cds]
namespace foo.bar;
entity Foo {}           //> foo.bar.Foo
entity Bar : Foo {}     //> foo.bar.Bar
```

:::

A namespace is not an object of its own. There is no corresponding definition in CSN.

#### The `context` Directive {#context}

Use `contexts` for nested namespace sections.

::: code-group

```cds[contexts.cds]
namespace foo.bar;
entity Foo {}           //> foo.bar.Foo
context scoped {
  entity Bar : Foo {}   //> foo.bar.scoped.Bar
  context nested {
    entity Zoo {}       //> foo.bar.scoped.nested.Zoo
  }
}
```

:::


#### Scoped Definitions {#scoped-names}

You can define types and entities with other definitions' names as prefixes:

```cds
namespace foo.bar;
entity Foo {}           //> foo.bar.Foo
entity Foo.Bar {}       //> foo.bar.Foo.Bar
type Foo.Bar.Car {}     //> foo.bar.Foo.Bar.Car
```


#### Fully Qualified Names

A model ultimately is a collection of definitions with unique, fully qualified names. For example, the second model above would compile to this [CSN](./csn):

::: code-group

```json [contexts.json]
{"definitions":{
  "foo.bar.Foo": { "kind": "entity" },
  "foo.bar.scoped": { "kind": "context" },
  "foo.bar.scoped.Bar": { "kind": "entity",
    "includes": [ "foo.bar.Foo" ]
  },
  "foo.bar.scoped.nested": { "kind": "context" },
  "foo.bar.scoped.nested.Zoo": { "kind": "entity" }
}}
```

:::





### Comments

CDL supports line-end, block comments, and *doc* comments as in Java and JavaScript:

```cds
// line-end comment
/* block comment */
/** doc comment */
```

#### Doc Comments {#doc-comment}

A multi-line comment of the form `/** … */` at an [annotation position](#annotation-targets) is considered a *doc comment*:

```cds
/**
 * I am the description for "Employee"
 */
entity Employees {
  key ID : Integer;
  /**
   * I am the description for "name"
   */
  name : String;
}
```

The text of a doc comment is stored in CSN in the property `doc`.
Doc comments are not propagated. For example, a doc comment defined for an entity
isn't automatically copied to projections of this entity.
When generating OData EDM(X), doc comments are translated to the annotation `@Core.Description`.

In CAP Node.js, doc comments need to be switched on when calling the compiler:

::: code-group

```sh [CLI]
cds compile foo.cds --docs
```

```js [JavaScript]
cds.compile(..., { docs: true })
```

:::

::: tip Doc comments are automatically enabled in CAP Java.
In CAP Java, doc comments are automatically enabled by the [CDS Maven Plugin](../java/developing-applications/building#cds-maven-plugin).
In generated interfaces they are [converted to corresponding Javadoc comments](../java/assets/cds-maven-plugin-site/generate-mojo.html#documentation){target="_blank"}.
:::

When generating output for deployment to SAP HANA, the first paragraph of a doc comment is translated
to the HANA `COMMENT` feature for tables, table columns, and for views (but not for view columns):

```sql
CREATE TABLE Employees (
  ID INTEGER,
  name NVARCHAR(...) COMMENT 'I am the description for "name"'
) COMMENT 'I am the description for "Employee"'
```


## Entities & Type Definitions

- [Entity Definitions](#entity-definitions)
- [Type Definitions](#type-definitions)
- [Structured Types](#structured-types)
- [Arrayed Types](#arrayed-types)
- [Virtual Elements](#virtual-elements)
- [Calculated elements](#calculated-elements)
- [Default Values](#default-values)
- [Type References](#type-references)
- [Constraints](#constraints)
- [Enums](#enums)





### Entity Definitions
{#entities}

Entities are structured types with named and typed elements,
representing sets of (persisted) data that can be read and manipulated using usual CRUD operations.
They usually contain one or more designated primary key elements:


```cds
define entity Employees {
  key ID : Integer;
  name : String;
  jobTitle : String;
}
```

> The `define` keyword is optional, that means `define entity Foo` is equal to `entity Foo`.


### Type Definitions
{#types}

You can declare custom types to reuse later on, for example, for elements in entity definitions.
Custom-defined types can be simple, that is derived from one of the predefined types, structured types or [Associations](#associations).

```cds
define type User : String(111);
define type Amount {
  value : Decimal(10,3);
  currency : Currency;
}
define type Currency : Association to Currencies;
```
> The `define` keyword is optional, that means `define type Foo` is equal to `type Foo`.

[Learn more about **Definitions of Named Aspects**.](#aspects){.learn-more}






### Structured Types

You can declare and use custom struct types as follows:

```cds
type Amount {
  value : Decimal(10,3);
  currency : Currency;
}
entity Books {
  price : Amount;
}
```

Elements can also be specified with anonymous inline struct types.
For example, the following is equivalent to the definition of `Books` above:

```cds
entity Books {
  price : {
    value : Decimal(10,3);
    currency : Currency;
  };
}
```

You can declare structured types based on other
definitions using the `projection on` syntax.
You can use nested projections or aliases as known from entity projections.
Only the effective signature of the projection is relevant.


```cds
type CustomerData : projection on Customer {
  name.firstName, // select from structures
  name.lastName,
  address as customerAddress, // aliases
}
```


### Arrayed Types

Prefix a type specification with `array of` or `many` to signify array types.

```cds
entity Foo { emails: many String; }
entity Bar { emails: many { kind:String; address:String; }; }
entity Car { emails: many EmailAddress; }
entity Car { emails: EmailAddresses; }
type EmailAddresses : many { kind:String; address:String; }
type EmailAddress : { kind:String; address:String; }
```

> Keywords `many` and `array of` are mere syntax variants with identical semantics and implementations.

When deployed to SQL databases, such fields are mapped to [LargeString](types) columns and the data is stored denormalized as JSON array.
With OData V4, arrayed types are rendered as `Collection` in the EDM(X).


::: warning
Filter expressions, [instance-based authorization](../guides/security/authorization#instance-based-auth) and [search](../guides/providing-services#searching-data) are not supported on arrayed elements.
:::

#### Null Values

For arrayed types the `null` and `not null` constraints apply to the _members_ of the collections. The default is `not null` indicating that the collections can't hold `null` values.

::: warning
An empty collection is represented by an empty JSON array. A `null` value is invalid for an element with arrayed type.
:::

In the following example the collection `emails` may hold members that are `null`. It may also hold a member where the element `kind` is `null`.
The collection `emails` itself must not be `null`!

```cds
entity Bar {
    emails      : many {
        kind    : String null;
        address : String not null;
    } null;  // -> collection emails may hold null values, overwriting default
}
```

### Virtual Elements

An element definition can be prefixed with modifier keyword `virtual`. This keyword indicates that this element isn't added to persistent artifacts, that is, tables or views in SQL databases. Virtual elements are part of OData metadata.

By default, virtual elements are annotated with `@Core.Computed: true`, not writable for the client and will be [silently ignored](../guides/providing-services#readonly). This means also, that they are not accessible in custom event handlers. If you want to make virtual elements writable for the client, you explicitly need to annotate these elements with `@Core.Computed: false`. Still those elements are not persisted and therefore, for example, not sortable or filterable.

```cds
entity Employees {
  [...]
  virtual something : String(11);
}
```


<span id="calculated-fields"/>


### Calculated Elements

Elements of entities and aspects can be specified with a calculation expression, in which you can
refer to other elements of the same entity/aspect.
This can be either a value expression or an expression that resolves to an association.

Calculated elements with a value expression are read-only, no value must be provided for
them in a WRITE operation. When reading such a calculated element, the result of the
expression is returned. They come in two variants: "on-read" and "on-write".
The difference between them is the point in time when the expression is evaluated.

#### On-read

```cds
entity Employees {
  firstName : String;
  lastName : String;
  name : String = firstName || ' ' || lastName;
  name_upper = upper(name);
  addresses : Association to many Addresses;
  city = addresses[kind='home'].city;
}
```

For a calculated element with "on-read" semantics, the calculation expression is evaluated when reading an entry from the entity.
Using such a calculated element in a query or view definition is equivalent to
writing the expression directly into the query, both with respect to semantics and to performance.
In CAP, it is implemented by replacing each occurrence of a calculated element in a query by the respective expression.

Entity using calculated elements:
```cds
entity EmployeeView as select from Employees {
  name,
  city
};
```
Equivalent entity:
```cds
entity EmployeeView as select from Employees {
  firstName || ' ' || lastName as name : String,
  addresses[kind='home'].city as city
};
```

Calculated elements "on-read" are a pure convenience feature. Instead of having to write
the same expression several times in queries, you can define a calculated element **once** and then
simply refer to it.

In the _definition_ of a calculated element "on-read", you can use almost all expressions that are allowed
in queries. Some restrictions apply:

* Subqueries are not allowed.
* Nested projections (inline/expand) are not allowed.
* A calculated element can't be key.

Like for views, the expressions are sent unchanged to the database, so
you need to ensure that they work on your respective database system(s).

A calculated element can be *used* in every location where an expression can occur. A calculated element can't be used in the following cases:

* in the ON condition of an unmanaged association
* as the foreign key of a managed association
* in a query together with nested projections (inline/expand)

::: warning
For the Node.js runtime, only the new database services under the _@cap-js_ scope support this feature.
:::

#### On-write

Calculated elements "on-write" (also referred to as "stored" calculated elements) are defined
by adding the keyword `stored`. A type specification is mandatory.

```cds
entity Employees {
  firstName : String;
  lastName : String;
  name : String = (firstName || ' ' || lastName) stored;
}
```

For a calculated element "on-write", the expression is already evaluated when an entry is written into
the database. The resulting value is then stored/persisted like a regular field, and when reading from the entity,
it behaves like a regular field as well. Using a stored calculated element can improve performance,
in particular when it's used for sorting or filtering. This is paid for by higher memory consumption.

While calculated elements "on-read" are handled entirely by CAP, the "on-write" variant is implemented by using
the corresponding feature for database tables.
The previous entity definition results in the following table definition:
```sql
-- SAP HANA syntax --
CREATE TABLE Employees (
  firstName NVARCHAR,
  lastName NVARCHAR,
  name NVARCHAR GENERATED ALWAYS AS (firstName || ' ' || lastName)
);
```
For the definition of calculated elements on-write, all the on-read variant's restrictions apply and referencing localized elements isn't allowed.
In addition, there are restrictions that depend on the particular database. Currently all databases
supported by CAP have a common restriction: The calculation expression may only refer to fields of the same
table row. Therefore, such an expression must not contain subqueries, aggregate functions, or paths with associations.

No restrictions apply for reading a calculated element on-write.

#### Association-like calculated elements {#association-like-calculated-elements}

A calculated element can also define a filtered association/composition using infix filters:

```cds
entity Employees {
  addresses : Association to many Addresses;
  homeAddress = addresses [1: kind='home'];
}
```

For such a calculated element, no explicit type can be specified.
Only a single association or composition can occur in the expression, and a filter must be specified.

The effect essentially is like [publishing an association with an infix filter](#publish-associations-with-filter).


### Default Values

As in SQL you can specify default values to fill in upon INSERTs if no value is specified for a given element.

```cds
entity Foo {
  bar : String default 'bar';
  boo : Integer default 1;
}
```

Default values can also be specified in custom type definitions:
```cds
type CreatedAt : Timestamp default $now;
type Complex {
  real : Decimal default 0.0;
  imag : Decimal default 0.0;
}
```

If the element has an enum type, you can use the enum symbol instead of a literal value:
```cds
type Status : String enum {open; closed;}
entity Order {
  status : Status default #open;
}
```


### Type References

If you want to base an element's type on another element of the same structure, you can use the `type of` operator.

```cds
entity Author {
  firstname : String(100);
   lastname : type of firstname; // has type "String(100)"
}
```

For referencing elements of other artifacts, you can use the element access through `:`.
Element references with `:` don't require `type of` in front of them.

```cds
entity Employees {
  firstname: Author:firstname;
  lastname: Author:lastname;
}
```


### Constraints

Element definitions can be augmented with constraint `not null` as known from SQL.

```cds
entity Employees {
  name : String(111) not null;
}
```


### Enums

You can specify enumeration values for a type as a semicolon-delimited list of symbols.
For string types, declaration of actual values is optional; if omitted, the actual values are the string counterparts of the symbols.

```cds
type Gender : String enum { male; female; non_binary = 'non-binary'; }
entity Order {
  status : Integer enum {
    submitted =  1;
    fulfilled =  2;
    shipped   =  3;
    canceled  = -1;
  };
}
```

To enforce your _enum_ values during runtime, use the [`@assert.range` annotation](../guides/providing-services#assert-range).
For localization of enum values, model them as [code list](./common#adding-own-code-lists).

<br>


## Views & Projections
{#views}

Use `as select from` or `as projection on` to derive new entities from existing ones by projections, very much like views in SQL. When mapped to relational databases, such entities are in fact translated to SQL views but they're frequently also used to declare projections without any SQL views involved.

The entity signature is inferred from the projection.

- [The `as select from` Variant](#as-select-from)
- [The `as projection on` Variant](#as-projection-on)
- [Views with Inferred Signatures](#views-with-inferred-signatures)

<div id="linkintoc" />

- [Views with Parameters](#views-with-parameters)


### The `as select from` Variant {#as-select-from}

Use the `as select from` variant to use all possible features an underlying relational database would support using any valid [CQL](./cql) query including all query clauses.

```cds
entity Foo1 as select from Bar; //> implicit {*}
entity Foo2 as select from Employees { * };
entity Foo3 as select from Employees LEFT JOIN Bar on Employees.ID=Bar.ID {
  foo, bar as car, sum(boo) as moo
} where exists (
  SELECT 1 as anyXY from SomeOtherEntity as soe where soe.x = y
)
group by foo, bar
order by moo asc;
```


### The `as projection on` Variant {#as-projection-on}

Use the `as projection on` variant instead of `as select from` to indicate that you don't use the full power of SQL in your query. For example, having a restricted query in an entity allows us to serve such an entity from external OData services.


```cds
entity Foo as projection on Bar {...}
```

Currently, the restrictions of `as projection on` compared to `as select from` are:

- no explicit, manual `JOINs`
- no explicit, manual `UNIONs`
- no sub selects in from clauses

Over time, we can add additional checks depending on specific outbound protocols.


### Views with Inferred Signatures

By default views inherit all properties and annotations from their primary underlying base entity.
Their [`elements`](./csn#structured-types) signature is **inferred** from the projection on base elements.
Each element inherits all properties from the respective base element, except the `key` property.
The `key` property is only inherited if all of the following applies:
- No explicit `key` is set in the query.
- All key elements of the primary base entity are selected (for example, by using `*`).
- No path expression with a to-many association is used.
- No `union`, `join` or similar query construct is used.

For example, the following definition:

```cds
entity SomeView as select from Employees {
  ID,
  name,
  job.title as jobTitle
};
```

Might result in this inferred signature:

```cds
entity SomeView {
  key ID: Integer;
  name: String;
  jobTitle: String;
};
```

Note: CAP does **not** enforce uniqueness for key elements of a view or projection.

Use a CDL cast to set an element's type, if one of the following conditions apply:
+ You don't want to use the inferred type.
+ The query column is an expression (no inferred type is computed).

```cds
entity SomeView as select from Employees {
  ID : Integer64,
  name : LargeString,
  'SAP SE' as company : String
};
```

::: tip
By using a cast, annotations and other properties are inherited from the provided type and not the base element, see [Annotation Propagation](#annotation-propagation)
:::

<div id="afterinferredsig" />

### Virtual elements in views

Virtual elements can be defined in views or projections like this:
```cds
entity SomeView as select from Employee {
  // ...,
  virtual virt1 : String(22),
  virtual virt2  // virtual element without type
}
```
These virtual elements have no relation to the query source `Employee` but are new fields
in the view. Virtual elements in views or projections are handled as described in the
section on [virtual elements in entities](#virtual-elements).


<div id="beforeviewwithparam" />

### Views with Parameters

You can equip views with parameters that are passed in whenever that view is queried. Default values can be specified.
Refer to these parameters in the view's query using the prefix `:`.

```cds
entity SomeView ( foo: Integer, bar: Boolean )
as SELECT * from Employees where ID=:foo;
```

When selecting from a view with parameters, the parameters are passed by name.
In the following example, `UsingView` also has a parameter `bar` that is passed down to `SomeView`.

```cds
entity UsingView ( bar: Boolean )
as SELECT * from SomeView(foo: 17, bar: :bar);
```

For Node.js, there's no programmatic API yet. You need to provide a [CQN snippet](/cds/cqn#select).

In CAP Java, run a select statement against the view with named [parameter values](/java/working-with-cql/query-execution#querying-views):

::: code-group
```js [Node]
SELECT.from({ ref: [{ id: 'UsingView', args: { bar: { val: true }}} ]} )
```
```Java [Java]
var params = Map.of("bar", true);
Result result = service.run(Select.from("UsingView"), params);
```
:::


[Learn more about how to expose views with parameters in **Services - Exposed Entities**.](#exposed-entities){ .learn-more}
[Learn more about views with parameters for existing HANA artifacts in **Native SAP HANA Artifacts**.](../advanced/hana){ .learn-more}



## Associations

Associations capture relationships between entities. They are like forward-declared joins added to a table definition in SQL.

- [Unmanaged Associations](#unmanaged-associations)
- [Managed Associations](#managed-associations)
- [To-many Associations](#to-many-associations)
- [Many-to-many Associations](#many-to-many-associations)

<span id="linkinassoctoc" />

- [Compositions](#compositions)
- [Managed Compositions](#managed-compositions)


### Unmanaged Associations

Unmanaged associations specify arbitrary join conditions in their `on` clause, which refer to available foreign key elements. The association's name (`address` in the following example) is used as the alias for the to-be-joined target entity.

```cds
entity Employees {
  address : Association to Addresses on address.ID = address_ID;
  address_ID : Integer;  //> foreign key
}
```
```cds
entity Addresses {
  key ID : Integer;
}
```


### Managed (To-One) Associations {#managed-associations}

For to-one associations, CDS can automatically resolve and add requisite foreign key elements from the target's primary keys and implicitly add respective join conditions.

```cds
entity Employees {
  address : Association to Addresses;
}
```

This example is equivalent to the [unmanaged example above](#unmanaged-associations), with the foreign
key element `address_ID` being added automatically upon activation to a SQL database.
The names of the automatically added foreign key elements cannot be changed.

> Note: For adding foreign key constraints on database level, see [Database Constraints.](../guides/databases#database-constraints).

If the target has a single primary key, a default value can be provided.
This default applies to the generated foreign key element `address_ID`:

```cds
entity Employees {
  address : Association to Addresses default 17;
}
```

### To-many Associations

For to-many associations specify an `on` condition following the canonical expression pattern `<assoc>.<backlink> = $self` as in this example:

```cds
entity Employees {
  key ID : Integer;
  addresses : Association to many Addresses
    on addresses.owner = $self;
}
```
```cds
entity Addresses {
  owner : Association to Employees;  //> the backlink
}
```

> The backlink can be any managed to-one association on the _many_ side pointing back to the _one_ side.


### Many-to-many Associations

For many-to-many association, follow the common practice of resolving logical many-to-many relationships into two one-to-many associations using a link entity to connect both.
For example:

```cds
entity Employees { [...]
  addresses : Association to many Emp2Addr on addresses.emp = $self;
}
entity Emp2Addr {
  key emp : Association to Employees;
  key adr : Association to Addresses;
}
```

[Learn more about **Managed Compositions for Many-to-many Relationships**.](#for-many-to-many-relationships){.learn-more}


<div id="aftermanytomany" />

<div id="inbetweenthings" />

<div id="beforecompo" />


### Compositions

Compositions constitute document structures through _contained-in_ relationships.
They frequently show up in to-many header-child scenarios.

```cds
entity Orders {
  key ID: Integer; //...
  Items : Composition of many Orders.Items on Items.parent = $self;
}
entity Orders.Items {
  key pos : Integer;
  key parent : Association to Orders;
  product : Association to Products;
  quantity : Integer;
}
```

:::info Contained-in relationship
Essentially, Compositions are the same as _[associations](#associations)_, just with the additional information that this association represents a _contained-in_ relationship so the same syntax and rules apply in their base form.
:::

::: warning Limitations of Compositions of one
Using of compositions of one for entities is discouraged. There is often no added value of using them as the information can be placed in the root entity. Compositions of one have limitations as follow:
- Very limited Draft support. Fiori elements does not support compositions of one unless you take care of their creation in a custom handler.
- No extensive support for modifications over paths if compositions of one are involved. You must fill in foreign keys manually in a custom handler.
:::

### Managed Compositions of Aspects {#managed-compositions}

Use managed compositions variant to nicely reflect document structures in your domain models, without the need for separate entities, reverse associations, and unmanaged `on` conditions.


#### With Inline Targets

```cds
entity Orders {
  key ID: Integer; //...
  Items : Composition of many {
    key pos : Integer;
    product : Association to Products;
    quantity : Integer;
  }
};
```

Managed Compositions are mostly syntactical sugar: Behind the scenes, they are unfolded to the [unmanaged equivalent as shown above](#compositions)
by automatically adding a new entity, the name of which being constructed as a [scoped name](#scoped-names) from the name of parent entity, followed by the name of the composition element,
that is `Orders.Items` in the previous example.
You can safely use this name at other places, for example to define an association to the generated child entity:


```cds
entity Orders {
  // …
  specialItem : Association to Orders.Items;
};
```


#### With Named Targets

Instead of anonymous target aspects you can also specify named aspects, which are unfolded the same way as anonymous inner types, as shown in the previous example:

```cds
entity Orders {
  key ID: Integer; //...
  Items : Composition of many OrderItems;
}
aspect OrderItems {
  key pos : Integer;
  product : Association to Products;
  quantity : Integer;
}
```

#### Default Target Cardinality

If not otherwise specified, a managed composition of an aspect has the default target cardinality *to-one*.

#### For Many-to-many Relationships

Managed Compositions are handy for [many-to-many relationships](#many-to-many-associations), where a link table usually is private to one side.

```cds
entity Teams { [...]
  members : Composition of many { key user: Association to Users; }
}
entity Users { [...]
  teams: Association to many Teams.members on teams.user = $self;
}
```

And here's an example of an attributed many-to-many relationship:

```cds
entity Teams { [...]
  members : Composition of many {
    key user : Association to Users;
    role : String enum { Lead; Member; Collaborator; }
  }
}
entity Users { ... }
```

To navigate between _Teams_ and _Users_, you have to follow two associations: `members.user` or `teams.up_`.
In OData, to get all users of all teams, use a query like the following:

```cds
GET /Teams?$expand=members($expand=user)
```




### Publish Associations in Projections {#publish-associations}

As associations are first class citizens, you can put them into the select list
of a view or projection ("publish") like regular elements. A `select *` includes all associations.
If you need to rename an association, you can provide an alias.

```cds
entity P_Employees as projection on Employees {
  ID,
  addresses
}
```

The effective signature of the projection contains an association `addresses` with the same
properties as association `addresses` of entity `Employees`.

#### Publish Associations with Infix Filter {#publish-associations-with-filter}

When publishing an unmanaged association in a view or projection, you can add a filter condition.
The ON condition of the resulting association is the ON condition of the original
association plus the filter condition, combined with `and`.

```cds
entity P_Authors as projection on Authors {
  *,
  books[stock > 0] as availableBooks
};
```

In this example, in addition to `books` projection `P_Authors` has a new association `availableBooks`
that points only to those books where `stock > 0`.

If the filter condition effectively reduces the cardinality of the association
to one, you should make this explicit in the filter by adding a `1:` before the condition:

```cds
entity P_Employees as projection on Employees {
  *,
  addresses[1: kind='home'] as homeAddress  // homeAddress is to-one
}
```

Filters usually are provided only for to-many associations, which usually are unmanaged.
Thus publishing with a filter is almost exclusively used for unmanaged associations.
Nevertheless you can also publish a managed association with a filter. This will automatically
turn the resulting association into an unmanaged one. You must ensure that all foreign key elements
needed for the ON condition are explicitly published.

```cds
entity P_Books as projection on Books {
  author.ID as authorID,  // needed for ON condition of deadAuthor
  author[dateOfDeath is not null] as deadAuthor  // -> unmanaged association
};
```

Publishing a _composition_ with a filter is similar, with an important difference:
in a deep Update, Insert, or Delete statement the respective operation does not cascade to the target entities.
Thus the type of the resulting element is set to `cds.Association`.

[Learn more about `cds.Association`.](/cds/csn#associations){.learn-more}

In [SAP Fiori Draft](../advanced/fiori#draft-support), it behaves
like an "enclosed" association, that means, it points to the target draft entity.

In the following example, `singleItem` has type `cds.Association`.
In draft mode, navigating along `singleItems` doesn't leave the draft tree.

```cds
@odata.draft.enabled
entity P_orders as projection on Orders {
  *,
  Items[quantity = 1] as singleItems
}
```


## Annotations

This section describes how to add Annotations to model definitions written in CDL, focused on the common syntax options, and fundamental concepts. Find additional information in the [OData Annotations](../advanced/odata#annotations) guide.

- [Annotation Syntax](#annotation-syntax)
- [Annotation Targets](#annotation-targets)
- [Annotation Values](#annotation-values)
- [Expressions as Annotation Values](#expressions-as-annotation-values)
- [Records as Syntax Shortcuts](#records-as-syntax-shortcuts)
- [Annotation Propagation](#annotation-propagation)
- [The `annotate` Directive](#annotate)
- [Extend Array Annotations](#extend-array-annotations)


### Annotation Syntax

Annotations in CDL are prefixed with an `@` character and can be placed before a definition, after the defined name or at the end of simple definitions.

```cds
@before entity Foo @inner {
  @before simpleElement @inner : String @after;
  @before structElement @inner { /* elements */ }
}
```

Multiple annotations can be placed in each spot separated by whitespaces or enclosed in `@(...)` and separated by comma - like the following are equivalent:

```cds
entity Foo @(
  my.annotation: foo,
  another.one: 4711
) { /* elements */ }
```
```cds
@my.annotation:foo
@another.one: 4711
entity Foo { /* elements */ }
```

For an `@inner` annotation, only the syntax `@(...)` is available.


#### Using `annotate` Directives

Instead of interspersing annotations with definitions, you can also use the `annotate` directive to add annotations to existing definitions.

```cds
annotate Foo with @(
  my.annotation: foo,
  another.one: 4711
);
```

[Learn more about the `annotate` directive in the _Aspects_ chapter below.](#annotate){.learn-more}



### Annotation Targets

You can basically annotate any named thing in a CDS model, such as:

Contexts and services:


```cds
@before context foo.bar @inner { ... }
@before service Sue @inner { ... }
```

Definitions and elements with simple or struct types:


```cds
@before type Foo @inner : String @after;
@before entity Foo @inner {
  @before key ID @inner : String @after;
  @before title @inner : String @after;
  @before struct @inner { ...elements... };
}
```

Enums:


```cds
… status : String @inner enum {
  open @after;
  closed @after;
  cancelled @after;
  accepted @after;
  rejected @after;
}
```

Columns in a view definition's query:


```cds
… as select from Foo {
  @before expr as alias @inner : String,
  …
}
```

Parameters in view definitions:


```cds
… with parameters (
  @before param @(inner) : String @after
) …
```

Actions/functions including their parameters and result:

```cds
@before action doSomething @inner (
  @before param @(inner) : String @after
) returns @before resultType;
```

Or in case of a structured result:

```cds
action doSomething() returns @before {
  @before resultElem @inner : String @after;
};
```


### Annotation Values

Values can be literals, references, or expressions. Expressions are explained in more detail in the next section.
If no value is given, the default value is `true` as for `@aFlag` in the following example:

```cds
@aFlag //= true, if no value is given
@aBoolean: false
@aString: 'foo'
@anInteger: 11
@aDecimal: 11.1
@aSymbol: #foo
@aReference: foo.bar
@anArray: [ /* can contain any kind of value */ ]
@anExpression: ( foo.bar * 17 )  // expression, see next section
```

As described in the [CSN spec](./csn#literals), the previously mentioned annotations would compile to CSN as follows:

```jsonc
{
  "@aFlag": true,
  "@aBoolean": false,
  "@aString": "foo",
  "@anInteger": 11,
  "@aDecimal": 11.1,
  "@aSymbol": {"#":"foo"},
  "@aReference": {"=":"foo.bar"},
  "@anArray": [ /* … */ ],
  "@anExpression": { /* see next section */ }
}
```

::: tip
In contrast to references in [expressions](#expressions-as-annotation-values), plain references aren't checked, resolved,
or rewritten by CDS parsers or linkers. They're interpreted and evaluated only on consumption-specific modules.
For example, for SAP Fiori models, it's the _4odata_ and _2edm(x)_ processors.
:::


### Records as Syntax Shortcuts

Annotations in CDS are flat lists of key-value pairs assigned to a target.
The record syntax - that is, `{key:<value>, ...}` - is a shortcut notation that applies a common prefix to nested annotations.
For example, the following are equivalent:

```cds
@Common.foo.bar
@Common.foo.car: 'wheels'
```
```cds
@Common: { foo.bar, foo.car: 'wheels' }
```
```cds
@Common.foo: { bar }
@Common.foo.car: 'wheels'
```
```cds
@Common.foo: { bar, car: 'wheels' }
```

and they would show up as follows in a parsed model (&rarr; see [CSN](./csn)):

```json
{
  "@Common.foo.bar": true,
  "@Common.foo.car": "wheels"
}
```

### Annotation Propagation {#annotation-propagation}

Annotations are inherited from types and base types to derived types, entities, and elements as well as from elements of underlying entities in case of views.

For example, given this view definition:

```cds
using Books from './bookshop-model';
entity BooksList as select from Books {
  ID, genre : Genre, title,
  author.name as author
};
```

* `BooksList` would inherit annotations from `Books`
* `BooksList:ID` would inherit from `Books:ID`
* `BooksList:author` would inherit from `Books:author.name`
* `BooksList.genre` would inherit from type `Genre`

The rules are:

1. Entity-level properties and annotations are inherited from the **primary** underlying source entity — here `Books`.

2. Each element that can **unambiguously** be traced back to a single source element, inherits that element's properties.

3. An explicit **cast** in the select clause cuts off the inheritance, for example, as for `genre` in our previous example.

::: tip
Propagation of annotations can be stopped via value `null`, for example, `@anno: null`.
:::


### Expressions as Annotation Values <Beta /> {#expressions-as-annotation-values}

In order to use an expression as an annotation value, it must be enclosed in parentheses:
```cds
@anExpression: ( foo.bar * 11 )
```

Syntactically, the same expressions are supported as in a select item or in the where clause of a query,
except subqueries. The expression can of course also be a single reference or a simple value:
```cds
@aRefExpr: ( foo.bar )
@aValueExpr: ( 11 )
```

Some advantages of using expressions as "first class" annotation values are:
* syntax and references are checked by the compiler
* code completion
* [automatic path rewriting in propagated annotations](#propagation)
* [automatic translation of expressions in OData annotations](#odata-annotations)

::: info Limitations
Elements that are not available to the compiler, for example the OData draft decoration, can't be used in annotation expressions.
:::

#### Name resolution

Each path in the expression is checked:
* For an annotation assigned to an entity, the first path step is resolved as element of the entity.
* For an annotation assigned to an entity element, the first path step is resolved as the annotated element or its siblings.
* If the annotation is assigned to a subelement of a structured element, the top level
  elements of the entity can be accessed via `$self`.
* A parameter `par` can be accessed via `:par`, just like parameters of a parametrized entity in queries.
* For an annotation assigned to a bound action or function, elements of the respective entity
  can be accessed via `$self`.
* The draft-specific elements `IsActiveEntity`, `HasActiveEntity`, and `HasDraftEntity` can be referred to with
  respective magic variables `$draft.IsActiveEntity`, `$draft.HasActiveEntity`, and `$draft.HasDraftEntity`.
  During draft augmentation, `$draft.<...>` is rewritten to `$self.<...>` for all draft enabled
  entities (root and sub nodes, but not for named types or entity parameters).
* If a path can't be resolved successfully, compilation fails with an error.

In contrast to `@aReference: foo.bar`, a single reference written as expression `@aRefExpr: ( foo.bar )`
is checked by the compiler.

```cds
@MyAnno: (a)            // reference to element
entity Foo (par: Integer) {
  key ID : Integer;
  @MyAnno: (:par)       // reference to entity parameter
  a : Integer;
  @MyAnno: (a)          // reference to sibling element
  b : Integer;
  s {
    @MyAnno: (y)        // reference to sibling element
    x : Integer;
    @MyAnno: ($self.a)  // reference to top level element
    y : Integer;
  }
}
actions {
  @MyAnno: ($self.a)
  action A ()
}
```

#### CSN Representation

In CSN, the expression is represented as a record with two properties:
* A string representation of the expression is stored in property `=`.
* A tokenized representation of the expression is stored in one of the properties
  `xpr`, `ref`, `val`, `func`, etc. (like if the expression was written in a query).

```json
{
  "@anExpression": {
    "=": "foo.bar * 11",
    "xpr": [ {"ref": ["foo", "bar"]}, "*", {"value": 11} ]
  },
  "@aRefExpr": {
    "=": "foo.bar",
    "ref": ["foo", "bar"]
  },
  "@aValueExpr": {
    "=": "11",
    "val": 11
  }
}
```

Note the different CSN representations for a [plain value](#annotation-values) `"@anInteger": 11`
and a value written as expression `@aValueExpr: ( 11 )`, respectively.

#### Propagation

[Annotations are propagated](#annotation-propagation) in views/projections, via includes, and along type references.
If the annotation value is an expression, it is sometimes necessary to adapt references inside the expression
during propagation, for example, when a referenced element is renamed in a projection.
The compiler automatically takes care of the necessary rewriting. When a reference in an annotation expression
is rewritten, the `=` property is set to `true`.

Example:
```cds
entity E {
  @Common.Text: (text)
  code : Integer;
  text : String;
}

entity P as projection on E {
  code,
  text as descr
}
```
When propagated to element `code` of projection `P`, the annotation is automatically
rewritten to `@Common.Text: (descr)`.

::: details Resulting CSN
```jsonc
{
  "definitions": {
    "E": {  // ...
      "elements": {  // ...
        "code": {
          // original annotation
          "@Common.Text": { "=": "text",
                            "ref": ["text"] },
          "type": "cds.Integer"
        },
        "text": {"type": "cds.String"}
      }
    },
    "P": {  // ...
      "elements": {  // ...
        "code": {
          // propagated annotation, reference adapted
          "@Common.Text": { "=": true,
                            "ref": ["descr"] },
          "type": "cds.Integer"
        },
        "descr": {"type": "cds.String"}
      }
} } }
```
:::

::: info

There are situations where automatic rewriting doesn't work, resulting in the compiler error
[`anno-missing-rewrite`](https://cap.cloud.sap/docs/cds/compiler/messages#anno-missing-rewrite).
Some of these situations are going to be addressed in upcoming releases.

:::


#### CDS Annotations

Using an expression as annotation value only makes sense if the evaluator of the annotation is
prepared to deal with the new CSN representation.
Currently, the CAP runtimes only support expressions in the `where` property of the `@restrict` annotation.

```cds
entity Orders @(restrict: [
    { grant: 'READ', to: 'Auditor', where: (AuditBy = $user.id) }
  ]) {/*...*/}
```

More annotations are going to follow in upcoming releases.

Of course, you can use this feature also in your custom annotations, where you control the code that evaluates
the annotations.

#### OData Annotations

The OData backend of the CAP CDS compiler supports expression-valued annotations.
See [Expressions in OData Annotations](../advanced/odata#expression-annotations).



### Extend Array Annotations {#extend-array-annotations}

Usually, the annotation value provided in an `annotate` directive overwrites an already existing annotation value.

If the existing value is an array, the *ellipsis* syntax allows to insert new values **before** or **after** the existing entries,
instead of overwriting the complete array. The ellipsis represents the already existing array entries. Of course, this works with any kind of array entries.

This is a sample of an existing array:

```cds
@anArray: [3, 4] entity Foo { /* elements */ }
```

This shows how to extend the array:

```cds
annotate Foo with @anArray: [1, 2, ...];  //> prepend new values: [1, 2, 3, 4]
annotate Foo with @anArray: [..., 5, 6];  //> append new values: [3, 4, 5, 6]
annotate Foo with @anArray: [1, 2, ..., 5, 6]; //> prepend and append
```

It's also possible to insert new entries at **arbitrary positions**. For this, use `... up to` with a *comparator* value that identifies the insertion point.


```cds
[... up to <comparator>, newEntry, ...]
```

`... up to` represents the existing entries of the array from the current position
up to and including the first entry that matches the comparator. New entries are then inserted behind the matched entry.
If there's no match, new entries are appended at the end of the existing array.

This is a sample of an existing array:

```cds
@anArray: [1, 2, 3, 4, 5, 6] entity Bar { /* elements */ }
```

This shows how to insert values after `2` and `4`:

```cds
annotate Bar with @anArray: [
  ... up to 2,  // existing entries 1, 2
   2.1, 2.2,    // insert new entries 2.1, 2.2
  ... up to 4,  // existing entries 3, 4
  4.1, 4.2,     // insert new entries 4.1, 4.2
  ...           // remaining existing entries 5, 6
];
```

The resulting array is:

```js
[1, 2, 2.1, 2.2, 3, 4, 4.1, 4.2, 5, 6]
```

If your array entries are objects, you have to provide a *comparator object*.
It matches an existing entry, if all attributes provided in the comparator match the corresponding attributes in an existing entry.
The comparator object doesn't have to contain all attributes that the existing array entries have,
simply choose those attributes that sufficiently characterize the array entry after which you want to insert.
Only simple values are allowed for the comparator attributes.

Example: Insert a new entry after `BeginDate`.

```cds
@UI.LineItem: [
    { $Type: 'UI.DataFieldForAction', Action: 'TravelService.acceptTravel', Label: '{i18n>AcceptTravel}' },
    { Value: TravelID,  Label: 'ID'    },
    { Value: BeginDate, Label: 'Begin' },
    { Value: EndDate,   Label: 'End'   }
  ]
entity TravelService.Travel { /* elements */ }
```

For this, you provide a comparator object with the attribute `Value`:

```cds
annotate TravelService.Travel with @UI.LineItem: [
  ... up to { Value: BeginDate },  // ... up to with comparator object
  { Value: BeginWeekday, Label: 'Day of week' }, // new entry
  ... // remaining array entries
];
```

::: tip
Only direct annotations can be extended using `...`. It's not supported to extend propagated annotations, for example, from aspects or types.
:::

<br>

## Aspects

CDS's aspects allow to flexibly extend definitions by new elements as well as overriding properties and annotations.
They're based on a mixin approach as known from Aspect-oriented Programming methods.

- [The `extend` Directive](#extend)
- [The `annotate` Directive](#annotate)
- [Named Aspects](#named-aspects)
- [Shortcut Syntax `:`](#includes)
- [Extending Views / Projections](#extend-view)
- See also: [Aspect-oriented Modelling](aspects)




### The `extend` Directive
{#extend}

Use `extend` to add extension fields or to add/override metadata to existing definitions, for example, annotations, as follows:

```cds
extend Foo with @title:'Foo';
extend Bar with @title:'Bar' {
  newField : String;
  extend nestedStructField {
    newField : String;
    extend existingField @title:'Nested Field';
  }
}
```

::: details Note the nested `extend` for existing fields
Make sure that you prepend the `extend` keyword to nested elements if you want to modify them. Without that a new field with that name would be added. If you only want to add annotations to an existing field, you can use [the **annotate** directive.](#annotate) instead.
:::


You can also directly extend a single element:
```cds
extend Foo:nestedStructField with { newField : String; }
```

With `extend` you can enlarge the *length* of a String or *precision* and *scale* of a Decimal:
```cds
extend User with (length:120);
extend Books:price.value with (precision:12,scale:3);
```
The extended type or element directly must have the respective property.

For multiple conflicting `extend` statements, the last `extend` wins, that means in three files `a.cds <- b.cds <- c.cds`, where `<-` means `using from`,
the `extend` from `c.cds` is applied, as it is the last in the dependency chain.



### The `annotate` Directive
{#annotate}

The `annotate` directive allows to annotate already existing definitions that may have been [imported](#model-imports) from other files or projects.

```cds
annotate Foo with @title:'Foo';
annotate Bar with @title:'Bar' {
  nestedStructField {
    existingField @title:'Nested Field';
  }
}
```

::: details `annotate` is a shortcut for `extend` ...

The `annotate` directive is essentially a shortcut variant of the [`extend` directive](#extend), with the default mode being switched to `extend`ing existing fields instead of adding new ones. For example, the following is equivalent to the previous example:

```cds
extend Foo with @title:'Foo';
extend Bar with @title:'Bar' {
  extend nestedStructField {
    extend existingField @title:'Nested Field';
  }
}
```
:::


You can also directly annotate a single element:
```cds
annotate Foo:existingField @title: 'Simple Field';
annotate Foo:nestedStructField.existingField @title:'Nested Field';
```




### Named Aspects

You can use `extend` with predefined aspects, to apply the same extensions to multiple targets:

```cds
@annotation
aspect NamedAspect {
  created { at: Timestamp; _by: User; }
} actions {
  action A() returns String;
}
```
```cds
extend Foo with NamedAspect;
extend Bar with NamedAspect;
```

By extending an entity with an aspect, you add all the aspect's fields, actions, and annotations to the entity.

Use keyword `aspect` as shown in the example to declare definitions that are only meant to be used in such extensions, not as types for elements.

To reuse annotations, without adding elements, use an empty aspect and extend your target with it
You can even extend projections with such aspects.

```cds
@annotation
aspect ReuseAnnotations {};
entity Proj as projection on Bar;
```
```cds
extend Proj with ReuseAnnotations;
```


### Includes -- `:` as Shortcut Syntax {#includes}

You can use an inheritance-like syntax option to extend a definition with one or more [named aspects](#named-aspects)
as follows:

```cds
define entity Foo : SomeAspect, AnotherAspect {
  key ID : Integer;
  name : String;
  [...]
}
```

This is syntactical sugar and equivalent to using a sequence of [extends](#extend) as follows:

```cds
define entity Foo {}
extend Foo with SomeAspect;
extend Foo with AnotherAspect;
extend Foo with {
  key ID : Integer;
  name : String;
  [...]
}
```

You can apply this to any definition of an entity or a structured type.




### Extending Views and Projections { #extend-view}

Use the `extend <entity> with columns` variant to extend the select list of a projection or view entity and do the following:

* Include more elements existing in the underlying entity.
* Add new calculated fields.
* Add new unmanaged associations.

```cds
extend SomeView with columns {
  foo as moo @woo,
  1 + 1 as two,
  bar : Association to Bar on bar.ID = moo
}
```

Enhancing nested structs isn't supported. Furthermore, the table alias of the view's data source
is not accessible in such an extend.

You can use the common [`annotate` directive](#annotate) to just add/override annotations of a view's elements.

<br>


## Services

- [Service Definitions](#service-definitions)
- [Exposed Entities](#exposed-entities)
- [(Auto-) Redirected Associations](#auto-redirect)
- [Auto-exposed Targets](#auto-expose)
- [Custom Actions/Functions](#actions)
- [Custom-defined Events](#events)
- [Extending Services](#extend-service)
  <span id="tocservices" />


### Service Definitions

CDS allows to define service interfaces as collections of exposed entities enclosed in a `service` block, which essentially is and acts the same as [`context`](#context):

```cds
service SomeService {
  entity SomeExposedEntity { ... };
  entity AnotherExposedEntity { ... };
}
```

The endpoint of the exposed service is constructed by its name, following some conventions (the string `service` is dropped and kebab-case is enforced). If you want to overwrite the path, you can add the `@path` annotation as follows:

```cds
@path: 'myCustomServicePath'
service SomeService { ... }
```

[Watch a short video by DJ Adams on how the `@path` annotations works.](https://www.youtube.com/shorts/Q_PipD_7yBs){.learn-more}

### Exposed Entities

The entities exposed by a service are most frequently projections on entities from underlying data models.
Standard view definitions, using [`as select from`](#views) or [`as projection on`](#as-projection-on), can be used for
exposing entities.

```cds
service CatalogService {
  entity Product as projection on data.Products {
    *, created.at as since
  } excluding { created };
}
service MyOrders {
  //> $user only implemented for SAP HANA
  entity Order as select from data.Orders { * } where buyer=$user.id;
  entity Product as projection on CatalogService.Product;
}
```

::: tip
You can optionally add annotations such as `@readonly` or `@insertonly` to exposed entities, which, will be enforced by the CAP runtimes in Java and Node.js.
:::

Entities can be also exposed as views with parameters:

```cds
service MyOrders {
  entity OrderWithParameter( foo: Integer ) as select from data.Orders where id=:foo;
}
```
A parametrized view like modeled in the section on [`view with parameter`](#views-with-parameters) can be exposed as follows:

```cds
service SomeService {
  entity ViewInService( p1: Integer, p2: Boolean ) as select from data.SomeView(foo: :p1, bar: :p2) {*};
}
```
Then the OData request for views with parameters should look like this:

```cds
GET: /OrderWithParameter(foo=5)/Set or GET: /OrderWithParameter(5)/Set
GET: /ViewInService(p1=5, p2=true)/Set
```

To expose an entity, it's not necessary to be lexically enclosed in the service definition. An entity's affiliation to a service is established using its fully qualified name, so you can also use one of the following options:

- Add a namespace.
- Use the service name as prefix.

In the following example, all entities belong to/are exposed by the same service:

::: code-group
```cds [myservice.cds]
service foo.MyService {
  entity A { /*...*/ };
}
entity foo.MyService.B { /*...*/ };
```
:::

::: code-group
```cds [another.cds]
namespace foo.MyService;
entity C { /*...*/ };
```
:::


### (Auto-) Redirected Associations
{#auto-redirect}

When exposing related entities, associations are automatically redirected. This ensures that clients can navigate between projected entities as expected. For example:

```cds
service AdminService {
  entity Books as projection on my.Books;
  entity Authors as projection on my.Authors;
  //> AdminService.Authors.books refers to AdminService.Books
}
```

#### Resolving Ambiguities

Auto-redirection fails if a target can't be resolved unambiguously, that is, when there is more than one projection with the same minimal 'distance' to the source. For example, compiling the following model with two projections on `my.Books` would produce this error:

::: danger
Target "Books" is exposed in service "AdminService" by multiple projections "AdminService.ListOfBooks", "AdminService.Books" - no implicit redirection.
:::

```cds
service AdminService {
  entity ListOfBooks as projection on my.Books;
  entity Books as projection on my.Books;
  entity Authors as projection on my.Authors;
  //> which one should AdminService.Authors.books refer to?
}
```

#### Using `redirected to` with Projected Associations

You can use `redirected to` to resolve the ambiguity as follows:

```cds
service AdminService {
  entity ListOfBooks as projection on my.Books;
  entity Books as projection on my.Books;
  entity Authors as projection on my.Authors { *, // [!code focus]
    books : redirected to Books //> resolved ambiguity // [!code focus]
  };
}
```

#### Using `@cds.redirection.target` Annotations

Alternatively, you can use the boolean annotation `@cds.redirection.target` with value `true` to make an entity a preferred redirection target, or with value `false` to exclude an entity as target for auto-redirection.

```cds
service AdminService {
  @cds.redirection.target: true // [!code focus]
  entity ListOfBooks as projection on my.Books; // [!code focus]
  entity Books as projection on my.Books;
  entity Authors as projection on my.Authors;
}
```



### Auto-Exposed Entities
{#auto-expose}

Annotate entities with `@cds.autoexpose` to automatically expose them in services containing entities with associations referring to them.

For example, given the following entity definitions:

```cds
// schema.cds
namespace schema;
entity Bar @cds.autoexpose { key id: Integer; }

using { sap.common.CodeList } from '@sap/cds/common';
entity Car : CodeList { key code: Integer; }
//> inherits  @cds.autoexpose from  sap.common.CodeList
```

... a service definition like this:

```cds
using { schema as my } from './schema.cds';
service Zoo {
  entity Foo { //...
    bar : Association to my.Bar;
    car : Association to my.Car;
  }
}
```

... would result in the service being automatically extended like this:

```cds
extend service Zoo with { // auto-exposed entities:
   @readonly entity Foo_bar as projection on Bar;
   @readonly entity Foo_car as projection on Car;
}
```

You can still expose such entities explicitly, for example, to make them read-write:

```cds
service Sue {
  entity Foo { /*...*/ }
  entity Bar as projection on my.Bar;
}
```

[Learn more about **CodeLists in `@sap/cds/common`**.](./common#code-lists){.learn-more}



### Custom Actions and Functions {#actions}

Within service definitions, you can additionally specify `actions` and `functions`. Use a comma-separated list of named and typed inbound parameters (optional) and a response type (optional for actions), which can be either a:

- [Predefined Type](#types)
- [Reference to a custom-defined type](#types)
- [Inline definition of an anonymous structured type](#structured-types)

```cds
service MyOrders {
  entity Order { /*...*/ };
  // unbound actions / functions
  type cancelOrderRet {
    acknowledge: String enum { succeeded; failed; };
    message: String;
  }
  action cancelOrder ( orderID:Integer, reason:String ) returns cancelOrderRet;
  function countOrders() returns Integer;
  function getOpenOrders() returns array of Order;
}
```

::: tip
The notion of actions and functions in CDS adopts that of [OData](https://docs.oasis-open.org/odata/odata/v4.0/os/part1-protocol/odata-v4.0-os-part1-protocol.html#_Toc372793737); actions and functions on service-level are _unbound_ ones.
:::


#### Bound Actions and Functions { #bound-actions}

Actions and functions can also be bound to individual entities of a service, enclosed in an additional `actions` block as the last clause in an entity/view definition.

```cds
service CatalogService {
  entity Products as projection on data.Products { ... }
    actions {
      // bound actions/functions
      action addRating (stars: Integer);
      function getViewsCount() returns Integer;
    }
}
```

Bound actions and functions have a binding parameter that is usually implicit.
It can also be modeled explicitly: the first parameter of a bound action or function is treated as binding parameter,
if it's typed by `[many] $self`. Use Explicit Binding to control the naming of the binding parameter. Use the
keyword `many` to indicate that the action or function is bound to a collection of instances rather than to a single one.

```cds
service CatalogService {
  entity Products as projection on data.Products { ... }
    actions {
      // bound actions/functions with explicit binding parameter
      action A1 (prod: $self, stars: Integer);
      action A2 (in: many $self);  // bound to collection of Products
    }
}
```

Explicitly modelled binding parameters are ignored for OData V2.



### Custom-Defined Events {#events}

Similar to [Actions and Functions](../cds/cdl#actions) you can declare `events`, which a service emits via messaging channels. Essentially, an event declaration looks very much like a type definition, specifying the event's name and the type structure of the event messages' payload.

```cds
service MyOrders { ...
  event OrderCanceled {
    orderID: Integer;
    reason: String;
  }
}
```

An event can also be defined as projection on an entity, structured type, or another event.
Only the effective signature of the projection is relevant.
```cds
service MyOrders { ...
  event OrderCanceledNarrow : projection on OrderCanceled { orderID }
}
```



### Extending Services {#extend-service}

You can [extend](#extend) services with additional entities and actions much as you would add new entities to a context:

```cds
extend service CatalogService with {
  entity Foo {};
  function getRatings() returns Integer;
}
```

Similarly, you can [extend](#extend) entities with additional actions
as you would add new elements:


```cds
extend entity CatalogService.Products with actions {
  function getRatings() returns Integer;
}
```

<div id="beforenamespaces" />




[JSON Schema]: https://json-schema.org
[OpenAPI]: https://www.openapis.org

# Core Schema Notation (CSN)

CSN (pronounced as "_Season_") is a notation for compact representations of CDS models — tailored to serve as an optimized format to share and interpret models with minimal footprint and dependencies.

It's similar to [JSON Schema] but goes beyond JSON's abilities, in order to capture full-blown _Entity-Relationship Models_ and [Extensions](#aspects). This makes CSN models a perfect source to generate target models, such as [OData/EDM](../advanced/odata) or [OpenAPI] interfaces, as well as persistence models for SQL or NoSQL databases.

## Anatomy

A CSN model in **JSON**:

```json
{
  "requires": [ "@sap/cds/common", "./db/schema" ],
  "definitions": {
    "some.type": { "type": "cds.String", "length": 11 },
    "another.type": { "type": "some.type" },
    "structured.type": { "elements": {
      "foo": { "type": "cds.Integer" },
      "bar": { "type": "cds.String" }
    }}
  },
  "extensions": [
    { "extend":"Foo", "elements":{
      "bar": { "type": "cds.String" }
    }}
  ]
}
```

The same model in **YAML**:

```yaml
requires:
  - @sap/cds/common
  - ./db/schema
definitions:
  some.type: {type: cds.String, length: 11}
  another.type: {type: some.type }
  structured.type:
    elements:
      foo: {type: cds.Integer}
      bar: {type: cds.String}
extensions: [
  - extend: Foo
    elements:
      bar: {type: cds.String}
]
```

The same model as a **plain JavaScript** object:

```js
({
  requires:[ '@sap/cds/common', './db/schema' ],
  definitions: {
    'some.type': { type:"cds.String", length:11 },
    'another.type': { type:"some.type" },
    'structured.type': { elements: {
      'foo': { type:"cds.Integer" },
      'bar': { type:"cds.String" }
    }}
  },
  extensions: [
    { extend:'Foo', elements:{
      'bar': { type:"cds.String" }
    }
  ],
})
```

For the remainder of this spec, you see examples in plain JavaScript representation with the following **conventions**:

```js
({property:...})   // a CSN-specified property name
({'name':...})     // a definition's declared name
"value"            // a string value, including referred names
11, true           // number and boolean literal values
```

#### Properties
* [`requires`](#imports) &ndash; an array listing [imported models](#imports)
* [`definitions`](#definitions) &ndash;  a dictionary of named [definitions](#definitions)
* [`extensions`](#aspects) &ndash; an array of unnamed [aspects](#aspects)
* [`i18n`](#i18n) &ndash; a dictionary of dictionaries of [text translations](#i18n)

> [!TIP] All properties are optional
> For example, one model could contain a few definitions, while another one only contains some extensions.


> [!NOTE] References are case-sensitive
> All references in properties like `type` or `target` use exactly the same notation regarding casing as their targets' names. To avoid problems when translating models to case-insensitive environments like SQL databases, avoid case-significant names and references. For example, avoid two different definitions in the same scope whose names only differ in casing, such as `foo` and `Foo`.





## Literals

There are several places where literals can show up in models, such as in SQL expressions, calculated fields, or annotations.

Standard literals are represented as in JSON:

| Kind                  | Example                  |
|-----------------------|--------------------------|
| Globals               | `true`, `false`, `null`  |
| Numbers<sup>1</sup>   | `11` or  `2.4`           |
| Strings               | `"foo"`                  |
| Dates<sup>2</sup>     | `"2016-11-24"`           |
| Times<sup>2</sup>     | `"16:11Z"`                |
| DateTimes<sup>2</sup> | `"2016-11-24T16:11Z"`     |
| Records               | `{"foo":<literal>, ...}` |
| Arrays                | `[<literal>, ...]`       |

In addition, CSN specifies these special forms for references, expressions, and `enum` symbols:

| Kind                     | Example               |
|--------------------------|-----------------------|
| Unparsed Expressions     | `{"=":"foo.bar < 9"}` |
| Enum symbols<sup>3</sup> | `{"#":"asc"}`         |

#### Remarks

><sup>1</sup> This is as in JSON and shares the same issues when decimals are mapped to doubles with potential rounding errors. The same applies to Integer64. Use strings to avoid that, if applicable.
>
><sup>2</sup> Also, as in JSON, dates, and times are represented just as strings as specified in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601); consumers are assumed to know the types and handle the values correctly.
>
><sup>3</sup> As enum symbols are equal to their values, it frequently suffices to just provide them as strings. Similar to time and dates in CSN and JSON, the consumers are assumed to know the types and handle the values correctly. The  `{"#":...}` syntax option is to serve cases where you have to distinguish the kind only based on the provided value, for example, in untyped annotations.





## Definitions

Each entry in the `definitions` dictionary is essentially a type definition. The name is the absolute, fully qualified name of the definition, and the value is a record with the definition details.


#### Example

```js
({definitions:{
  'Name':     {type:"cds.String"},
  'Currency': {type:"cds.String", length:3},
  'USD':      {type:"Currency"},
  'Amount':   {elements:{
    'value':    {type:"cds.Decimal", precision:11, scale:3},
    'currency': {type:"Currency"},
  }},
  'SortOrder':{enum:{ 'asc':{}, 'desc':{} }}
}})
```

The __name__ of a definition is its key in the enclosing dictionary, like in `definitions` for top-level entries or in `elements` for structured types and entities.

Names **must**:
* Be nonempty strings.
* Neither start, nor end with `.` or `::`.
* Not contain substrings `..` or `:::`.
* Not contain the substring `::` more than once.


#### Properties {#def-properties}

* `kind` &ndash; one of `context`, `service`, `entity`, `type`, `action`, `function`, or `annotation`
* `type` &ndash; an optional base type that this definition is derived from
* [`elements`][elements] &ndash; optional dictionary of [_elements_][elements] in case of structured types

Property `kind` is always omitted for [elements] and can be omitted for top-level [type definitions]. These examples are semantically equivalent:

```js
Foo1 = { type:"cds.String" }
Foo2 = { type:"cds.String", kind:"type" }
```


## Type Definitions

[type definitions]: #type-definitions

Custom-defined types are entries in [`definitions`](#definitions) with an optional property `kind`=`"type"` and the following properties.

| Property   | Used for                                                              |
|------------|-----------------------------------------------------------------------|
| `type`     | [Scalar Types](#scalar-types), [Structured Types](#structured-types), and [Associations](#associations) |
| `elements` | [Structured Types](#structured-types)                                 |
| `items`    | [Arrayed Types](#arrayed-types)                                       |
| `enum`     | [Enumeration Types](#enumeration-types)                               |


#### Example

```js
({definitions: {
  'scalar.type':  {type:"cds.String", length:3 },
  'struct.type':  {elements:{'foo': {type:"cds.Integer"}}},
  'arrayed.type': {items:{type:"cds.Integer"}},
  'enum.type':    {enum:{ 'asc':{}, 'desc':{} }}
}})
```

#### Properties


* `kind` &ndash; omitted or _`"type"`_
* `type` &ndash; the base type, this definition is derived from
* [`elements`][elements] &ndash; optional element definitions for [_structured types_][struct].
* [`items`][arrays] &ndash; optional definition of item types for [_arrayed types_][arrays].
* [`enum`][enum] &ndash; an optional dictionary of enum members for [_enumeration types_][enum].
* `value` &ndash; a constant [literal value](#literals) or calculation expression
* `default` &ndash; a default [value or expression](#literals)
* `localized` _= true_ if this type was declared like _foo : localized String_
* `...` &ndash; other type-specific properties, for example, a String's `length`



### Scalar Types


Scalar types always have property `type` specified, plus optional type-specific parameter properties.

```js
({definitions:{
  'scalar.type': {type:"cds.String", length:3 },
}})
```

See the [CDL reference docs](types) for an overview of CDS' built-in types.

While in [CDS sources](cdl) you can refer to these types without prefix, they always have to be specified with their **fully qualified names in CSN**, for example:

```js
({definitions: {
  'Foo': { type:"cds.Integer" },
  'Bar': { type:"cds.Decimal", precision:11, scale:3 },
}})
```


### Structured Types

[struct]: #structured-types
[elements]: #structured-types
[Structured Types]: #structured-types

Structured types are signified by the presence of an `elements` property. The value of `elements` is a dictionary of `elements`. The name is the local name of the element and the values in turn are [Type Definitions](#type-definitions).

The optional property `includes` contains a list of fully qualified entity-, aspect-, or type-names. Elements, actions, and annotations from those definitions are then copied into the structured type.

```js
({definitions:{
  'structured.type': {elements:{
    'foo': {type:"cds.Integer"},
    'bar': {type:"cds.String"}
  }}
}})
```


### Arrayed Types

[arrays]: #arrayed-types

Arrayed types are signified by the presence of a property `items`. The value of which is in turn a [type definition](#type-definitions) that specifies the arrayed items' type.

```js
({definitions:{
  'arrayed.type': {items:{type:"cds.Integer"}}
}})
```


### Enumeration Types

[enum]: #enumeration-types

The `enum` property is a dictionary of enum member elements with the name being the enum symbol and the value being a [CQN literal value expression](cxn#literal-values). The literal expression optionally specifies a constant `val` as a [literal](#literals) plus optional annotations. An enumeration type can specify an explicit `type` (for example, _Decimal_) but can also omit it and refer from given enumeration values, or _String_ as default.

```js
({definitions:{
  'Gender': {enum:{
    'male':{},
    'female':{},
    'non_binary': {
          val: 'non-binary'
        }
  }},
  'Status': {enum:{
    'submitted': {val:1},
    'fulfilled': {val:2}
  }},
  'Rating': {type:"cds.Decimal", enum:{
    'low':    {val:0},
    'medium': {val:50},
    'high':   {val:100}
  }}
}})
```





## Entity Definitions

[entities]: #entity-definitions
[entity]: #entity-definitions

Entities are [structured types](#structured-types) with **_kind_** =`'entity'`. In addition, one or more elements usually have property `key` set to true, to flag the entity's primary key.

#### Example

```js
({definitions:{
  'Products': {kind:"entity", elements:{
    'ID':     {type:"cds.Integer", key:true},
    'title':  {type:"cds.String", notNull:true},
    'price':  {type:"Amount", virtual:true},
  }}
}})
```

#### Properties

* `kind` &ndash; is always _`"entity"`_
* `elements` &ndash; as in [Structured Types], optionally equipped with one or more of these boolean properties:
  * `key` &ndash; signifies that the element is (part of) the primary key
  * `virtual` &ndash; has this element ignored in generic persistence mapping
  * `notNull` &ndash; the _not null_ constraint as in SQL
* `includes` &ndash; as in [Structured Types]



### View Definitions

[views]: #view-definitions
[view]: #view-definitions

Views are entities defined as projections on underlying entities. In CSN, views are signified by the presence of property `query`, which captures the projection as a [CQN](cqn) expression.


#### Example

```js
({definitions:{
  'Foo': { kind:"entity", query: {
    SELECT:{
      from: {ref:['Bar']},
      columns: [ {ref:['title']}, {ref:['price']} ]
    }
  }}
}})
```

#### Properties

* `kind` &ndash; mandatory; always _`"entity"`_
* `query` &ndash; the parsed query in [CQN](cqn) format
* `elements` &ndash; optional [elements signature](#views-with-declared-signatures), omitted and inferred
* `params` &ndash; optional [parameters](#views-with-parameters)



### Views with Declared Signatures

Views with declared signatures have the additional property `elements` filled in as in [entities](cdl#entities):

```js
({definitions:{
  'with.declared.signature': {kind:"entity",
    elements: {
      'title': {type:"cds.String"},
      'price': {type:"Amount"}
    },
    query: { SELECT:{...} },
  }
}})
```


### Views with Parameters

Views with parameters have an additional property `params` &ndash; an optional dictionary of parameter [type definitions](#type-definitions):

```js
({definitions:{
  'with.params': {kind:"entity",
    params: { 'ID': { type: 'cds.Integer' } },
    query: { SELECT:{...} },
  }
}})
```

### Projections

Use the `projection` property for views if you don't need the full power of SQL. See `as projection on` in [CDL](./cdl#as-projection-on) for restrictions.

```js
({ definitions: {
  'Foo': { kind: "entity",
    projection: {
      from: { ref: ['Bar'] },
      columns: [ '*' ]
    }
  }
}})
```

#### Properties

* `kind` &ndash; mandatory; always _`"entity"`_
* `projection` &ndash; the parsed query; equivalent to `query.SELECT`, see [CQN](cqn)
* `elements` &ndash; optional [elements signature](#views-with-declared-signatures), omitted and inferred

## Associations


Associations are like [scalar type definitions](#scalar-types) with `type` being `cds.Association` or `cds.Composition` plus additional properties specifying the association's `target` and optional information like `on` conditions or foreign `keys`.

### Basic to-one Associations

The basic form of associations are *to-one* associations to a designated target:

```js
({definitions:{
  'Books': { kind:"entity", elements:{
    'author': { type:"cds.Association", target:"Authors" },
  }},
  //> an association type-def
  'Currency': { type:"cds.Association", target:"Currencies" },
}})
```



### With Specified `cardinality` {#assoc-card}

Add property `cardinality` to explicitly specify a *to-one* or *to-many* relationship:

```js
({definitions:{
  'Authors': { kind:"entity", elements:{
    'books': { type:"cds.Association", target:"Books", cardinality:{max:"*"} },
  }},
}})
```

Property `cardinality` is an object `{src?,min?,max}` with...

* `src` set to `1` give a hint to database optimizers, that a source entity always exists
* `min` specifying the target's minimum cardinality &ndash; default: `0`
* `max` specifying the target's maximum cardinality &ndash; default: `1`

In summary, the default cardinality is _[0..1]_, which means *to-one*.

### With Specified `on` Condition {#assoc-on}

So-called *unmanaged* associations have an explicitly specified `on` condition:

```js
({definitions:{
  'Authors': { kind:"entity", elements:{
    'books': { type:"cds.Association", target:"Books", cardinality{max:"*"},
      on: [{ref:['books', 'author']}, '=', {ref:['$self']}]
    },
  }}
 }})
```



### With Specified `keys` {#assoc-keys}

Managed to-one associations automatically use the target's designated primary `key` elements. You can overrule this by explicitly specifying alternative target properties to be used in the `keys` property:

```js
({definitions:{
  'Books': {kind:"entity", elements:{
    'genre': {type:"cds.Association", target:"Genres", keys:[
      {ref:["category"], as:"cat"},
      {ref:["name"]},
    ]},
  }},
}})
```

Property `keys` has the format and mechanisms of [CQN projections](cqn#select).



## Annotations

Annotations are represented as properties, prefixed with `@`.
This format applies to type/entity-level annotations as well as to element-level ones.

#### Example

```js
({definitions:{
  'Employees': {kind:"entity",
    '@title':"Mitarbeiter",
    '@readonly':true,
    elements:{
      'firstname': {type:"cds.String", '@title':"Vorname"},
      'surname':   {type:"cds.String", '@title':"Nachname"},
    }
  },
}})
```

Annotations are used to add custom information to definitions, the prefixed `@` acts as a protection against conflicts with built-in/standard properties. They're flat lists of key-value pairs, with keys being fully qualified property names and values being represented as introduced in the section [Literals and Expressions](#literals).





## Aspects

In parsed-only models, the top-level property `extensions` holds an array of unapplied extensions or annotations (&rarr; see also [Aspects in CDL](cdl#aspects)). The entries are of this form:

```js
ext = { extend|annotate: <name>, <property>: <value>, … }
```

with:

- `extend` or `annotate` referring to the definition to be extended or annotated
- `<property>` being the property that should be extended, for example, `elements` if an entity
  should be extended with further elements



### Extend with \<named aspect\>

The most basic form allows to express an extension of a named definition with another named definition (&rarr; see [Named Aspects](cdl#named-aspects)):

```js
csn = { extensions:[
  { extend:"TargetDefinition", includes:["NamedAspect"]}
]}
```




### Extend with \<anonymous aspect\>

The form `{ extend:<target>, <property>: <value>, … }` allows to add elements to an existing [struct] definition as well as to add or override annotations of the target definition:

```js
csn = { extensions:[

  // extend Foo with @foo { ..., bar: String; }
  {
    extend: "Foo",
    '@foo': true,
    elements: {
      // adds a new element 'bar'
      bar: { type: "cds.String", '@bar': true },
    }
  },

]}
```


### annotate with \<anonymous aspect\>

The form `{ annotate:<target>, <property>: <value>, … }` allows to add or override annotations of the target definition as well as those of nested elements:

```js
csn = {extensions:[

  // annotate Foo with @foo;
  { annotate:"Foo", '@foo':true },

  // annotate Foo with @foo { boo @boo }
  { annotate:"Foo", '@foo':true, elements: {
    // annotates existing element 'boo'
    boo: {'@boo':true },
  }},

]}
```



## Services

Services are definitions with _kind =`'service'`_:

```js
({definitions:{
  'MyOrders': {kind:"service"}
}})
```



### Actions / Functions

Entity definitions (for _bound_ actions/functions) can have an additional property `actions`.
The keys of these `actions` are the (local) names of actions/functions.
_Unbound_ actions/functions of a service are represented as top level definitions.

Example:

```js
({definitions:{
  'OrderService': {kind:"service"},
  'OrderService.Orders': {kind:"entity", elements:{...}, actions:{
    'validate': {kind:"function",
      returns: {type: "cds.Boolean"}
    }
  }},
  'OrderService.cancelOrder': {kind:"action",
      params:{
        'orderID': {type:"cds.Integer"},
        'reason':  {type:"cds.String"},
      },
      returns: {elements:{
        'ack': {enum:{ 'succeeded':{}, 'failed':{} }},
        'msg': {type:"cds.String"},
      }}
    }
  }}
}})
```

#### Properties

* `kind` &ndash; either `"action"` or `"function"` as in _OData_
* `params` &ndash; a dictionary with the values being
  [Type Definitions](#type-definitions)
* `returns` &ndash; a [Type Definition](#type-definitions)
  describing the response

> Note: The definition of the response can be a reference to a declared type or the inline definition of a new (structured) type.





## Imports

The `requires` property lists other models to import definitions from.
It is the CSN equivalent of the CDL [`using` directive](./cdl#using).

#### Example

```js
({
  requires: [ '@sap/cds/common', './db/schema' ],
  // [...]
})
```

As in Node.js the filenames are either absolute module names or relative
filenames, starting with `./` or `../`.

## i18n
A CSN may optionally contain a top-level `i18n` property, which can contain translated texts. The expected structure is as follows:

```js
({
  i18n: {
    'language-key': {
      'text-key': "some string"
    }
  }
})
```

This data must be written and handled by the application, there's no out-of-the-box support for this by CAP.



# Query Notation (CQN)


## Introduction

CQN is a canonical plain object representation of CDS queries. Such query objects can be obtained by parsing [CQL](./cql), by using the [query builder APIs](../node.js/cds-ql), or by simply constructing respective objects directly in your code.

For example, the following three snippets all construct the same query object:

```js
// Parsing CQL tagged template strings
let query = cds.ql `SELECT from Foo`
```

```js
// Query building
let query = SELECT.from (ref`Foo`)
```

```js
// Constructing plain CQN objects
let query = {SELECT:{from:[{ref:['Foo']}]}}
```

Such queries can be [executed with `cds.run`](../node.js/core-services#srv-run-query):

```js
let results = await cds.run (query)
```

Following is a detailed specification of the CQN as [TypeScript declarations](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html), including all query types and their properties,
as well as the fundamental expression types. Find the [full CQN type definitions in the appendix below](#full-cqn-d-ts-file).


## SELECT

Following is the TypeScript declaration of `SELECT` query objects:

```tsx
class SELECT { SELECT: {
  distinct?   : true
  count?      : true
  one?        : true
  from        : source
  columns?    : column[]
  where?      : xo[]
  having?     : xo[]
  groupBy?    : expr[]
  orderBy?    : order[]
  limit?      : { rows: val, offset: val }
}}
```
> Using:
> [`source`](#source),
> [`column`](#column),
> [`xo`](#xo),
> [`expr`](#expr),
> [`order`](#order),
> [`val`](#val)

CQL SELECT queries enhance SQL's SELECT statements with these noteworthy additions:

- The `from` clause supports [`{ref}`](#ref) paths with *[infix filters](#infix)*.
- The `columns` clause supports deeply *[nested projections](#expand)*.
- The `count` property requests the total count, similar to OData's `$count`.
- The `one` property causes a single row object to be read instead of an array.

Also `SELECT` statements with `from` as the only mandatory property are allowed,
which is equivalent to SQL's `SELECT * from ...`.



### `.from`
###### source

Property `from` specifies the source of the query, which can be a table, a view, or a subquery.
It is specified with type `source` as follows:

```tsx
class SELECT { SELECT: { //...
  from : source // [!code focus]
}}
```
```tsx
type source = ref &as | SELECT | {
  join : 'inner' | 'left' | 'right'
  args : [ source, source ]
  on?  : expr
}
```
> Using:
> [`ref`](#ref),
> [`as`](#as),
> [`expr`](#expr)
>
> Used in:
> [`SELECT`](#select)



### `.columns`

###### column
###### as
###### cast
###### infix
###### expand


Property `columns` specifies the columns to be selected, projected, or aggregated, and is specified as an array of `column`s:

```tsx
class SELECT { SELECT: { //...
  columns : column[] // [!code focus]
}}
```
```tsx
type column = '*' | expr &as &cast | ref &as &(
  { expand?: column[] } |
  { inline?: column[] }
) &infix
```
```tsx
interface as { as?: name }
interface cast { cast?: {type:name} }
interface infix {
  orderBy?  : order[]
  where?    : expr
  limit?    : { rows: val, offset: val }
}
```
> Using:
> [`expr`](#expr),
> [`name`](#name),
> [`ref`](#ref),
>
> Used in:
> [`SELECT`](#select)


### `.where`
### `.having`
### `.search`

Properties `where`, and `having`, specify the filter predicates to be applied to the rows selected, or grouped, respectively. Property `search` is of same kind and is used for full-text search.

```tsx
class SELECT { SELECT: {
  where  : xo[] // [!code focus]
  having : xo[] // [!code focus]
  search : xo[] // [!code focus]
}}
```


### `.orderBy`
###### order

```tsx
class SELECT { SELECT: { //...
  orderBy : order[] // [!code focus]
}}
```
```tsx
type order = expr & {
  sort  : 'asc' | 'desc'
  nulls : 'first' | 'last'
}
```
> Using:
> [`expr`](#expr)
>
> Used in:
> [`SELECT`](#select)
>


## INSERT
## UPSERT

CQN representations for `INSERT` and `UPSERT` are essentially identical:

```tsx
class INSERT { INSERT: UPSERT['UPSERT'] }
class UPSERT { UPSERT: {
  into      : ref
  entries?  : data[]
  columns?  : string[]
  values?   : scalar[]
  rows?     : scalar[][]
  from?     : SELECT
}}
```
```tsx
interface data  { [elm:string]: scalar | data | data[] }
```

> Using:
> [`ref`](#ref),
> [`expr`](#expr)
> [`scalar`](#scalar),
> [`SELECT`](#select)
>
> See also:
> [`UPDATE.data`](#data),

Data to be inserted can be specified in one of the following ways:

* Using [`entries`](#entries) as an array of records with name-value pairs.
* Using [`values`](#values) as in SQL's _values_ clauses.
* Using [`rows`](#rows) as an array of one or more `values`.

The latter two options require a `columns` property to specify names of columns
to be filled with the values in the same order.


### `.entries`

Allows input data to be specified as records with name-value pairs,
including _deep_ inserts.

```js
let q = {INSERT:{ into: { ref: ['Books'] }, entries: [
  { ID:201, title:'Wuthering Heights' },
  { ID:271, title:'Catweazle' }
]}}
```
```js
let q = {INSERT:{ into: { ref: ['Authors'] }, entries: [
  { ID:150, name:'Edgar Allen Poe', books: [
    { ID:251, title:'The Raven' },
    { ID:252, title:'Eleonora' }
  ]}
]}}
```
[See definition in `INSERT` summary](#insert) {.learn-more}



### `.values`

{#scalar}

Allows input data to be specified as an single array of values, as in SQL.

```js
let q = {INSERT:{ into: { ref: ['Books'] },
  columns: [ 'ID', 'title', 'author_id', 'stock' ],
  values: [ 201, 'Wuthering Heights', 101, 12 ]
}}
```
[See definition in `INSERT` summary](#insert) {.learn-more}


### `.rows`

Allows input data for multiple rows to be specified as arrays of values.

```js
let q = {INSERT:{ into: { ref: ['Books'] },
  columns: [
    'ID', 'title', 'author_id', 'stock'
  ],
  rows: [
    [ 201, 'Wuthering Heights', 101, 12 ],
    [ 252, 'Eleonora', 150, 234 ]
  ]
}}
```
[See definition in `INSERT` summary](#insert) {.learn-more}



## UPDATE

```tsx
class UPDATE { UPDATE: {
  entity  : ref
  where?  : expr
  data    : data
  with    : changes
}}
```
> Using:
> [`ref`](#ref),
> [`expr`](#expr),
> [`data`](#data),
> [`changes`](#changes)


### `.data`

Data to be updated can be specified in property `data` as records with name-value pairs, same as in [`INSERT.entries`](#entries).

```tsx
interface data  { [element:name]: scalar | data | data[] }
```
> Using:
> [`name`](#name),
> [`scalar`](#scalar)


### `.with`
###### changes

Property `with` specifies the changes to be applied to the data, very similar to property [`data`](#data) with the difference to also allow [expressions](#expressions) as values.

```tsx
interface changes { [element:name]: scalar | expr | changes | changes[] }
```

> Using:
> [`name`](#name),
> [`expr`](#expr),
> [`scalar`](#scalar)



## DELETE

```js
class DELETE { DELETE: {
  from    : ref
  where?  : expr
}}
```
> Using:
> [`ref`](#ref),
> [`expr`](#expr)


## Expressions
###### expr
###### ref
###### val
###### xpr
###### list
###### func
###### param
###### xo
###### name
###### scalar

Expressions can be entity or element references, query parameters,
literal values, lists of all the former, function calls, sub selects,
or compound expressions.

```tsx
type expr  = ref | val | xpr | list | func | param | SELECT
```
```tsx
type ref   = { ref: ( name | { id:name &infix })[] }
type val   = { val: scalar }
type xpr   = { xpr: xo[] }
type list  = { list: expr[] }
type func  = { func: string, args: expr[] }
type param = { ref: [ '?' | number | string ], param: true }
```

```tsx
type xo       = expr | keyword | operator
type operator = '=' | '==' | '!=' | '<' | '<=' | '>' | '>='
type keyword  = 'in' | 'like' | 'and' | 'or' | 'not'
type scalar   = number | string | boolean | null
type name     = string
```

>[!note]
> CQN by intent does not _understand_ expressions and therefore
> keywords and operators are just represented as plain strings in flat
> `xo` sequences. This allows us to translate to and from any other query languages,
> including support for native SQL features.


<div id="hierarchy-queries" />
<Fragment target="#hierarchy-queries" >

## Hierarchy Queries <Concept />

For the representation of a hierarchy, the `from` attribute is extended:

```js
from: … | hierarchy
hierarchy = {hierarchy:{
  source: ref,
  parent: ref,
  levels: [...ref],
  orderBy: [...ordering_term],
  start: _xpr,
  nodetype: ref,
  directory: { association: ref, where: _xpr},
  period: { from: ref, to: ref},
  valid: { from: ref, to: ref}
}}
```

| Property    | Description                                                   |                                                                                                   |
|-------------|---------------------------------------------------------------|---------------------------------------------------------------------------------------------------|
| `source`    | primary [source]                                              |                                                                                                   |
| `parent`    | association [reference][ref]                                  | _A reference to an association that defines the to-parent relation for parent-child hierarchies._ |
| `levels`    | array of field [references][ref] for leveled hierarchies      | _Field references that define a leveled hierarchy._                                               |
| `orderBy`   | array of [ordering terms](#order)                             | _Defines the ordering of siblings._                                                               |
| `start`     | [predicate expression][_xpr]                                  | _References the element that defines the condition identifying the root nodes._                   |
| `nodetype`  | field [reference][ref]                                        | _Node type of a hierarchy node in a heterogeneous hierarchy._                                     |
| `directory` | association [reference][ref] and [predicate expression][_xpr] | _References an association that points to the directory entity._                                  |
| `period`    | contains field [references][ref]                              | _Identifies the columns that define the time period for a temporal hierarchy._                    |
| `valid`     | contains field [references][ref]                              | _Identifies the columns that determine whether a record in the temporal hierarchy is valid._      |

#### Example

For example, the following query in CQL:

```sql
SELECT from hierarchy (
  source CostCenter
  child to parent association parentCostCenter
  siblings order by parentCostCenter.id
){
  ID, name, …
}
```

is represented in CQN as:

```js
CQN = {SELECT:{
  from: {
    hierarchy: {
      source: {ref: ["CostCenter"]},
      parent: {ref: ["parentCostCenter"]},
      orderBy: [{ref: ["parentCostCenter", "id"]}]
    }
  }
  columns: [
    {ref:["ID"]},
    {ref:["name"]},
    …
  ]
}}
```

</Fragment>


## Full `cqn.d.ts` File

::: code-group

```tsx [cqn.d.ts]
/**
 * `INSERT` and `UPSERT` queries are represented by the same internal
 * structures. The `UPSERT` keyword is used to indicate that the
 * statement should be updated if the targeted data exists.
 * The `into` property specifies the target entity.
 *
 * The data to be inserted or updated can be specified in different ways:
 *
 * - in the `entries` property as deeply nested records.
 * - in the `columns` and `values` properties as in SQL.
 * - in the `columns` and `rows` properties, with `rows` being array of `values`.
 * - in the `from` property with a `SELECT` query to provide the data to be inserted.
 *
 * The latter is the equivalent of SQL's `INSERT INTO ... SELECT ...` statements.
 */
export class INSERT { INSERT: UPSERT['UPSERT'] }
export class UPSERT { UPSERT: {
  into      : ref
  entries?  : data[]
  columns?  : string[]
  values?   : scalar[]
  rows?     : scalar[][]
  from?     : SELECT
}}


/**
 * `UPDATE` queries are used to capture modifications to existing data.
 * They support a `where` clause to specify the rows to be updated,
 * and a `with` clause to specify the new values. Alternatively, the
 * `data` property can be used to specify updates with plain data only.
 */
export class UPDATE { UPDATE: {
  entity  : ref
  where?  : expr
  data    : data
  with    : changes
}}


/**
 * `DELETE` queries are used to remove data from a target datasource.
 * They support a `where` clause to specify the rows to be deleted.
 */
export class DELETE { DELETE: {
  from    : ref
  where?  : expr
}}


/**
 * `SELECT` queries are used to retrieve data from a target datasource,
 * and very much resemble SQL's `SELECT` statements, with these noteworthy
 * additions:
 *
 * - The `from` clause supports `{ref}` paths with infix filters.
 * - The `columns` clause supports deeply nested projections.
 * - The `count` property requests the total count, similar to OData's `$count`.
 * - The `one` property indicates that only a single record object shall be
 *   returned instead of an array.
 *
 * Also, CDS, and hence CQN, supports minimalistic `SELECT` statements with a `from`
 * as the only mandatory property, which is equivalent to SQL's `SELECT * from ...`.
 */
export class SELECT { SELECT: {
  distinct?   : true
  count?      : true
  one?        : true
  from        : source
  columns?    : column[]
  where?      : xo[]
  having?     : xo[]
  groupBy?    : expr[]
  orderBy?    : order[]
  limit?      : { rows: val, offset: val }
}}

type source = OneOf< ref &as | SELECT | {
  join : 'inner' | 'left' | 'right'
  args : [ source, source ]
  on?  : expr
}>

type column = OneOf< '*' | expr &as &cast | ref &as & OneOf<(
  { expand?: column[] } |
  { inline?: column[] }
)> &infix >

type order = expr & {
  sort  : 'asc' | 'desc'
  nulls : 'first' | 'last'
}


interface changes { [elm:string]: OneOf< scalar | expr | changes | changes[] >}
interface data { [elm:string]: OneOf< scalar | data | data[] >}
interface as { as?: name }
interface cast { cast?: {type:name} }

interface infix {
  orderBy?  : order[]
  where?    : expr
  limit?    : { rows: val, offset: val }
}


/**
 * Expressions can be entity or element references, query parameters,
 * literal values, lists of all the former, function calls, sub selects,
 * or compound expressions.
 */
export type expr  = OneOf< ref | val | xpr | list | func | param | SELECT >
export type ref   = { ref: OneOf< name | { id:name &infix } >[] }
export type val   = { val: scalar }
export type xpr   = { xpr: xo[] }
export type list  = { list: expr[] }
export type func  = { func: string, args: expr[] }
export type param = { ref: [ '?' | number | string ], param: true }

/**
 * This is used in `{xpr}` objects as well as in `SELECT.where` clauses to
 * represent compound expressions as flat `xo` sequences.
 * Note that CQN by intent does not _understand_ expressions and therefore
 * keywords and operators are just represented as plain strings.
 * This allows us to translate to and from any other query languages,
 * including support for native SQL features.
 */
type xo       = OneOf< expr | keyword | operator >
type operator = '=' | '==' | '!=' | '<' | '<=' | '>' | '>='
type keyword  = 'in' | 'like' | 'and' | 'or' | 'not'
type scalar   = number | string | boolean | null
type name     = string



// ---------------------------------------------------------------------------
//  maybe coming later...

declare class CREATE { CREATE: {} }
declare class DROP { DROP: {} }


// ---------------------------------------------------------------------------
//  internal helpers...

type OneOf<U> = Partial<(U extends any ? (k:U) => void : never) extends (k: infer I) => void ? I : never>
```
:::

<div id="secondary-file">cds/cqn.fragment.md</div>


# Common Types and Aspects

_@sap/cds/common_ {.subtitle}

<br>

CDS ships with a prebuilt model *`@sap/cds/common`* that provides common types and aspects for reuse.

[ISO 3166]: https://en.wikipedia.org/wiki/ISO_3166
[ISO 3166-1]: https://en.wikipedia.org/wiki/ISO_3166-1
[ISO 3166-2]: https://en.wikipedia.org/wiki/ISO_3166-2
[ISO 3166-3]: https://en.wikipedia.org/wiki/ISO_3166-3
[ISO 4217]: https://en.wikipedia.org/wiki/ISO_4217
[ISO/IEC 15897]: https://en.wikipedia.org/wiki/ISO/IEC_15897
[tzdata]: https://en.wikipedia.org/wiki/Tz_database
[localized data]: ../guides/localized-data
[temporal data]: ../guides/temporal-data

## Why Use _@sap/cds/common_?

It's recommended that all applications use the common types and aspects provided through _@sap/cds/common_ to benefit from these features:

* **Concise** and **comprehensible** models &rarr; see also [Conceptual Modeling](../guides/domain-modeling)
* **Foster interoperability** between all applications
* **Proven best practices** captured from real applications
* **Streamlined** data models with **minimal entry barriers**
* **Optimized** implementations and runtime performance
* **Automatic** support for [localized](../guides/localized-data) code lists and [value helps](../advanced/fiori#pre-defined-types-in-sap-cds-common)
* **Extensibility** using [Aspects](../guides/domain-modeling#aspect-oriented-modeling)
* **Verticalization** through third-party extension packages

For example, usage is as simple as indicated in the following sample:

```cds
using { Country } from '@sap/cds/common';
entity Addresses {
  street  : String;
  town    : String;
  country : Country; //> using reuse type
}
```

### Outcome = Optimized Best Practice

The final outcomes in terms of modeling patterns, persistence structures, and implementations is essentially the same as with native means, if you would have collected design experiences from prior solutions, such as we did.
::: tip
All the common reuse features of _@sap/cds/common_ are provided only through this ~100 line .cds model. Additional runtime support isn't required. _@sap/cds/common_ merely uses basic CDS modeling features as well as generic features like [localized data] and [temporal data] (which only need minimal runtime support with minimal overhead).
:::

In effect, the results are **straightforward**, capturing **best practices** we learned from real business applications, with **minimal footprint**, **optimized performance**, and **maximized adaptability** and **extensibility**.


## Common Reuse Aspects

_@sap/cds/common_ defines the following [aspects](cdl#aspects) for use in your entity definitions. They give you shortcuts, for concise and comprehensible models, interoperability and out-of-the-box runtime features connected to them.


### Aspect `cuid`

Use `cuid` as a convenient shortcut, to add canonical, universally unique primary keys to your entity definitions. These examples are equivalent:

```cds
entity Foo : cuid {...}
```


```cds
entity Foo {
  key ID : UUID;
  [...]
}
```

> The service provider runtimes automatically fill in UUID-typed keys like these with auto-generated UUIDs.

[Learn more about **canonical keys** and **UUIDs**.](../guides/domain-modeling#prefer-canonic-keys){ .learn-more}


### Aspect `managed`

Use `managed`, to add four elements to capture _created by/at_ and latest _modified by/at_ management information for records. The following examples are equivalent-

```cds
entity Foo : managed {...}
```


```cds
entity Foo {
  createdAt  : Timestamp @cds.on.insert : $now;
  createdBy  : User      @cds.on.insert : $user;
  modifiedAt : Timestamp @cds.on.insert : $now  @cds.on.update : $now;
  modifiedBy : User      @cds.on.insert : $user @cds.on.update : $user;
  [...]
}
```
::: tip
`modifiedAt` and `modifiedBy` are set whenever the respective row was modified, that means, also during `CREATE` operations.
:::

The annotations `@cds.on.insert/update` are handled in generic service providers so to fill in those fields automatically.

[Learn more about **generic service features**.](../guides/domain-modeling#managed-data){ .learn-more}


### Aspect `temporal`

This aspect basically adds two canonical elements, `validFrom` and `validTo` to an entity. It also adds a tag annotation that connects the CDS compiler's and runtime's built-in support for _[Temporal Data](../guides/temporal-data)_. This built-in support covers handling date-effective records and time slices, including time travel. All you've to do is, add the temporal aspect to respective entities as follows:

```cds
entity Contract : temporal {...}
```

[Learn more about **temporal data**.][temporal data]{ .learn-more}


## Common Reuse Types {#code-types}

_@sap/cds/common_ provides predefined easy-to-use types for _Countries_, _Currencies_, and _Languages_. Use these types in all applications to foster interoperability.

### Type `Country`
[`Country`]: #country

The reuse type `Country` is defined in _@sap/cds/common_ as a simple managed [Association](cdl#associations) to the [code list](#code-lists) for [countries](#entity-countries) as follows:

```cds
type Country : Association to sap.common.Countries;
```

Here's an example of how you would use that reuse type:


```cds
using { Country } from '@sap/cds/common';
entity Addresses {
  street  : String;
  town    : String;
  country : Country; //> using reuse type
}
```

The [code lists](#code-lists) define a key element `code`, which results in a foreign key column `country_code` in your SQL table for Addresses. For example:


```sql
CREATE TABLE Addresses (
  street NVARCHAR(5000),
  town NVARCHAR(5000),
  country_code NVARCHAR(3) -- foreign key
);
```

[Learn more about **managed associations**.](cdl#associations){ .learn-more}


### Type `Currency`

The type for an association to [Currencies](#entity-currencies).

```cds
type Currency : Association to sap.common.Currencies;
```

[It's the same as for `Country`.](#type-country){ .learn-more}

### Type `Language`

The type for an association to [Languages](#entity-languages).

```cds
type Language : Association to sap.common.Languages;
```

[It's the same as for `Country`.](#type-country){ .learn-more}

### Type `Timezone`

The type for an association to [Timezones](#entity-timezones).

```cds
type Timezone : Association to sap.common.Timezones;
```

[It's the same as for `Country`.](#type-country){ .learn-more}

## Common Code Lists { #code-lists}

As seen in the previous section, the reuse types `Country`, `Currency`, and `Language` are defined as associations to respective code list entities. They act as code list tables for respective elements in your domain model.

> Note: You rarely have to refer to the code lists in consuming models, but always only do so transitively by using the corresponding reuse types [as shown previously](#code-types).

#### Namespace: `sap.common`

The following definitions are within namespace `sap.common`...

### Aspect `CodeList`

This is the base definition for the three code list entities in _@sap/cds/common_. It can also be used for your own code lists.

```cds
aspect sap.common.CodeList {
  name  : localized String(111);
  descr : localized String(1111);
}
```
[Learn more about **localized** keyword.](../guides/localized-data){ .learn-more}


### Entity `Countries`

The code list entity for countries is meant to be used with **[ISO 3166-1] two-letter alpha codes** as primary keys. For example, `'GB'` for the United Kingdom. Nevertheless, it's defined as `String(3)` to allow you to fill in three-letter codes, if needed.

```cds
entity sap.common.Countries : CodeList {
  key code : String(3); //> ISO 3166-1 alpha-2 codes (or alpha-3)
}
```


### Entity `Currencies`

The code list entity for currencies is meant to be used with **[ISO 4217] three-letter alpha codes** as primary keys, for example, `'USD'` for US Dollar. In addition, it provides an element to hold the minor unit fractions and for common currency symbols.

```cds
entity sap.common.Currencies : CodeList {
  key code  : String(3); //> ISO 4217 alpha-3 codes
  symbol    : String(5); //> for example, $, €, £, ₪, ...
  minorUnit : Int16;     //> for example, 0 or 2
}
```


### Entity `Languages`

The code list entity for countries is meant to be used with POSIX locales as defined in **[ISO/IEC 15897]** as primary keys. For example, `'en_GB'` for British English.

```cds
entity sap.common.Languages : CodeList {
  key code : sap.common.Locale; //> for example, en_GB
}
```
[Learn more on **normalized locales**.](../guides/i18n#normalized-locales){ .learn-more}

### Entity `Timezones`

The code list entity for time zones is meant to be used with primary keys like _Area/Location_, as defined in the [IANA time zone database][tzdata].
Examples are `America/Argentina/Buenos_Aires`, `Europe/Berlin`, or `Etc/UTC`.

```cds
entity sap.common.Timezones : CodeList {
  key code : String(100); //> for example, Europe/Berlin
}
```

[Learn more about time zones in JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) {.learn-more}

[Learn more about time zones in Java](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/ZoneId.html) {.learn-more}


### SQL Persistence

The following table definition represents the resulting SQL persistence of the `Countries` code list, with the ones for `Currencies` and `Languages` alike:

```sql
-- the basic code list table
CREATE TABLE sap_common_Countries (
  name NVARCHAR(255),
  descr NVARCHAR(1000),
  code NVARCHAR(3),
  PRIMARY KEY(code)
);
```


### Minimalistic Design

The models for code lists are intentionally minimalistic to keep the entry barriers as low as possible, focusing on the bare minimum of what all applications generally need: a unique code and localizable fields for name and full name or descriptions.

**ISO alpha codes** for languages, countries, and currencies were chosen because they:

1. Are most common (most projects would choose that)
2. Are most efficient (as these codes are also frequently displayed on UIs)
3. Guarantee minimal entry barriers (bringing about 1 above)
4. Guarantee best support (for example, by readable foreign keys)

Assumption is that ~80% of all apps don't need more than what is already covered in this minimalistic model. Yet, in case you need more, you can easily leverage CDS standard features to adapt and extend these base models to your needs as demonstrated in the section [Adapting to your needs](#adapting-to-your-needs).

## Aspects for Localized Data

Following are types and aspects mostly used behind the scenes for [localized data](../guides/localized-data). <br>
For example given this entity definition:

```cds
entity Foo {
  key ID : UUID;
  name   : localized String;
  descr  : localized String;
}
```

When unfolding the `localized` fields, we essentially add `.texts` entities in these steps:

1. Add a new entity `Foo.texts` which inherits from `TextsAspects`:
   ```cds
   entity Foo.texts : sap.common.TextsAspects { ... }
   ```
   Which in turn unfolds to:
   ```cds
   entity Foo.texts {
     key locale : sap.common.Locale;
   }
   ```

2. Add the primary key of the main entity `Foo`:
   ```cds
   entity Foo.texts {
     key locale : sap.common.Locale;
     key ID : UUID; // [!code focus]
   }
   ```

3. Add the localized fields:
   ```cds
   entity Foo.texts {
     key locale : sap.common.Locale;
     key ID : UUID;
     name   : String; // [!code focus]
     descr  : String; // [!code focus]
   }
   ```



#### Namespace: `sap.common`

The following definitions are with namespace `sap.common`...

### Aspect `TextsAspect` {#texts-aspects}

This aspect is used when generating `.texts` entities for the unfolding of localized elements. It can be extended, which effectively extends all generated `.texts` entities.

```cds
aspect sap.common.TextsAspect {
  key locale: sap.common.Locale;
}
```

[Learn more about **Extending .texts entities**.](../guides/localized-data#extending-texts-entities){ .learn-more}

### Type `Locale` {#locale-type}

```cds
type sap.common.Locale : String(14) @title: '{i18n>LanguageCode}';
```

The reuse type `sap.common.Locale` is used when generating `.texts` entities for the unfolding of *localized* elements.

[Learn more about **localized data**.](../guides/localized-data){ .learn-more}

### SQL Persistence

In addition, the base entity these additional tables and views are generated behind the scenes to efficiently deal with translations:

```sql
-- _texts table for translations
CREATE TABLE Foo_texts (
  ID NVARCHAR(36),
  locale NVARCHAR(14),
  name NVARCHAR(255),
  descr NVARCHAR(1000),
  PRIMARY KEY(ID, locale)
);
```

```sql
-- view to easily read localized texts with automatic fallback
CREATE VIEW localized_Foo AS SELECT
  code,
  COALESCE (localized.name, name) AS name,
  COALESCE (localized.descr, descr) AS descr
FROM Foo (
  LEFT JOIN Foo_texts AS localized
    ON localized.code= code
    AND localized.locale = SESSION_CONTEXT('locale')
)
```

[Learn more about **localized data**.](../guides/localized-data){ .learn-more}

## Providing Initial Data

You can provide initial data for the code lists by placing CSV files in a folder called `data` next to your data models.

The following is an example of a `csv` file to provide data for countries:


::: code-group
```csv [db/data/sap.common-Countries.csv]
code;name;descr
AU;Australia;Commonwealth of Australia
CA;Canada;Canada
CN;China;People's Republic of China (PRC)
FR;France;French Republic
DE;Germany;Federal Republic of Germany
IN;India;Republic of India
IL;Israel;State of Israel
MM;Myanmar;Republic of the Union of Myanmar
GB;United Kingdom;United Kingdom of Great Britain and Northern Ireland
US;United States;United States of America (USA)
EU;European Union;European Union
```
:::

[Learn more about the database aspects of **Providing Initial Data**.](../guides/databases#providing-initial-data){ .learn-more}


### Add Translated Texts

In addition, you can provide translations for the `sap.common.Countries_texts` table as follows:


::: code-group
```csv [db/data/sap.common-Countries_texts.csv]
code;locale;name;descr
AU;de;Australien;Commonwealth Australien
CA;de;Kanada;Canada
CN;de;China;Volksrepublik China
FR;de;Frankreich;Republik Frankreich
DE;de;Deutschland;Bundesrepublik Deutschland
IN;de;Indien;Republik Indien
IL;de;Israel;Staat Israel
MM;de;Myanmar;Republik der Union Myanmar
GB;de;Vereinigtes Königreich;Vereinigtes Königreich Großbritannien und Nordirland
US;de;Vereinigte Staaten;Vereinigte Staaten von Amerika
EU;de;Europäische Union;Europäische Union
```
:::

[Learn more about **Localization/i18n**.](../guides/localized-data){ .learn-more}


### Using Tools like Excel

You can use Excel or similar tools to maintain these files. For example, the following screenshot shows how we maintained the above two files in Numbers on a Mac:

![This screenshot is explained in the accompanying text.](./assets/csv-numbers.png)

### Using Prebuilt Content Package {#prebuilt-data}

Package [@sap/cds-common-content](https://www.npmjs.com/package/@sap/cds-common-content) provides prebuilt data for the entities `Countries`, `Currencies`, `Languages`, and `Timezones`.

Add it your project:

```sh
npm add @sap/cds-common-content --save
```

Use it in your `cds` files:

```cds
using from '@sap/cds-common-content';
```

[Learn more about integrating reuse packages](../guides/extensibility/composition){.learn-more}


## Adapting to Your Needs

As stated, the predefined definitions are minimalistic by intent. Yet, as _@sap/cds/common_ is also just a CDS model, you can apply all the standard features provided by [CDS](./cdl), especially CDS' [Aspects](./cdl#aspects) to adapt, and extend these definitions to your needs.

Let's look at a few examples of what could be done. You can combine these extensions in an effective model.
::: tip
You can do such extensions in the models of your project. You can also collect your extensions into reuse packages and share them as common definitions with several consuming projects, similar to _@sap/cds/common_ itself.
:::

[Learn more about providing reuse packages.](../guides/extensibility/composition){ .learn-more}


### Adding Detailed Fields as of [ISO 3166-1]


```cds
using { sap.common.Countries } from '@sap/cds/common';
extend Countries {
  numcode : Integer; //> ISO 3166-1 three-digit numeric codes
  alpha3 : String(3); //> ISO 3166-1 three-letter alpha codes
  alpha4 : String(4); //> ISO 3166-3 four-letter alpha codes
  independent : Boolean;
  status : String(111);
  statusRemark : String(1111);
  remarkPart3 : String(1111);
}
```

> Value lists in SAP Fiori automatically search in the new text fields as well.


### Protecting Certain Entries

Some application logic might have to be hard-coded against certain entries in code lists. Therefore, these entries have to be protected against changes and removal. For example, let's assume a code list for payment methods defined as follows:

```cds
entity PaymentMethods : sap.common.CodeList {
  code : String(11);
}
```

Let's further assume the entires with code `Main` and `Travel` are required by implementations and hence must not be changed or removed. Have a look at a couple of solutions.

<div id="beforeprogrammatic" />

#### Programmatic Solution

A fallback, and at the same time, the most open, and most flexible approach, is to use a custom handler to assert that. For example, in Node.js:

```js
srv.on ('DELETE', 'PaymentMethods', req=>{
  const entry = req.query.DELETE.where[2].val
  if (['Main','Travel'].includes(entry))
    return req.reject(403, 'these entries must not be deleted')
})
```


### Using Different Foreign Keys

Let's assume you prefer to have references to the latest code list entries without adjusting foreign keys. This can be achieved by adding and using numeric ISO codes for foreign keys instead of the alpha codes.


::: code-group
```cds [your-common.2.cds]
namespace your.common;
using { sap.common.Countries } from '@sap/cds/common';

// Extend Countries code list with fields for numeric codes
extend Countries {
  numcode : Integer; //> ISO 3166-1 three-digit numeric codes
}

// Define an own Country type using numcodes for foreign keys
type Country : Association to Countries { numcode };
```
:::

You can use your own definition of `Country` instead of the one from _@sap/cds/common_ in your models as follows:


```cds
using { your.common.Country } from './your-common.2';

entity Addresses {
  //...
  country : Country;
}
```

### Mapping to SAP S/4HANA or ABAP Table Signatures


```cds
using { sap.common.Countries } from '@sap/cds/common';
entity Countries4GFN as projection on Countries {
  code as CountryCodeAlpha2,
  name as CountryShortName,
  // ...
}
entity Countries4ABAP as projection on Countries {
  code as LAND,
  // ...
}
```

These views are updatable on SAP HANA and many other databases. You can also use CDS to expose them through corresponding OData services in order to ease integration with SAP S/4HANA or older ABAP backends.


## Adding Own Code Lists

As another example of adaptations, let's add support for subdivisions, that means regions, as of [ISO 3166-2] to countries.


### Defining a New Code List Entity


::: code-group
```cds [your-common.4.1.cds]
using sap from '@sap/cds/common';

// new code list for regions
entity Regions : sap.common.CodeList {
  key code : String(5); // ISO 3166-2 alpha5 codes, like DE-BW
  country  : Association to sap.common.Countries;
}

// bi-directionally associate Regions with Countries
extend sap.common.Countries {
  regions : Composition of many Regions on regions.country = $self;
}
```
:::

`Regions` is a new, custom-defined code list entity defined in the same way as the predefined ones in _@sap/cds/common_. In particular, it inherits all elements and annotations from the base definition [`sap.common.CodeList`](#code-lists). For example, the `@cds.autoexpose` annotation, which provides that `Regions` is auto-exposed in any OData service that has exposed entities with associations to it. The localization of the predefined elements `name` and `descr` is also inherited.

[Learn in our sample how an own code list can be used to localize `enum` values.](https://github.com/SAP-samples/cap-sflight/blob/236de55b58fd0620dcd1d4f043779a7c632391b1/db/schema.cds#L60){.learn-more}


### Defining a New Reuse Type

Following the pattern for codes in _@sap/cds/common_ a bit more, you can also define a reuse type for regions as a managed association:


::: code-group
```cds [your-common.4.2.cds]
using { Regions } from './your-common.4.1'; /*>skip<*/
// Define an own reuse type referring to Regions
type Region : Association to Regions;
```
:::

### Using the New Reuse Type and Code List

This finally allows you to add respective elements, the same way you do it with predefined reuse types. These elements receive the same support from built-in generic features. For example:


```cds
using { Country, Region } from './your-common.4.2';
entity Addresses {
  street  : String;
  town    : String;
  country : Country; //> pre-defined reuse type
  region  : Region; //> your custom reuse type
}
```

## Code Lists with Validity

Even ISO codes may change over time and you may have to react to that in your applications. For example, when Burma was renamed to Myanmar in 1989. Let's investigate strategies on how that can be updated in our code lists.


### Accommodating Changes

The renaming from Burma to Myanmar in 1989, was reflected in [ISO 3166] as follows (_the alpha-4 codes as specified in [ISO 3166-3] signify entries officially deleted from [ISO 3166-1] code lists_):

| Name    | Alpha-2 | Alpha-3 | Alpha-4 | Numeric |
|---------|---------|---------|---------|---------|
| Burma   | BU      | BUR     | BUMM    | 104     |
| Myanmar | MM      | MMR     |         | 104     |

By default, and with the given default definitions in _@sap/cds/common_, this would have been reflected as a new entry for Myanmar and you'd have the following choices on what to do with the existing records in your data:

* **(a)** Adjust foreign keys for records so that it always reflects the current state.
* **(b)** Keep foreign keys as is for cases where the old records reflect the state effective at the time they were created or valid.


### Exclude Outdated Entries from Pick Lists (Optional)

Although outdated entries like the one for Burma have to remain in the code lists as targets for references from historic records in other entities, you would certainly want to exclude it from all pick lists used in UIs when entering new data. This is how you could achieve that:


#### 1. Extend the Common Code List Entity

```cds
using { sap.common.Countries } from '@sap/cds/common';
extend Countries with { validTo: Date default '9999-12-31'; }
```


#### 2. Fill Validity Boundaries in Code Lists:

| code | name    | validTo    |
|------|---------|------------|
| BU   | Burma   | 1989-06-18 |
| MM   | Myanmar | 9999-12-31 |


#### 3. Model Pick List Entity

Add the following line to your service definition:

```cds
entity CountriesPickList as projection on sap.common.Countries where validTo >= $now;
```

Basically, the entity `Countries` serves all standard requests, and the new entity `CountriesPickList` is built for the value help only. This entity is a projection that gives you only those records that are valid right now.

#### 4. Include Pick List with Validity on the UI

This snippet equips UI fields for a `countries` association with a value help from the `CountriesPickList` entity.

```cds
annotate YourService.EntityName with {

  countries @(
    Common: {
      Text: country.name , // TextArrangement: #TextOnly,
      ValueList: {
        Label: 'Country Value Help',
        CollectionPath: 'CountriesPickList',
        Parameters: [
          { $Type: 'Common.ValueListParameterInOut',
            LocalDataProperty: country_code,
            ValueListProperty: 'code'
          },
          { $Type: 'Common.ValueListParameterDisplayOnly',
            ValueListProperty: 'name'
          }
      ]
      }
    },
  );
}
```



# Compiler Messages

This page lists selected error messages and explanations on how to fix them.
It is not a complete list of all compiler messages.

::: warning Note on message IDs
Message IDs are not finalized, yet. They can change at short notice.
:::


## anno-duplicate-unrelated-layer

An annotation is assigned multiple times through unrelated layers.

A _layer_ can be seen as a group of connected sources, for example CDL files.
They form a cyclic connection through their dependencies
(for example, `using` in CDL).  If there are no cyclic dependencies, a single
CDL file is equivalent to a layer.

#### Example

Erroneous code example using four CDS files:

```cds
// (1) Base.cds: Contains the artifact that should be annotated
entity FooBar {  }

// (2) FooAnnotate.cds: First unrelated layer to Base.cds
using from './Base';
annotate FooBar with @Anno: 'Foo';

// (3) BarAnnotate.cds: Second unrelated layer to Base.cds
using from './Base';
annotate FooBar with @Anno: 'Bar';

// (4) All.cds: Combine all files ❌
using from './FooAnnotate';
using from './BarAnnotate';
```

In (4) the compiler will warn that there are duplicate annotations in unrelated
layers.  That is because (2) and (3) are unrelated, i.e. they do not have a
connection.

Due to these unrelated layers, the compiler can't decide in (4) which
annotation should be applied first.

Instead of passing (4) to the compiler, you can also pass (2) and (3) to it.
Because there are no cyclic dependencies between the files, each file
represents one layer.

#### How to Fix

Remove one of the duplicate annotations.  Chances are, that only one was
intended to begin with.  For the erroneous example above, remove the annotation
from (3).

Alternatively, add an annotation assignment to (4).  This annotation has
precedence and the error will vanish.  For the example above, (4) will look
like this:

```cds
// (4) All.cds: Combine all files
using from './FooAnnotate';
using from './BarAnnotate';
// This annotation has precedence.
annotate FooBar with @Anno: 'Bar';
```

You can also make (3) depend on (2) so that they are no longer in unrelated
layers and the compiler can determine which annotation to apply.

```cds
// (3) BarAnnotate.cds: Now depends on (2)
using from './FooAnnotate';
annotate FooBar with @Anno: 'Bar';
```

This works because there is now a defined dependency order.
## anno-missing-rewrite

A propagated annotation containing expressions can't be rewritten and would
end up with invalid paths.

While propagating annotations containing expressions such as `@anno: (path)`,
the compiler ensures that the path remains valid.  If necessary, the paths
have to be rewritten, e.g. when being propagated to projections that rename
their source's elements.  If rewriting is not possible, this error is emitted.

#### Example

Erroneous code example:

```cds
type T : {
    @anno: (sibling)
    elem: String;
    sibling: String;
};
type TString : T:elem; // ❌ there is no `sibling`
```

The annotating `@anno` would be propagated to `TString`.  However, because its
path refers to an element that is not reachable at `TString`, the path can't
be rewritten and compilation fails.

#### How to Fix

Explicitly override the annotation.  Either remove it by setting its value to
`null` or by using another value.

```cds
// (1) direct annotation
@anno: null
type TString : T:elem;

// (2) annotate statement
type TString : T:elem;
annotate TString with @(anno: null);
```

Variant (1) may not always be applicable, e.g. if annotations in a structured
type would need to be overridden.  In those cases, use variant (2) and assign
annotations via the `annotate` statement.
## check-proper-type-of

An element in a `type of` expression doesn't have proper type information.

The message's severity is `Info` but may be raised to `Error` in the SQL,
SAP HANA, and OData backends.  These backends require elements to have a type.
Otherwise, they aren't able to render elements (for example, to SQL columns).

#### Example

Erroneous code example:

```cds
entity Foo {
  key id : Integer;
};
view ViewFoo as select from Foo {
  1+1 as calculatedField @(anno)
};
entity Bar {
  // ❌ `e` has no proper type but has the annotation `@anno`.
  e : ViewFoo:calculatedField;
};
```

`ViewFoo:calculatedField` is a calculated field without an explicit type.

`type of` is used in `E:e`'s type specification.  You would expect the element
to have a proper type.  However, because the referenced element is calculated,
the compiler isn't able to determine the correct type.
The element still inherits `ViewFoo:calculatedField`'s annotations and other
properties but won't have a proper type, which is required by some backends.

#### How to Fix

Assign an explicit type to `ViewFoo:calculatedField`.

```cds
view ViewFoo as select from Foo {
  1+1 as calculatedField @(anno) : Integer
};
```

#### Related Messages

- [`def-missing-type`](#def-missing-type)
## def-duplicate-autoexposed

Two or more entities with the same name can't be auto-exposed in the same
service.

Auto-exposure is a compiler feature which makes it easier for developers
to write services.  Auto-exposure uses the name of the entity to expose
it in the service.  It ignores the entity's namespace and context.
This may lead to name collisions.

The message's severity is `Error` and is raised by the compiler.  You need to
adapt your model to fix the error.

#### Example

Erroneous code example:

```cds
// (1)
entity ns.first.Foo {
  key parent : Association to one ns.Base;
};
// (2)
entity ns.second.Foo {
  key parent : Association to one ns.Base;
};
// (3)
entity ns.Base {
  key id    : UUID;
  to_first  : Composition of many  ns.first.Foo;
  to_second : Composition of many ns.second.Foo;
}
service ns.MyService {
  // (4) ❌
  entity BaseView as projection on ns.Base;
};
```

Both (1) and (2) define an entity `Foo`, but in different namespaces.  For
example, they could be located in different files with a `namespace` statement.
(3) contains compositions of both `first.Foo` and `second.Foo`.

In (4), a projection on `Base` is exposed in service `MyService`.
Both composition targets are auto-exposed.  However, because the namespaces
of (2) and (3) are ignored, a name collision happens.

#### How to Fix

You need to explicitly expose one or more entities under a name that does not
exist in the service, yet.

For the erroneous example above, you could add these two lines to the service
`ns.MyService`:

```cds
  entity first.Foo as projection on ns.first.Foo;   // (5)
  entity second.Foo as projection on ns.second.Foo; // (6)
```

Here we reuse the namespaces `first` and `second`.   We don't use `ns` because
it's the common namespace.  But you can choose any other name.

The compiler will pick up both manually exposed entities and will correctly
redirect all associations.

_Note:_ For the example, it is sufficient to expose only one entity.  If you
remove (6), you will get these two projections:
- `ns.MyService.first.Foo` for (5)
- `ns.MyService.Foo` for (6)
Where (6) is the name chosen by the compiler.

#### Notes on auto-exposure

You may wonder why the compiler does not reuse the namespace when
auto-exposing entities.  The reason is that the resulting auto-exposed names
could become _long_ names that don't seem natural nor intuitive.  We chose to
expose the entity name because that's what most developers want to do when
they manually expose entities.

#### Other Notes

This message was called `duplicate-autoexposed` in cds-compiler v3 and earlier.
## def-missing-type

A type artifact doesn't have proper type information.

The message's severity is `Info` but may be raised to `Error` in the SQL,
SAP HANA, and OData backends.  These backends require types to have type
information.  Otherwise, they aren't able to render elements that use this
type (for example, to SQL columns).

#### Example

Erroneous code example:

```json
{
  "definitions": {
    "MainType": {
      "kind": "type"
    }
  }
}
```

`MainType` is of kind "type" but has not further type-information.

#### How to Fix

Add explicit type information to `MainType`, for example, add an `elements`
property to make a structured type.

```json
{
  "definitions": {
    "MainType": {
      "kind": "type",
      "elements": {
        "id": {
          "type": "cds.String"
        }
      }
    }
  }
}
```

#### Related Messages

- [`check-proper-type-of`](#check-proper-type-of)
## def-upcoming-virtual-change

The behavior of `@sap/cds-compiler` v6 will change for a selected element.

#### Example

Erroneous code example:

```cds
entity Source {
  key ID : String;
  a : String;
};

entity Proj as projection on Source {
  ID,
  virtual a, // ❌ behavior will change in v6
};
```

In `@sap/cds-compiler` v5 and earlier, element `Proj:a` is a reference
to element `Source:a`, which was marked virtual.

In `@sap/cds-compiler` v6 and later, it will instead be a _new_ element,
without any reference to `Source:a`.

This may or may not affect your runtime coding, hence the warning.


#### How to Fix

If the v6 behavior works for you, there is nothing you need to do.

However, if you want to keep a reference to `Source:a` in CSN, for example
because you use the reference at runtime, then you can keep the old behavior
by either:

1. prepending a table alias to the reference
2. adding a column alias

```cds
// (1) prepend a table alias
entity V as projection on E {
  ID,
  virtual E.a, // ok
};
```

```cds
// (2) add an alias
entity V as projection on E {
  ID,
  virtual a as a, // ok
};
```
## extend-repeated-intralayer

The order of elements of an artifact may not be stable due to multiple
extensions in the same layer (for example in the same file).

A _layer_ can be seen as a group of connected sources, for example, CDL files.
They form a cyclic connection through their dependencies
(for example, `using` in CDL).

#### Example

Erroneous code example with multiple CDL files:

```cds
// (1) Definition.cds
using from './Extension.cds';
entity FooBar { };
extend FooBar { foo: Integer; }; // ❌

// (2) Extension.cds
using from './Definition.cds';
extend FooBar { bar: Integer; }; // ❌
```

Here we have a cyclic dependency between (1) and (2).  Together they form one
layer with multiple extensions.  Again, the element order isn't stable.

#### How to Fix

Move extensions for the same artifact into the same extension block:

```cds
// (1) Definition.cds : No extension block
using from './Extension.cds';
entity FooBar { }

// (2) Extension.cds : Now contains both extensions
using from './Definition.cds';
extend FooBar {
  foo : Integer;
  bar : Integer;
}
```

#### Related Messages

- [`extend-unrelated-layer`](#extend-unrelated-layer)
## extend-unrelated-layer

Unstable element order due to extensions for the same artifact in
unrelated layers.

A _layer_ can be seen as a group of connected sources, for example CDL files.
They form a cyclic connection through their dependencies
(for example, `using` in CDL).

#### Example

Erroneous code example using four CDS files:

```cds
// (1) Base.cds: Contains the artifact that should be extended
entity FooBar {  }

// (2) FooExtend.cds: First unrelated layer to Base.cds
using from './Base';
extend FooBar { foo : Integer; }

// (3) BarExtend.cds: Second unrelated layer to Base.cds
using from './Base';
extend FooBar { bar : Integer; }

// (4) ❌ All.cds: Combine all files
using from './FooExtend';
using from './BarExtend';
```

In (4) the compiler will warn that the element order of `FooBar` is unstable.
That is because the extensions in (2) and (3) are in different layers and when
used in (4) it can't be ensured which extension is applied first.

Instead of passing (4) to the compiler, you can also pass (2) and (3) to it.
Because there are no cyclic dependencies between the files, each file
represents one layer.

#### How to Fix

Move extensions for the same artifact into the same layer, that is, the same
file.

For the erroneous example above, remove the extension from (3) and move
it to (2):

```cds
// (2) FooExtend.cds
using from './Base';
extend FooBar {
  foo : Integer;
  bar : Integer;
}
```

#### Related Messages

- [`extend-repeated-intralayer`](#extend-repeated-intralayer)
## file-unexpected-case-mismatch

The filename of a `using` statement does not match
the file's actual name on disk.

To avoid operating-system dependent issues, the compiler checks if the name of
an imported file matches the name of the file in the filesystem / on disk.
For example, by default macOS uses a case-insensitive file system.
Hence, a file named `model.cds` will also be loaded by `using from './Model.cds'`
on such systems.

However, on other filesystems that are case-sensitive, e.g. when building your
application in another environment, the file will not be found.

Hence, the `using` statement needs to be adapted.

#### Example

Erroneous code example:

```cds
// index.cds
using from './Model';
```

using following directory tree:

```
├── index.cds
└── model.cds
```

On case-insensitive systems, the file can be loaded, but the compiler will warn
about the mismatch.
On case-sensitive file systems, compilation will fail, as the imported file
can't be found.

While in this case, compilation will fail on case-sensitive systems, it could
instead end up with semantic changes, too.
Given the same `index.cds`, but a different directory tree:

```
├── index.cds
├── Model
│   └── index.cds
└── model.cds
```

On case-sensitive systems, `./Model/index.cds` will be loaded.
On case-insensitive systems, however, `model.cds` will be loaded,
as the compiler first tries to load `Model.cds`, before looking for
`Model/index.cds`.


#### How to Fix

Adapt the filename in your `using` statement.

If you have both `model.cds` and `Model/index.cds`, but don't want to use
a `.cds` suffix, use `using from './Model/'`, i.e. add a trailing slash to
indicate that you want to load from the folder `Model`.
## redirected-to-ambiguous

The redirected target originates more than once from the original target
through direct or indirect sources of the redirected target.

The message's severity is `Error` and is raised by the compiler.
The error happens due to an ill-formed redirection, which requires changes to
your model.

#### Example

Erroneous code example:

```cds
entity Main {
      key id : Integer;
    toTarget : Association to Target;
}

entity Target {
    key id : Integer;
}

view View as select from
    Main,
    Target,
    Target as Duplicate
{
    // ❌ This redirection can't be resolved:
    Main.toTarget : redirected to View
};
```

Entity `Target` exists more than once in `View` under different table aliases.
In the previous example, this happens through the *direct* sources in the
select clause.
Because the original target exists twice in the redirected target, the compiler
isn't able to correctly resolve the redirection due to ambiguities.

This can also happen through *indirect* sources.  For example if entity `Main`
were to include `Target`, then selecting from `Target` just once would be
enough to trigger this error.

#### How to Fix

You must have the original target only once in your direct and indirect
sources.  The previous example can be fixed by removing `Duplicate` from
the select clause.

```cds
view View as select from Main, Target {
    Main.toTarget : redirected to View
};
```

If this isn't feasible then you have to redefine the association using a mixin
clause.

```cds
view View as select from Main, Target mixin {
    toMain : Association to View on Main.id = Target.id;
} into {
    Main.id   as mainId,
    Target.id as targetId,
    toMain
};
```

#### Related Messages

- [`redirected-to-unrelated`](#redirected-to-unrelated)
- [`redirected-to-complex`](#redirected-to-complex)
## redirected-to-complex

The redirected target is a complex view, for example, contains a JOIN or UNION.

The message's severity is `Info` and is raised by the compiler.
It is emitted to help developers identify possible modeling issues.

#### Example

Erroneous code example:

```cds
entity Main {
    key id : Integer;
    // self association for example purpose only
    toMain : Association to one Main;
}
entity Secondary {
    content: String;
};
entity CrossJoin as SELECT from Main, Secondary;
entity RedirectToComplex as projection on Main {
    id,
    toMain: redirected to CrossJoin, // ❌
};
```

`Main:toMain` is a to-one association.  Since `Main` contains a single key,
which is used in the managed association, we know that following the
association returns a single result.

The cross join in the view `CrossJoin` results in multiple rows with the same
`id`.  Following the redirected view now returns multiple results, effectively
making the to-one association a to-many association.

Visualizing the tables with a bit of data, this issue becomes obvious:

```markdown
Main                        Secondary
| id  | toMain_id |         | content |
|-----|-----------|         |---------|
| 1   | 2         |         | 'Hello' |
| 2   | 1         |         | 'World' |

CrossJoin
| id  | toMain_id | content |
|-----|-----------|---------|
| 1   | 2         | 'Hello' |
| 1   | 2         | 'World' |
| 2   | 1         | 'Hello' |
| 2   | 1         | 'World' |
```

#### How to Fix

First, ensure that the redirected association points to an entity that is
a reasonable redirection target.  That means, the redirection target shouldn't
accidentally make it a to-many association.

Then add an explicit ON-condition or explicit foreign keys to the redirected
association.  That will silence the compiler message.

#### Related Messages

- [`redirected-to-ambiguous`](#redirected-to-ambiguous)
- [`redirected-to-unrelated`](#redirected-to-unrelated)
## redirected-to-unrelated

The redirected target doesn't originate from the original target.

The message's severity is `Error` and is raised by the compiler.
The error happens due to an ill-formed redirection, which requires changes to
your model.

#### Example

Erroneous code example:

```cds
entity Main {
    key id : Integer;
    // self association for example purpose only
    toMain : Association to Main;
}
entity Secondary {
    key id : Integer;
}
entity InvalidRedirect as projection on Main {
    id,
    // ❌ Invalid redirection
    toMain: redirected to Secondary,
};
```

Projection `InvalidRedirect` tries to redirect `toMain` to `Secondary`.
However, that entity doesn't have any connection to the original target
`Main`, that means, it doesn't originate from `Main`.

While this example may be clear, your model may have multiple redirections
that make the error not as obvious.

Erroneous code example with multiple redirections:

```cds
entity Main {
    key id : Integer;
    toMain : Association to Main;
}
entity FirstRedirect as projection on Main {
    id,
    toMain: redirected to FirstRedirect,
}
entity SecondRedirect as projection on FirstRedirect {
    id,
    // Invalid redirection
    toMain: redirected to Main,
}
```

The intent of the example above is to redirect `toMain` to its original target
in `SecondRedirect`.  But because `SecondRedirect` uses `toMain` from
`FirstRedirect`, the original target is `FirstRedirect`.  And `Main` doesn't
originate from `FirstRedirect` but only vice versa.

#### How to Fix

You must redirect the association to an entity that originates from the
original target.  In the first example above you could redirect
`SecondRedirect:toMain` to `SecondRedirect`.  However, if that isn't feasible
then you have to redefine the association using a mixin clause.

```cds
view SecondRedirect as select from FirstRedirect mixin {
    toMain : Association to Main on id = $self.id;
} into {
    FirstRedirect.id as id,
    toMain
};
```

#### Related Messages

- [`redirected-to-ambiguous`](#redirected-to-ambiguous)
- [`redirected-to-complex`](#redirected-to-complex)
## rewrite-not-supported

The compiler isn't able to rewrite ON conditions for some associations.
They have to be explicitly defined by the user.

The message's severity is `Error`.

#### Example

Erroneous code example:

```cds
entity Base {
  key id     : Integer;
  primary    : Association to Primary on primary.id = primary_id;
  primary_id : Integer;
}

entity Primary {
  key id       : Integer;
  secondary    : Association to Secondary on secondary.id = secondary_id;
  secondary_id : Integer;
}

entity Secondary {
  key id : Integer;
  text   : LargeString;
}

entity View as select from Base {
  id,
  primary.secondary // ❌ The ON condition isn't rewritten here
};
```

In the previous example, the ON condition in `View` of `secondary` can't be
automatically rewritten because the associations are unmanaged and the
compiler can't determine how to properly rewrite them for `View`.

#### How to Fix

You have to provide an explicit ON condition.  This can be achieved by using
the `redirected to` statement:

```cds
entity View as select from Base {
  id,
  primary.secondary_id,
  primary.secondary: redirected to Secondary on
    secondary.id = secondary_id
};
```

In the corrected view above, the association `secondary` gets an explicit ON
condition.  For this to work it is necessary to add `secondary_id` to the
selection list, that means, we have to explicitly use the foreign key.


#### Related Messages

- [`rewrite-undefined-key`](#rewrite-undefined-key)
## rewrite-undefined-key

The compiler isn't able to rewrite an association's foreign keys,
because the redirected target is missing elements to match them.

The message's severity is `Error`.

#### Example

Erroneous code example:

```cds
entity model.Base {
  key ID : UUID;
  toTarget : Association to model.Target; // (1)
}
entity model.Target {
  key ID : UUID; // (2)
  field : String;
}

service S {
  entity Base as projection on model.Base; // ❌ (3) Can't redirect 'toTarget'

  entity Target as projection on model.Target {
    field, // (4) No 'ID'
  };
}
```

In the example, the projected association `toTarget` at (3) in entity
`S.Base` can't be redirected to `S.Target`, because `S.Target` does not
project element `ID` (4).

`toTarget` (1) is a managed association and hence foreign keys are inferred
for it.  The compiler generates a foreign key `ID`, which corresponds to
element `ID` of `model.Target` (2).

As both entities are exposed in service `S`, the compiler tries to redirect
`S.Base:toTarget` to an entity inside the same service, to create
a "self-contained" service.  It notices, however, that `S.Target` does not
have element `ID`, and therefore can't match the foreign key to a target
element and emits this error message.

#### How to Fix

If you don't need to expose association `toTarget` in `S.Target`, you can
exclude it in the projection via an `excluding` clause.

```cds
service S {
  entity Base as projection on model.Base
    excluding { toTarget };
  // ...
}
```

If the association is required in the service, you need to either project
element `ID` in `S.Target`, or redirect the association explicitly.

The easiest fix is to select `ID` explicitly:
```cds
service S {
  // ...
  entity Target as projection on model.Target {
    field, ID, // Explicitly select element ID
  };
}
```

However, if you don't want to expose `ID`, redirect association `toTarget`
explicitly, matching the foreign key to another element:

```cds
service S {
  entity Base as projection on model.Base {
    ID,
    toTarget : redirected to Target { fakeID as ID }, // (1)
  };
  entity Target as projection on model.Target {
    calculateKey() as fakeID : UUID,                  // (2)
    field,
  };
}
```

Note that at (1), we use element `fakeID` of `S.Target` as foreign key `ID`.
That changes its semantic meaning and may not be feasible in all cases!
In the example, we assume at (2) that a key can be calculated.


#### Related Messages

- [`rewrite-not-supported`](#rewrite-not-supported)
## syntax-expecting-unsigned-int

The compiler expects a safe non-negative integer here.
The last safe integer is `2^53 - 1` or `9007199254740991`.

A safe integer is an integer that fulfills all of the following:

- Can be exactly represented as an IEEE-754 double precision number.
- The IEEE-754 representation cannot be the result of rounding any
  other integer to fit the IEEE-754 representation.

The message's severity is `Error`.

#### Example

Erroneous code example:


```cds
type LengthIsUnsafe : String(9007199254740992); // ❌
type NotAnInteger : String(42.1);               // ❌
```

In the erroneous example, the string length for the type `LengthIsUnsafe` is
not a safe integer. It is too large.
Likewise, the string length for the type `NotAnInteger` is a decimal.

#### How to Fix

You have to provide a safe integer:

```cds
type LengthIsSafe : String(9007199254740991);
type AnInteger : String(42);
```

At other places, using unsafe integers (or non-integer numbers) is allowed:

- Annotation values: The value is then simply a string.
- Expressions: The `val` property in the CSN contains a string
  having a sibling `literal: 'number'`.
## type-missing-enum-value

An enum definition is missing explicit values for one or more of its entries.

Enum definitions that aren't based on string-types do not get implicit values.
They have therefore to be defined explicitly in the model.

The message's severity is `Warning` and is raised by the compiler.  You need
to adapt your model to fix the warning.

#### Example

Erroneous code example:

```cds
entity Books {
  // …
  category: Integer enum {
    Fiction; // ❌
    Action;  // ❌
    // …
  } default #Action;
};
```

Both entries `#Fiction` and `#Action` of the enum `category` are missing an
explicit value.  Because the base type `Integer` is not a string, no implicit
values are defined for them.

#### How to Fix

Explicitly assign a value or change the type to a string if the values are not
important in your model.  The erroneous example above can be changed to:

```cds
entity Books {
  // …
  category: Integer enum {
    Fiction = 1;
    Action = 2;
    // …
  } default #Action;
};
```

#### Background

Many languages support implicit values for integer-like enums.  However,
CAP CDS does not have this feature, because otherwise, if values are persisted,
adding a new entry in-between existing ones would lead to issues during
deserialization later on.

Assume that CAP would assign implicit values for integer enums.  If a new value
were to be added between `Fiction` and `Action` in the erroneous example above,
then the generated SQL statement for entity `Books` would change:  
Instead of default value `2`, value `3` would be persisted.  Without data
migration, existing action books would have changed their category.

To avoid this scenario, always add explicit values to enums.
## type-unexpected-foreign-keys

Foreign keys were specified in a composition-of-aspect.

Compositions of aspects are managed by the compiler.
Specifying a foreign key list is not supported.
If you need to specify foreign keys, use a composition
of an entity instead.

The message's severity is `Error`.

#### Example

Erroneous code example:

```cds
aspect Item {
  key ID : UUID;
  field : String;
};
entity Model {
  key ID : UUID;
  Item : Composition of Item { ID }; // ❌
};
```

`Item` is an aspect.  Because an explicit list of foreign keys is specified,
the compiler rejects this CDS snippet.  With an explicit foreign key list,
only entities can be used, but not aspects.

#### How to Fix

Either remove the explicit list of foreign keys and let the compiler handle
the composition, or use a composition of entity instead.

```cds
aspect Item {
  key ID : UUID;
  field : String;
};
entity Model {
  key ID : UUID;
  Item : Composition of Model.Item { ID }; // ok
};
entity Model.Item : Item { };
```

The snippet uses a user-defined entity, that includes the aspects.

#### Related Messages

- [`type-unexpected-on-condition`](#type-unexpected-on-condition)
## type-unexpected-on-condition

An ON-condition was specified in a composition-of-aspect.

Compositions of aspects are managed by the compiler.
Specifying an ON-condition is not supported.
If you need to specify an ON-condition, use a composition
of an entity instead.

The message's severity is `Error`.

#### Example

Erroneous code example:

```cds
aspect Item {
  key ID : UUID;
  field : String;
};
entity Model {
  key ID : UUID;
  Item : Composition of Item on Item.ID = ID; // ❌
};
```

`Item` is an aspect.  Because an ON-condition is specified, the compiler
rejects this CDS snippet.  With an ON-condition, only entities can be used,
but not aspects.

#### How to Fix

Either remove the ON-condition and let the compiler handle
the composition, or use a composition of entity instead.

```cds
aspect Item {
  key ID : UUID;
  field : String;
};
entity Model {
  key ID : UUID;
  Item : Composition of Model.Item on Item.ID = ID; // ok
};
entity Model.Item : Item { };
```

The snippet uses a user-defined entity, that includes the aspects.

#### Related Messages

- [`type-unexpected-foreign-keys`](#type-unexpected-foreign-keys)
## wildcard-excluding-one

You're replacing an element in your projection, that is already included by
using the wildcard `*`.

The message's severity is `Info`.

#### Example

Erroneous code example:

```cds
entity Book {
  key  id : String;
     isbn : String;
  content : String;
};
entity IsbnBook as projection on Book {
  *,
  isbn as id, // ❌
};
```

`IsbnBook:id` replaces `Book:id`, which was included in `IsbnBook` through
the wildcard `*`.

#### How to Fix

Add the replaced element to the list of wildcard excludes:

```cds
entity IsbnBook as projection on Book {
  *,
  isbn as id
} excluding { id };
```






# On The Nature of Models

Introduces the fundamental principles of CDS models.


## Metaphysics of Languages

A *model* is a *thing* that describes *something*.
For example, a *data model describes the type structure (commonly also called *'schema*') of *data*.

### Languages

### Representations

Models can come in different *representations*, which follow different *syntaxes*. For example, we use the *CDL* syntax for *human-readable* representations of CDS models, while CSN is an *object notation*, i.e. a special form of *syntax*, used for *machine-readable* representations of CDS models. 

::: details On CSN representations... 

We can go one meta-level further and distinguish between different representations of CSN representations: in a Node.js process at runtime they are just native in-memory JavaScript objects, when shared they are serialized to JSON format, which can in turn be translated to YAML, and so forth. When we create CSN objects at runtime, they could be plain JavaScript code. 

:::

### Reflections

CDS models can be compiled to other languages, that play in the same fields, yet not covering the same information, but rather with some loss of information — we call these '*reflections*'. 

Examples are:

- SQL DDL covers the persistence model interface only → only flat tables and views
- OData EDMX covers the service interfaces only → queryable entities still exist, with implicit features
- GraphQL also covers service interfaces → queryable entities still exist, but without less features
- OpenAPI also covers the service interfaces, with → queryable entities got 'flattened' to paths with input and output types

---

The above principles apply not only to CDS models, but also to Queries:

- CQL is a syntax for human-readable representations
- CQN is an object notation for machine-readable representations

And for Expressions:

- CXL is a syntax for human-readable representations
- CXN is an object notation for machine-readable representations

...




## What is a CDS Model?

Models in `cds` are plain JavaScript objects conforming to the _[Core Schema Notation (CSN)](./csn)_. They can be parsed from [_.cds_ sources](./cdl), read from _.json_ or _.yaml_ files or dynamically created in code at runtime.

The following ways and examples of creating models are equivalent:

### In Plain Coding at Runtime

```js
const cds = require('@sap/cds')

// define the model
var model = {definitions:{
    Products: {kind:'entity', elements:{
        ID: {type:'Integer', key:true},
        title: {type:'String', length:11, localized:true},
        description: {type:'String', localized:true},
    }},
    Orders: {kind:'entity', elements:{
        product: {type:'Association', target:'Products'},
        quantity: {type:'Integer'},
    }},
}}

// do something with it
console.log (cds.compile.to.yaml (model))
```


### Parsed at Runtime

```js
const cds = require('@sap/cds')

// define the model
var model = cds.parse (`
    entity Products {
        key ID: Integer;
        title: localized String(11);
        description: localized String;
    }
    entity Orders {
        product: Association to Products;
        quantity: Integer;
    }
`)

// do something with it
console.log (cds.compile.to.yaml (model))
```


### From _.cds_ Source Files

```cds
// some.cds source file
entity Products {
    key ID: Integer;
    title: localized String(11);
    description: localized String;
}
entity Orders {
    product: Association to Products;
    quantity: Integer;
}
```

Read/parse it, and do something with it, for example:

```js
const cds = require('@sap/cds')
cds.get('./some.cds') .then (cds.compile.to.yaml) .then (console.log)
```

> Which is equivalent to: `cds ./some.cds -2 yaml` using the CLI


### From _.json_ Files

```json
{"definitions": {
    "Products": {
        "kind": "entity",
        "elements": {
            "ID": { "type": "Integer", "key": true },
            "title": { "type": "String", "length": 11, "localized": true },
            "description": { "type": "String", "localized": true }
        }
    },
    "Orders": {
        "kind": "entity",
        "elements": {
            "product": { "type": "Association", "target": "Products" },
            "quantity": { "type": "Integer" }
        }
    }
}}
```

```js
const cds = require('@sap/cds')
cds.get('./some.json') .then (cds.compile.to.yaml) .then (console.log)
```

<div id="beforefrontends" />

### From Other Frontends

You can add any other frontend instead of using [CDL](./cdl); it's just about generating the respective [CSN](./csn) structures, most easily as _.json_. For example, different parties already added these frontends:

* ABAP CDS 2 csn
* OData EDMX 2 csn
* Fiori annotation.xml 2 csn
* i18n properties files 2 csn
* Java/JPA models 2 csn


## Processing Models

All model processing and compilation steps, which can be applied subsequently just work on the basis of plain CSN objects. There's no assumption about and no lock-in to a specific source format.



# CAP Service SDK for Node.js
Reference Documentation
{ .subtitle}




As an application developer you'd primarily use the Node.js APIs documented herein to implement **domain-specific custom logic** along these lines:

1. Define services in CDS &rarr; see [Cookbook > Providing & Consuming Services](../guides/providing-services#service-definitions)
2. Add service implementations &rarr; [`cds.Service` > Implementations](./core-services#implementing-services)
3. Register custom event handlers in which &rarr; [`srv.on`/`before`/`after`](./core-services#srv-on-before-after)
4. Read/write data from other services in which &rarr; [`srv.run`](./core-services#srv-run-query) + [`cds.ql`](./cds-ql)
5. ..., that is from your primary database &rarr; [`cds.DatabaseService`](./databases)
5. ..., that is from other connected services &rarr; [`cds.RemoteService`](./remote-services)
6. Emit and handle asynchronous events &rarr; [`cds.MessagingService`](./messaging)

All the rest is largely handled by the CAP runtime framework behind the scenes.
This especially applies to bootstrapping the [`cds.server`](./cds-serve) and the generic features
provided through [`cds.ApplicationService`](./app-services).





# The *cds* Façade Object {#title}



The `cds` facade object provides access to all CAP Node.js APIs. Use it like that:

```js
const cds = require('@sap/cds')
let csn = cds.compile(`entity Foo {}`)
```

::: tip Use `cds repl` to try out things
For example, like this to get the compiled CSN for an entity `Foo`:
```js
[dev] cds repl
Welcome to cds repl v 7.3.0
> cds.compile(`entity Foo { key ID : UUID }`)
{ definitions: {
  Foo: { kind: 'entity', elements: { ID: { key: true, type: 'cds.UUID' } } }
}}
```
:::



## Refs to Submodules

Many properties of cds are references to submodules, which are lazy-loaded on first access to minimize bootstrapping time and memory consumption. The submodules are documented in separate documents.

- [cds. model](cds-facade#cds-model) {.property}
  - [cds. resolve()](cds-compile#cds-resolve) {.method}
  - [cds. load()](cds-compile#cds-load) {.method}
  - [cds. parse()](cds-compile#cds-parse) {.method}
  - [cds. compile](cds-compile) {.method}
  - [cds. linked()](cds-reflect) {.method}
- [cds. server](cds-server) {.property}
- [cds. serve()](cds-serve) {.method}
  - cds. services {.property}
  - cds. middlewares {.property}
  - cds. protocols {.property}
  - cds. auth {.property}
- [cds. connect](cds-connect) {.property}
- [cds. ql](cds-ql) {.property}
- [cds. tx()](cds-tx) {.method}
- [cds. log()](cds-log) {.method}
- [cds. env](cds-env) {.property}
- [cds. auth](authentication) {.property}
- [cds. i18n](cds-i18n) {.property}
- [cds. test](cds-test) {.property}
- [cds. utils](cds-utils) {.property}

<br>

Import classes and functions through the facade object only:

##### **Good:** {#import-good .good}

```ts
const { Request } = require('@sap/cds') // [!code ++]
```

##### **Bad:** {#import-bad .bad}

Never code against paths inside `@sap/cds/`:

```ts
const Request = require('@sap/cds/lib/.../Request') // [!code --]
```

## Builtin Types & Classes

Following properties provide access to the classes and prototypes of [linked CSNs](cds-reflect).

### [cds. builtin .types](cds-reflect#cds-builtin-types) {.property}
### [cds. linked .classes](cds-reflect#cds-linked-classes) {.property}

The following top-level properties are convenience shortcuts to their counterparts in `cds.linked.classes`. <br>
For example:

```js
cds.entity === cds.linked.classes.entity
```

  - [cds. Association](cds-reflect#cds-association) {.property}
  - [cds. Composition](cds-reflect#cds-linked-classes) {.property}
  - [cds. entity](cds-reflect#cds-entity) {.property}
  - [cds. event](cds-reflect#cds-linked-classes) {.property}
  - [cds. type](cds-reflect#cds-linked-classes) {.property}
  - [cds. array](cds-reflect#cds-linked-classes) {.property}
  - [cds. struct](cds-reflect#cds-struct) {.property}
  - [cds. service](cds-reflect#cds-struct) {.property}



## Core Classes

### [cds. Service](core-services#core-services) {.class}

- [cds. ApplicationService](app-services) {.class}
- [cds. RemoteService](remote-services) {.class}
- [cds. MessagingService](messaging) {.class}
- [cds. DatabaseService](databases) {.class}
- [cds. SQLService](databases) {.class}

### [cds. EventContext](events#cds-event-context) {.class}
### [cds. Event](events#cds-event) {.class}
### [cds. Request](events#cds-request) {.class}
### [cds. User](authentication#cds-user) {.class}




## Properties

Following are properties which are not references to submodules.



### cds. version {.property}

Returns the version of the `@sap/cds` package from which the current instance of the `cds` facade module was loaded. For example, use that to write version specific code:

```js
const [major, minor] = cds.version.split('.').map(Number)
if (major < 6) // code for pre cds6 usage
```




### cds. home {.property}

Returns the pathname of the `@sap/cds` installation folder from which the current instance of the `cds` facade module was loaded.

```js
[dev] cds repl
> cds.home // [!code focus]
~/.npm/lib/node_modules/@sap/cds
```



### cds. root {.property}

Returns the project root that is used by all CAP runtime file access as the root directory.
By default this is `process.cwd()`, but can be set to a different root folder.
It's guaranteed to be an absolute folder name.

```js
// Print current project's package name
let package_json = path.join (cds.root,'package.json') // [!code focus]
let { name, description } = require(package_json)
console.log ({ name, description })
```



### cds. cli {.property}

Provides access to the parsed effective `cds` cli command and arguments. Example: If you would add log respective output in a project-local `server.js`, and start your server with `cds watch`, you'd see an output like this:

```js
Trace : {
  command: 'serve',
  argv: [ 'all' ],
  options: {
    'with-mocks': true,
    'in-memory?': true
  }
}
```

For example, [`cds-plugins`](cds-serve) can use that to plug into different parts of the framework for different commands being executed.

Known values for `cds.cli.command` are `add`, `build`, `compile`, `deploy`, `import`, `init`, `serve`.
`cds watch` is normalized to `serve`.

### cds. entities {.property}

Is a shortcut to `cds.db.entities`. Used as a function, you can [specify a namespace](/node.js/cds-reflect#entities).

### cds. env {.property}

Provides access to the effective configuration of the current process, transparently from various sources, including the local _package.json_ or _.cdsrc.json_, service bindings and process environments.

```js
[dev] cds repl
> cds.env.requires.auth // [!code focus]
{
  kind: 'basic-auth',
  strategy: 'mock',
  users: {
    alice: { tenant: 't1', roles: [ 'admin' ] },
    bob: { tenant: 't1', roles: [ 'cds.ExtensionDeveloper' ] },
    # ...,
    '*': true
  },
  tenants: {
    t1: { features: [ 'isbn' ] },
    t2: { features: '*' }
  }
}
```

[Learn more about `cds.env`](cds-env){.learn-more}


### cds. requires {.property}

... is an overlay and convenience shortcut to [`cds.env.requires`](#cds-env), with additional entries for services with names different from the service definition's name in cds models. For example, given this service definition:

```cds
service ReviewsService {}
```

... and this configuration:

```jsonc
{ "cds": {
  "requires": {
    "db": "sqlite",
    "reviews" : {                  // lookup name
      "service": "ReviewsService"  // service definition's name
    }
  }
}}
```

You can access the entries as follows:

```js
[dev] cds repl
> cds.env.requires.db              //> the effective config for db
> cds.env.requires.reviews         //> the effective config for reviews
> cds.env.requires.ReviewsService  //> undefined
```

```js
[dev] cds repl
> cds.requires.db                  //> the effective config for db
> cds.requires.reviews             //> the effective config for reviews
> cds.requires.ReviewsService      //> same as cds.requires.reviews
```

The additional entries are useful for code that needs to securely access the service by cds definition name.

Note: as `cds.requires` is an overlay to `cds.env.requires`, it inherits all properties from there via prototype chain. In effect using operations which only look at *own* properties, like `Object.keys()` behave different than for `cds.env.requires`:

```js
[dev] cds repl
> Object.keys(cds.env.requires) //> [ 'db', 'reviews' ]
> Object.keys(cds.requires)     //> [ 'ReviewsService' ]
```





### cds. services {.property}

A dictionary and cache of all instances of [`cds.Service`](core-services) constructed through [`cds.serve()`](cds-serve),
or connected to by [`cds.connect()`](cds-connect).

It's an *iterable* object, so can be accessed in the following ways:

```js
let { CatalogService, db } = cds.services
let all_services = [ ... cds.services ]
for (let k in cds.services) //... k is a services's name
for (let s of cds.services) //... s is an instance of cds.Service
```



### cds. context {.property}

Provides access to common event context properties like `tenant`, `user`, `locale` as well as the current root transaction for automatically managed transactions.

[Learn more about that in reference docs for `cds.tx`.](./cds-tx){.learn-more}



### cds. model {.property}

The effective [CDS model](../cds/csn) loaded during bootstrapping, which contains all service and entity definitions, including required services. Many framework operations use that as a default where models are required. It is loaded in built-in `server.js` like so:

```js
cds.model = await cds.load('*')
```

[Learn more about bootstrapping in `cds.server`.](./cds-serve){.learn-more}




### cds. app {.property}

The [express.js Application object](https://expressjs.com/de/4x/api.html#app) constructed during bootstrapping. Several framework operations use that to add express handlers or middlewares. It is initialised in built-in `server.js` like so:

```js
cds.app = require('express')()
```

[Learn more about bootstrapping in `cds.server`.](./cds-serve){.learn-more}




### cds. db {.property}

A shortcut to [`cds.services.db`](#cds-services), the primary database connected to during bootstrapping. Many framework operations use that to address and interact with the primary database. In particular that applies to the global [`cds.ql`](cds-ql) statement objects. For example:

```js
let books = await SELECT.from(Books) // is a shortcut for:
let books = await cds.db.run ( SELECT.from(Books) )
```

It is initialized in built-in `server.js` like so:

```js
cds.db = await cds.connect.to('db')
```

[Learn more about bootstrapping in `cds.server`.](./cds-serve){.learn-more}



## Methods



### cds. error() {.method}

```ts
function cds.error (
  message  : string | object,
  details? : object
  caller?  : function
)
```

This is a helper to construct new errors in various ways:

```js
let e = new cds.error ('message')
let e = new cds.error ('message', { code, ... })
let e = new cds.error ({ message, code, ... })
```

If called without `new`  the error is thrown immediately allowing code like that:

```js
let e = foo || cds.error (`Expected 'foo' to be truthy, but got: ${foo}`)
```

You can also use `cds.error` with tagged template strings:

```js
let e = foo || cds.error `Expected 'foo' to be truthy, but got: ${foo}`
```

> In contrast to basic template strings, passed in objects are added using Node's  `util.format()` instead of `toString()`.

Method `cds.error.expected` allows to conveniently construct error messages as above:

```js
let e = foo || cds.error.expected `${{foo}} to be truthy`
```

Optional argument `caller` can be a calling function to truncate the error stack. Default is `cds.error` itself, so it will never show up in the stacks.





### cds. exit() {.method}

Provides a graceful shutdown for running servers, by first emitting `cds.emit('shutdown')` with handlers allowed to be `async` functions. If not running in a server, it calls `process.exit()`

```js
cds.on('shutdown', async()=> fs.promises.rm('some-file.json'))
cds.on('shutdown', ()=> console.log('shutdown'))
cds.exit() //> will rune above handlers before stopping the server
```




## Lifecycle Events

The `cds` facade object is an [EventEmitter](https://nodejs.org/api/events.html#asynchronous-vs-synchronous),
which frameworks emits events to, during the server bootstrapping process, or when we compile models.
You can register event handlers using `cds.on()` like so:


```js twoslash
// @noErrors
const cds = require('@sap/cds')
cds.on('bootstrap', ...)
cds.on('served', ...)
cds.on('listening', ...)
```

- [Learn more about Lifecycle Events emitted by `cds.compile`](cds-compile#lifecycle-events) {.learn-more}
- [Learn more about Lifecycle Events emitted by `cds.server`](cds-server#lifecycle-events) {.learn-more}


> [!warning]
> As we're using Node's standard [EventEmitter](https://nodejs.org/api/events.html#asynchronous-vs-synchronous),
> event handlers execute **synchronously** in the order they are registered, with `served` and `shutdown`
> events as the only exceptions.



# Reflecting CDS Models

{{$frontmatter?.synopsis}}





[def]: ../cds/csn#definitions
[defs]: ../cds/csn#definitions



## cds. linked ([csn](../cds/csn)) {#cds-linked .method}
[`cds.linked`]: #cds-linked

Method `cds.linked` (or `cds.reflect` which is an alias to the same method) turns a given parsed model into an instance of [class `LinkedCSN`](#linked-csn), and all definitions within into instances of [class `LinkedDefinition`](#any), recursively.

Declaration:

```tsx
function* cds.linked (csn: CSN | string) => LinkedCSN
```

A typical usage is like that:

```js
let csn = cds.load('some-model.cds')
let linked = cds.linked(csn) // linked === csn
```

Instead of a already compiled CSN, you can also pass a string containing CDL source code:

```js
let linked = cds.linked`
  entity Books {
  	key ID: UUID;
  	title: String;
  	author: Association to Authors;
  }
  entity Authors {
  	key ID: UUID;
  	name: String;
  }
`
```

The passed in model gets **modified**, and the returned linked model is actually the modified passed-in csn.

The operation is **idempotent**, that is, you can repeatedly invoke it on already linked models with zero overhead.





## LinkedCSN {#linked-csn .class}
[reflected model]: #linked-csn
[linked model]: #linked-csn
[`LinkedCSN`]: #linked-csn

Models passed through [`cds.linked`] become instances of this class.

### . is_linked {.property}

A tag property which is `true` for linked models. {.indent}

### . definitions {.property}

The [CSN definitions](../cds/csn#definitions) of the model, turned into an instance of [`LinkedDefinitions`].  {.indent}

### . services {.property alt="The following documentation on entities also applies to services. "}

### . entities {.property}

These are convenient shortcuts to access all *[service](../cds/cdl#services)* or all *[entity](../cds/cdl#entities)* definitions in a model. <br>The value is an instance of [`LinkedDefinitions`].

For example:

```js
let m = cds.linked`
  namespace my.bookshop;
  entity Books {...}
  entity Authors {...}
  service CatalogService {
    entity ListOfBooks as projection on Books {...}
  }
`

// Object nature
let { CatalogService, AdminService } = m.services
let { Books, Authors } = m.entities

// Array nature
for (let each of m.entities) console.log(each.name)

// Function nature
let { ListOfBooks } = m.entities ('my.bookshop.CatalogService')
```

In addition to the object and array natures of  [`LinkedDefinitions`] these properties also can be used as functions, which allows to optionally specify a namespace to fetch all definitions with prefixed with that. If no namespace is specified, the model's declared namespace is used, if any.



### each() {#each .method }

```tsx
function* lm.each (
   filter : string | def => true/false,
   defs?  : linked_definitions
)
```


Fetches definitions matching the given filter, returning an iterator on them.

```js
let m = cds.reflect (csn)
for (let d of m.each('entity')) {
  console.log (d.kind, d.name)
}
```

The first argument **_filter_** specifies a filter to match definitions, which can be one of:

- a `string` referring to a _kind_ of definition
- a `function` returning `true` or `false`

Derived kinds are supported, for example, `m.each('struct')` matches structs
as well as entities; kind `'any'` matches all.

The second optional argument **_[defs]_** allows to specify the definitions to fetch in, defaults to `this.definitions`.



### all() {#all .method }

```tsx
function lm.all (
   filter : string | def => true/false,
   defs?  : linked_definitions
)
```

Convenience shortcut to [`[... model.each()]`](#each), for example, the following are equivalent:

```js
m.all('entity')        //> using shortcut
[...m.each('entity')]  //> using spread operator
```



### find() {#find .method }

```tsx
function lm.find (
   filter : string | def => true/false,
   defs?  : linked_definitions
)
```

Convenience shortcut to fetch definitions matching the given filter, returning the first match, if any. For example:

```js
let service = m.find('service')
```

The implementation uses to [`.each()`](#each) as follows:

```js
for (let any of m.each('service'))  return any
```



### foreach() {#foreach .method }

```tsx
function lm.foreach (
  filter  : def => true/false | string,
  visitor : def => {},
  defs?   : linked_definitions
)
```

Calls the visitor for each definition matching the given filter. `foreach` iterates through the passed in defs only, `forall` in addition walks through all nested element definitions hierarchically.

* `filter` / `kind` — the filter or kind used to match definitions [&rarr; see _.each(x)_](#each)
* `visitor` — the callback function
* `defs` — the definitions to fetch in, default: `this.definitions`

Examples:

```js
// print the names of all services
let m = cds.reflect(csn)
m.foreach ('service', s => console.log(s.name))
```
```js
// print the names of all Associations in Books element
let { Books } = m.entities()
m.foreach ('Association', a => console.log(a.name), Books.elements)
```





## LinkedDefinitions {.class #iterable}

[`LinkedDefinitions`]: #iterable

All objects of a linked model containing CSN definitions are instances of this class.

For example, that applies to:

- *`cds.model` [.definitions](#definitions), [.services](#services), [.entities](#entities)*
- *`cds.service` [.entities](#entities-1), [.events](#events), [.actions](#actions-1)*
- *`cds.entity`  [.keys](#keys), [.associations](#associations), [.compositions](#compositions), [.actions](#actions)*
- *`cds.struct` [.elements](#elements)* (hence also *`cds.entity` .elements*)
- *`cds.Association` [.foreignKeys](#foreignkeys)*

Instances of `LinkedDefinitions` allow both, object-style access, as well as array-like access.
For example:

```js
let linked = cds.linked (model)
let { Books, Authors } = linked.entities // object-like
let [ Books, Authors ] = linked.entities // array-like
```

> Note: Orders of definitions could change, so you should always prefer object destructuring over array destructuring.


The array-like nature also allows using these shortcuts in `for..of` loops, of course. Which means, you can do that:

```js
for (let each of linked.definitions) console.log (each.name)
```

... instead of iterating definitions using `for..in` loops like that:

```js
for (let each in linked.definitions) {
  let d = linked.definitions [each]
  console.log (d.name)
}
```

Each entry in an instance of `LinkedDefinitions` is a [`LinkedDefinition`].



## LinkedDefinition {.class #any}

[`LinkedDefinition`]: #any

All [`cds.linked`] definitions are instances of this class, or subclasses thereof. It is accessible through [`cds.linked.classes.any`](#cds-linked-classes).

### . is_linked {.property}

A tag property which is `true` for all linked definitions. {.indent}

### . name {.property}

The linked definition's fully qualified name as a non-enumerable property. {.indent}

### . kind {.property}

The linked definition's resolved kind as a non-enumerable property.
One of:

- `'context'`
- `'service'`
- `'entity'`
- `'type'`
- `'aspect'`
- `'event'`
- `'element'`
- `'annotation'`

... as documented in the [CSN specification](../cds/csn#definitions).



#### *instanceof*

You can use JavaScript's standard `instanceof` operator in combination with the built-in classes to check a linked definition's type:

```js
let { Foo } = cds.linked(csn).entities
if (Foo instanceof cds.entity) console.log ("it's an entity")
```





## cds. service {.class}

All *[service](../cds/cdl#services)* definitions in a linked model are instances of this class.

```tsx
class cds.service extends cds.context {...}
```

### . is_service {.property}

A tag property which is `true` for linked entity definitions. {.indent}

### . entities {.property alt="The following documentation on actions also applies to entities. "}

### . events {.property alt="The following documentation on actions also applies to events. "}

### . actions {.property}

These properties are convenience shortcuts to access a service definition's exposed [*entity*](../cds/cdl#entities), [*type*](../cds/cdl#types), [*event*](../cds/cdl#events), [*action* or *function*](../cds/cdl#actions) definitions. <br>Their values are [`LinkedDefinitions`].
 {.indent}



## cds. entity {.class }

All entity definitions in a linked model are instances of this class.

```tsx
class cds.entity extends cds.struct {...}
```

> As `cds.entity` is a subclass of [`cds.struct`](#cds-struct) it also inherits all methods from that.

### . is_entity {.property}

A tag property which is `true` for linked entity definitions.
{.indent}

### . keys {.property alt="The following documentation on actions also applies to keys. "}


### . associations {.property alt="The following documentation on actions also applies to associations. "}

### . compositions {.property alt="The following documentation on actions also applies to compositions. "}

### . actions {.property}

These properties are convenient shortcuts to access an entity definition's declared [*keys*](../cds/cdl#entities), *[Association](../cds/cdl#associations)* or *[Composition](../cds/cdl#associations)* elements, as well as [*bound action* or *function*](../cds/cdl#bound-actions) definitions. <br>
Their values are [`LinkedDefinitions`].
{.indent}


### . texts {.property}

If the entity has *[localized](../guides/localized-data)* elements, this property is a reference to the respective `.texts` entity. If not, this property is undefined
{.indent}

### . drafts {.property}

If draft is enabled, a definition to easily refer to *[draft](../advanced/fiori#draft-support)* data for the current entity is returned.
{.indent}



## cds. struct {.class }

This is the base class of *[struct](../cds/cdl#structured-types)* elements and types, *[aspects](../cds/cdl#aspects)*, and *[entities](../cds/cdl#entities)*.

```tsx
class cds.struct extends cds.type {...}
```

### . is_struct {.property}

A tag property which is `true` for linked struct definitions (types and elements). <br>
It is also `true` for linked entity definitions, that is, instances of as [`cds.entity`](#cds-entity). {.indent}

### . elements {.property}

The entity's declared elements as [documented in the CSN Specification](../cds/csn#entity-definitions) <br>as an instance of [`LinkedDefinitions`]. { .indent}



## cds. Association {.class}

All linked definitions of type `Association` or `Composition`, including elements, are instances of this class. Besides the properties specified for [Associations in CSN](../cds/csn#associations), linked associations provide the following reflection properties...


### . _target {.property}

A reference to the association's resolved linked target definition. {.indent}


### . isAssociation {.property}

A tag property which is `true` for all linked Association definitions, including Compositions. {.indent}

### . isComposition {.property}

A tag property which is `true` for all linked Composition definitions. {.indent}

### . is2one / 2many {.property}

Convenient shortcuts to check whether an association definition has to-one or to-many cardinality. { .indent}

### . keys {.property}

The declared or derived foreign keys. As specified in [CSN spec](../cds/csn#assoc-keys) this is a *projection* of the association target's elements. {.indent}

### . foreignKeys {.property}

The effective foreign keys of [*managed* association](../cds/cdl#managed-associations) as linked definitions. <br>The value is an instance of [`LinkedDefinitions`].
{.indent}






## cds. linked .classes {#cds-linked-classes .property}

[`cds.linked.classes`]: #cds-linked-classes


This property gives you access to the very roots of `cds`'s type system. When a model is passed through [`cds.linked`] all definitions effectively become instances of one of these classes.
In essence they are defined as follows:

```js
class any {...}
class context extends any {...}
cds.service = class service extends context {...}
cds.type = class type extends any {...}
              class scalar extends type {...}
                class boolean extends scalar {...}
                class number extends scalar {...}
                class date extends scalar {...}
                class string extends scalar {...}
cds.array  = class array extends type {...}
cds.struct = class struct extends type {...}
cds.entity = class entity extends struct {...}
cds.event = class event extends struct {...}
cds.Association = class Association extends type {...}
cds.Composition = class Composition extends Association {...}
```

> A few prominent ones of the above classes are available through top-level shortcuts as indicated by the `cds.<classname> =` prefixes in the above pseudo code, find more details on these in the following sections.

For example, you can use these classes as follows:

```js
let m = cds.linked`
   entity Books { author: Association to Authors; }
   entity Authors { key ID: UUID; }
`)
let { Books, Authors } = m.entities
let isEntity = Books instanceof cds.entity
let keys = Books.keys
let { author } = Books.elements
if (author.is2many) ...
```



#### mixin() {.method}

Provided a convenient way to enhance one or more of the builtin classes with additional methods.
Use it like that:

```js
const cds = require ('@sap/cds')

// simplistic csn2cdl enablement
cds.linked.classes .mixin (
  class type {
    toCDL(){ return `${this.kind} ${this.name} : ${this.typeAsCDL()};\n` }
    typeAsCDL(){ return `${this.type.replace(/^cds\./,'')}` }
  },
  class struct {
    typeAsCDL() { return `{\n${ Object.values(this.elements).map (
      e => `  ${e.toCDL()}`
    ).join('')}}`}
  },
  class entity extends cds.struct {
    typeAsCDL() { return (
      this.includes ? this.includes+' ' : ''
    ) + super.typeAsCDL() }
  },
  class Association {
    typeAsCDL(){ return `Association to ${this.target}` }
  },
)

// test drive
let m = cds.linked`
  entity Books : cuid { title:String; author: Association to Authors }
  entity Authors : cuid { name:String; }
  aspect cuid : { key ID:UUID; }
`
m.foreach (d => console.log(d.toCDL()))
```





## cds. builtin. types {#cds-builtin-types .property}
[`cds.builtin.types`]: #cds-builtin-types


This property gives you access to all prototypes of the builtin classes as well as to all linked definitions of the [builtin pre-defined types](../cds/types). The resulting object is in turn like the `definitions` in a [`LinkedCSN`].

Actually, at runtime CDS is in fact bootstrapped out of this using core [CSN](../cds/csn) object structures and [`cds.linked`] techniques. Think of it to be constructed as follows:

```js
cds.builtin.types = cds.linked`
  using from './roots';
  context cds {
    type UUID         : String(36);
    type Boolean      : boolean;
    type Integer      : number;
    type UInt8        : Integer;
    type Int16        : Integer;
    type Int32        : Integer;
    type Int64        : Integer;
    type Integer64    : Integer;
    type Decimal      : number;
    type Double       : number;
    type Date         : date;
    type Time         : date;
    type DateTime     : date;
    type Timestamp    : date;
    type String       : string;
    type Binary       : string;
    type LargeString  : string;
    type LargeBinary  : string;
    type Map          : struct;
  }
`.definitions
```

With `./roots` being this in-memory CSN:

```js
const { any, context, service ,
  type, scalar, string, number, boolean, date,
  array, struct, entity, event, aspect
  Association, Composition
} = cds.linked.classes

const roots = module.exports = {definitions:{
  any: new any,
  context: new context ({type:'any'}),
  type: new type ({type:'any'}),
    scalar: new scalar ({type:'type'}),
      string: new string ({type:'scalar'}),
      number: new number ({type:'scalar'}),
      boolean: new boolean ({type:'scalar'}),
      date: new date ({type:'scalar'}),
    array: new array ({type:'type'}),
    struct: new struct ({type:'type'}),
      entity: new entity ({type:'struct'}),
      event: new event ({type:'struct'}),
      aspect: new aspect ({type:'struct'}),
    Association: new Association ({type:'type'}),
      Composition: new Composition ({type:'Association'}),
  service: new service ({type:'context'}),
}}
```
> Indentation indicates inheritance.





# Serving Provided Services



## cds. serve (...) {.method}



Use `cds.serve()` to construct service providers from the service definitions in corresponding CDS models.

Declaration:

```ts:no-line-numbers
async function cds.serve (
  service        : 'all' | string | cds.Service | typeof cds.Service,
  options        : { service = 'all', ... }
) .from ( model  : string | CSN )         // default: cds.model
  .to ( protocol : string | 'rest' | 'odata' | 'odata-v2' | 'odata-v4' | ... )
  .at ( path     : string )
  .in ( app      : express.Application )  // default: cds.app
.with ( impl     : string | function | cds.Service | typeof cds.Service )
```


##### Common Usages:

```js
const { CatalogService } = await cds.serve ('my-services')
```
```js
const app = require('express')()
cds.serve('all') .in (app)
```




##### Arguments:

* `name` specifies which service to construct a provider for; use `all` to construct providers for all definitions found in the models.

```js
cds.serve('CatalogService')  //> serve a single service
cds.serve('all')             //> serve all services found
```

You may alternatively specify a string starting with `'./'` or refer to a file name with a non-identifier character in it, like `'-'` below, as a convenient shortcut to serve all services from that model:
```js
cds.serve('./reviews-service')  //> is not an identifier through './'
cds.serve('reviews-service')    //> same as '-', hence both act as:
cds.serve('all').from('./reviews-service')
```

The method returns a fluent API object, which is also a _Promise_ resolving to either an object with `'all'` constructed service providers, or to the single one created in case you specified a single service:

```js
const { CatalogService, AdminService } = await cds.serve('all')
const ReviewsService = await cds.serve('ReviewsService')
```


##### Caching:

The constructed service providers are cached in [`cds.services`](cds-facade#cds-services), which (a) makes them accessible to [`cds.connect`](cds-connect), as well as (b) allows us to extend already constructed services through subsequent invocation of [`cds.serve`](cds-serve).


##### Common Usages and Defaults

Most commonly, you'd use `cds.serve` in a custom file to add all the services to your [express.js](https://expressjs.com) app as follows:

```js
const app = require('express')()
cds.serve('all').in(app)
app.listen()
```

This uses these defaults for all options:

| Option               | Description                     | Default                     |
|----------------------|---------------------------------|-----------------------------|
| cds.serve ...        | which services to construct     | `'all'` services            |
| <i>&#8627;</i> .from | models to load definitions from | `'./srv'` folder            |
| <i>&#8627;</i> .in   | express app to mount to         | — none —                    |
| <i>&#8627;</i> .to   | client protocol to serve to     | `'fiori'`                   |
| <i>&#8627;</i> .at   | endpoint path to serve at       | [`@path`](#path) or `.name` |
| <i>&#8627;</i> .with | implementation function         | `@impl` or `._source`.js    |

Alternatively you can construct services individually, also from other models, and also mount them yourself, as document in the subsequent sections on individual fluent API options.

If you just want to add some additional middleware, it's recommended to bootstrap from a [custom `server.js`](#cds-server).




### .from <i> (model) </i> {#from .method}

Allows to determine the CDS models to fetch service definitions from, which can be specified as one of:

- A filename of a single model, which gets loaded and parsed with [`cds.load`]
- A name of a folder containing several models, also loaded with [`cds.load`]
- The string `'all'` as a shortcut for all models in the `'./srv'` folder
- An already parsed model in [CSN](../cds/csn) format

The latter allows you to [`cds.load`] or dynamically construct models yourself and pass in the [CSN](../cds/csn) models, as in this example:

```js
const csn = await cds.load('my-services.cds')
cds.serve('all').from(csn)...
```

**If omitted**, `'./srv'` is used as default.



### .to <i> (protocol) </i> {#to .method}

Allows to specify the protocol through which to expose the service. Currently supported values are:

* `'rest'` plain HTTP rest protocol without any OData-specific extensions
* `'odata'` standard OData rest protocol without any Fiori-specific extensions
* `'fiori'` OData protocol with all Fiori-specific extensions like Draft enabled

**If omitted**, `'fiori'` is used as default.



### .at <i> (path) </i> {#at .method}

Allows to programmatically specify the mount point for the service.

**Note** that this is only possible when constructing single services:
```js
cds.serve('CatalogService').at('/cat')
cds.serve('all').at('/cat') //> error
```

**If omitted**, the mount point is determined from annotation [`@path`](#path), if present, or from the service's lowercase name, excluding trailing _Service_.

```cds
service MyService @(path:'/cat'){...}  //> served at: /cat
service CatalogService {...}           //> served at: /catalog
```


### .in <i> ([express app](https://expressjs.com/api.html#app)) </i> {#in .method}

Adds all service providers as routers to the given [express app](https://expressjs.com/api.html#app).

```js
const app = require('express')()
cds.serve('all').in(app)
app.listen()
```





### .with <i> (impl) </i> {#with .method}

Allows to specify a function that adds [event handlers] to the service provider, either as a function or as a string referring to a separate node module containing the function.

```js
cds.serve('./srv/cat-service.cds') .with ('./srv/cat-service.js')
```

```js
cds.serve('./srv/cat-service') .with (srv => {
  srv.on ('READ','Books', (req) => req.reply([...]))
})
```

[Learn more about using impl annotations.](core-services#implementing-services){.learn-more}
[Learn more about adding event handlers.](core-services#srv-on-before-after){.learn-more}


**Note** that this is only possible when constructing single services:
```js
cds.serve('CatalogService') .with (srv=>{...})
cds.serve('all') .with (srv=>{...})  //> error
```

**If omitted**, an implementation is resolved from annotation `@impl`, if present, or from a `.js` file with the same basename than the CDS model, for example:

```cds
service MyService @(impl:'cat-service.js'){...}
```

```sh
srv/cat-service.cds  #> CDS model with service definition
srv/cat-service.js   #> service implementation used by default
```



## cds. middlewares

For each service served at a certain protocol, the framework registers a configurable set of express middlewares by default like so:

```js
app.use (cds.middlewares.before, protocol_adapter)
```

The standard set of middlewares uses the following order:

```js
cds.middlewares.before = [
  context(),   // provides cds.context
  trace(),     // provides detailed trace logs when DEBUG=trace
  auth(),      // provides cds.context.user & .tenant
  ctx_model(), // fills in cds.context.model, in case of extensibility
]
```

::: warning _Be aware of the interdependencies of middlewares_ 
_ctx_model_ requires that _cds.context_ middleware has run before.
_ctx_auth_ requires that _authentication_ has run before.
:::


### . context() {.method}

This middleware initializes [cds.context](events#cds-context) and starts the continuation. It's required for every application.


### . trace() {.method}

The tracing middleware allows you to do a first-level performance analysis. It logs how much time is spent on which layer of the framework when serving a request.
To enable this middleware, you can set for example the [environment variable](cds-log#debug-env-variable) `DEBUG=trace`.


### . auth() {.method}

[By configuring an authentication strategy](./authentication#strategies), a middleware is mounted that fulfills the configured strategy and subsequently adds the user and tenant identified by that strategy to [cds.context](events#cds-context).


### . ctx_model() {.method}

It adds the currently active model to the continuation. It's required for all applications using extensibility or feature toggles.


### .add(mw, pos?) {.method}

Registers additional middlewares at the specified position.
`mw` must be a function that returns an express middleware.
`pos` specified the index or a relative position within the middleware chain. If not specified, the middleware is added to the end.

```js
cds.middlewares.add (mw, {at:0}) // to the front
cds.middlewares.add (mw, {at:2})
cds.middlewares.add (mw, {before:'auth'})
cds.middlewares.add (mw, {after:'auth'})
cds.middlewares.add (mw) // to the end
```

<div id="beforecustomization" />


### Custom Middlewares

The configuration of middlewares must be done programmatically before bootstrapping the CDS services, for example, in a [custom server.js](cds-serve#custom-server-js).

The framework exports the default middlewares itself and the list of middlewares which run before the protocol adapter starts processing the request.

```js
cds.middlewares = {
  auth,
  context,
  ctx_model,
  errors,
  trace,
  before = [
    context(),
    trace(),
    auth(),
    ctx_model()
  ]
}
```

In order to plug in custom middlewares, you can override the complete list of middlewares or extend the list programmatically.

::: warning
Be aware that overriding requires constant updates as new middlewares by the framework are not automatically taken over.
:::

[Learn more about the middlewares default order.](#cds-middlewares){.learn-more}

#### Customization of `cds.context.user`

You can register middlewares to customize `cds.context.user`.
It must be done after authentication.
If `cds.context.tenant` is manipulated as well, it must also be done before `cds.context.model` is set for the current request.

```js
cds.middlewares.before = [
  cds.middlewares.context(),
  cds.middlewares.trace(),
  cds.middlewares.auth(),
  function ctx_user (_,__,next) {
    const ctx = cds.context
    ctx.user.id = '<my-idp>' + ctx.user.id
    next()
  },
  cds.middlewares.ctx_model()
]
```

#### Enabling Feature Flags

You can register middlewares to customize `req.features`.
It must be done before `cds.context.model` is set for the current request.

```js
cds.middlewares.before = [
  cds.middlewares.context(),
  cds.middlewares.trace(),
  cds.middlewares.auth(),
  function req_features (req,_,next) {
    req.features = ['<feature-1>', '<feature-2>']
    next()
  },
  cds.middlewares.ctx_model()
]
```

[Learn more about Feature Vector Providers.](../guides/extensibility/feature-toggles#feature-vector-providers){.learn-more}


### Current Limitations

- Configuration of middlewares must be done programmatically.



## cds. protocols

The framework provides adapters for OData V4 and REST out of the box. In addition, GraphQL can be served by using our open source package [`@cap-js/graphql`](https://github.com/cap-js/graphql).

By default, the protocols are served at the following path:
|protocol|path|
|---|---|
|OData V4|/odata/v4|
|REST|/rest|
|GraphQL|/graphql|

### @protocol

Configures at which protocol(s) a service is served.

```cds
@odata
service CatalogService {}
//> serves CatalogService at: /odata/v4/catalog

@protocol: 'odata'
service CatalogService {}
//> serves CatalogService at: /odata/v4/catalog

@protocol: ['odata', 'rest', 'graphql']
service CatalogService {}
//> serves CatalogService at: /odata/v4/catalog, /rest/catalog and /graphql

@protocol: [{ kind: 'odata', path: 'some/path' }]
service CatalogService {}
//> serves CatalogService at: /odata/v4/some/path
```

Note, that
- the shortcuts `@rest`, `@odata`, `@graphql` are only supported for services served at only one protocol.
- `@protocol` has precedence over the shortcuts.
- `@protocol.path` has precedence over `@path`.
- the default protocol is OData V4.
- `odata` is a shortcut for `odata-v4`.
- `@protocol: 'none'` will treat the service as _internal_.

### @path

Configures the path at which a service is served.

```cds
@path: 'browse'
service CatalogService {}
//> serves CatalogService at: /odata/v4/browse

@path: '/browse'
service CatalogService {}
//> serves CatalogService at: /browse
```

Be aware that using an absolute path will disallow serving the service at multiple protocols.

### Custom Protocol Adapter

Similar to the configuration of the GraphQL Adapter, you can plug in your own protocol.
The `impl` property must point to the implementation of your protocol adapter.
Additional options for the protocol adapter are provided on the same level.

```js
cds.env.protocols = {
  'custom-protocol': { path: '/custom', impl: '<custom-impl.js>', ...options }
}
```

### Current Limitations

- Configuration of protocols must be done programmatically.
- Additional protocols do not respect `@protocol` annotation yet.
- The configured protocols do not show up in the `index.html` yet.



# Connecting to Required Services

Services frequently consume other services, which could be **local** services served by the same process, or **external** services, for example consumed through OData.
The latter include **database** services. In all cases use `cds.connect` to connect to such services, for example, from your:


## Connecting to Required Services { #cds-connect-to }



### cds. connect.to () {.method}

Use `cds.connect.to()` to connect to services configured in a project's `cds.requires` configuration.

```js
const ReviewsService = await cds.connect.to('ReviewsService')
```

The method returns a _Promise_ resolving to a _[Service](../cds/cdl#services)_ instance which acts as a client proxy to the service's API, allowing you to call its methods and access its data using common [`cds.Service`](core-services#consuming-services) methods, e.g.:

```js
let reviews = await ReviewsService.read ('Reviews')
```


**Arguments** are as follows:

```ts:no-line-numbers
async function cds.connect.to (
  name? : string,  // reference to an entry in `cds.requires` config
  options? : {
    kind : string  // reference to a preset in `cds.requires.kinds` config
    impl : string  // module name of the implementation
  }
) : Promise<Service>
```

Argument `name` is used to look up connect options from [configured services](#cds-env-requires), which are defined in the `cds.requires` section of your _package.json_ or _.cdsrc.json_ or _.yaml_ files.

Argument `options` also allows to pass additional options such as `credentials` programmatically, and thus create services without configurations and [service bindings](#service-bindings), for example, you could connect to a local SQLite database in your tests like this:

```js
const db2 = await cds.connect.to ({
  kind: 'sqlite', credentials: { url: 'db2.sqlite' }
})
```


### cds. services {#cds-connect-caching .property}

When connecting to a service using `cds.connect.to()`, the service instance is cached in [`cds.services`](cds-facade#cds-services) under the service name. This means that subsequent calls to `cds.connect.to()` with the same service name will all return the same instance. As services constructed by [`cds.serve`](cds-serve#cds-serve) are registered with [`cds.services`](cds-facade#cds-services) as well, a connect finds and returns them as local service connections.

You can also access cached service instance like this:

```js
const { ReviewsService } = cds.services
```

> Note: If _ad-hoc_ options are provided, the instance is not cached.



## Configuring Required Services {#cds-env-requires }

To configure required remote services in Node.js, simply add respective entries to the `cds.requires` sections in your _package.json_ or in _.cdsrc.json_ or _.yaml_. These configurations are constructed as follows:

::: code-group

```json [package.json]
{"cds":{
  "requires": {
    "db": { "kind": "sqlite", "credentials": { "url":"db.sqlite" }},
    "ReviewsService": {
      "kind": "odata", "model": "@capire/reviews"
    },
    "OrdersService": {
      "kind": "odata", "model": "@capire/orders"
    },
  }
}}
```

```yaml [.cdsrc.yaml]
cds:
  requires:
    db:
      kind: sqlite
      credentials:
        url: db.sqlite
    ReviewsService:
      kind: odata,
      model: @capire/reviews
    OrdersService:
      kind: odata,
      model: @capire/orders
```

:::

Entries in this section tell the service loader to not serve that service as part of your application, but expects a service binding at runtime in order to connect to the external service provider. The options are as follows:


### cds.requires.<i>\<srv\></i>`.impl`

Service implementations are ultimately configured in `cds.requires` like that:

```json
"cds": { "requires": {
  "some-service": { "impl": "some/node/module/path" },
  "another-service": { "impl": "./local/module/path" }
}}
```

Given that configuration, `cds.connect.to('some-service')` would load the specific service implementation from `some/node/module/path`.
Prefix the module path in `impl` with `./` to refer to a file relative to your project root.


### cds.requires.<i>\<srv\></i>`.kind`

As service configurations inherit from each other along `kind` chains, we can refer to default configurations shipped with `@sap/cds`, as you commonly see that in our [_cap/samples_](https://github.com/sap-samples/cloud-cap-samples), like so:

```json
"cds": { "requires": {
  "db": { "kind": "sqlite" },
  "remote-service": { "kind": "odata" }
}}
```

This is backed by these default configurations:

```json
"cds": { "requires": {
  "sqlite": { "impl": "[...]/sqlite/service" },
  "odata": { "impl": "[...]/odata/service" },
}}
```

> Run `cds env get requires` to see all default configurations.
> Run `cds env get requires.db.impl` to see the impl used for your database.

Given that configuration, `cds.connect.to('db')` would load the generic service implementation.

[Learn more about `cds.env`.](cds-env){.learn-more}


### cds.requires.<i>\<srv\></i>`.model`

Specify (imported) models for remote services in this property. This allows the service runtime to reflect on the external API and add generic features. The value can be either a single string referring to a CDS model source, resolved as absolute node module, or relative to the project root, or an array of such.

```json
"cds": { "requires": {
  "remote-service": { "kind": "odata", "model":"some/imported/model" }
}}
```

Upon [bootstrapping](./cds-serve), all these required models will be loaded and compiled into the effective [`cds.model`](cds-facade#cds-model) as well.


### cds.requires.<i>\<srv\></i>`.service`

If you specify a model, then a service definition for your required service must be included in that model. By default, the name of the service that is checked for is the name of the required service. This can be overwritten by setting `service` inside the required service configuration.

```json
"cds": { "requires": {
  "remote-service": { "kind": "odata", "model":"some/imported/model", "service": "BusinessPartnerService" }
}}
```

The example specifies `service: 'BusinessPartnerService'`, which results in a check for a service called `BusinessPartnerService` instead of `remote-service` in the model loaded from `some/imported/model`.




## Service Bindings {#service-bindings}

A service binding connects an application with a cloud service. For that, the cloud service's credentials need to be injected in the CDS configuration:

```jsonc
{
  "requires": {
    "db": {
      "kind": "hana",
      "credentials": { /* from service binding */ }
    }
  }
}
```


### cds.requires.<i>\<srv\></i>.credentials

All service binding information goes into this property. It's filled from the process environment when starting server processes, managed by deployment environments. Service bindings provide the details about how to reach a required service at runtime, that is, providing requisite credentials, most prominently the target service's `url`.


You specify the credentials to be used for a service by using one of the following:

- Process environment variables
- Command line options
- File system
- Auto binding

For example, in development, you can add them to a _.env_ file as follows:

```properties
# .env file
cds.requires.remote-service.credentials = { "url":"http://...", ... }
```

::: warning ❗ Never add secrets or passwords to _package.json_ or _.cdsrc.json_!
General rule of thumb: `.credentials` are always filled (and overridden) from process environment on process start.
:::



### Basic Mechanism {#bindings-via-cds-env}


The CAP Node.js runtime expects to find the service bindings in `cds.env.requires`.

1. Configured required services constitute endpoints for service bindings.

   ```json
   "cds": {
     "requires": {
       "ReviewsService": {...},
      }
   }
   ```

2. These are made available to the runtime via `cds.env.requires`.

   ```js
   const { ReviewsService } = cds.env.requires
   ```

3. Service Bindings essentially fill in `credentials` to these entries.

   ```js
   const { ReviewsService } = cds.env.requires
   ReviewsService.credentials = {
     url: "http://localhost:4005/reviews"
   }
   ```

The latter is appropriate in test suites. In productive code, you never provide credentials in a hard-coded way. Instead, use one of the options presented in the following sections.




### In Cloud Foundry {#bindings-in-cloud-platforms}

Find general information about how to configure service bindings in Cloud Foundry:

- [Deploying Services using MTA Deployment Descriptor](https://help.sap.com/docs/SAP_HANA_PLATFORM/4505d0bdaf4948449b7f7379d24d0f0d/33548a721e6548688605049792d55295.html)
- [Binding Service Instances to Cloud Foundry Applications](https://help.sap.com/docs/SERVICEMANAGEMENT/09cc82baadc542a688176dce601398de/0e6850de6e7146c3a17b86736e80ee2e.html)
- [Binding Service Instances to Applications using the Cloud Foundry CLI](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/296cd5945fd84d7d91061b2b2bcacb93.html)

Cloud Foundry uses auto configuration of service credentials through the `VCAP_SERVICES` environment variable.

[Learn more about environment variables on Cloud Foundry and `cf env`.](https://docs.cloudfoundry.org/devguide/deploy-apps/environment-variable.html){.learn-more}



#### Through `VCAP_SERVICES` env var {#vcap_services}

When deploying to Cloud Foundry, service bindings are provided in `VCAP_SERVICES` process environment variables, which is JSON-stringified array containing credentials for multiple services. The entries are matched to the entries in `cds.requires` as follows, in order of precedence:

1. The service's `name` is matched against the `name` property of `VCAP_SERVICE` entries
2. The service's `name` is matched against the `binding_name` property
3. The service's `name` is matched against entries in the `tags` array
4. The service's `kind` is matched against entries in the `tags` array
5. The service's `kind` is matched against the `label` property, for example, 'hana'
6. The service's `kind` is matched against the `type` property (The type property is only relevant for [servicebinding.io](https://servicebinding.io) bindings)
7. The service's `vcap.name` is matched against the `name` property

All the config properties found in the first matched entry will be copied into the <Config>cds.requires.\<srv\>.credentials</Config> property.

Here are a few examples:



<table class="no-stripes">
<thead>
<tr>
<th>CAP config</th>
<th>VCAP_SERVICES</th>
</tr>
</thead>
<tbody>
<tr >
<td >

```json
{
  "cds": {
    "requires": {
      "db": { ... }
    }
  }
}
```
</td>
<td >

```json
{
  "VCAP_SERVICES": {
    "hana": [{
      "name": "db", ...
    }]
  }
}
```
</td>
</tr>
<tr >
<td >

```json
{
  "cds": {
    "requires": {
      "db": { "kind": "hana" }
    }
  }
}
```
</td>
<td >

```json
{
  "VCAP_SERVICES": {
    "hana": [{
      "label": "hana", ...
    }]
  }
}
```
</td>
</tr>
<tr >
<td >

```json
{
  "cds": {
    "requires": {
      "db": {
        "vcap": { "name": "myDb" }
      }
    }
  }
}
```
</td>
<td >

```json
{
  "VCAP_SERVICES": {
    "hana": [{
      "name": "myDb",
      ...
    }]
  }
}
```
</td>
</tr>
</tbody>
</table>




### In Kubernetes / Kyma { #in-kubernetes-kyma}

CAP supports [servicebinding.io](https://servicebinding.io/) service bindings and SAP BTP service bindings created by the [SAP BTP Service Operator](https://github.com/SAP/sap-btp-service-operator).

1. Specify a root directory for all service bindings using `SERVICE_BINDING_ROOT` environment variable:

    ```yaml
    spec:
      containers:
      - name: bookshop-srv
        env:
        # ...
        - name: SERVICE_BINDING_ROOT
          value: /bindings
    ```

2. Create service bindings

    Use the `ServiceBinding` custom resource of the [SAP BTP Service Operator](https://github.com/SAP/sap-btp-service-operator) to create bindings to SAP BTP services:

    ```yaml
    apiVersion: services.cloud.sap.com/v1alpha1
    kind: ServiceBinding
    metadata:
      name: bookshop-xsuaa-binding
    spec:
      serviceInstanceName: bookshop-xsuaa-binding
      externalName: bookshop-xsuaa-binding
      secretName: bookshop-xsuaa-secret
    ```

    Bindings to other services need to follow the [servicebinding.io workload projection specification](https://servicebinding.io/spec/core/1.0.0-rc3/#workload-projection).

3. Mount the secrets of the service bindings underneath the root directory:

    ```yaml
    spec:
      containers:
      - name: bookshop-srv
        # ...
        volumeMounts:
        - name: bookshop-auth
          mountPath: "/bindings/auth"
          readOnly: true
      volumes:
      - name: bookshop-auth
        secret:
          secretName: bookshop-xsuaa-secret
    ```

    The `secretName` property refers to an existing Kubernetes secret, either manually created or by the `ServiceBinding` resource. The name of the sub directory (`auth` in the example) is recognized as the binding name.

CAP services receive their credentials from these bindings [as if they were provided using VCAP_SERVICES](#vcap_services).



#### Through environment variables {#env-service-bindings}

All values of a secret can be added as environment variables to a pod. A prefix can be prepended to each of the environment variables. To inject the values from the secret in the right place of your CDS configuration, you use the configuration path to the `credentials` object of the service as the prefix:

`cds_requires_<your service>_credentials_`

Please pay attention to the underscore ("`_`") character at the end of the prefix.

*Example:*

```yaml
  spec:
    containers:
    - name: app-srv
      # ...
      envFrom:
        - prefix: cds_requires_db_credentials_
          secretRef:
            name: app-db
```

::: warning
For the _configuration path_, you **must** use the underscore ("`_`") character as delimiter. CAP supports dot ("`.`") as well, but Kubernetes won't recognize variables using dots. Your _service name_ **mustn't** contain underscores.
:::


#### Through the file system {#file-system-service-bindings}

CAP can read configuration from a file system by specifying the root path of the configuration in the `CDS_CONFIG` environment variable.

Set `CDS_CONFIG` to the path that should serve as your configuration root, for example: `/etc/secrets/cds`.

Put the service credentials into a path that is constructed like this:

`<configuration root>/requires/<your service>/credentials`

Each file will be added to the configuration with its name as the property name and the content as the value. If you have a deep credential structure, you can add further sub directories or put the content in a file as a JSON array or object.

For Kubernetes, you can create a volume with the content of a secret and mount it on your container.

*Example:*

```yaml
  spec:
    volumes:
      - name: app-db-secret-vol
        secret:
          secretName: app-db
    containers:
    - name: app-srv
      # ...
      env:
        - name: CDS_CONFIG
          value: /etc/secrets/cds
      volumeMounts:
        - name: app-db-secret-vol
          mountPath: /etc/secrets/cds/requires/db/credentials
          readOnly: true
```

#### Provide Service Bindings (`VCAP_SERVICES`) {#provide-service-bindings}

If your application runs in a different environment than Cloud Foundry, the `VCAP_SERVICES` env variable is not available. But it may be needed by some libraries, for example the SAP Cloud SDK.

By enabling the CDS feature `features.emulate_vcap_services`, the `VCAP_SERVICES` env variable will be populated from your configured services.

For example, you can enable it in the _package.json_ file for your production profile:

```json
{
  "cds": {
    "features": {
      "[production]": {
        "emulate_vcap_services": true
      }
    }
  }
}
```

::: warning
This is a backward compatibility feature.<br> It might be removed in a next [major CAP version](../releases/schedule#yearly-major-releases).
:::

Each service that has credentials and a `vcap.label` property is put into the `VCAP_SERVICES` env variable. All properties from the service's `vcap` object will be taken over to the service binding.

The `vcap.label` property is pre-configured for some services used by CAP.

For example, for the XSUAA service you only need to provide credentials and the service kind:

```json
{
  "requires": {
    "auth": {
      "kind": "xsuaa",
      "credentials": {
        "clientid": "cpapp",
        "clientsecret": "dlfed4XYZ"
      }
    }
  }
}
```

The `VCAP_SERVICES` variable is generated like this:

```json
{
  "xsuaa": [
    {
      "label": "xsuaa",
      "tags": [ "auth" ],
      "credentials": {
        "clientid": "cpapp",
        "clientsecret": "dlfed4XYZ"
      }
    }
  ]
}
```

The generated value can be displayed using the command:

```sh
cds env get VCAP_SERVICES --process-env
```

A list of all services with a preconfigured `vcap.label` property can be displayed with this command:

```sh
cds env | grep vcap.label
```

You can include your own services by configuring `vcap.label` properties in your CAP configuration.

For example, in the _package.json_ file:

```json
{
  "cds": {
    "requires": {
      "myservice": {
        "vcap": {
          "label": "myservice-label"
        }
      }
    }
  }
}
```

The credentials can be provided in any supported way. For example, as env variables:

```sh
cds_requires_myservice_credentials_user=test-user
cds_requires_myservice_credentials_password=test-password
```

The resulting `VCAP_SERVICES` env variable looks like this:

```json
{
  "myservice-label": [
    {
      "label": "myservice-label",
      "credentials": {
        "user": "test-user",
        "password": "test-password"
      }
    }
  ]
}
```




### Through _.cdsrc-private.json_ File for Hybrid Testing

[Learn more about hybrid testing using _.cdsrc-private.json_.](../advanced/hybrid-testing#bind-to-cloud-services)

```json
{
  "requires": {
    "ReviewsService": {
      "credentials": {
        "url": "http://localhost:4005/reviews"
      }
    },
    "db": {
      "credentials": {
        "url": "db.sqlite"
      }
    }
  }
}
```

::: warning
Make sure that the _.cdsrc-private.json_ file is not checked into your project.
:::

### Through `process.env` Variables {#bindings-via-process-env}

You could pass credentials as process environment variables, for example in ad-hoc tests from the command line:

```sh
export cds_requires_ReviewsService_credentials_url=http://localhost:4005/reviews
export cds_requires_db_credentials_database=sqlite.db
cds watch fiori
```

#### In _.env_ Files for Local Testing

Add environment variables to a local _.env_ file for repeated local tests:

```properties
cds.requires.ReviewsService.credentials = { "url": "http://localhost:4005/reviews" }
cds.requires.db.credentials.database = sqlite.db
```
> Never check in or deploy such _.env_ files!

<div id="endofconnect" />
<Fragment target="#endofconnect">

## Typical Use Cases <Concept />

###  <i>  Service Reuse </i>

###  <i>  Service Integration </i>
###  <i>  Framework Services </i>


## Best Practices

###  <i>  Mocking Remote Services </i>

###  <i>  Local Integration Tests </i>
###  <i>  Late-Cut Micro Services </i>

</Fragment>



## Importing Service APIs



## Mocking Required Services

<div id="secondary-file">node.js/cds-connect.fragment.md</div>


# Application Services

## Class `cds.ApplicationService`

Class `cds.ApplicationService` is the default service provider implementation, adding generic handlers as introduced in the Cookbook guides on [Providing Services](../guides/providing-services), [Localized Data](../guides/localized-data.md) and [Temporal Data](../guides/temporal-data.md).

Take this service definition for example:

```cds
service AdminService {
  entity Authors as projection on my.Authors;
  entity Books as projection on my.Books;
  entity Genre as projection on my.Genre;
}
```

Without any custom service implementation in place, `cds.serve` would create and instantiate instances of `cds.ApplicationService` by default like so:

```js
// srv/admin-service.cds
let name = 'AdminService', options = {...}
let srv = new cds.ApplicationService (name, cds.model, options)
await srv.init()
```

If you add a custom implementation, this would comonly be derived from `cds.ApplicationService`:

```js
// srv/admin-service.js
const cds = require('@sap/cds')
module.exports = class AdminService extends cds.ApplicationService {
  init() {
    // register your handlers ...
    return super.init()
  }
}
```



### Generic Handlers in `srv.init()`

Generic handlers are registered by via respective class methods documented below in `cds.ApplicationService.prototype.init()` like so:

```tsx
class cds.ApplicationService extends cds.Service {
  init() {
    const generics = //... all static method with prefix 'handle_'
    for (let each of generics) this[each].call(this)
    return super.init()
  }
  static handle_authorization() {...}
  static handle_etags() {...}
  static handle_validations() {...}
  static handle_temporal_data() {...}
  static handle_localized_data() {...}
  static handle_managed_data() {...}
  static handle_paging() {...}
  static handle_fiori() {...}
  static handle_crud() {...}
}
```

> The reason we used `static` methods was to **(a)** give you an easy way of overriding and adding new generic handlers / features, and **(b)** without getting into conflicts with instance methods of subclasses.



### _static_ handle_authorization() {.method}

This method is adding request handlers for initial authorization checks, as documented in the [Authorization guide](../guides/security/authorization.md).



### _static_ handle_etags() {.method}

This method is adding request handlers for out-of-the-box concurrency control using ETags, as documented in the [Providing Services guide](../guides/providing-services#concurrency-control).



### _static_ handle_validations() {.method}

This method is adding request handlers for input validation based in `@assert` annotations, and other, as documented in the [Providing Services guide](../guides/providing-services#input-validation).




### _static_ handle_temporal_data() {.method}

This method is adding request handlers for handling temporal data, as documented in the [Temporal Data guide](../guides/temporal-data.md).




### _static_ handle_localized_data() {.method}

This method is adding request handlers for handling localized data, as documented in the [Localized Data guide](../guides/localized-data.md).




### _static_ handle_managed_data() {.method}

This method is adding request handlers for handling managed data, as documented in the [Providing Services guide](../guides/domain-modeling#managed-data).



### _static_ handle_paging() {.method}

This method is adding request handlers for paging & implicit sorting, as documented in the [Providing Services guide](../guides/providing-services#pagination-sorting).



### _static_ handle_fiori() {.method}

This method is adding request handlers for handling Fiori Drafts and other Fiori-specifics, as documented in the [Serving Fiori guide](../advanced/fiori.md).



### _static_ handle_crud() {.method}

This method is adding request handlers for all CRUD operations including *deep* CRUD, as documented in the [Providing Services guide](../guides/providing-services#generic-providers).



## Overriding Generic Handlers

You can override some of these methods in subclasses, for example to skip certain generic features, or to add additional ones. For example like that:

```js
class YourService extends cds.ApplicationService {
  static handle_validations() {
    // Note: this is an instance of YourService here:
    this.on('CREATE','*', req => {...})
    return super.handle_validations()
  }
}
```

>

## Adding Generic Handlers

You can also add own sets of generic handlers to all instances of `cds.ApplicationService`, and subclasses thereof, by simply adding a new class method prefixed with `handle_` like so:

```js
const cds = require('@sap/cds')
cds.ApplicationService.handle_log_events = cds.service.impl (function(){
  this.on('*', req => console.log(req.event))
})
```

<div id="secondary-file">node.js/app-services.fragment.md</div>


# Remote Services <Concept />

Class `cds.RemoteService` is a service proxy class to consume remote services via different [protocols](/node.js/cds-serve#cds-protocols), like OData or plain REST.

## cds.**RemoteService**  <i>  class </i> { #cds-remote-service}

### class cds.**RemoteService** <i>  extends cds.Service </i>

## cds.RemoteService — Configuration {#remoteservice-configuration }
[remoteservice configuration]: #remoteservice-configuration

The `cds.RemoteService` configuration allows you to define various options for connecting to remote services.





### CSRF-Token Handling

If the remote system you want to consume requires it, you can enable the new CSRF-token handling of `@sap-cloud-sdk/core` via configuration options `csrf` and `csrfInBatch`. These options allow to configure CSRF-token handling for each remote service separately.

#### Basic Configuration

```json
"cds": {
    "requires": {
        "API_BUSINESS_PARTNER": {
            "kind": "odata",
            "model": "srv/external/API_BUSINESS_PARTNER",
            "csrf": true,
            "csrfInBatch": true
        }
    }
}
```

In this example, CSRF handling is enabled for the `API_BUSINESS_PARTNER` service, for regular requests (`csrf: true`) and requests made within batch operations (`csrfInBatch: true`).

#### Advanced Configuration

Actually `csrf: true` is a convenient preset. If needed, you can further customize the CSRF-token handling with additional parameters:

```json
"cds": {
    "requires": {
        "API_BUSINESS_PARTNER": {
            ...
            "csrf": {  // [!code focus]
              "method": "get",  // [!code focus]
              "url": "..."  // [!code focus]
            }
        }
    }
}
```

Here, the CSRF-token handling is customized at a more granular level:

 - `method`: The HTTP method for fetching the CSRF token. The default is `head`.
 - `url`: The URL for fetching the CSRF token. The default is the resource path without parameters.

### Timeout Handling

The `requestTimeout` setting in the `cds.RemoteService` configuration specifies the maximum duration, in milliseconds
(default: 60000), to wait for a response from the remote service before timing out.


#### Configuration Option

```json
{
  "API_BUSINESS_PARTNER": {
    "kind": "odata",
    "credentials": {
      ...
      "requestTimeout": 1000000 // [!code focus]
    }
  }
}
```

::: tip
See [Using Destinations](../guides/using-services#using-destinations) for more details on destination configuration.
:::

##  <i>  More to Come </i>

This documentation is not complete yet, or the APIs are not released for general availability. There's more to come in this place in upcoming releases.



# Messaging

{{$frontmatter?.synopsis}}

## cds.**MessagingService**  <i>  class </i>

  Class `cds.MessagingService` and subclasses thereof are technical services representing asynchronous messaging channels.
  They can be used directly/low-level, or behind the scenes on higher-level service-to-service eventing.

### class cds.**MessagingService**  <i>  extends cds.Service </i>

## Declaring Events

In your CDS model, you can model events using the `event` keyword inside services.
Once you created the `messaging` section in `cds.requires`, all modeled events are automatically enabled for messaging.

You can then use the services to emit events (for your own service) or receive events (for external services).

Example:

In your _package.json_:

```json
{
  "cds": {
    "requires": {
      "ExternalService": {
        "kind": "odata",
        "model": "srv/external/external.cds"
      },
      "messaging": {
        "kind": "enterprise-messaging"
      }
    }
  }
}
```

In _srv/external/external.cds_:

```cds
service ExternalService {
    event ExternalEvent {
        ID: UUID;
        name: String;
    }
}
```

In _srv/own.cds_:

```cds
service OwnService {
    event OwnEvent {
        ID: UUID;
        name: String;
    }
}
```

In _srv/own.js_:

```js
module.exports = async srv => {
  const externalService = await cds.connect.to('ExternalService')
  externalService.on('ExternalEvent', async msg => {
    await srv.emit('OwnEvent', msg.data)
  })
}
```

#### Custom Topics with Declared Events

You can specify topics to modeled events using the `@topic` annotation.
::: tip
If no annotation is provided, the topic will be set to the fully qualified event name.
:::

Example:

```cds
service OwnService {
    @topic: 'my.custom.topic'
    event OwnEvent { ID: UUID; name: String; }
}
```


## Emitting Events

To send a message to the message broker, you can use the `emit` method on a transaction for the connected service.

Example:

```js
const messaging = await cds.connect.to('messaging')

this.after(['CREATE', 'UPDATE', 'DELETE'], 'Reviews', async (_, req) => {
  const { subject } = req.data
  const { rating } = await cds.run(
    SELECT.one(['round(avg(rating),2) as rating'])
    .from(Reviews)
    .where({ subject }))

  // send to a topic
  await messaging.emit('cap/msg/system/review/reviewed',
   { subject, rating })

  // alternative if you want to send custom headers
  await messaging.emit({ event: 'cap/msg/system/review/reviewed',
    data: { subject, rating },
    headers: { 'X-Correlation-ID': req.headers['X-Correlation-ID'] }})
})
```
::: tip
The messages are sent once the transaction is successful.
Per default, a persistent queue is used. See [Messaging - Queue](./queue) for more information.
:::

## Receiving Events

To listen to messages from a message broker, you can use the `on` method on the connected service.
This also creates the necessary topic subscriptions.

Example:

```js
const messaging = await cds.connect.to('messaging')

// listen to a topic
messaging.on('cap/msg/system/review/reviewed', msg => {
  const { subject, rating } = msg.data
  return cds.run(UPDATE(Books, subject).with({ rating }))
})
```

Once all handlers are executed successfully, the message is acknowledged.
If one handler throws an error, the message broker will be informed that the message couldn't be consumed properly and might send the message again. To avoid endless cycles, consider catching all errors.

If you want to receive all messages without creating topic subscriptions, you can register on `'*'`. This is useful when consuming messages from a dead letter queue.

```js
messaging.on('*', async msg => { /*...*/ })
```

::: tip
In general, messages do not contain user information but operate with a technical user. As a consequence, the user of the message processing context (`cds.context.user`) is set to [`cds.User.privileged`](/node.js/authentication#privileged-user) and, hence, any necessary authorization checks must be done in custom handlers.
:::

### Inbox <Beta />

You can store received messages in an inbox before they're processed. Under the hood, it uses the [task queue](./queue) for reliable asynchronous processing.
Enable it by setting the `inboxed` option to `true`, for example:

```js
{
  cds: {
    requires: {
      messaging: {
        kind: 'enterprise-messaging',
        inboxed: true
      }
    }
  }
}
```

## CloudEvents Protocol

[CloudEvents](https://cloudevents.io/) is a commonly used specification for describing event data.

An example event looks like this:

```js
{
  "type": "sap.s4.beh.salesorder.v1.SalesOrder.Created.v1",
  "specversion": "1.0",
  "source": "/default/sap.s4.beh/ER9CLNT001",
  "id": "0894ef45-7741-1eea-b7be-ce30f48e9a1d",
  "time": "2020-08-14T06:21:52Z",
  "datacontenttype": "application/json",
  "data": {
    "SalesOrder":"3016329"
  }
}
```

To help you adhere to this standard, CAP prefills these header fields automatically.
To enable this, you need to set the option `format: 'cloudevents'` in your message broker.

Example:

```js
{
  cds: {
    requires: {
      messaging: {
        kind: 'enterprise-messaging-shared',
        format: 'cloudevents'
      }
    }
  }
}
```

You can always overwrite the default values.

### Topic Prefixes

If you want the topics to start with a certain string, you can set a publish and/or a subscribe prefix in your message broker.

Example:

```js
{
  cds: {
    requires: {
      messaging: {
        kind: 'enterprise-messaging-shared',
        publishPrefix: 'default/sap.cap/books/',
        subscribePrefix: 'default/sap.cap/reviews/'
      }
    }
  }
}
```

### Topic Manipulations

<span id="beforeeventmesh" />
<Fragment target="#beforeeventmesh">

#### [SAP Message Queuing](../guides/messaging/event-mesh#sap-message-queuing) <Internal />

Dots are replaced by slashes.

Example:

`my.custom.topic` is changed to `my/custom/topic`.

</Fragment>

#### [SAP Event Mesh](../guides/messaging/#sap-event-mesh)

If you specify your format to be `cloudevents`, the following default prefixes are set:

```js
{
  publishPrefix: '$namespace/ce/',
  subscribePrefix: '+/+/+/ce/'
}
```

In addition to that, slashes in the event name are replaced by dots and the `source` header field is derived based on `publishPrefix`.

Examples:

| publishPrefix            | derived source      |
|--------------------------|---------------------|
| `my/own/namespace/ce/`   | `/my/own/namespace` |
| `my/own.namespace/-/ce/` | `/my/own.namespace` |


## Message Brokers

To safely send and receive messages between applications, you need a message broker in-between where you can create queues that listen to topics. All relevant incoming messages are first stored in those queues before they're consumed. This way messages aren't lost when the consuming application isn't available.

In CDS, you can configure one of the available broker services in your [`requires` section](cds-connect#cds-env-requires).

According to our [grow as you go principle](../about/#grow-as-you-go), it makes sense to first test your application logic without a message broker and enable it later. Therefore, we provide support for [local messaging](#local-messaging) (if everything is inside one Node.js process) as well as [file-based messaging](#file-based).

### Configuring Message Brokers

You must provide all necessary credentials by [binding](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/296cd5945fd84d7d91061b2b2bcacb93.html) the message broker to your app.

For local environments, use [`cds bind`](../advanced/hybrid-testing#cds-bind-usage) in a [hybrid setup](../guides/messaging/event-mesh#run-tests-in-hybrid-setup).

::: tip
For local testing use [`kind`: `enterprise-messaging-shared`](#event-mesh-shared) to avoid the complexity of HTTP-based messaging.
:::

### SAP Event Mesh (Shared) { #event-mesh-shared}

`kind`: `enterprise-messaging-shared`

Use this if you want to communicate using [SAP Event Mesh](https://help.sap.com/docs/SAP_EM/bf82e6b26456494cbdd197057c09979f/df532e8735eb4322b00bfc7e42f84e8d.html) in a shared way.

If you register at least one handler, a queue will automatically be created if not yet existent. Keep in mind that unused queues aren't automatically deleted, this has to be done manually.

You have the following configuration options:

- `queue`: An object containing the `name` property as the name of your queue, additional properties are described [in the SAP Business Accelerator Hub](https://hub.sap.com/api/SAPEventMeshDefaultManagementAPIs/path/putQueue).
- `amqp`: AQMP client options as described in the [`@sap/xb-msg-amqp-v100` documentation](https://www.npmjs.com/package/@sap/xb-msg-amqp-v100?activeTab=readme)

If the queue name isn't specified, it's derived from `application_name` and the first four characters of `application_id` of your `VCAP_APPLICATION` environmental variable, as well as the `namespace` property of your SAP Event Mesh binding in `VCAP_SERVICES`: `{namespace}/{application_name}/{truncated_application_id}`.
This makes sure that every application has its own queue.

Example:

```json
{
    "requires": {
        "messaging": {
            "kind": "enterprise-messaging-shared",
            "queue": {
               "name": "my/enterprise/messaging/queue",
               "accessType": "EXCLUSIVE",
               "maxMessageSizeInBytes": 19000000
            },
            "amqp": {
              "incomingSessionWindow": 100
            }
        }
    }
}
```

::: warning _❗ Warning_
When using `enterprise-messaging-shared` in a multitenant scenario, only the provider account will have an event bus. There is no tenant isolation.
:::

::: tip
You need to install the latest version of the npm package `@sap/xb-msg-amqp-v100`.
:::

::: tip
For optimal performance, you should set the correct access type.
To make sure your server is not flooded with messages, you should set the incoming session window.
:::

### SAP Event Mesh

`kind`: `enterprise-messaging`

This is the same as `enterprise-messaging-shared` except that messages are transferred through HTTP. For incoming messages, a webhook is used.

Compared to `enterprise-messaging-shared` you have the additional configuration option:
- `webhook`: An object containing the `waitingPeriod` property as the time in milliseconds until a webhook is created after the application is listening to incoming HTTP requests (default: 5000). Additional properties are described in the `Subscription` object in [SAP Event Mesh - REST APIs Messaging](https://help.sap.com/doc/3dfdf81b17b744ea921ce7ad464d1bd7/Cloud/en-US/messagingrest-api-spec.html).

Example:

```json
{
    "requires": {
        "messaging": {
            "kind": "enterprise-messaging",
            "queue": {
               "name": "my/enterprise/messaging/queue",
               "accessType": "EXCLUSIVE",
               "maxMessageSizeInBytes": 19000000
            },
            "webhook": {
              "waitingPeriod": 7000
            }
        }
    }
}

```




















If your server is authenticated using [XSUAA](authentication#jwt), you need to grant the scope `$XSAPPNAME.emcallback` to SAP Event Mesh for it to be able to trigger the handshake and send messages.

::: code-group
```js [xs-security.json]
{
  ...,
  "scopes": [
    ...,
    {
      "name": "$XSAPPNAME.emcallback",
      "description": "Event Mesh Callback Access",
      "grant-as-authority-to-apps": [
        "$XSSERVICENAME(<SERVICE_NAME_OF_YOUR_EVENT_MESH_INSTANCE>)"
      ]
    }
  ]
}
```
:::

Make sure to add this to the service descriptor of your SAP Event Mesh instance:

```js
{
  ...,
  "authorities": [
    "$ACCEPT_GRANTED_AUTHORITIES"
  ]
}
```
::: warning
This will not work in the `dev` plan of SAP Event Mesh.
:::

::: warning
If you enable the [cors middleware](https://www.npmjs.com/package/cors), [handshake requests](https://help.sap.com/docs/SAP_EM/bf82e6b26456494cbdd197057c09979f/6a0e4c77e3014acb8738af039bd9df71.html?q=handshake) from SAP Event Mesh might be intercepted.
:::

<span id="aftereventmesh" />
<Fragment target="#aftereventmesh">

#### Multitenancy with SAP Event Mesh <Internal /> {#multitenancy-event-mesh}

::: warning
SAP Event Mesh deprecated its multitenancy capability for new stakeholders, see [Getting Started with Event Mesh (default plan) in the SaaS context](https://wiki.one.int.sap/wiki/x/kUIAgQ).
:::

1. Set the property `instanceType` to `reuse` in the service descriptor of your SAP Event Mesh instance:

    ```js
    {
      ...,
      "instanceType": "reuse"
    }
    ```

2. Enable [multitenancy](../guides/multitenancy/?impl-variant=java). If you listen to topics, SAP Event Mesh is automatically added to the subscription dependencies.
When a tenant subscribes, the needed artifacts are automatically deployed to the tenant's event bus and undeployed if the tenant unsubscribes.

Since it can take up to 10 minutes to start an event bus, you must tell the SaaS provisioning service to perform an asynchronous subscription call:

```json
{
  "xsappname": "[...]",
  "appUrls": {
    "getDependencies": "https://[...]/mtx/v1/provisioning/dependencies",
    "onSubscription": "https://[...]/mtx/v1/provisioning/tenant/{tenantId}",
    "onSubscriptionAsync": true,
    "callbackTimeoutMillis": 600000
  }
}
```

To allow manual deployments of messaging artifacts across all subscribed tenants, you can use the scope `$XSAPPNAME.emmanagement`. Adding it to the `authorities` section will allow you to run a deployment task on Cloud Foundry.

::: code-group

```js [xs-security.json]
{
  ...,
  "scopes": [
    ...,
    {
      "name": "$XSAPPNAME.emmanagement",
      "description": "Event Mesh Management Access"
    }
  ],
  "role-templates": [
    {
      "name": "emmanagement",
      "description": "Event Mesh Management Access",
      "scope-references": ["$XSAPPNAME.emmanagement"],
      "attribute-references": []
    }
  ],
  "authorities": [
    "$XSAPPNAME.emmanagement"
  ]
}

```

:::




```sh
cf run-task <YOUR_APP> "node node_modules/@sap/cds/tasks/enterprise-messaging-deploy.js"
```

If you assign the role `emmanagement` to your user, you can trigger the deployment endpoint manually:

```http
POST <APP_URL>/messaging/enterprise-messaging/deploy HTTP/1.1
Content-Type: application/json

{
  "tenants": ["<TENANT_ID_1>", ...], // or ["all"] (default: ["all"])
  "queues": ["<QUEUE_NAME_1>", ...] // or ["all"] (default: ["all"])
}
```

::: tip
In environments like Cloud Foundry, it takes some time until the route of the application is accessible from outside. If a webhook is created too early, its handshake-request will not reach the application, therefore make sure that `webhook.waitingPeriod` is high enough.
:::

::: tip
If you want to receive messages on your local computer, you need to provide an app URI, which is accessible by SAP Event Mesh through the environment variable `VCAP_APPLICATION.application_uris[0]`. You can achieve this by creating a tunnel from the public internet to the respective port of your local machine.
:::

</Fragment>

### SAP Cloud Application Event Hub { #event-broker }

`kind`: `event-broker`

Use this if you want to communicate using [SAP Cloud Application Event Hub](https://help.sap.com/docs/event-broker).

The integration with SAP Cloud Application Event Hub is provided using the plugin [`@cap-js/event-broker`](https://github.com/cap-js/event-broker).
Please see the plugin's [setup guide](https://github.com/cap-js/event-broker/blob/main/README.md#setup) for more details.

### SAP Integration Suite, Advanced Event Mesh <Beta /> 
{ #advanced-event-mesh }

`kind`: `advanced-event-mesh`

Use this if you want to communicate using [SAP Integration Suite, advanced event mesh](https://help.sap.com/docs/event-broker).

The integration with SAP Integration Suite, advanced event mesh is provided using the plugin [`@cap-js/advanced-event-mesh`](https://github.com/cap-js/advanced-event-mesh).
Please see the plugin's [setup guide](https://github.com/cap-js/advanced-event-mesh/blob/main/README.md#setup) for more details.

<div id="queuing-sap" />
<Fragment target="#queuing-sap">

### SAP Message Queuing <Internal />

`kind`: `message-queuing`

Use this if you want to communicate using [SAP BTP Message Queuing](https://wiki.one.int.sap/wiki/display/CoCo/Message+Queuing+-+Message+Broker+as+a+Service+@+SAP).

You have the following configuration options:

- `queue`: An object containing the `name` property as the name of your queue as well as additional properties described in the [API specification](https://github.wdf.sap.corp/PubSubBroker/ssb-management/tree/master/docs/public/management-api-spec-v1.yaml#L368).
- `amqp`: AQMP client options as described in the [`@sap/xb-msg-amqp-v100`](https://www.npmjs.com/package/@sap/xb-msg-amqp-v100?activeTab=readme) documentation.

If the queue name isn't specified, it's derived from `application_name` and the first 4 characters of `application_id` of your `VCAP_APPLICATION` environmental variable: `{application_name}/{truncated_application_id}`.
This makes sure that every application has its own queue.

If you register a handler, a queue will automatically be created if not yet existent.
Keep in mind that unused queues aren't automatically removed, this has to be done manually.
::: tip
You need to install the latest version of the npm package `@sap/xb-msg-amqp-v100`.
:::

::: warning No automatic tenant isolation in multitenant scenario
When using `message-queuing` in a multitenant scenario, only the provider account will have an event bus. There is no automatic tenant isolation and developers are responsible to propagate the tenant id, for example via headers, and to [set the right context](../node.js/cds-tx#setting-contexts).
:::

</Fragment>

<div id="kafka-sap" />
<Fragment target="#kafka-sap">

### Apache Kafka <Internal />

`kind`: `kafka`

Use this if you want to communicate using [Apache Kafka on BTP](https://wiki.one.int.sap/wiki/display/HCPBD/Kafka).

You have the following configuration options:

- `topic`: The Kafka topic to use, the default is `"cds.default"`.
- `local`: `true` if the [locally-running Apache Kafka instance](https://wiki.one.int.sap/wiki/display/HCPBD/Getting+Started+With+Kafka#GettingStartedWithKafka-HowcanIdevelopagainstyourKafkaserviceonmylaptop?) shall be used, the default is `false`.

Tenant isolation is achieved via the message header `x-sap-cap-tenant-id`.

::: tip
You need to install the npm package `kafkajs`.
:::

</Fragment>

### Redis PubSub <Beta />
::: warning
This is a beta feature. Beta features aren't part of the officially delivered scope that SAP guarantees for future releases.
:::

`kind`: `redis-messaging`

Use [Redis PubSub](https://redis.io/) as a message broker.

There are no queues:
- Messages are lost when consumers are not available.
- All instances receive the messages independently.

::: warning No tenant isolation in multitenant scenario
When using `redis-messaging` in a multitenant scenario, only the provider account will have an event bus. There is no tenant isolation.
:::

::: tip
You need to install the latest version of the npm package `redis`.
:::


### File Based

`kind`: `file-based-messaging`

Don't use this in production, only if you want to test your application _locally_. It creates a file and uses it as a simple message broker.

>You can have at most one consuming app per emitted event.

You have the following configuration options:
* `file`: You can set the file path (default is _~/.cds-msg-box_).

Example:

```json
{
    "requires": {
        "messaging": {
            "kind": "file-based-messaging",
            "file": "../msg-box"
        }
    }
}
```

::: warning No tenant isolation in multitenant scenario
When using `file-based-messaging` in a multitenant scenario, only the provider account will have an event bus. There is no tenant isolation.
:::


### Local Messaging

`kind`: `local-messaging`

You can use local messaging to communicate inside one Node.js process. It's especially useful in your automated tests.

### Composite-Messaging

`kind`: `composite-messaging`

If you have several messaging services and don't want to mention them explicitly in your code, you can create a `composite-messaging` service where you can define routes for incoming and outgoing messages. In those routes, you can use glob patterns to match topics (`**` for any number of any character, `*` for any number of any character except `/` and `.`, `?` for a single character).

Example:

```json
{
  "requires": {
    "messaging": {
      "kind": "composite-messaging",
      "routes": {
        "myEnterpriseMessagingReview": ["cap/msg/system/review/*"],
        "myEnterpriseMessagingBook": ["**/book/*"]
      }
    },
    "myEnterpriseMessagingReview": {
      "kind": "enterprise-messaging",
      "queue": {
        "name": "cap/msg/system/review"
      }
    },
    "myEnterpriseMessagingBook": {
      "kind": "enterprise-messaging",
      "queue": {
        "name": "cap/msg/system/book"
      }
    }
  }
}
```

```js
module.exports = async srv => {
  const messaging = await cds.connect.to('messaging')

  messaging.on('book/repository/book/modified', msg => {
    // comes from myEnterpriseMessagingBook
  })

  messaging.on('cap/msg/system/review/reviewed', msg => {
    // comes from myEnterpriseMessagingReview
  })
}
```

<div id="secondary-file">node.js/messaging.fragment.md</div>


# Database Services

<div v-html="$frontmatter?.synopsis" />

## cds.**DatabaseService**  <i>  class </i> { #cds-db-service}

### class cds.**DatabaseService**  <i>  extends cds.Service </i>




### <span>srv</span>.begin <i> () → this </i> {#db-begin }

In case of database services this actually starts the transaction by acquiring a physical connection from the connection pool, and optionally sends a command to the database like `BEGIN TRANSACTION`.

This method is called automatically by the framework on the first query, so **you never have to call it** in application coding. There are only very rare cases where you'd want to do so, for example to reuse a `tx` object to start subsequent physical transactions after a former `commit` or `rollback`. But this is not considered good practice.


## cds.DatabaseService — Consumption {#databaseservice-consumption }
[databaseservice consumption]: #databaseservice-consumption





### `InsertResult` (Beta)

- On INSERT, DatabaseServices return an instance of `InsertResult` defined as follows:
  - Iterator that returns the keys of the created entries, for example:
    - Example: `[...result]` -> `[{ ID: 1 }, { ID: 2 }, ...]`
    - In case of `INSERT...as(SELECT...)`, the iterator returns `{}` for each row
  - `affectedRows`: the number inserted (root) entries or the number of affectedRows in case of INSERT into SELECT
  - `valueOf()`: returns `affectedRows` such that comparisons like `result > 0` can be used
    ::: tip
    `===` can't be used as it also compares the type
    :::


## cds.DatabaseService — Configuration {#databaseservice-configuration }
[databaseservice configuration]: #databaseservice-configuration

### Pool

Instead of opening and closing a database connection for every request, we use a pool to reuse connections.
By default, the following [pool configuration](https://www.npmjs.com/package/generic-pool) is used:

```json
{
  "acquireTimeoutMillis": <if (NODE_ENV='production') 1000 else 10000>,
  "evictionRunIntervalMillis": <2 * (idleTimeoutMillis || softIdleTimeoutMillis || 30000)>,
  "min": 0,
  "max": 100,
  "numTestsPerEvictionRun": <(max - min) / 3>,
  "softIdleTimeoutMillis": 30000,
  "idleTimeoutMillis": 30000,
  "testOnBorrow": true,
  "fifo": false
}
```

::: warning
This default pool configuration does not apply to `@cap-js` database implementations.
:::

The _generic-pool_ has a built-in pool evictor, which inspects idle database connections in the pool and destroys them if they are too old.

The following parameters are provided in the pool configuration:

- _acquireTimeoutMillis_: The parameter specifies how much time it is allowed to wait an existing connection is fetched from the pool or a new connection is established.
- _evictionRunIntervalMillis_: The parameter specifies how often to run eviction checks. In case of 0 the check is not run.
- _min_: Minimum number of database connections to keep in pool at any given time.
  ::: warning
  This should be kept at the default 0. Otherwise every eviction run destroys all unused connections older than `idleTimeoutMillis` and afterwards creates new connections until `min` is reached.
  :::

- _max_: Maximum number of database connections to keep in pool at any given time.
- _numTestsPerEvictionRun_: Number of database connections to be checked with one eviction run.
- _softIdleTimeoutMillis_: Amount of time database connection may sit idle in the pool before it is eligible for eviction. At least "min" connections should stay in the pool. In case of -1 no connection can get evicted.
- _idleTimeoutMillis_: The minimum amount of time that a database connection may stay idle in the pool before it is eligible for eviction due to idle time.
This parameter supercedes softIdleTimeoutMillis.
- _testOnBorrow_: Should the pool validate the database connections before giving them to the clients?
- _fifo_: If false, the most recently released resources will be the first to be allocated (stack). If true, the oldest resources will be first to be allocated (queue). Default value: false.

Pool configuration can be adjusted by setting the `pool` option as shown in the following example:

```json
{
  "cds": {
    "requires": {
      "db": {
        "kind": "hana",
        "pool": {
          "acquireTimeoutMillis": 5000,
          "min": 0,
          "max": 100,
          "fifo": true
        }
      }
    }
  }
}
```

::: warning _❗ Warning_
The parameters are very specific to the current technical setup, such as the application environment and database location.
Even though we provide a default pool configuration, we expect that each application provides its own configuration based on its specific needs.
:::



<div id="afterpool" />
<Fragment target="#afterpool">


### TCP keepalive with `hdb` <Beta />

Starting with version `^0.18.3`, the SAP HANA driver `hdb` allows to [configure TCP keepalive behaviour](https://github.com/SAP/node-hdb#tcp-keepalive).
You can set `tcpKeepAliveIdle` on the connection using the environment variable `HDB_TCP_KEEP_ALIVE_IDLE`.
Valid values are a positive number or `false`.
> As the setting must be injected into the credentials that may be received from an external source, for example in the case of multitenancy, the easiest way to do this is via the environment.

</Fragment>


## cds.DatabaseService — UPSERT {#databaseservice-upsert }
[databaseservice upsert]: #databaseservice-upsert




The main use case of upsert is data replication. [Upsert](../cds/cqn.md#upsert) updates existing entity records from the given data or inserts new ones if they don't exist in the database.

::: warning
Even if an entity doesn't exist in the database:<br> &rarr; Upsert is **not** equivalent to Insert.
:::

`UPSERT` statements can be created with the [UPSERT](cds-ql#upsert) query API:

```js
UPSERT.into('db.Books')
  .entries({ ID: 4711, title: 'Wuthering Heights', stock: 100 })
```

`UPSERT` queries are translated into DB native upsert statements, more specifically they unfold to an [UPSERT SQL statement](https://help.sap.com/docs/HANA_CLOUD_DATABASE/c1d3f60099654ecfb3fe36ac93c121bb/ea8b6773be584203bcd99da76844c5ed.html) on SAP HANA and to an [INSERT ON CONFLICT SQL statement](https://www.sqlite.org/lang_upsert.html) on SQLite.

- The rows to be upserted need to have the same structure, that is, all rows needs to specify the same named values.
- The upsert data must contain all key elements of the entity.
- If upsert data is incomplete only the given values are updated or inserted, which means the `UPSERT` statement has "PATCH semantics".
- `UPSERT` statements don't have a where clause. The key values of the entity that is upserted are extracted from the data.

The following actions are *not* performed on upsert:
 * UUID key values are _not generated_.
 * Generic CAP handlers, such as audit logging, are not invoked.

::: warning
In contrast to the Java runtime, deep upserts and delta payloads are not yet supported.
:::

##  <i>  More to Come </i>

This documentation is not complete yet, or the APIs are not released for general availability.
Stay tuned to upcoming releases for further updates.

<div id="secondary-file">node.js/databases.fragment.md</div>



# Fiori Support

See [Cookbook > Serving UIs > Draft Support](../advanced/fiori#draft-support) for an overview on SAP Fiori Draft support in CAP.

## Lean Draft

Lean draft is a new approach which makes it easier to differentiate between drafts and active instances in your code. This new architecture drastically reduces the complexity.

### Handlers Registration {#draft-support}

Class `ApplicationService` provides built-in support for Fiori Draft. All CRUD events are supported for both, active and draft entities.
Please note that draft-enabled entities must follow a specific draft choreography.

The examples are provided for `.on` handlers, but the same is true for `.before` and `.after` handlers.

  ```js
  // only active entities
  srv.on(['CREATE', 'READ', 'UPDATE', 'DELETE'], 'MyEntity', /*...*/)
  // only draft entities
  srv.on(['CREATE', 'READ', 'UPDATE', 'DELETE'], 'MyEntity.drafts', /*...*/)
  // bound action/function on active entity
  srv.on('boundActionOrFunction', 'MyEntity', /*...*/)
  // bound action/function on draft entity
  srv.on('boundActionOrFunction', 'MyEntity.drafts', /*...*/)
  ```

It's also possible to use the array variant to register a handler for both entities, for example: `srv.on('boundActionOrFunction', ['MyEntity', 'MyEntity.drafts'], /*...*/)`.

:::warning Bound actions/functions modifying active entity instances
If a bound action/function modifies an active entity instance, custom handlers need to take care that a draft entity doesn't exist, otherwise all changes are overridden when saving the draft.
:::

Additionally, you can add your logic to the draft-specific events as follows:

  ```js
  // When a new draft is created
  srv.on('NEW', 'MyEntity.drafts', /*...*/)
  // When a draft is discarded
  srv.on('CANCEL', 'MyEntity.drafts', /*...*/)
  // When a new draft is created from an active instance
  srv.on('EDIT', 'MyEntity', /*...*/)
  // When the active entity is changed
  srv.on('SAVE', 'MyEntity', /*...*/)
  ```

- The `CANCEL` event is triggered when you cancel the draft. In this case, the draft entity is deleted and the active entity isn't changed.
- The `EDIT` event is triggered when you start editing an active entity. As a result `MyEntity.drafts` is created.
- The `SAVE` event is just a shortcut for `['UPDATE', 'CREATE']` on an active entity. This event is also triggered when you press the `SAVE` button in UI after finishing editing your draft. Note, that composition children of the active entity will also be updated or created.

### Draft Locks

To prevent inconsistency, the entities with draft are locked for modifications by other users. The lock is released when the draft is saved, canceled or a timeout is hit. The default timeout is 15 minutes. You can configure this timeout by the following application configuration property:

```properties
cds.fiori.draft_lock_timeout=30min
```

You can set the property to one of the following:
- number of hours like `'1h'` 
- number of minutes like `'10min'`
- number of milliseconds like `1000`

:::tip Delete released draft locks
If the `draft_lock_timeout` has been reached, every user can delete other users' drafts to create an own draft. There can't be two drafts at the same time on the same entity.
:::

### Garbage Collection of Stale Drafts

Inactive drafts are deleted automatically after the default timeout of 30 days. You can configure or deactivate this timeout by the following configuration:

```json
{
  "cds": {
    "fiori": {
      "draft_deletion_timeout": "28d"
    }
  }
}
```

You can set the property to one of the following:
- `false` in order to deactivate the timeout
- number of days like `'30d'` 
- number of hours like `'72h'`
- number of milliseconds like `1000`

::: info Technical background
It can occur that inactive drafts are still in the database after the configured timeout. The deletion is implemented as a side effect of creating new drafts and there's no periodic job that does the garbage collection.
:::

### Bypassing the SAP Fiori Draft Flow
Creating or modifying active instances directly is possible without creating drafts. This comes in handy when technical services without a UI interact with each other.

To enable this feature, set this feature flag in your configuration:

```json
{
  "cds": {
    "fiori": {
      "bypass_draft": true
    }
  }
}
```

You can then create active instances directly:

```http
POST /Books

{
  "ID": 123,
  "IsActiveEntity": true
}
```

You can modify them directly:

```http
PATCH /Books(ID=123,IsActiveEntity=true)

{
  "title": "How to be more active"
}
```

This feature is required to enable [SAP Fiori Elements Mass Edit](https://sapui5.hana.ondemand.com/sdk/#/topic/965ef5b2895641bc9b6cd44f1bd0eb4d.html), allowing users to change multiple objects with the
same editable properties without creating drafts for each row.

:::warning Additional entry point
Note that this feature creates additional entry points to your application. Custom handlers are triggered with delta
payloads rather than the complete business object.
:::

### Differences to Previous Version

- Draft-enabled entities have corresponding CSN entities for drafts:

    ```js
    const { MyEntity } = srv.entities
    MyEntity.drafts // points to model.definitions['MyEntity.drafts']
    ```

- Queries are now cleansed from draft-related properties (like `IsActiveEntity`)
- `PATCH` event isn't supported anymore.
- The target is resolved before the handler execution and points to either the active or draft entity:

    ```js
    srv.on('READ', 'MyEntity.drafts', (req, next) => {
      assert.equal(req.target.name, 'MyEntity.drafts')
      return next()
    })
    ```

    ::: info Special case: "Editing Status: All"
    In the special case of the Fiori Elements filter "Editing Status: All", two separate `READ` events are triggered for either the active or draft entity.
    The individual results are then combined behind the scenes.
    :::

- Draft-related properties (with the exception of `IsActiveEntity`) are only computed for the target entity, not for expanded sub entities since this is not required by Fiori Elements.
- Manual filtering on draft-related properties is not allowed, only certain draft scenarios are supported.


### Programmatic Invocation of Draft Actions <Beta />

You can programmatically invoke draft actions with the following APIs:

```js
await srv.new(MyEntity.drafts, data)     // create new draft
await srv.discard(MyEntity.drafts, keys) // discard draft
await srv.edit(MyEntity, keys)           // create draft from active instance
await srv.new(MyEntity.drafts).for(keys) // same as above
await srv.save(MyEntity.drafts, keys)    // activate draft
```




# Querying in JavaScript



## Constructing Queries

Module `cds.ql` provides facilities to construct queries in [*Core Query Notation (CQN)*](../cds/cqn) in different flavours and styles:

1. Fluent API style, with query-by-example objects for where clauses and order by clauses:

```js
let q = SELECT.from('Books').where({ID:201}).orderBy({title:1})
```

2. Using with [tagged template literals (TTL)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates):

```js
let q = cds.ql `SELECT from Books where ID=${201} order by title`
```

3. Fluent API with interspersed [tagged template literals (TTL)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates):

```js
let q = SELECT.from `Books where ID=${201} order by title`
let p = SELECT.from `Books`.where`ID=${201}`.orderBy`title`
```

4. Manually constructing CQN objects:

```js
const { expr, ref, val, columns, expand, where, orderBy } = cds.ql
```
```js
let q = {
  SELECT: {
    from: ref`Books`,
    where: [ref`ID`, '=', val(201)],
    orderBy: [ref`title`],
  }
}
```
```js
let q = {
  SELECT: {
    from: ref`Authors`,
    columns: [
      ref`ID`,
      ref`name`,
      expand (ref`books`, where`stock>7`, orderBy`title`,
        columns`ID,title`
      )
    ],
    where: [ref`name`, 'like', val('%Poe%')]
  }
}
```

#### API Facades

The API is made available through global objects `SELECT`, `INSERT`, `UPSERT`, `UPDATE`, `DELETE`. Alternatively, you can obtain these objects from `cds.ql` like so:

```js
const cds = require('@sap/cds')
const { SELECT, INSERT, UPDATE, DELETE } = cds.ql
```

#### Using Reflected Definitions

It is recommended best practice to use entity definitions reflected from a service's model to construct queries. Doing so simplifies code as it avoids repeating namespaces all over the place.

```js
const { Books } = cds.entities
let q1 = SELECT.from (Books) .where `ID=${201}`
```

[Learn more about using reflected definitions from a service's model](core-services#entities){.learn-more}

####  Not Locked in to SQL

While both [CQL](../cds/cql) / [CQN](../cds/cqn) as well as the fluent API of `cds.ql` resemble well-known SQL syntax neither of them are locked in to SQL. In fact, queries can be sent to any kind of services, including NoSQL databases or remote services for execution.




## Executing Queries

Queries are executed by passing them to a service's [`srv.run()`](core-services#srv-run-query) method, for example, to the primary database:

```js
let query = SELECT `ID,title` .from `Books`
let books = await cds.db.run (query)
```

Alternatively, you can just `await` a constructed query, which by default passes the query to `cds.db.run()`. So, the following is equivalent to the above:

```js
let books = await SELECT `ID,title` .from `Books`
```
Instead of a database service, you can also send queries to other services, local or remote ones. For example:

```js
const cats = await cds.connect.to ('CatalogService')
let books = await cats.run (query)
```

> `CatalogService` might be a remote service connected via OData. In this case, the query would be translated to an OData request sent via http.

The APIs are also available through [`cds.Service`'s CRUD-style Convenience API](core-services#crud-style-api), e.g.:

```js
const db = cds.db
let books = await db.read`Books`.where`ID=${201}`.orderBy`title`
```



## First-Class Objects

Constructing queries doesn't execute them immediately, but just captures the given query information. Very much like functions in JavaScript, queries are first-class objects, which can be assigned to variables, modified, passed as arguments, or returned from functions. Let's investigate this somewhat more, given this example:

```js
let cats = await cds.connect.to('CatalogService') //> connected via OData
let PoesBooks = SELECT.from (Books) .where `name like '%Poe%'`
let books = await cats.get (PoesBooks)
```

This is what happens behind the scenes:

1. We use the fluent API to construct a query as a CQN and assign it to `PoesBooks`
2. We pass the query as an argument to function `cats.get()`
3. The get event handler translates the query to an OData request sent to the remote service
4. The remote OData protocol adapter translates the inbound query back to CQN
5. This CQN query is passed on to the remote service provider
6. A registered event handler forwards that query to the local `cds.db` service
7. The database service implementation translates the query to plain SQL and sends that to the database for execution



####  Leveraging Late Materialization

You can also combine queries much like sub selects in SQL to form more complex queries as shown in this example:

```sql
let input = '%Brontë%'
let Authors = SELECT `ID` .from `Authors` .where `name like ${ input }`
let Books = SELECT.from `Books` .where `author_ID in ${ Authors }`
```
```js
await cds.run (Books) //> late/no materialization of Authors
```

With that we leverage late materialization, offered by SQL databases.
Compare that to inferior imperative programming:

```js
let input = '%Brontë%'
let Authors = await SELECT `ID` .from `Authors` .where `name like ${ input }`
for (let a of Authors) { //> looping over eagerly materialized Authors
  let Books = await SELECT.from `Books` .where `author_ID = ${ a.ID }`
}
```





## Avoiding SQL Injection
All the APIs are designed to avoid [SQL Injection](https://wikipedia.org/wiki/SQL_injection) by default. For example, let's see how the following code would be executed:

```js
let input = 201 //> might be entered by end users
let books = await SELECT.from `Books` .where `ID=${input}`
```

The query is...

1. captured as a CQN object with the where clause represented as:
```js
..., where:[ {ref:['ID']}, '=', {val:201} ]
```

2. translated to plain SQL string with binding parameters
```sql
SELECT ID from Books where ID=?
```

3. executed with binding parameters provided from `{val}`entries in CQN
```js
dbc.run (sql, [201])
```

The only mistake you could make is to imperatively concatenate user input with CQL or SQL fragments, instead of using the tagged strings or other options promoted by `cds.ql`. For example, assumed you had written the above code sample like that:

```js
let input = 201 //> might be entered by end users
let books = await SELECT.from `Books` .where ('ID='+input)
let bookz = await SELECT.from `Books` .where (`ID=${input}`)
```
> **Note** also that tagged template strings never have surrounding parentheses! I.e., the third line above does the very same string concatenation as the second line.


A malicious user might enter some SQL code fragment like that:
```sql
0; DELETE from Books; -- gotcha!
```
{}

In effect, your generated SQL statements would effectively look like that:

```sql
SELECT ID from Books where ID=0;
DELETE from Books; -- gotcha!
```
::: danger Whenever there's user input involved...
Never use string concatenation when constructing queries!

Never surround tagged template strings with parentheses!
:::

## Using `cds repl`

Event though being a reference doc, the sections below will never be able to cover any possible query you might want to construct. For that reason, we recommend to use the `cds repl` command to experiment with queries interactively. It is a great way to learn how to construct queries and to experiment with them. Here is an example session:

```sh
cds repl -u ql
```
```js
cds.ql`SELECT from Authors {
  ID, name, books [order by title] {
    ID, title, genre.name as genre
  }
} where exists books.genre[name = 'Mystery']`
```
... which will display this:
```js
cds.ql {
  SELECT: {
    from: { ref: [ 'Authors' ] },
    columns: [
      { ref: [ 'ID' ] },
      { ref: [ 'name' ] },
      {
        ref: [
          {
            id: 'books',
            orderBy: [ { ref: [ 'title' ] } ]
          }
        ],
        expand: [
          { ref: [ 'ID' ] },
          { ref: [ 'title' ] },
          { ref: [ 'genre', 'name' ], as: 'genre' }
        ]
      }
    ],
    where: [
      'exists',
      {
        ref: [
          'books',
          {
            id: 'genre',
            where: [ { ref: [ 'name' ] }, '=', { val: 'Mystery' } ]
          }
        ]
      }
    ]
  }
}
```

You can also test-drive the query by executing it with a running application:

```sh
cds repl -u ql -r cap/samples/bookshpop
```
```js
await cds.ql`SELECT from Authors {
  ID, name, books [order by title] {
    ID, title, genre.name as genre
  }
} where exists books.genre[name = 'Mystery']`
```
... which would display the results like that:
```js
[
  {
    ID: 150,
    name: 'Edgar Allen Poe',
    books: [
      { ID: 251, title: 'The Raven', genre: 'Mystery' },
      { ID: 252, title: 'Eleonora', genre: 'Romance' }
    ]
  }
]
```

> [!TIP]
> Using `cds repl` as shown above is likely the best way to learn how to construct queries in detail.
> When doing so, ensure to use the `cds.ql` functions with full queries in CQL syntax, as shown in the example above, as that is the most reliable way to ensure correctness.

[An article by DJ Adams exploring `cds repl`.](https://qmacro.org/blog/posts/2025/03/21/level-up-your-cap-skills-by-learning-how-to-use-the-cds-repl/){.learn-more}

## cds.ql() {.method}

Use the `cds.ql()` method to construct instances of [`cds.Query`](#class-cds-ql-query) from these inputs:

- tagged template strings (SELECT only)
- normal strings (SELECT only)
- plain CQN objects

For example:

```js
let q = cds.ql ({ SELECT: { from: {ref:[ Books.name ]} }})
let q = cds.ql (`SELECT from Books { ID, title }`)
let q = cds.ql `SELECT from ${Books} { ID, title }`
q instanceof cds.ql.Query //> true
```

If the input is already a `cds.Query` instance, it is returned unchanged:

```js
let q1 = cds.ql `SELECT from Books`
let q2 = cds.ql (q1)
q1 === q2 //> true
```


## cds.ql. Query {#class-cds-ql-query .class}

Instances of `cds.Query` capture queries at runtime. Subclasses provide [fluent APIs](#constructing-queries) to construct queries as highlighted below.



### .kind {.property}

The kind of query, that is one of these strings:

- `'SELECT'`
- `'INSERT'`
- `'UPSERT'`
- `'UPDATE'`
- `'DELETE'`

This is usefull for generic query processors, such as outbound protocol adapters or database services, which need to translate given queries into target representations.



### then() {.method}

Instances of `cds.Query` are thenables. `await`ing them executes the query with the bound service or the primary database service.

```js
await SELECT.from(Books) // is equivalent to:
await cds.db.run( SELECT.from(Books) )
```



### bind (srv) {.method}

Binds a query for execution with the given `srv` .

```js
let srv = new cds.Service
await SELECT.from(Books).bind(srv) // is equivalent to:
await srv.run( SELECT.from(Books) )
```





## SELECT {.class}

Fluent API to construct [CQN SELECT](../cds/cqn#select) query objects in a [CQL](../cds/cql)/SQL-like style. In contrast to SQL, though, the clauses can be arrayed in arbitrary order.

`SELECT` itself is a function acting as a shortcut to `SELECT.columns`, thereby resembling SQL syntax:

```sql
SELECT `a, b` .from `Foo`  -- is a shortcut for:
SELECT .columns `a, b` .from `Foo`
```

Moreover, it accepts a single tagged template string starting with `from`:

```js
const limit = 11, sort_column = 'a'
const q = SELECT `from Foo {
   a, b as c, sum(d)
} where x < ${limit}
group by a,b
order by ${sort_column} asc`
const foos = await q
```

This allows constructing [CQN](../cds/cqn) query objects using [CQL](../cds/cql) language constructs which are not covered by `cds.ql` fluent API.



### .one {.property}


Start constructing a query with `SELECT.one` to indicate we're interested in only the first row. At runtime, a single entry, if any, is returned instead of an array:

```js
const one = await SELECT.one.from (Authors)
```

> same effect, but potentially more expensive:

```js
const [one] = await SELECT.from (Authors)
```



### .elements {.property}


The CSN outline of the selected elements as an object. Key is the selected element or alias, value is the CSN definition:

Let's assume the following query:
```js
SELECT.from('sap.capire.bookshop.Books').columns('ID', 'title')
```

This query is represented within `.elements` as:

```js
{
  ID: number { key: true, type: 'cds.Integer' },
  title: string {
    '@mandatory': true,
    localized: true,
    type: 'cds.String',
    length: 111,
    '@Common.FieldControl': { '#': 'Mandatory' }
  }
}
```

This is useful for custom implementations that act on the selection of specific elements.



### .distinct {.property}

Start the query with `SELECT.distinct` to skip duplicates as in SQL:

```js
SELECT.distinct.from (Authors)
```



### columns() {.method}

```tsx
function SELECT.columns ( projection : function )
function SELECT.columns ( cql : tagged template string )
function SELECT.columns ( columns[] : CQL expr string | CQN expr object )
function SELECT.columns ( ...columns[] : CQL expr string | CQN expr object )
```

Specifies which columns to be fetched, very much like SQL select clauses, enhanced by [CQL](../cds/cql) projections and path expressions. The arguments can be a projection function, a tagged template string, or individual column expressions as CQL string snippets, or as [CQN column expression objects](../cds/cqn.md#select).

```sql
SELECT.from `Books` .columns (b => { b.title, b.author.name.as('author') })
SELECT.from `Books` .columns `{ title, author.name as author }`
SELECT.from `Books` .columns `title, author.name as author`
SELECT.from `Books` .columns ( 'title', 'author.name as author')
SELECT.from `Books` .columns ( 'title', {ref:['author','name'],as:'author'} )
SELECT.from `Books` .columns (['title', {ref:['author','name'],as:'author'} ])
```

Projection functions are the **most recommended** way to specify projections as they have several advantages (with tagged templates coming closest):

- they support nested projections, aka expands
- they don't need to call a parser
- they resemble CQL very much
- they use standard JavaScript constructs
- we can perspectively offer type inference and code completion

With respect to resembling CQL let's compare this query in CQL using entity aliases to the `cds.ql` code sample below:

```sql
SELECT from Authors a {
   a.ID, a.name, a.books {
     *, createdAt as since,
     suppliers[city='Paris']{*}
   }
}
```

Here is the same using `cds.ql` with projection functions:

```js
SELECT.from ('Authors', a => {
   a.ID, a.name, a.books (b => {
     b`.*`, b.createdAt`as since`,
     b.suppliers`[city='Paris']`('*')
   })
})
```

Projection functions use these mechanisms:

- projections are single-argument arrow functions: `a => { ... }`
- with the argument as entity alias in column expressions: `a.name`
- with functions for nested projections: `a.books (b => {...})`
- with `*` as special case of that: ```b`.*` ```, and `b.suppliers('*')`
- with template strings for aliases: ```b.createdAt`as since` ```
- as well as for infix filters: ```b.suppliers`[city='Paris']` ```

**Note:** Not every CQL or SQL construct can be expressed with projection functions. This is where tagged template strings kick in



### from() {.method #select-from}

```tsx
function SELECT.from (
   entity : string | CSN definition | tagged template string,
   key?   : string | number | object,
   cols?  : array  | projection
)
```

Fills in [CQN `from` clauses](../cds/cqn.md#select), optionally adding a primary key, and a projection.
The latter are alternatives for using separate `.one`, `.where` and  `.columns` clauses. <br/>
For example, these queries:

```js
SELECT.from (Books,201)
SELECT.from (Books,201, b => { b.ID, b.title })
```

... are equivalent to these:

```js
SELECT.one.from (Books) .where ({ID:201})
SELECT.one.from (Books) .where ({ID:201})
.columns (b => { b.ID, b.title })
```

> NOTE: Specifying a `key` argument automatically [enables `SELECT.one`](#one).



Argument `key` can be a single string or number value, or a [query-by-example](#where) object:

```js
SELECT.from (Books,201) //> shortcut for {ID:201}
SELECT.from (Books, {ID:201})
SELECT.from (Books.texts, {ID:201, locale:'de'})
```

Argument `cols` is a projection [as accepted by `.columns (cols)`](#columns)



### alias() {.method}

Specifies the alias which you can refer to in other functions:

```js
SELECT.from ('Authors').alias('a').where({
   exists: SELECT.from('Books').where('author_ID = a.ID')
})
```



### where(){.method alt="The following documentation on having also applies to where"}

### having() {.method}

These two methods fill in corresponding  [CQL](../cds/cql) clauses with predicate  expressions.

```tsx
function SELECT.where/having ( qbeobj : query-by-example object )
function SELECT.where/having ( clause : tagged template string )
function SELECT.where/having ( expr: string, value: any, ... )
```

Expressions can be specified as a query-by-example object, a tagged template string, or as an alternating string / value arguments list:

```js
SELECT.from `Books` .where ({ ID: req.data.ID }) // qbe
SELECT.from `Books` .where `ID = ${req.data.ID}` // tts
SELECT.from `Books` .where ('ID =', req.data.ID) // expr/value list
```
Assumed we got some user input as follows:

```js
const name='foo', kinds=[1,2,3], min=0.1, max=0.9, stock=111
```

With tagged template strings we could construct a query like that:

```js
SELECT.from `Foo` .where `name like ${name} and (
   kind in ${kinds}
   or ratio between ${min} and ${max}
   or stock >= ${stock}
)`
```

Doing the same with object literals would look like that:

```js
SELECT.from('Foo') .where ({ name: {like:'%foo%'}, and: {
   kind: { in: kinds },
   or: { ratio: { between: min, and: max },
     or: { stock: { '>=': stock } }
    }
}})
```

The provided expression is consistently accounted for by wrapping the existing where clause in an `xpr` if needed.



### groupBy() {.method}

Fills in SQL `group by` clauses. Arguments are a single tagged template string, or column expression strings or [CXN](../cds/cxn.md) objects, like that:

```js
SELECT ... .groupBy `a.name, b`
SELECT ... .groupBy ('a.name', 'b')
SELECT ... .groupBy ({ref:['a','name']}, {ref:['b']})
```



### orderBy() {.method}

Fills in SQL `order by` clauses. Arguments are a single tagged template string, or column expression strings, optionally followed by `asc` or `desc`, or [CXN](../cds/cxn.md) objects, like that:

```js
SELECT ... .orderBy `a.name, b desc`
SELECT ... .orderBy ('a.name', 'b desc')
SELECT ... .orderBy ({ref:['a','name']}, {ref:['b'],sort:'desc'})
```



### limit() {.method}

Equivalent of the standard SQL `limit` and `offset` clauses.
Arguments can be standard numbers or [CXN](../cds/cxn.md) expression objects.

```js
SELECT ... .limit (25)      //> first page
SELECT ... .limit (25,100)  //> fifth page
```



### forUpdate() {.method}


Exclusively locks the selected rows for subsequent updates in the current transaction, thereby preventing concurrent updates by other parallel transactions.

```js
try {
   let book = await SELECT.from(Books,201).forUpdate()
   //> book is locked for other transactions
   await UPDATE (Books,201) .with ({...})
} catch (e) {
   //> failed to acquire the lock, likely because of timeout
}
```

The `options` argument is optional; currently supported is:

* `wait` — an integer specifying the timeout after which to fail with an error in case a lock couldn't be obtained. The time unit is database-specific. On SAP HANA, for example, the time unit is seconds. A default `wait` value that is used if `options.wait == null` can be specified via <Config keyOnly>cds.sql.lock_acquire_timeout: -1</Config>. A value of `-1` can be used to deactivate the default for the individual call. If the wait option isn't specified, the database-specific default behavior applies.

All acquired locks are released when the current transaction is finished, that is, committed  or rolled back.



### forShareLock() {.method}

Locks the selected rows in the current transaction, thereby preventing concurrent updates by other parallel
transactions, until the transaction is committed or rolled back. Using a shared lock allows all transactions to read the locked record.

If a queried record is already exclusively locked by another transaction, the `.forShareLock()` method waits for the lock to be released.



### hints() {.method}

Passes hints to the database query optimizer that can influence the execution plan. The hints can be passed as individual arguments or as an array.


```js
SELECT ... .hints ('IGNORE_PLAN_CACHE')
SELECT ... .hints ('IGNORE_PLAN_CACHE', 'MAX_CONCURRENCY(1)')
SELECT ... .hints (['IGNORE_PLAN_CACHE', 'MAX_CONCURRENCY(1)'])
```





## INSERT {.class}

Fluent API to construct [CQN INSERT](../cds/cqn#insert) query objects in a [CQL](../cds/cql)/SQL-like style. In contrast to SQL, though, the clauses can be arrayed in arbitrary order.


 `INSERT` itself is a function acting as a shortcut to `INSERT.entries`, allowing uses like that:


```js
const books = [
   { ID:201, title:'Wuthering Heights', author_id:101, stock:12 },
   { ID:251, title:'The Raven', author_id:150, stock:333 },
   { ID:271, title:'Catweazle', author_id:170, stock:222 }
]
INSERT (books) .into (Books)
```



### into() {.method}

```tsx
function INSERT.into (
  entity   : string | CSN definition | tagged template string,
  entries? : object[]
)
```


Specifies the target entity to insert data into, either as a string or a reflected definition:


```js
const { Books } = cds.entities
INSERT.into (Books) .entries (...)
INSERT.into ('Books') .entries (...)
INSERT.into `Books` .entries (...)
```

You can optionally pass records of data [as  accepted by `.entries`](#insert-entries) as a shortcut to which:

```js
INSERT.into (Books, [
   { ID:201, title:'Wuthering Heights', author_id:101, stock:12 },
   { ID:251, title:'The Raven', author_id:150, stock:333 },
   { ID:271, title:'Catweazle', author_id:170, stock:222 }
])
```



### entries() {.method #insert-entries}

```tsx
function INSERT.entries (records : object[] | Query | Readable)
```

Allows inserting multiple rows with one statement.

The arguments can be one of...

- one or more records as variable list of arguments
- an array of one or more records
- a readable stream
- a sub SELECT query

Using individual records:


```js
await INSERT.into (Books) .entries (
   { ID:201, title:'Wuthering Heights', author_id:101, stock:12 },
   { ID:251, title:'The Raven', author_id:150, stock:333 },
   { ID:271, title:'Catweazle', author_id:170, stock:222 }
)
```

Using an **array** of records, read from a JSON:

```js
let books = JSON.parse (fs.readFileSync('books.json'))
await INSERT(books).into(Books) // same as INSERT.into(Books).entries(books)
```

Using a **stream** instead of reading and parsing the full JSON into memory:

```js
let stream = fs.createReadStream('books.json')
await INSERT(stream).into(Books) // same as INSERT.into(Books).entries(stream)
```

Using a **subselect** query to copy *within* the database:

```js
await INSERT.into (Books) .entries (SELECT.from(Products))
```

::: details Pushed down to database....

Note that the sub select variant creates a single [native  `INSERT INTO SELECT` SQL statement](https://www.w3schools.com/sql/sql_insert_into_select.asp), which is most efficient, as the data is copied **within** the database. In contrast to that, ...

```js
INSERT.into(Books).entries(await SELECT.from(Products))
```
... would also work, but would be much less efficient, as it would (1) first read all data from database into the client and then (2) insert the read data back into the database.


:::



### values() {.method alt="The following documentation on rows also applies to values. "}

### rows() {.method}


Use `.columns` with `.values` as in SQL:

```js
INSERT.into (Books) .columns (
   'ID', 'title', 'author_id', 'stock'
) .values (
   201, 'Wuthering Heights', 101, 12
)
```

>  Both, `.columns` and `.values` can alternatively wrapped into an array.

Use  `.rows` instead of `.values` to insert multiple rows with one statement:

```js
INSERT.into (Books) .columns (
   'ID', 'title', 'author_id', 'stock'
) .rows (
   [ 201, 'Wuthering Heights', 101, 12 ],
   [ 251, 'The Raven', 150, 333 ],
   [ 252, 'Eleonora', 150, 234 ]
)
```
### from() {.method #from}


Constructs a _INSERT into SELECT_ statement.
```js
INSERT.into('Bar') .from (SELECT.from('Foo'))
```


## UPSERT {.class}

Fluent API to construct [CQN UPSERT](../cds/cqn#upsert) query objects in a [CQL](../cds/cql)/SQL-like style. In contrast to SQL, though, the clauses can be arrayed in arbitrary order.


 `UPSERT`  itself is a function acting as a shortcut to `UPSERT.entries`, allowing uses like that:


```js
const books = [
   { ID:201, title:'Wuthering Heights', author_id:101, stock:12 },
   { ID:251, title:'The Raven', author_id:150, stock:333 },
   { ID:271, title:'Catweazle', author_id:170, stock:222 }
]
UPSERT (books) .into (Books)
```

### into() {.method #upsert-entries}

```tsx
function UPSERT.into (
  entity   : string | CSN definition | tagged template string,
  entries? : object[]
)
```


Specifies the target entity to upsert data into, either as a string or a reflected definition..


```js
const { Books } = cds.entities
UPSERT.into (Books) .entries (...)
UPSERT.into ('Books') .entries (...)
UPSERT.into `Books` .entries (...)
```

You can optionally pass records of data [as  accepted by `.entries`](#upsert-entries) as a shortcut to which:

```js
UPSERT.into (Books, [
   { ID:201, title:'Wuthering Heights', author_id:101, stock:12 },
   { ID:251, title:'The Raven', author_id:150, stock:333 },
   { ID:271, title:'Catweazle', author_id:170, stock:222 }
])
```


### entries() {.method}


Allows upserting multiple rows with one statement where each row
is a record with named values, for example, as could be read from a JSON
source.


```js
UPSERT.into (Books) .entries (
   { ID:201, title:'Wuthering Heights', author_id:101, stock:12 },
   { ID:251, title:'The Raven', author_id:150, stock:333 },
   { ID:271, title:'Catweazle', author_id:170, stock:222 }
)
```

The entries can be specified as individual method parameters of type object — as shown above —, or as a single array of which.

[Learn more about limitations when using it with databases.](databases#databaseservice-upsert){.learn-more}

## UPDATE {.class}

Fluent API to construct [CQN UPDATE](../cds/cqn#update) query objects in a [CQL](../cds/cql)/SQL-like style. In contrast to SQL, though, the clauses can be arrayed in arbitrary order.

 `UPDATE` itself is a function acting as a shortcut to `UPDATE.entity`, allowing usages like this:


```sql
UPDATE `Books` .set `stock = stock - ${quantity}` -- as shortcut to:
UPDATE.entity `Books` .set `stock = stock - ${quantity}`
```

### entity() {.method}

```tsx
function UPDATE.entity (
   entity : string | CSN definition | tagged template string,
   key?   : string | number | object,
)
```

Specifies the target of the update operation, optionally followed by a primary key, and a projection.
The latter provides an alternative for using separate  `.where` clauses. <br/>
For example, these queries are equivalent:

```js
UPDATE (Books,201)...
UPDATE (Books) .where ({ID:201}) ...
```

Argument `key` can be a single string or number value, or a [query-by-example](#where) object:

```js
UPDATE (Books,201) ... //> shortcut for {ID:201}
UPDATE (Books, {ID:201}) ...
UPDATE (Books.texts, {ID:201, locale:'de'}) ...
```



### set() {.method alt="The following documentation on with also applies to set. "}

### with() {.method}


 Specifies the data to update...

1. As a single-expression tagged template string
```js
let [ ID, quantity ] = [ 201, 1 ]
UPDATE `Books` .set `stock = stock - ${quantity}` .where `ID=${ID}`
```

2. As an object with keys being element names of the target entity and values being simple values, [query-by-example](#where) expressions,  or [CQN](../cds/cqn.md) expressions:
```js
let [ ID, quantity ] = [ 201, 1 ]
UPDATE (Books,ID) .with ({
  title: 'Sturmhöhe',       //>  simple value
  stock: {'-=': quantity},    //>  qbe expression
  descr: {xpr: [{ref:[descr]}, '||', 'Some addition to descr.']}
})
```

> Method `.set` and `.with` are aliases to the same method.



### where() {.method}

[As in SELECT.where](#where) {.learn-more}





## DELETE {.class}

Fluent API to construct [CQN DELETE](../cds/cqn#delete) query objects in a [CQL](../cds/cql)/SQL-like style. In contrast to SQL, though, the clauses can be arrayed in arbitrary order.

```js
DELETE.from('Books').where ({stock:{'<':1}})
```



### from() {.method #delete-from}

```tsx
function DELETE.from (
   entity : string | CSN definition | tagged template string,
   key?   : string | number | object
)
```

[As in SELECT.from](#select-from) {.learn-more}



### where() {.method}

[As in SELECT.where](#where) {.learn-more}



## Expressions

The following methods facilitate constructing CXN objects manually.

> [!note]
> Many sections below are still under construction. We are working on it... Please refer to the [CXL](../cds/cxn) documentation for more information on the CXN syntax for the time being.

### expr() {.method}

Constructs a CXN expression object from given input.
Same as [`xpr`](#xpr), but if the result contains only single
entries these are returned as is.

```js
const { expr } = cds.ql
expr([ref`foo`,'=',val(11)]) //> {xpr:[{ref:['foo']},'=',{val:11}]}
expr(ref`foo`,'=',val(11))   //> {xpr:[{ref:['foo']},'=',{val:11}]}
expr`foo = 11`               //> {xpr:[{ref:['foo']},'=',{val:11}]}
expr`foo`                    //> {ref:['foo']}
expr`11`                     //> {val:11}
```

### ref() {.method}

Constructs a CXN `{ref}` object from given input, which can be one of:

- several path segment strings
- a single array of the same
- a tagged template literal in CXL path syntax


```js
const { ref } = cds.ql
ref('foo')        //> {ref:['foo']}
ref('foo','bar')  //> {ref:['foo','bar']}
ref`foo.bar`      //> {ref:['foo','bar']}
ref`foo`          //> {ref:['foo']}
```

Note that only simple paths are supported, that is, without infix filters or functions.

[Use `expr()` to parse paths with infix filters via a tagged template literals.](#expr) {.learn-more}


### val() {.method}

Constructs CXN `{val}` object from given input, which can be one of:
- a single `string`, `number`, `boolean`, or `null`
- a tagged template literal in CXL literal syntax

```js
const { val } = cds.ql
val(`foo`) //> {val:'foo'}`
val`foo`   //> {val:'foo'}
val`11`    //> {val:11}
val(11)    //> {val:11}
```

### xpr() {.method}

Constructs a CXN `xpr` object from given input, which can be one of:
- multiple CXN `expr` objects, or strings representing keywords or operators
- a single array of the same
- a tagged template literal in CXL syntax

```js
const { xpr } = cds.ql
xpr([ref`foo`,'=',val(11)]) //> {xpr:[{ref:['foo']},'=',{val:11}]}
xpr(ref`foo`,'=',val(11))   //> {xpr:[{ref:['foo']},'=',{val:11}]}
xpr`foo = 11`               //> {xpr:[{ref:['foo']},'=',{val:11}]}
xpr`foo`                    //> {xpr:[{ref:['foo']}]}
xpr`'foo'`                  //> {xpr:[{val:'foo'}]}
xpr`11`                     //> {xpr:[{val:11}]}
xpr('=')                    //> {xpr:['=']}
xpr('like')                 //> {xpr:['like']}
```

[See also `expr()`](#expr) {.learn-more}


### list() {.method}

 Constructs a CXN `list` object from given input, with can be one of:
 - multiple CXN `expr` objects, or values turned into `{val}`s, including strings
 - a single array of the same
 ```js
 const { list } = cds.ql
 list([`foo`,11]) //> {list:[{val:'foo'},{val:11}]}
 list(`foo`,11)   //> {list:[{val:'foo'},{val:11}]}
 expr`'foo',11`   //> {list:[{val:'foo'},{val:11}]}
 expr`foo,11`     //> {list:[{ref:['foo']},{val:11}]}
 ```
[Use `expr()` to get the same via a tagged template literals.](#expr) {.learn-more}


### func() {.method}

Constructs a CXN `func` object from given input. The first argument is the
function name, the remaining `args` can the same as in {@link ql.list `list()`},
and are handled the same way.
```js
const { func } = cds.ql
func('substring',[`foo`,1]) //> {func:'substring',args:[{val:'foo'},{val:1}]}
func('substring',`foo`,1)   //> {func:'substring',args:[{val:'foo'},{val:1}]}
expr`substring('foo',1)`    //> {func:'substring',args:[{val:'foo'},{val:1}]}
expr`substring(foo,1)`      //> {func:'substring',args:[{ref:['foo']},{val:1}]}
expr`substring(foo,1)`      //> {func:'substring',args:[{ref:['foo']},{val:1}]}
```
[Use `expr()` to get the same via a tagged template literals.](#expr) {.learn-more}


### predicate() {.method}
<UnderConstruction/>

TODO: Add description

```js
const { predicate } = cds.ql
predicate`a=1 and b=2 or c=3 and d=4`
predicate ({ a:1, b:2, or:{ c:3, d:4 }})
predicate ('a=',1,'and ( b=',2,'or c=',3,')')
```

### columns() {.method}
<UnderConstruction/>

TODO

### nested() {.method}
<UnderConstruction/>

TODO

### expand() {.method}
<UnderConstruction/>

TODO: Add description

```js
expand (ref`books`, where`stock>7`, orderBy`title`,
   columns`ID,title`
)
```

### inline() {.method}
<UnderConstruction/>

TODO

### where() {.method}
<UnderConstruction/>

TODO

### orderBy() {.method}
<UnderConstruction/>

TODO

### orders() {.method}
<UnderConstruction/>

TODO
<div id="secondary-file">node.js/cds-ql.fragment.md</div>


# Minimalistic Logging Facade






## cds.log  <i>  (id?, options?) </i> { #cds-log}

Returns a logger identified by the given id.

```js
const LOG = cds.log('sql')
LOG.info ('whatever', you, 'like...')
```

#### *Arguments*
- `id?` —  the id for which a logger is requested — default: `'cds'`
- `options?` — alternative to `level` pass an options object with:
  - `level?` — the [log level](#log-levels)  specified as string or number — default: `'info'`
  - `label?` — the [log label](#logger-label) to add to each log output — default: `id`
- `level?` — specify a string instead of `options` as a shorthand for `{level}`

```js
// all following are equivalent...
const LOG = cds.log('foo', 'warn')  //> shorthand for:
const LOG = cds.log('foo', { level: 'warn' })
// including case-insensitivity...
const LOG = cds.log('foo', 'WARN')  //> shorthand for:
const LOG = cds.log('foo', { level: 'WARN' })
```


### *Logger `id` — cached & shared loggers* {#logger-id}

The loggers constructed by `cds.log()` are cached internally, and the same instances are returned on subsequent invocations of `cds.log()` with the same `id`. This allows to use and share the same logger in different modules.

```js
const LOG1 = cds.log('foo')
const LOG2 = cds.log('foo')
console.log (LOG1 === LOG2) //> true
```

### *Logger `label` — used to prefix log output* {#logger-label}

By default, each log output is prefixed with `[<id>] -`, for example, as in `[cds] - server listening `. Sometimes you may want to use different ids and labels. Use option `label`  to do so as in this examples:

```js
const LOG = cds.log('foo',{label:'bar'})
LOG.info("it's a foo")
//> [bar] - it's a foo
```

### _Logger usage → much like `console`_ { #logger-api }

Loggers returned by `cds.log()` look and behave very much like [JavaScript's standard `console` object](https://nodejs.org/api/console.html) a log method for each [log level](#log-levels):

```js
cds.log() → {
  trace(...), _trace,
  debug(...), _debug,
  info(...),  _info, log(...), // alias for info()
  warn(...),  _warn,
  error(...), _error,
}
```

In addition, there is a boolean indicator to check which levels are active through corresponding underscored property, for example, `LOG._debug` is true if debug is enabled.

### *Recommendations*
1. **Leave formatting to the log functions** — for example don't expensively construct debug messages, which aren't logged at all if debug is not switched on. For example:

   ```js
   // DONT:
   const { format } = require('util')
   LOG.debug (`Expected ${arg} to be a string, but got: ${format(value)}`)
   // DO:
   LOG.debug ('Expected', arg, 'to be a string, but got', value)
   ```

2. **Check levels explicitly** — to further minimize overhead you can check whether a log level is switched on using the boolean `Logger._<level>` properties like so:

   ```js
   const LOG = cds.log('sql')
   LOG._info && LOG.info ('whatever', you, 'like...')
   ```




## cds.log.format { #cds-log-format}

### _Setting Formats for New Loggers_

You can provide a custom log formatter function by setting `cds.log.format` programmatically as shown below, for example in your custom `server.js`.


```js
// the current default:
cds.log.format = (id, level, ...args) => [ `[${id}]`, '-', ...args ]
```
```js
// a verbose format:
const _levels = [ 'SILENT', 'ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE' ]
cds.log.format = (id, level, ...args) => [
  '[', (new Date).toISOString(),
  '|', _levels[level].padEnd(5),
  '|', cds.context?.tenant || '-',
  '|', cds.context?.id || '-',
  '|', id, '] -', ...args
]
```

Formatter functions are expected to return an array of arguments, which are passed to the logger functions — same as the arguments for `console.log()`.

### _Setting Formats for Existing Loggers_

You can also change the format used by newly or formerly constructed loggers using `.setFormat()` function:

```js
const _levels = [ 'SILENT', 'ERROR', 'WARN', 'INFO', 'DEBUG', 'TRACE' ]
const LOG = cds.log('foo') .setFormat ((id, level, ...args) => [
  '[', (new Date).toISOString(),
  '|', _levels[level].padEnd(5),
  '|', cds.context?.tenant || '-',
  '|', cds.context?.id || '-',
  '|', id, '] -', ...args
])
```


## cds.log.levels { #log-levels }

Constants of supported log levels:

```js
cds.log.levels = {
  SILENT: 0,    // all log output switched off
  ERROR: 1,     // logs errors only
  WARN: 2,      // logs errors and warnings only
  INFO: 3,      // logs errors, warnings and general infos
  DEBUG: 4,     // logs errors, warnings, info, and debug
                // (and trace when using default logger implementation)
  TRACE: 5,     // most detailed log level
  SILLY: 5,     // alias for TRACE
  VERBOSE: 5    // alias for TRACE
}
```

You can use these constants when constructing loggers, for example:

```js
const LOG = cds.log('foo', cds.log.levels.WARN)
```



### *Configuring Log Levels*

Configure initial log-levels per module through `cds.log.levels`, for example like that in your `package.json`:

```json
{
  "cds": {
    "log": {
      "levels": {
        "sql": "debug",
        "cds": "info"
      }
    }
  }
}
```

[Learn more about `cds.env`.](cds-env){.learn-more}

[See pre-defined module names below.](#cds-log-modules){.learn-more}



### *Programmatically Set Log Levels*
You can specify a default log level to use when constructing a logger as shown above. When called subsequently with a *different* log level, the cached and shared logger's log level will be changed dynamically. For example:

```js
// some-module.js
const LOG = cds.log('foo') // using default log level 'info'
```

```js
// some-other-module.js
const LOG = cds.log('foo') // shares the same logger as above
```

```js
// some-controller-module.js
cds.log('foo','debug') // switches the 'foo' logger to 'debug' level
```



### *Log Levels as Used by the CAP Node.js Runtime*

The CAP Node.js runtime uses the following guidelines with regards to which log level to use in which situation:

- `error`: Something went horribly wrong and it's unclear what to do (that is, an unexpected error).
- `warn`: Something off the happy trail happened, but it can be handled (that is, an expected error).
- `info`: Brief information about what is currently happening.
- `debug`: Detailed information about what is currently happening.
- `trace`/`silly`/`verbose` (not used by the CAP Node.js runtime): Exhaustive information about what is currently happening.


## cds.log.Logger

Constructs a new logger with the method signature of `{ trace, debug, log, info, warn, error }` (cf. [`console`](https://nodejs.org/api/console.html)). The default implementation maps each method to the equivalent methods of `console`.

You can assign different implementations by exchanging the factory with your own, for example, in order to integrate advanced logging frameworks such as [winston](#winston).

#### *Arguments*

- `label`— the log label to use with each log output, if applicable
- `level`— the log level to enable → *0=off, 1=error, 2=warn, 3=info, 4=debug, 5=trace*


### *Using `winston` Loggers* {#winston}

**Prerequisites:** You need to add [winston](https://www.npmjs.com/package/winston) to your project:
```sh
npm add winston
```

Being designed as a simple log facade, `cds.log` can be easily integrated with advanced logging frameworks such as  [`winston`](https://www.npmjs.com/package/winston). For example, using the built-in convenience method `cds.log.winstonLogger()` in your project's server.js like that:

```js
cds.log.Logger = cds.log.winstonLogger()
```

You can specify winston custom options to that method [as documented for `winston.createLogger()`](https://github.com/winstonjs/winston#creating-your-own-logger), for example like that:

```js
cds.log.Logger = cds.log.winstonLogger({
  format: winston.format.simple(),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({
      filename: 'errors.log',
      level: 'error'
    })
  ],
})
```

### _Custom Loggers_

Custom loggers basically have to return an object fulfilling the `console`-like [`cds.log` loggers API](#logger-api) as in this example:

```js
const winston = require("winston")
const util = require('util')
const cds = require('@sap/cds')
cds.log.Logger = (label, level) => {
  // construct winston logger
  const logger = winston.createLogger({
    levels: cds.log.levels, // use cds.log's levels
    level: Object.keys(cds.log.levels)[level],
    transports: [new winston.transports.Console()],
  })
  // winston's log methods expect single message strings
  const _fmt = (args) => util.formatWithOptions(
    {colors:false}, `[${label}] -`, ...args
  )
  // map to cds.log's API
  return Object.assign (logger, {
    trace: (...args) => logger.TRACE (_fmt(args)),
    debug: (...args) => logger.DEBUG (_fmt(args)),
    log:   (...args) => logger.INFO  (_fmt(args)),
    info:  (...args) => logger.INFO  (_fmt(args)),
    warn:  (...args) => logger.WARN  (_fmt(args)),
    error: (...args) => logger.ERROR (_fmt(args)),
  })
}
```

Actually, the above is essentially the implementation of `cds.log.winstonLogger()`.



## `DEBUG` env variable

Use env variable `DEBUG` to quickly switch on debug output from command line like that:

```sh
DEBUG=app,sql cds watch
DEBUG=all cds watch
```

Values can be

  - comma-separated list of [logger ids](#logger-id), or
  - the value `all` to switch on all debug output.

### *Matching multiple values of `DEBUG`*

When obtaining loggers with `cds.log()` you can specify alternate ids that will all be matched against the entries of the `DEBUG` env variable; for example:

```js
const LOG = cds.log('db|sql')
```

Will be debug-enabled by both, `DEBUG=db`, as well as `DEBUG=sql ...`.

**Note:** The alternative ids specified after `|` have no impact on the unique logger ids. That is, the logger above will have the id `'db'`, while `'sql'` will only be used for matching against `DEBUG` env variable.

## Configuration
Configuration for `cds.log()` can be specified through `cds.env.log`, for example like that in your `package.json`:

```json
{
  "cds": {
    "log": {
      "levels": {
        "sql": "debug",
        "cds": "info"
      }
    }
  }
}
```

[Learn more about `cds.env`.](cds-env){.learn-more}

The following configuration options can be applied:

- `levels` — configures log levels for logged modules. The keys refer to the [loggers' `id`](#logger-id), the values are lower-case names of [log levels](#log-levels).

- `user` — Specify `true` to log the user's ID (`req.user.id`) as `remote_user` (Kibana formatter only). Consider the data privacy implications! Default: `false`.

- `sanitize_values`— Specify `false` to deactivate the default behavior of sanitizing payload data in debug logs in production. Default: `true`.

## Common IDs { #cds-log-modules }

The runtime uses the same logger facade, that is `cds.log()`. For each component, it requires a separate logger. So projects can set different log levels for different components/layers. The following table lists the ids used to set the log levels:

| Component                                | Logger IDs(s)     |
|------------------------------------------|-------------------|
| Server and common output                 | `cds`             |
| CLI output                               | `cli`             |
| CDS build output                         | `build`           |
| [Application Service](./app-services)    | `app`             |
| [Databases](databases)                   | `db\|sql`         |
| [Messaging Service](messaging)           | `messaging`       |
| [Remote Service](remote-services)        | `remote`          |
| AuditLog Service                         | `audit-log`       |
| OData Protocol Adapter                   | `odata`           |
| REST Protocol Adapter                    | `rest`            |
| GraphQL Protocol Adapter                 | `graphql`         |
| [Authentication](./authentication)       | `auth`            |
| Database Deployment                      | `deploy`          |
| Multitenancy and Extensibility           | `mtx`             |


## Logging in Development

During development, we want concise, human-readable output in the console, with clickable stack traces in case of errors. You should not be overloaded with information that is additionally obfuscated by a bad rendering. Hence, [console.log()](https://nodejs.org/api/console.html#console_console_log_data_args), that makes use of [util.format()](https://nodejs.org/api/util.html#util_util_format_format_args) out of the box, with raw arguments is a good choice.

The *plain log formatter*, which is the default in non-production environments, prepends the list of arguments with `[<module> -]`. The following screenshot shows the log output for the previous warning and rejection with the plain log formatter.

![The screenshot is explained in the accompanying text.](./assets/plain-formatter-output.png)

The plain log formatter is the default formatter in non-production.


## Logging in Production

SAP BTP offers two services, [SAP Cloud Logging](https://help.sap.com/docs/cloud-logging) and [SAP Application Logging Service](https://help.sap.com/docs/application-logging-service), to which bound Cloud Foundry applications can stream logs.
In both services, operators can access and analyze observability data, as described in [Access and Analyze Observability Data](https://help.sap.com/docs/cloud-logging/cloud-logging/access-and-analyze-observability-data) for SAP Cloud Logging and [Access and Analyze Application Logs, Container Metrics and Custom Metrics](https://help.sap.com/docs/application-logging-service/sap-application-logging-service/access-and-analyze-application-logs-container-metrics-and-custom-metrics) for SAP Application Logging Service.
To get connected with either of those services, the application needs to be bound to the respective service instance(s) as described for [SAP Cloud Logging](https://help.sap.com/docs/cloud-logging/cloud-logging/ingest-via-cloud-foundry-runtime?version=Cloud) and [SAP Application Logging Service](https://help.sap.com/docs/application-logging-service/sap-application-logging-service/produce-logs-container-metrics-and-custom-metrics).

Additionally, the log output needs to be formatted in a way that enables the respective dashboard technology to optimally support the user, for example, filtering for logs of specific levels, modules, status, etc.

The *JSON log formatter* constructs a loggable object from the passed arguments as well as [cds.context](events#cds-event-context) and the headers of the incoming request (if available).

The JSON log formatter is the default formatter in production.

::: tip
Since `@sap/cds 7.5`, running `cds add kibana-logging` or setting <Config>cds.features.kibana_formatter: true</Config> are no longer needed. If you want to opt-out of the JSON formatter in production, set <Config>cds.log.format: plain</Config>.
:::

Further, there are two formatting aspects that are activated automatically, if appropriate, and add the following information to the loggable object:
1. Running on Cloud Foundry: `tenant_subdomain`, `CF_INSTANCE_IP` and information from `VCAP_APPLICATION`
1. Bound to an instance of the [SAP Application Logging Service](https://help.sap.com/docs/application-logging-service/sap-application-logging-service/sap-application-logging-service-for-cloud-foundry-environment) or [SAP Cloud Logging](https://help.sap.com/docs/cloud-logging/sap-cloud-logging/what-is-sap-cloud-logging): `categories` and *custom fields* as described in [Custom Fields](#custom-fields)

The following screenshot shows the log output for the rejection in the previous example with the JSON log formatter including the two aspects.

![The screenshot is explained in the accompanying text.](assets/json-formatter-output.png)

::: warning
The SAP Application Logging Service offers [different plans with different quotas](https://help.sap.com/docs/application-logging-service/sap-application-logging-service/service-plans-and-quotas). Please make sure the plan you use is sufficient, that is, no logs are being dropped so that the information is available in Kibana. As soon as logs are dropped, you cannot reliably assess what is going on in your app.
:::


### Header Masking

Some header values shall not appear in logs, for example when pertaining to authorization. Configuration option <Config keyOnly>cds.log.mask_headers: ["/authorization/i", "/cookie/i", "/cert/i", "/ssl/i"]</Config> allows to specify a list of matchers for which the header value shall be masked. Masked values are printed as `***`. The default value is `["/authorization/i", "/cookie/i", "/cert/i", "/ssl/i"]`.

::: warning
In case your application shares any sensitive data (for example, secrets) via headers, please ensure that you adjust the configuration as necessary.
:::

::: tip
In the log entry, header field names are normalized to lowercase with `_` instead of `-`.
Make sure your matchers work on the original header name, for example, `"/Foo-Bar/"` instead of the normalized `"/foo_bar/"`.
:::


### Custom Fields { #custom-fields }

Information that is not included in the [list of supported fields](https://help.sap.com/docs/application-logging-service/sap-application-logging-service/supported-fields) of the SAP Application Logging Service can be shown as additional information. This information needs to be provided as custom fields.

By default, the JSON formatter uses the following custom fields configuration for SAP Application Logging Service:

```jsonc
{
  "log": {
    "als_custom_fields": {
      // <key>: <index>
      "query": 0,                //> sql
      "target": 1, "details": 2, //> generic validations
      "reason": 3                //> errors
    }
  }
}
```

Up to 20 such custom fields can be provided using this mechanism. The advantage of this approach is that the additional information can be indexed. Besides being a manual task, it has the drawback that the indexes should be kept stable.

::: details Background

The SAP Application Logging Service requires the following formatting of custom field content inside the JSON object that is logged:

```js
{
  ...,
  '#cf': {
    strings: [
      { k: '<key>', v: '<value>', i: <index> },
      ...
    ]
  }
}
```

That is, a generic collection of key-value-pairs that are treated as opaque strings.

The information is then rendered as follows:

```txt
custom.string.key0: <key>
custom.string.value0: <value>
```

Hence, in order to analyze, for example, the SQL statements leading to errors, you'd need to look at field `custom.string.value0` (given the default of `cds.env.log.als_custom_fields`).

In a more practical example, the log would look something like this:

```log
msg: SQL Error: Unknown column "IDONTEXIST" in table "DUMMY"
...
custom.string.key0: query
custom.string.value0: SELECT IDONTEXIST FROM DUMMY
```

Without the additional custom field `query` and it's respective value, it would first be necessary to reproduce the issue locally to know what the faulty statement is.

:::

For SAP Cloud Logging, the JSON formatter uses the following default configuration:

```jsonc
{
  "log": {
    "cls_custom_fields": [
      "query",             //> sql
      "target", "details", //> generic validations
      "reason"             //> errors
    ]
  }
}
```

In order for the JSON formatter to detect the binding to SAP Cloud Logging via user-provided service, the user-provided service must have either tag `cloud-logging` or `Cloud Logging`.
(For existing user-provided services, tags can be added via [`cf update-user-provided-service`](https://cli.cloudfoundry.org/en-US/v7/update-user-provided-service.html).)

The key-value pairs can either be part of the first argument or an exclusive object thereafter:

```js
LOG.info({ message: 'foo', reason: 'bar' })
LOG.info('foo', { reason: 'bar' })
```

As always, both defaults are overridable via [cds.env](cds-env#cds-env).


## Request Correlation { #node-observability-correlation }

Unfortunately, there is no standard correlation ID header. `x-correlation-id` and `x-request-id` are the most commonly used, but SAP products often use `x-correlationid` (that is, without the second hyphen) and SAP BTP uses `x-vcap-request-id` when logging incoming requests.

As CAP aims to be platform independent, we check an array of headers (or generate a new ID if none hits) and ensure the value available at `cds.context.id` as well as `req.headers['x-correlation-id']`:

```js
const { headers: h } = req
const id = h['x-correlation-id'] || h['x-correlationid']
  || h['x-request-id'] || h['x-vcap-request-id']
  || uuid()
if (!cds.context) cds.context = { id }
req.headers['x-correlation-id'] = cds.context.id
```

Subsequently, the JSON log formatter (see [Logging in Production](#logging-in-production)) sets the following fields:
- `cds.context.id` &rarr; `correlation_id`
- Request header `x_vcap_request_id` &rarr; `request_id`
- Request header `traceparent` (cf. [W3C Trace Context](https://www.w3.org/TR/trace-context/)) &rarr; `w3c_traceparent`

Specifically field `w3c_traceparent` is then used by both SAP Application Logging Service and SAP Cloud Logging to determine field `trace_id` in order to correlate requests, logs, and traces across multiple applications.

The following screenshot shows an example for log correlation based on field `correlation_id` in a log analytic dashboard of the [SAP Application Logging Service for SAP BTP](https://help.sap.com/docs/application-logging-service).

![Default Formatter Output](assets/correlation.png)



# Project-Specific Configurations

Learn here about using cds.env to specify and access configuration options for the Node.js runtimes as well as the @sap/cds-dk CLI commands.


## CLI `cds env` Command {#cli}

Run the `cds env` command in the root folder of your project to see the effective configuration.
The listed settings include [global defaults](#defaults) as well as [project-specific settings](#project-settings)
and [process environment settings](#process-env).

Here's a brief intro how to use it:

```sh
cds env               #> shortcut to `cds env ls`
cds env ls            #> lists all settings in properties format
cds env ls folders    #> lists the `folders` settings
cds env get           #> prints all settings in JSON-like format
cds env get folders   #> prints the `folders` settings
cds env get defaults  #> prints defaults only
cds env ?             #> get help
```

For example:


<pre class="log">
> cds env ls requires.db

requires.db.credentials.url = <em>':memory:'</em>
requires.db.impl = <em>'@cap-js/sqlite'</em>
requires.db.kind = <em>'sqlite'</em>
</pre>


<br>


<pre class="log">
> cds env requires.db

{
  impl: <em>'@cap-js/sqlite'</em>,
  credentials: { url: <em>':memory:'</em> },
  kind: <em>'sqlite'</em>
}
</pre>



Alternatively, you can also use the `cds eval` or `cds repl` CLI commands to access the `cds.env` property, which provides programmatic access to the effective settings:


<pre class="log">
> cds -e .env.requires.db

{
  impl: <em>'@cap-js/sqlite'</em>,
  credentials: { url: <em>':memory:'</em> },
  kind: <em>'sqlite'</em>
}
</pre>


<br>

<pre class="log">
<i>$</i> cds -r
<em>Welcome to cds repl ...</em>
> cds.env.requires.db
{
  impl: <em>'@cap-js/sqlite'</em>,
  credentials: { url: <em>':memory:'</em> },
  kind: <em>'sqlite'</em>
}
</pre>


## The `cds.env` Module {#cds-env}

The `cds env` CLI command and all configuration-related tasks and features in Node.js-based tools and runtimes are backed by the `cds.env` module, which can be accessed through the central `cds` facade. For example, you can use it as follows:

```js
const cds = require('@sap/cds')
console.log (cds.env.requires.sql)
```
> This would print the same output as the one above for `cds env get requires.sql`.

As depicted in the figure below `cds.env` provides one-stop convenient and transparent access to the effective configuration read from various sources, including global defaults, static, project-specific configuration as well as dynamic settings from process environment and service bindings. Different environments, for example, dev vs prod can be identified and selected by [profiles](#profiles).

!['cds env' in the middle, targeted by arrows coming from project content, service bindings and environment.](./assets/cds.env.drawio.svg)

## Sources for `cds.env`

`cds.env` is actually a getter property, which on first usage loads settings from the following sources:

| order | source | |
|-|-|-|
| 1 | [`@sap/cds`](#defaults) | built-in defaults
| 2 | [_~/.cdsrc.json_](#defaults) | user-specific defaults
| 3 | [_./.cdsrc.json_](#project-settings) | static project settings
| 4 | [_./package.json_](#project-settings) | static project settings &rarr; `{"cds":{ ... }}`
| 5 | [_./.cdsrc-private.json_](#private-project-settings) | user-specific project config |
| 6 | [_./default-env.json_](#process-env) | *deprecated, see cds bind*
| 7 | [_./.env_](#process-env)  | user-specific project env (lines of `name=value`)
| 8 | [`process.env.CDS_CONFIG`](#env-cds-config) | runtime settings from shell or cloud
| 9 | [`process.env`](#process-env) | runtime env vars from shell or cloud
| 10 |  [`process.env.VCAP_SERVICES`](#services) | service bindings
| 11 |  [_~/.cds-services.json_](#services) | service bindings for [_development_ profile](#profiles)

> - `./` represents a project's root directory.
> - `~/` represents a user's home directory.

::: warning
Private files are for you only and should not be checked into your source code management.
:::

The settings are merged into `cds.env` starting from lower to higher order. Meaning that propertiers specified in a source of higher order will overwrite the value from a lower order.

For example, given the following sources:

::: code-group
```jsonc [cdsrc.json]
{
  "requires": {
    "db": {
      "kind": "sql",
      "model": "./db",
      "credentials": { "url": ":memory:" }
    }
  }
}
```
:::

::: code-group
```jsonc [package.json]
{
  "cds": {
    "requires": {
      "db": {
        "kind": "sqlite"
      }
    }
  }
}
```
:::

::: code-group
```properties [env.properties]
cds.requires.db.credentials.database = my.sqlite
```
:::

This would result in the following effective configuration:
```js
cds.env = { ...,
  requires: {
    db: {
      kind: "sqlite",
      model: "./db",
      credentials: { database:"my.sqlite" }
    }
  }
}
```



### Programmatic Settings

Node.js programs can also add and change settings by simply assigning values like so:

```js
const cds = require('@sap/cds')
cds.env.requires.sql.kind = 'sqlite'
cds.env.requires.sql.credentials = { database:'my.sqlite' }
```

> This would change the respective settings in the running program only, without writing back to the sources listed above.


## Global Defaults {#defaults}


### Built-In to `@sap/cds`

The lowest level of settings is read from built-in defaults, which comprise settings for these top-level properties:

| Settings   | Description                                  |
|------------|----------------------------------------------|
| `build`    | for build-related settings                   |
| `features` | to switch on/off cds features                |
| `folders`  | locations for `app`, `srv`, and `db` folders |
| `i18n`     | for i18n-related settings                    |
| `odata`    | for OData protocol-related settings          |
| `requires` | to configure required services               |

> As these properties are provided in the defaults, apps can safely access them, for example, through `cds.env.requires.sql`, without always checking for null values on the top-level entries.


### User-Specific Defaults in _~/.cdsrc.json_

You can also create a _.cdsrc.json_ file in your user's home folder to specify
settings to be used commonly across several projects.


## Project Configuration {#project-settings}

Settings, which are essential to your project topology go into static project settings.
Examples are the `folders` layout of your project, specific `build` tasks, or the list
of required services in `requires` — most frequently your primary database configured
under `requires.db`.

::: tip
The settings described here are part of your project's static content and delivery. They're checked in to your git repos and used also in productive deployments. **Don't** add environment-specific options as static settings but use one of the [dynamic process environment options](#process-env) for that.
:::

### In _./package.json_

You can provide static settings in a `"cds"` section of your project's _package.json_ as in the following example:

```json
"cds": {
  "requires": {
    "db": "sql"
  }
}
```

### In _./.cdsrc.json_

Alternatively, you can put static settings in _.cdsrc.json_ file in your project root:

```json
"requires": {
  "db": "sql"
}
```

## Private Project Settings {#private-project-settings}

### In _./.cdsrc-private.json_

A _.cdsrc.json_ equivalent for your private settings used in local testing. The file should not be committed to your version control system.

## Process Environment {#process-env}

### On the Command Line

On UNIX-based systems (Mac, Linux) you can specify individual process env variables as prefixes to the command to start your server.
For example:

```sh
CDS_REQUIRES_DB_KIND=sql cds run
```

### In _./default-env.json_

The use of _default-env.json_ is deprecated. Please use [`cds bind`](../advanced/hybrid-testing#run-with-service-bindings).


### In `./.env`

Example for `.env`:

```properties
cds_requires_db_kind = sql
```

or

```properties
cds.requires.db.kind = sql
```

or

```properties
cds.requires.db = { "kind": "sql" }
```

::: warning
The dot ("`.`") notation can only be used in `.env` files, because the dot is not a valid environment variable character. You can use it here if your config string contains underscore ("`_`") characters.
:::

### `CDS_CONFIG` env variable {#env-cds-config}

You can use the `CDS_CONFIG` env variable in three different ways to add settings to the CDS environment:

1. Using a JSON string

    ```sh
    CDS_CONFIG='{"requires":{"db":{"kind":"sqlite"}}}' cds serve
    ```

2. Using a JSON file

    ```sh
    CDS_CONFIG=./my-cdsrc.json cds serve
    ```

3. Using a directory

    ```sh
    CDS_CONFIG=/etc/secrets/cds cds serve
    ```

    For each file and folder, a new property is added to the configuration with its name. For a file the property value is the string content of the file. But if a file contains a parsable JSON string starting with `[` or `{` character, it is parsed and added as a substructure.
    For a directory an object is added and the algorithm continues there.

    ```yaml
    /etc/secrets/cds/requires/auth/kind: xsuaa
    /etc/secrets/cds/requires/auth/credentials/clientid: capapp
    /etc/secrets/cds/requires/auth/credentials/clientsecret: dlfed4XYZ
    /etc/secrets/cds/requires/db:
      { kind: "hana", "credentials": { "user": "hana-user" } }
    ```

    Results in:

    ```json
    {
      "requires": {
        "auth": {
          "kind": "xsuaa",
          "credentials": {
            "clientid": "cpapp",
            "clientsecret": "dlfed4XYZ"
          }
        },
        "db": {
          "kind": "hana",
          "credentials": {
            "user": "hana-user"
          }
        }
      }
    }
    ```

## Required Services {#services}

If your app requires external services (databases, message brokers, ...), you must
add them to the `cds.requires` section.

### In `cds.requires.<service>` Settings

Here, you can configure the services. Find details about the individual options in the documentation of [`cds.connect`](cds-connect#cds-env-requires).

### Prototype-Chained Along `.kind` References

You can use the `kind` property to reference other services for prototype chaining.
> CDS provides default service configurations for all supported services (`hana`, `enterprise-messaging`, ...).

Example:

::: code-group
```json [package.json]
{
  "cds": {
    "requires": {
      "serviceA": {
        "kind": "serviceB",
        "myProperty": "my overwritten property"
      },
      "serviceB": {
        "kind": "hana",
        "myProperty": "my property",
        "myOtherProperty": "my other property"
      }
    }
  }
}
```
:::

`serviceA` will have the following properties:

```json
{
  "kind": "serviceB",
  "myProperty": "my overwritten property",
  "myOtherProperty": "my other property", // from serviceB
  "impl": "[...]/hana/Service.js", // from hana
  "use": "hana" // where impl is defined
}
```


## Configuration Profiles {#profiles}

Wrap entries into `[<profile-name>]:{ ... }` to provide settings for different environments. For example:

::: code-group
```json [package.json]
{
  "cds": {
    "requires": {
      "db": {
        "[development]": { "kind": "sqlite" },
        "[production]": { "kind": "hana" }
      }
    }
  }
}
```
:::

The profile is determined at bootstrap time as follows:

1. from `--production` command line argument, if specified
2. from `--profile` command line argument, if specified
3. from `NODE_ENV` property, if specified
4. from `CDS_ENV`, if specified

If the profile is not set to `production`, the `development` profile is automatically enabled.

You can also introduce own custom profile names and use them as follows:

```sh
cds run --profile my-custom-profile
```

or

::: code-group
```sh [Mac/Linux]
CDS_ENV=my-custom-profile cds run
```
```cmd [Windows]
set CDS_ENV=my-custom-profile
cds run
```
```powershell [Powershell]
$Env:CDS_ENV=my-custom-profile
cds run
```
:::


## App-Specific Settings

You can use the same machinery as documented above for app-specific configuration options:

::: code-group

```json [package.json]
"cds": { ... },
"my-app": { "myoption": "value" }
```

:::

And access them from your app as follows:

```js
const { myoption } = cds.env.for('my-app')
```



# Transaction Management

Transaction management in CAP deals with (ACID) database transactions, principal / context propagation on service-to-service calls and tenant isolation.

::: tip **In Essence...** 
As an application developer, **you don't have to care** about transactions, principal propagation, or tenant isolation at all. CAP runtime manages that for you automatically. Only in rare cases, you need to go beyond that level, and use one or more of the options documented hereinafter.
:::

<br>


## Automatic Transactions


Whenever an instance of `cds.Service` processes requests, the core framework automatically cares for starting and committing or rolling back database transactions, connection pooling, principal propagation and tenant isolation.

For example a call like that:

```js
await db.read('Books')
```

... will cause this to take place on SQL level:

```sql
-- ACQUIRE connection from pool
CONNECT; -- if no pooled one
BEGIN;
SELECT * from Books;
COMMIT;
-- RELEASE connection to pool
```

<br>

::: tip
**Service-managed Transactions** — whenever a service operation, like `db.read()` above, is executed, the core framework ensures it will either join an existing transaction, or create a new root transaction. Within event handlers, your service always is in a transaction.
:::



## Nested Transactions

Services commonly process requests in event handlers, which in turn send requests to other services, like in this simplistic implementation of a bank transfer operation:

```js
const log = cds.connect.to('log')
const db = cds.connect.to('db')

BankingService.on ('transfer', req => {
  let { from, to, amount } = req.data
  await db.update('BankAccount',from).set('balance -=', amount),
  await db.update('BankAccount',to).set('balance +=', amount),
  await log.insert ({ kind:'Transfer', from, to, amount })
})
```

Again, all transaction handling is done by the CAP core framework, in this case by orchestrating three transactions:

1. A *root* transaction for `BankingService.transfer`
2. A *nested* transaction for the calls to the `db` service
3. A *nested* transaction for the calls to the `log` service

Nested transactions are automatically committed when their root transaction is committed upon successful processing of the request; or rolled back if not.

<br>

::: warning
**No Distributed Transactions** — Note that in the previous example, the two nested transactions are *synchronized* with respect to a final commit / rollback, but *not as a distributed atomic transaction*. This means, it still can happen, that the commit of one nested transaction succeeds, while the other fails.
:::



## Manual Transactions

Use `cds.tx()` to start and commit transactions manually, if you need to ensure two or more queries to run in a single transaction. The easiest way to achieve this is shown below:

```js
cds.tx (async ()=>{
  const [ Emily ] = await db.insert (Authors, {name:'Emily Brontë'})
  await db.insert (Books, { title: 'Wuthering Heights', author: Emily })
})
```

[Learn more about `cds.tx()`](#srv-tx){.learn-more}

This usage variant, which accepts a function with nested operations ...

1. creates a new root transaction
2. executes all nested operations in this transaction
3. automatically finalizes the transaction with commit or rollback

<br>

::: tip
**Only in non-managed environments** — as said above: you don't need to care for that if you are in a managed environment, that is, when implementing an event handler. In that case, the core service runtime automatically created a transaction for you already.
:::

::: warning _❗ Warning_ 
If you're using the database SQLite, it leads to deadlocks when two transactions wait for each other. Parallel transactions are not allowed and a new transaction is not started before the previous one is finished.
:::


## Background Jobs

Background jobs are tasks to be executed *outside of the current transaction*, possibly also with other users, and maybe repeatedly. Use `cds.spawn()` to do so:

```js
// run in current tenant context but with privileged user
// and with a new database transactions each...
cds.spawn ({ user: cds.User.privileged, every: 1000 /* ms */ }, async ()=>{
  const mails = await SELECT.from('Outbox')
  await MailServer.send(mails)
  await DELETE.from('Outbox').where (`ID in ${mails.map(m => m.ID)}`)
})
```

[Learn more about `cds.spawn()`](#cds-spawn){.learn-more}



## cds. context {#event-contexts .property}

Automatic transaction management, as offered by the CAP, needs access to properties of the invocation context — most prominently, the current **user** and **tenant**, or the inbound HTTP request object.


### Accessing Context

Access that information anywhere in your code through `cds.context` like that:

```js
// Accessing current user
const { user } = cds.context
if (user.is('admin')) ...
```

```js
// Accessing HTTP req, res objects
const { req, res } = cds.context.http
if (!req.is('application/json')) res.send(415)
```

[Learn more about available `cds.context` properties](events#cds-context){.learn-more}

### Setting Contexts

Setting `cds.context` usually happens in inbound authentication middlewares or in inbound protocol adapters. You can also set it in your code, for example, you might implement a simplistic custom authentication middleware like so:

```js
app.use ((req, res, next) => {
  const { 'x-tenant':tenant, 'x-user-id':user } = req.headers
  cds.context = { tenant, user } // Setting cds.context
  next()
})
```



### Continuation-local Variable

`cds.context` is implemented as a so-called *continuation-local* variable.

As JavaScript is single-threaded, we cannot capture request-level invocation contexts such (as current user, tenant, or locale) in what other languages like Java call thread-local variables. But luckily, starting with Node v12, means for so-called *"Continuation-Local Storage (CLS)"* were given to us. Basically, the equivalent of thread-local variables in the asynchronous continuations-based execution model of Node.js.


### Context Propagation

When creating new root transactions in calls to `cds.tx()`, all properties not specified in the `context` argument are inherited from `cds.context`, if set in the current continuation.

In effect, this means the new transaction demarcates a new ACID boundary, while it inherits the event context properties unless overridden in the `context` argument to `cds.tx()`. The following applies:

```js
cds.context = { tenant:'t1', user:'u1' }
cds.context.user.id === 'u1'          //> true
let tx = cds.tx({ user:'u2' })
tx.context !== cds.context            //> true
tx.context.tenant === 't1'            //> true
tx.context.user.id === 'u2'           //> true
tx.context.user !== cds.context.user  //> true
cds.context.user.id === 'u1'          //> true
```




## cds/srv. tx() {#srv-tx .method}

```tsx
function srv.tx ( ctx?, fn? : tx<srv> => {...} ) => Promise
function srv.tx ( ctx? ) => tx<srv>
var ctx : { tenant, user, locale }
```

Use this method to run the given function `fn` and all nested operations in a new *root* transaction.
For example:

```js
await srv.tx (async tx => {
  let exists = await tx.run ( SELECT(1).from(Books,201).forUpdate() )
  if (exists) await tx.update (Books,201).with(data)
  else await tx.create (Books,{ ID:201,...data })
})
```

::: details Transaction objects  `tx<srv>`

The `tx` object created by `srv.tx()` and passed to the function `fn` is a derivate of the service instance, constructed like that:

```js
tx = { __proto__:srv,
  context: { tenant, user, locale }, // defaults from cds.context
  model: cds.model, // could be a tenant-extended variant instead
  commit(){...},
  rollback(){...},
}
```

:::



The new root transaction is also active for all nested operations run from fn, including other services, most important database services. In particular, the following would work as well as expected (this time using `cds.tx` as shortcut `cds.db.tx`):

```js
await cds.tx (async () => {
  let exists = await SELECT(1).from(Books,201).forUpdate()
  if (exists) await UPDATE (Books,201).with(data)
  else await INSERT.into (Books,{ ID:201,...data })
})
```

**Optional argument `ctx`** allows to override values for nested contexts, which are otherwise inherited from `cds.context`, for example:

```js
await cds.tx ({ tenant:t0, user: privileged }, async ()=>{
  // following + nested will now run with specified tenant and user...
  let exists = await SELECT(1).from(Books,201).forUpdate()
  ...
})
```

**If argument `fn` is omitted**, the constructed `tx` would be returned and can be used to manage the transaction in a fully manual fashion:

```js
const tx = srv.tx() // [!code focus]
try { // [!code focus]
  let exists = await tx.run ( SELECT(1).from(Books,201).forUpdate() )
  if (exists) await tx.update (Books,201).with(data)
  else await tx.create (Books,{ ID:201,...data })
  await tx.commit() // [!code focus]
} catch(e) {
  await tx.rollback(e) // will rethrow e // [!code focus]
} // [!code focus]
```

::: warning

Note though, that with this usage we've **not** started a new async context, and all nested calls to other services, like db, will **not** happen within the confines of the constructed `tx`.

:::






### srv.tx  <i>  (context?, fn?) → tx\<srv\> </i>


Use `srv.tx()` to start new app-controlled transactions manually, most commonly for [database services](databases) as in this example:

```js
let db = await cds.connect.to('db')
let tx = db.tx()
try {
  await tx.run (SELECT.from(Foo))
  await tx.create (Foo, {...})
  await tx.read (Foo)
  await tx.commit()
} catch(e) {
  await tx.rollback(e)
}
```

**Arguments:**

* `context` – an optional context object → [see below](#srv-tx-ctx)
* `fn` – an optional function to run → [see below](#srv-tx-fn)

**Returns:** a transaction object, which is constructed as a derivate of `srv` like that:

```js
tx = Object.create (srv, Object.getOwnPropertyDescriptors({
  commit(){...},
  rollback(){...},
}))
```

In effect, `tx` objects ...

* are concrete context-specific — that is tenant-specific — incarnations of `srv`es
* support all the [Service API](core-services) methods like `run`, `create` and `read`
* support methods `tx.commit` and `tx.rollback` as documented below.

**Important:** The caller of `srv.tx()` is responsible to `commit` or `rollback` the transaction, otherwise the transaction would never be finalized and respective physical driver connections never be released / returned to pools.

### srv.tx  <i>  ({ tenant?, user?, ... }) → tx\<srv\> </i> {#srv-tx-ctx}

Optionally specify an object with [event context](events#cds-event-context) properties as the *first* argument to execute subsequent operations with different tenant or user context:

```js
let tx = db.tx ({ tenant:'t1' user:'u2' })
```

The argument is an object with these properties:

* `user` — a unique user ID string or an [instance of `cds.User`](authentication#cds-user)
* `tenant` — a unique string identifying the tenant
* `locale` — a locale string in format `<language>_<region>`

The implementation constructs a new instance of [cds.EventContext](events#cds-event-context) from the given properties, which is assigned to [tx.context](#tx-context) of the new transaction.

[Learn more in section **Continuations & Contexts**.](#event-contexts){.learn-more}




### srv.tx  <i>  ((tx)=>{...}) → tx\<srv\> </i> {#srv-tx-fn}

Optionally specify a function as the *last* argument to have `commit` and `rollback` called automatically. For example, the following snippets are equivalent:

```js
await db.tx (async tx => {
  await tx.run (SELECT.from(Foo))
  await tx.create (Foo, {...})
  await tx.read (Foo)
})
```

```js
let tx = db.tx()
try {
  await tx.run (SELECT.from(Foo))
  await tx.create (Foo, {...})
  await tx.read (Foo)
  await tx.commit()
} catch(e) {
  await tx.rollback(e)
}
```

In addition to creating a new tx for the current service,

### srv.tx  <i>  (ctx) → tx\<srv\> </i> {#srv-tx-context}

If the argument is an instance of [cds.EventContext](events#cds-event-context) the constructed transaction will use this context as it's `tx.context`.
If the specified context was constructed for a transaction started with `cds.tx()`, the new transaction will be constructed as a nested transaction. If not, the new transaction will be constructed as a root transaction.

```js
cds.context = { tenant:'t1', user:'u2' }
const tx = cds.tx (cds.context)
//> tx is a new root transaction
```

```js
const tx = cds.context = cds.tx ({ tenant:'t1', user:'u2' })
const tx1 = cds.tx (cds.context)
//> tx1 is a new nested transaction to tx
```


### _↳_ <span>tx</span>.context  <i>  → [cds.EventContext](events#cds-event-context) </i> {#tx-context }

Each new transaction created by [cds.tx()](#srv-tx) will get a new instance of [cds.EventContext](events#cds-event-context) constructed and assigned to this property. If there is a `cds.context` set in the current continuation, the newly constructed context object will inherit properties from that.

[Learn more in section **Continuations & Contexts**.](#event-contexts){.learn-more}


### _↳_ <span>tx</span>.commit  <i>  (res?) ⇢ res </i> {#commit }

In case of database services, this sends a `COMMIT` (or `ROLLBACK`) command to the database and releases the physical connection, that is returns it to the connection pool. In addition, the commit is propagated to all nested transactions.

The methods are [bound](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind) to the `tx` instance, and the passed-in argument is returned, or rethrown in case of `rollback`, which allows them to be used as follows:

```js
let tx = cds.tx()
tx.run(...) .then (tx.commit, tx.rollback)
```


###  _↳_ <span>tx</span>.rollback  <i>  (err?) ⇢ err </i> {#rollback }

In case of database services, this sends `ROLLBACK` command to the database and releases the physical connection. In addition, the rollback is propagated to all nested transactions, and if an `err` object is passed, it is rethrown.

[See documentation for `commit` for common details.](#commit){.learn-more}

<br>

::: warning
**Note:** `commit` and `rollback` both release the physical connection. This means subsequent attempts to send queries via this `tx` will fail.
:::



## cds.spawn() {#cds-spawn .method}

Runs the given function as detached continuation in a specified event context (not inheriting from the current one).
Options `every` or `after` allow to run the function repeatedly or deferred. For example:

```js
cds.spawn ({ tenant:'t0', every: 1000 /* ms */ }, async (tx) => {
  const mails = await SELECT.from('Outbox')
  await MailServer.send(mails)
  await DELETE.from('Outbox').where (`ID in ${mails.map(m => m.ID)}`)
})
```

::: tip
Even though the callback function is executed as a background job, all asynchronous operations inside the callback function must be awaited. Otherwise, transaction handling does not work properly.
:::

**Arguments:**

* `options` is the same as the `ctx` argument for `cds.tx()`, plus:
  * `every: <n>` number of milliseconds to use in `setInterval(fn,n)`
  * `after: <n>` number of milliseconds to use in `setTimeout(fn,n)`
  * if non of both is given, `setImmediate(fn)` is used to run the job
* `fn` is a function representing the background task

**Returns:**

- An event emitter which allows to register handlers on `succeeded`, `failed`, and `done` events.

```js
let job = cds.spawn(...)
job.on('succeeded', ()=>console.log('succeeded'))
```

- In addition, property `job.timer` returns the response of `setTimeout` in case option `after` was used, or `setInterval` in case of option `every`. For example, this allows to stop a regular running job like that:

```js
let job = cds.spawn({ every:111 }, ...)
await sleep (11111)
clearInterval (job.timer) // stops the background job loop
```

The implementation guarantees decoupled execution from request-handling threads/continuations, by...

- constructing a new root transaction `tx` per run using `cds.tx()`
- setting that as the background run's continuation's `cds.context`
- invoking `fn`, passing `tx` as argument to it.

Think of it as if each run happens in an own thread with own context, with automatic transaction management.

By default, the nested context inherits all values except `timestamp` from `cds.context`, especially user and tenant. Use the argument `options` if you want to override values, for example to run the background thread with different user or tenant than the one you called `cds.spawn()` from.



## DEPRECATED APIs

#### srv.tx <i> (req) → tx\<srv\> </i> {#srv-tx-req}

Prior to release 5, you always had to write application code like that to ensure context propagation and correctly managed transactions:

```js
this.on('READ','Books', req => {
  const tx = cds.tx(req)
  return tx.read ('Books')
})
```

This still works but is not required **nor recommended** anymore.



# Authentication

{{$frontmatter?.synopsis}} This is done by [authentication middlewares](#strategies) setting the [`cds.context.user` property](#cds-user) which is then used in [authorization enforcement](#enforcement) decisions.

## cds. User { #cds-user .class }
[user]: #cds-user
[`cds.context.user`]: #cds-user

Represents the currently logged-in user as filled into [`cds.context.user`](events#user) by authentication middlewares.
Simply create instances of `cds.User` or of subclasses thereof in custom middlewares.
For example:

```js
const cds = require('@sap/cds')
const DummyUser = new class extends cds.User { is:()=>true }
module.exports = (req,res,next) => {
  cds.context.user = new DummyUser('dummy')
  next()
}
```

Or you can call the constructor of `cds.User` with specific arguments, to create a user instance. For example:
```js
const cds = require('@sap/cds')
// with user ID as string
const user = new cds.User('userId')
// a user instance
const anotherUser = new cds.User(user)
// a user instance like object
const yetAnotherUser = new cds.User({id: user.id, roles: user.roles, attr: user.attr})
```


### .is <i> (\<role\>) </i> {#user-is .method}

Checks if user has assigned the given role. Example usage:

```js
if (req.user.is('admin')) ...
```

The role names correspond to the values of [`@requires` and the `@restrict.grants.to` annotations](../guides/security/authorization) in your CDS models.


### . id {#user-id .property}

A user's unique ID.
It corresponds to `$user` in [`@restrict` annotations](../guides/security/authorization) of your CDS models
(Also in JavaScript, `user` can act as a shortcut for `user.id` in comparisons.) {.indent}



### . attr {#user-attr .property}

User-related attributes, for example, from JWT tokens
These correspond to `$user.<x>` in [`@restrict` annotations](../guides/security/authorization) of your CDS models {.indent}

### . tokenInfo {#user-token-info .property}

Parsed JWT token info provided by `@sap/xssec`.

<div id="xssec-tokeninfo-reference" />
<Fragment target="#xssec-tokeninfo-reference">

[For more information see the API description.](https://github.wdf.sap.corp/CPSecurity/node-xs2sec/blob/master/doc/TokenInfo.md) <Internal />{.learn-more}

</Fragment>

> **Note:** This API is only available for authentication kinds based on `@sap/xssec`.



## cds.**User.Privileged** { #privileged-user .class }

In some cases, you might need to bypass authorization checks while [consuming a local service](./core-services). For this, you can create a transaction with a privileged user as follows:

```js
this.before('*', function (req) {
  const user = new cds.User.Privileged
  return this.tx({ user }, tx => tx.run(
    INSERT.into('RequestLog').entries({
      url: req._.req.url,
      user: req.user.id
    })
  )
})
```

Alternatively, you can also use the ready-to-use instance `cds.User.privileged` directly, that is, `const user = cds.User.privileged`.


## cds.**User.Anonymous** { #anonymous-user .class }

Class `cds.User.Anonymous` allows you to instantiate an anonymous user (`const user = new cds.User.Anonymous`), for example in a [custom authentication](#custom) implementation.

Alternatively, you can also use the ready-to-use instance `cds.User.anonymous` directly, that is, `const user = cds.User.anonymous`.


## cds.**User.default** { #default-user .property }

If a request couldn't be authenticated, for example due to a missing authorization header, the framework will use `cds.User.default` as fallback.

By default, `cds.User.default` points to `cds.User.Anonymous`. However, you can override this, for example to be `cds.User.Privileged` in tests, or to be any other class that returns an instance of `cds.User`.


## Authorization Enforcement {#enforcement}

Applications can use the `cds.context.user` APIs to do programmatic enforcement.
For example, the authorization of the following CDS service:

```cds
service CustomerService @(requires: 'authenticated-user'){
  entity Orders @(restrict: [
    { grant: ['READ','WRITE'], to: 'admin' },
  ]){/*...*/}
  entity Approval @(restrict: [
    { grant: 'WRITE', where: '$user.level > 2' }
  ]){/*...*/}
}
```

can be programmatically enforced by means of the API as follows:

```js
const cds = require('@sap/cds')
cds.serve ('CustomerService') .with (function(){
  this.before ('*', req =>
    req.user.is('authenticated') || req.reject(403)
  )
  this.before (['READ', 'CREATE'], 'Orders', req =>
    req.user.is('admin') || req.reject(403)
  )
  this.before ('*', 'Approval', req =>
    req.user.attr.level > 2 || req.reject(403)
  )
})
```


## Authentication Strategies {#strategies}

CAP ships with a few prebuilt authentication strategies, used by default: [`mocked`](#mocked) during development and [`jwt`](#jwt) in production.
You can override these defaults and configure the authentication strategy to be used through the `cds.requires.auth` [config option in `cds.env`](./cds-env), for example:

::: code-group
```json [package.json]
"cds": {
  "requires": {
    "auth": "jwt"
  }
}
```
:::

::: tip Inspect effective configuration
Run `cds env get requires.auth` in your project root to find out the effective config for your current environment.
:::


### Dummy Authentication {#dummy }

This strategy creates a user that passes all authorization checks. It's meant for temporarily disabling the `@requires` and `@restrict` annotations at development time.

**Configuration:** Choose this strategy as follows:

::: code-group
```json [package.json]
"cds": {
  "requires": {
    "auth": "dummy"
  }
}
```
:::


### Mocked Authentication {#mocked }

This authentication strategy uses basic authentication with pre-defined mock users during development.

> **Note:** When testing different users in the browser, it's best to use an incognito window, because logon information might otherwise be reused.

**Configuration:** Choose this strategy as follows:

::: code-group
```json [package.json]
"cds": {
  "requires": {
    "auth": "mocked"
  }
}
```
:::

You can optionally configure users as follows:

::: code-group
```json [package.json]
"cds": {
  "requires": {
    "auth": {
      "kind": "mocked",
      "users": {
        "<user.id>": {
          "password": "<password>",
          "roles": [ "<role-name>", ... ],
          "attr": { ... }
        }
      }
    }
  }
}
```
:::


#### Pre-defined Mock Users {#mock-users}

The default configuration shipped with `@sap/cds` specifies these users:

```jsonc
  "users": {
    "alice": { "tenant": "t1", "roles": [ "admin" ] },
    "bob":   { "tenant": "t1", "roles": [ "cds.ExtensionDeveloper" ] },
    "carol": { "tenant": "t1", "roles": [ "admin", "cds.ExtensionDeveloper", "cds.UIFlexDeveloper" ] },
    "dave":  { "tenant": "t1", "roles": [ "admin" ], "features": [] },
    "erin":  { "tenant": "t2", "roles": [ "admin", "cds.ExtensionDeveloper", "cds.UIFlexDeveloper" ] },
    "fred":  { "tenant": "t2", "features": [ "isbn" ] },
    "me":    { "tenant": "t1", "features": [ "*" ] },
    "yves":  { "roles": [ "internal-user" ] }
    "*":     true //> all other logins are allowed as well
  }
```

This default configuration is merged with your custom configuration such that, by default, logins by alice, bob, ... and others (`*`) are allowed.

If you want to restrict these additional logins, you need to overwrite the defaults:

```jsonc
  "users": {
    "alice": { "roles": [] },
    "bob": { "roles": [] },
    "*": false //> do not allow other users than the ones specified
  }
```


### Basic Authentication {#basic }

This authentication strategy uses basic authentication to use mock users during development.

> **Note:** When testing different users in the browser, it's best to use an incognito window, because logon information might otherwise be reused.

**Configuration:** Choose this strategy as follows:

::: code-group
```json [package.json]
"cds": {
  "requires": {
    "auth": "basic"
  }
}
```
:::

You can optionally configure users as follows:

::: code-group
```json [package.json]
"cds": {
  "requires": {
    "auth": {
      "kind": "basic",
      "users": {
        "<user.id>": {
          "password": "<password>",
          "roles": [ "<role-name>", ... ],
          "attr": { ... }
        }
      }
    }
  }
}
```
:::

In contrast to [mocked authentication](#mocked), no default users are automatically added to the configuration.


### JWT-based Authentication { #jwt }

This is the default strategy used in production. User identity, as well as assigned roles and user attributes, are provided at runtime, by a bound instance of the ['User Account and Authentication'](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/419ae2ef1ddd49dca9eb65af2d67c6ec.html) service (UAA). This is done in form of a JWT token in the `Authorization` header of incoming HTTP requests.

This authentication strategy also adds [`cds.context.user.tokenInfo`](#user-token-info).

**Prerequisites:** You need to add [@sap/xssec](https://help.sap.com/docs/HANA_CLOUD_DATABASE/b9902c314aef4afb8f7a29bf8c5b37b3/54513272339246049bf438a03a8095e4.html#loio54513272339246049bf438a03a8095e4__section_atx_2vt_vt) to your project:
```sh
npm add @sap/xssec
```

**Configuration:** Choose this strategy as follows:

::: code-group
```json [package.json]
"cds": {
  "requires": {
    "auth": "jwt"
  }
}
```
:::

[Learn more about testing JWT-based authentication in **XSUAA in Hybrid Setup**.](#xsuaa-setup){.learn-more}


### XSUAA-based Authentication { #xsuaa }

Authentication kind `xsuaa` is a logical extension of kind [`jwt`](#jwt) that additionally offers access to SAML attributes through `cds.context.user.attr` (for example, `cds.context.user.attr.familyName`).

**Prerequisites:** You need to add [@sap/xssec](https://help.sap.com/docs/HANA_CLOUD_DATABASE/b9902c314aef4afb8f7a29bf8c5b37b3/54513272339246049bf438a03a8095e4.html#loio54513272339246049bf438a03a8095e4__section_atx_2vt_vt) to your project:
```sh
npm add @sap/xssec
```

**Configuration:** Choose this strategy as follows:

::: code-group
```json [package.json]
"cds": {
  "requires": {
    "auth": "xsuaa"
  }
}
```
:::

[See **XSUAA in Hybrid Setup** below for additional information of how to test this](#xsuaa-setup){.learn-more}


### IAS-based Authentication { #ias }

This is an additional authentication strategy using the [Identity Authentication Service](https://help.sap.com/docs/IDENTITY_AUTHENTICATION) (IAS) that can be used in production. User identity and user attributes are provided at runtime, by a bound instance of the IAS service. This is done in form of a JWT token in the `Authorization` header of incoming HTTP requests.

This authentication strategy also adds [`cds.context.user.tokenInfo`](#user-token-info).

To allow forwarding to remote services, JWT tokens issued by IAS service don't contain authorization information. In particular, no scopes are included. Closing this gap is up to you as application developer.

**Prerequisites:** You need to add [@sap/xssec](https://help.sap.com/docs/HANA_CLOUD_DATABASE/b9902c314aef4afb8f7a29bf8c5b37b3/54513272339246049bf438a03a8095e4.html#loio54513272339246049bf438a03a8095e4__section_atx_2vt_vt) to your project:
```sh
npm add @sap/xssec
```

**Configuration:** Choose this strategy as follows:

::: code-group
```json [package.json]
"cds": {
  "requires": {
    "auth": "ias"
  }
}
```
:::

#### Token Validation

For tokens issued by SAP Cloud Identity Service, `@sap/xssec` offers two additional validations: (1) token ownership via x5t thumbprint and (2) proof-of-possession.
These validations are enabled by default for requests to the app's `cert` route (`.cert` segment in the domain).

The default behavior can be overwritten using additional configuration as follows:

```json
"requires": {
  "auth": {
    "kind": "ias",
    "config": { // passed to @sap/xssec as is
      "validation": {
        "x5t": { "enabled": false },
        "proofToken": { "enabled": false }
      }
    }
  }
}
```

Please see [`@sap/xssec` documentation](https://www.npmjs.com/package/@sap/xssec) for more details.

### Custom Authentication { #custom }

You can configure an own implementation by specifying an own `impl` as follows:

```json
"requires": {
  "auth": {
    "impl": "srv/custom-auth.js" // > relative path from project root
  }
}
```

Essentially, custom authentication middlewares must do two things:

First, they _must_ [fulfill the `cds.context.user` contract](#cds-user) by assigning an instance of `cds.User` or a look-alike to the continuation of the incoming request at `cds.context.user`.

Second, if running in a multitenant environment, `cds.context.tenant` must be set to a string identifying the tenant that is addressed by the incoming request.

```js
module.exports = function custom_auth (req, res, next) {
  // do your custom authentication
  cds.context.user = new cds.User({
    id: '<user-id>',
    roles: ['<role-a>', '<role-b>'],
    attr: {
      <user-attribute-a>: '<value>',
      <user-attribute-b>: '<value>'
    }
  })
  cds.context.tenant = '<tenant>'
}
```

The TypeScript equivalent has to use the default export.

```ts
import cds from "@sap/cds";
import {Request, Response, NextFunction} from "express";
type Req = Request & { user: cds.User, tenant: string };

export default function custom_auth(req: Req, res: Response, next: NextFunction) {
  // do your custom authentication ...
}
```

[If you want to customize the user ID, please also have a look at this example.](/node.js/cds-serve#customization-of-cds-context-user){.learn-more}


## Authentication Enforced in Production

In a productive scenario with an authentication strategy configured, for example the default `jwt`, all CAP service endpoints are authenticated by default, regardless of the authorization model. That is, all services without `@restrict` or `@requires` implicitly get `@requires: 'authenticated-user'`.

This can be disabled via feature flag <Config>cds.requires.auth.restrict_all_services: false</Config>, or by using [mocked authentication](#mocked) explicitly in production.


## XSUAA in Hybrid Setup {#xsuaa-setup}

### Prepare Local Environment

The following steps assume you've set up the [**Cloud Foundry Command Line Interface**](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/856119883b8c4c97b6a766cc6a09b48c.html).

1. Log in to Cloud Foundry:
```sh
cf l -a <api-endpoint>
```
If you don't know the API endpoint, have a look at section [Regions and API Endpoints Available for the Cloud Foundry Environment](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/350356d1dc314d3199dca15bd2ab9b0e.html#loiof344a57233d34199b2123b9620d0bb41).

2. Go to the project you have created in [Getting started in a Nutshell](../get-started/in-a-nutshell).

3. Configure your app for XSUAA-based authentication if not done yet:
    ```sh
    cds add xsuaa --for hybrid
    ```
  This command creates the XSUAA configuration file `xs-security.json` and adds the service and required dependencies to your `package.json` file.

4. Make sure `xsappname` is configured and `tenant-mode` is set to `dedicated` in `xs-security.json` file:
```json
{
  "xsappname": "bookshop-hybrid",
  "tenant-mode": "dedicated",
  ...
  }
```

5. Configure the redirect URI:

    Add the following OAuth configuration to the `xs-security.json` file:

    ```json
    "oauth2-configuration": {
      "redirect-uris": [
        "http://localhost:5000/login/callback"
      ]
    }
    ```

6. Create an XSUAA service instance with this configuration:

    ```sh
    cf create-service xsuaa application bookshop-uaa -c xs-security.json
    ```

    > Later on, if you've changed the scopes, you can use `cf update-service bookshop-uaa -c xs-security.json` to update the configuration.

    ::: tip
    This step is necessary for locally running apps and for apps deployed on Cloud Foundry.
    :::

### Configure the Application

1. Create a service key:

    ```sh
    cf create-service-key bookshop-uaa bookshop-uaa-key
    ```

    This lets you gain access to the XSUAA credentials from your local application.


2. Bind to the new service key:

    ```sh
    cds bind -2 bookshop-uaa
    ```

    This adds an `auth` section containing the binding and the kind `xsuaa` to the _.cdsrc-private.json_ file. This file is created if it doesn't exist and keeps the local and private settings of your app:

    ```json
    {
      "requires": {
        "[hybrid]": {
          "auth": {
            "kind": "xsuaa",
            "binding": { ... }
          }
        }
      }
    }
    ```

    >If your running in BAS, you can alternatively [create a new run configuration](https://help.sap.com/products/SAP%20Business%20Application%20Studio/9c36fdb911ae4cadab467a314d9e331f/cdbc00244452483e9582a4f486b42d64.html), connecting the `auth` to your XSUAA service instance.

    >In that case you need to add the environment variable `cds_requires_auth_kind=xsuaa` to the run configuration.

3. Check authentication configuration:
```sh
cds env list requires.auth --resolve-bindings --profile hybrid
```
This prints the full `auth` configuration including the credentials.


### Set Up the Roles for the Application { #auth-in-cockpit}

By creating a service instance of the `xsuaa` service, all the roles from the _xs-security.json_ file are added to your subaccount. Next, you create a role collection that assigns these roles to your users.

1. Open the SAP BTP Cockpit.

    > For your trial account, this is: [https://cockpit.hanatrial.ondemand.com](https://cockpit.hanatrial.ondemand.com)

2. Navigate to your subaccount and then choose *Security* > *Role Collections*.
3. Choose *Create New Role Collection*:

   ![Create role collections in SAP BTP cockpit](./assets/create-role-collection.png)

4. Enter a *Name* for the role collection, for example `BookshopAdmin`, and choose *Create*.
5. Choose your new role collection to open it and switch to *Edit* mode.
6. Add the `admin` role for your bookshop application (application id `bookshop!a<XXXX>`) to the *Roles* list.
7. Add the email addresses for your users to the *Users* list.
8. Choose *Save*

### Running App Router

The App Router component implements the necessary authentication flow with XSUAA to let the user log in interactively.
The resulting JWT token is sent to the application where it's used to enforce authorization and check the user's roles.

1. Add App Router to the `app` folder of your project:

    ```sh
    cds add approuter
    ```

2. Install `npm` packages for App Router:

    ```sh
    npm install --prefix app/router
    ```

3. In your project folder run:

    ::: code-group
    ```sh [Mac/Linux]
    cds bind --exec -- npm start --prefix app/router
    ```
    ```cmd [Windows]
    cds bind --exec -- npm start --prefix app/router
    ```
    ```powershell [Powershell]
    cds bind --exec '--' npm start --prefix app/router
    ```
    :::

    [Learn more about `cds bind --exec`.](../advanced/hybrid-testing#cds-bind-exec){.learn-more}

    This starts an [App Router](https://help.sap.com/docs/HANA_CLOUD_DATABASE/b9902c314aef4afb8f7a29bf8c5b37b3/0117b71251314272bfe904a2600e89c0.html) instance on [http://localhost:5000](http://localhost:5000) with the credentials for the XSUAA service that you have bound using `cds bind`.

    > Usually the App Router is started using `npm start` in the `app` folder. But you need to provide the `VCAP_SERVICES` variable with the XSUAA credentials. With the `cds bind --exec` command you can launch an arbitrary command with the `VCAP_SERVICES` variable filled with your `cds bind` service bindings.

    Since it only serves static files or delegates to the backend service, you can keep the server running. It doesn't need to be restarted after you have changed files.

4. Make sure that your CAP application is running as well with the `hybrid` profile:

    ```sh
    cds watch --profile hybrid
    ```

    > If you are using BAS Run Configurations, you need to configure `cds watch` with profile `hybrid`:
    > 1. Right click on your run configuration
    > 2. Choose *Show in File*
    > 3. Change the command `args`:
    > ```json
    > "args": [
    >    "cds",
    >    "watch",
    >    "--profile",
    >    "hybrid"
    > ],
    > ```

5. After the App Router and CAP application are started, log in at [http://localhost:5000](http://localhost:5000) and verify that the routes are protected as expected.

    In our example, if you assigned the `admin` scope to your user in SAP BTP cockpit, you can now access the admin service at [http://localhost:5000/admin](http://localhost:5000/admin).

    <br>

    > To test UIs w/o a running UAA service, just add this to _app/router/xs-app.json_:
    ```"authenticationMethod": "none"```

**SAP Business Application Studio:**

The login fails pointing to the correct OAuth configuration URL that is expected.

1. Replace the URL `http://localhost:5000/` in your `xs-security.json` file with the full URL from the error message:

    ```json
    "oauth2-configuration": {
        "redirect-uris": [
          "<url from error message>"
      ]
    }
    ```
    ::: warning
    This is a specific configuration for your dev space and should not be submitted or shared.
    :::

2. Update the XSUAA service:

    ```sh
    cf update-service bookshop-uaa -c xs-security.json
    ```

3. Retry

<div id="secondary-file">node.js/authentication.fragment.md</div>


# Testing with `cds.test`



## Overview

The `cds.test` library provides best practice utils for writing tests for CAP Node.js applications.

Install it with:

```sh
npm add -D @cap-js/cds-test
```

::: tip Examples
Find examples in [*cap/samples*](https://github.com/sap-samples/cloud-cap-samples/tree/main/test) and in the [*SFlight sample*](https://github.com/SAP-samples/cap-sflight/tree/main/test).
:::


### Running a CAP Server

Use function [`cds.test()`](#cds-test) to easily launch and test a CAP server. For example, given your CAP application has a `./test` subfolder containing tests as follows:

```zsh
project/    # your project's root folder
├─ srv/
├─ db/
├─ test/    # your .test.js files go in here
└─ package.json
```

Start your app's server in your `.test.js` files like that:

```js{3}
const cds = require('@sap/cds')
describe(()=>{
  const test = cds.test(__dirname+'/..')
})
```
This launches a server from the specified target folder in a `beforeAll()` hook, with controlled shutdown when all tests have finished in an `afterAll()` hook.

::: warning  Don't use `process.chdir()`!
Doing so in Jest tests may leave test containers in failed state, leading to failing subsequent tests. Use [`cds.test.in()`](#test-in-folder) instead.
:::

::: danger Don't load [`cds.env`](cds-env) before [`cds.test()`](#cds-test)!
To ensure `cds.env`, and hence all plugins, are loaded from the test's target folder, the call to `cds.test()` is the first thing you do in your tests. Any references to [`cds`](cds-facade) sub modules or any imports of which have to go after.  → [Learn more in `CDS_TEST_ENV_CHECK`.](#cds-test-env-check)
:::




### Testing Service APIs


As `cds.test()` launches the server in the current process, you can access all services programmatically using the respective [Node.js Service APIs](core-services). Here's an example for that taken from [*cap/samples*](https://github.com/SAP-samples/cloud-cap-samples/blob/a8345122ea5e32f4316fe8faef9448b53bd097d4/test/consuming-services.test.js#L2):


```js
it('Allows testing programmatic APIs', async () => {
  const AdminService = await cds.connect.to('AdminService')
  const { Authors } = AdminService.entities
  expect (await SELECT.from(Authors))
  .to.eql(await AdminService.read(Authors))
  .to.eql(await AdminService.run(SELECT.from(Authors)))
})
```


### Testing HTTP APIs

To test HTTP APIs, we can use bound functions like so:

```js
const { GET, POST } = cds.test(...)
const { data } = await GET ('/browse/Books')
await POST (`/browse/submitOrder`, { book: 201, quantity: 5 })
```

[Learn more in GET/PUT/POST.](#http-bound) {.learn-more}


#### Authenticated Endpoints
`cds.test()` uses the standard authentication strategy in development mode, which is the [mocked authentication](./authentication#mocked). This also includes the usage of [pre-definded mock users](./authentication#mock-users)

You can set the user for an authenticated request like this:

```js
await GET('/admin/Books', { auth: { username: 'alice', password: '' } })
```

This is the same as setting the HTTP `Authorization` header with values for basic authentication:

::: code-group
```http [test.http]
GET http://localhost:4004/admin/Books
Authorization: Basic alice:
```
:::

[Learn how to explicitly configure mock users in your _package.json_ file.](./authentication#mocked){.learn-more}

### Using Jest or Mocha

[*Mocha*](https://mochajs.org) and [*Jest*](https://jestjs.io) are the most used test runners at the moment, with each having its user base.

The `cds.test` library is designed to allow you to write tests that can run with both. Here's an example:

```js
describe('my test suite', ()=>{
  const { GET, expect } = cds.test(...)
  it ('should test', ()=>{   // Jest & Mocha
    const { data } = await GET ('/browse/Books')
    expect(data.value).to.eql([ // chai style expect
      { ID: 201, title: 'Wuthering Heights', author: 'Emily Brontë' },
      { ID: 252, title: 'Eleonora', author: 'Edgar Allen Poe' },
      //...
    ])
  })
})
```
> To ensure that your tests run with both `jest` and `mocha`, start a test server with `cds.test(...)` inside a `describe` block of the test.

You can use Mocha-style `before/after` or Jest-style `beforeAll/afterAll` in your tests, as well as the common `describe, test, it` methods. In addition, to be portable, you should use the [Chai Assertion Library's](#chai)  variant of `expect`.

::: tip [All tests in *cap/samples*](https://github.com/sap-samples/cloud-cap-samples/blob/master/test) are written in that portable way. <br>
Run them with `npm run jest` or with `npm run mocha`.
:::

::: warning Helpers can cause conflicts
_jest_ helpers might cause conflicts with the generic implementation of `@sap/cds`.

To avoid such conflicts, do not use the following helpers:
- _jest.resetModules_ as it leaves the server in an inconsistent state.
- _jest.useFakeTimers_ as it intercepts the server shutdown causing test timeouts.
:::

### Using Test Watchers

You can also start the tests in watch mode, for example:

```sh
jest --watchAll
```

This should give you green tests, when running in *cap/samples* root:

<pre class="log">
<em>PASS</em>  <i>test/</i>cds.ql.test.js
<em>PASS</em>  <i>test/</i>hierarchical-data.test.js
<em>PASS</em>  <i>test/</i>hello-world.test.js
<em>PASS</em>  <i>test/</i>messaging.test.js
<em>PASS</em>  <i>test/</i>consuming-services.test.js
<em>PASS</em>  <i>test/</i>custom-handlers.test.js
<em>PASS</em>  <i>test/</i>odata.test.js
<em>PASS</em>  <i>test/</i>localized-data.test.js

Test Suites: <em>8 passed</em>, 8 total
Tests:       <em>65 passed</em>, 65 total
Snapshots:   0 total
Time:        3.611 s, estimated 4 s
<i>Ran all test suites.</i>
</pre>

Similarly, you can use other test watchers like `mocha -w`.





## Class `cds.test.Test`

Instances of this class are returned by [`cds.test()`](#cds-test), for example:

```js
const test = cds.test(_dirname)
```

You can also use this class and create instances yourself, for example, like that:

```js
const { Test } = cds.test
let test = new Test
test.run().in(_dirname)
```



### cds.test() {.method}

This method is the most convenient way to start a test server. It's actually just a convenient shortcut to construct a new instance of class `Test` and call [`test.run()`](#test-run), defined as follows:

```js
const { Test } = cds.test
cds.test = (...args) => (new Test).run(...args)
```

:::warning Run `cds.test` once per test file

`@sap/cds` relies on server state like `cds.model`. Running `cds.test` multiple times within the same test file can lead to a conflicting state and erratic behavior.
:::



### .chai, ... {.property}

To write tests that run in [*Mocha*](https://mochajs.org) as well as in [*Jest*](https://jestjs.io), you should use the [*Chai Assertion Library*](https://www.chaijs.com/) through the following convenient methods.

:::warning Using `chai` requires these dependencies added to your project:

```sh
npm add -D chai@4 chai-as-promised@7 chai-subset jest
```

:::



#### .expect { .property}

Shortcut to the [`chai.expect()`](https://www.chaijs.com/guide/styles/#expect) function, used like that:

```js
const { expect } = cds.test(), foobar = {foo:'bar'}
it('should support chai.except style', ()=>{
  expect(foobar).to.have.property('foo')
  expect(foobar.foo).to.equal('bar')
})
```

If you prefer Jest's `expect()` functions, you can just use the respective global:

```js
cds.test()
it('should use jest.expect', ()=>{
  expect({foo:'bar'}).toHaveProperty('foo')
})
```



#### .assert { .property}

Shortcut to the [`chai.assert()`](https://www.chaijs.com/guide/styles/#assert) function, used like that:

```js
const { assert } = cds.test(), foobar = {foo:'bar'}
it('should use chai.assert style', ()=>{
  assert.property(foobar,'foo')
  assert.equal(foobar.foo,'bar')
})
```



#### .should { .property}

Shortcut to the [`chai.should()`](https://www.chaijs.com/guide/styles/#should) function, used like that:

```js
const { should } = cds.test(), foobar = {foo:'bar'}
it('should support chai.should style', ()=>{
  foobar.should.have.property('foo')
  foobar.foo.should.equal('bar')
  should.equal(foobar.foo,'bar')
})
```



#### .chai {.property}

This getter provides access to the [*chai*](https://www.chaijs.com) library, preconfigured with the [chai-subset](https://www.chaijs.com/plugins/chai-subset/) and [chai-as-promised](https://www.chaijs.com/plugins/chai-as-promised/) plugins. These plugins contribute the `containSubset` and `eventually` APIs, respectively. The getter is implemented like this:

```js
get chai() {
  return require('chai')
  .use (require('chai-subset'))
  .use (require('chai-as-promised'))
}
```



### .axios {.property}

Provides access to the [Axios](https://github.com/axios/axios) instance used as HTTP client.
It comes preconfigured with the base URL of the running server, that is, `http://localhost:<port>`.  This way, you only need to specify host-relative URLs in tests, like `/catalog/Books`. {.indent}

:::warning Using `axios` requires adding this dependency:

```sh
npm add -D axios
```

:::



### GET / PUT / POST ... {#http-bound .method}

These are bound variants of the [`test.get/put/post/...` methods](#http-methods) allowing to write HTTP requests like that:

```js
const { GET, POST } = cds.test()
const { data } = await GET('/browse/Books')
await POST('/browse/submitOrder',
  { book:201, quantity:1 },
  { auth: { username: 'alice' }}
)
```

[Learn more about Axios.](https://axios-http.com) {.learn-more}

For single URL arguments, the functions can be used in tagged template string style, which allows omitting the parentheses from function calls:

```js
let { data } = await GET('/browse/Books')
let { data } = await GET `/browse/Books`
```





### test. get/put/post/...() {#http-methods .method}

These are mirrored version of the corresponding [methods from `axios`](https://github.com/axios/axios#instance-methods), which prefix each request with the started server's url and port, which simplifies your test code:

```js
const test = cds.test() //> served at localhost with an arbitrary port
const { data } = await test.get('/browse/Books')
await test.post('/browse/submitOrder',
  { book:201, quantity:1 },
  { auth: { username: 'alice' }}
)
```

[Learn more about Axios.](https://axios-http.com) {.learn-more}



### test .data .reset() {.method}

This is a bound method, which can be used in a `beforeEach` handler to automatically reset and redeploy the database for each test like so:

```js
const { test } = cds.test()
beforeEach (test.data.reset)
```

Instead of using the bound variant, you can also call this method the standard way:

```js
beforeEach (async()=>{
  await test.data.reset() // [!code focus]
  //...
})
```



### test. log() {.method}

Allows to capture console output in the current test scope. The method returns an object to control the captured logs:

```tsx
function cds.test.log() => {
  output : string
  clear()
  release()
}
```

Usage examples:

```js
describe('cds.test.log()', ()=>{
  let log = cds.test.log()

  it ('should capture log output', ()=>{
    expect (log.output.length).to.equal(0)
    console.log('foo',{bar:2})
    expect (log.output.length).to.be.greaterThan(0)
    expect (log.output).to.contain('foo')
  })

  it('should support log.clear()', ()=> {
    log.clear()
    expect (log.output).to.equal('')
  })

  it('should support log.release()', ()=> {
    log.release() // releases captured log
    console.log('foobar') // not captured
    expect (log.output).to.equal('')
  })
})
```

The implementation redirects any console operations in a `beforeAll()` hook, clears `log.output` before each test, and releases the captured console in an `afterAll()` hook.



### test. run (...) {.method}

This is the method behind [`cds.test()`](#cds-test) to start a CDS server, that is the following are equivalent:

```js
cds.test(...)
```

```js
(new cds.test.Test).run(...)
```

It asynchronously launches a CDS server in a `beforeAll()` hook with an arbitrary port, with controlled shutdown when all tests have finished in an `afterAll()` hook.

The arguments are the same as supported by the `cds serve` CLI command.

Specify the command `'serve'` as the first argument to serve specific CDS files or services:

```js
cds.test('serve','srv/cat-service.cds')
cds.test('serve','CatalogService')
```

You can optionally add [`test.in(folder)`](#test-in-folder) in fluent style to run the test in a specific folder:

```js
cds.test('serve','srv/cat-service.cds').in('/cap/samples/bookshop')
```

If the first argument is **not** `'serve'`, it's interpreted as a target folder:

```js
cds.test('/cap/samples/bookshop')
```

This variant is a convenient shortcut for:

```js
cds.test('serve','all','--in-memory?').in('/cap/samples/bookshop')
cds.test().in('/cap/samples/bookshop') //> equivalent
```



### test. in (folder, ...) {.method}

Safely switches [`cds.root`](cds-facade#cds-root) to the specified target folder. Most frequently you'd use it in combination with starting a server with [`cds.test()`](#cds-test) in fluent style like that:

```js
let test = cds.test(...).in(__dirname)
```

It can also be used as static method to only change `cds.root` without starting a server:

```js
cds.test.in(__dirname)
```



### `CDS_TEST_ENV_CHECK`

It's important to ensure [`cds.env`](cds-env), and hence all plugins, are loaded from the test's target folder. To ensure this, any references to or imports of [`cds`](cds-facade) sub modules have to go after all plugins are loaded. For example if you had a test like that:

```js
cds.env.fiori.lean_draft = true   //> cds.env loaded from ./  [!code --]
cds.test(__dirname)               //> target folder: __dirname
```

This would result in the test server started from `__dirname`, but erroneously using `cds.env` loaded from `./`.

As these mistakes end up in hard-to-resolve follow up errors, [`test.in()`](#test-in-folder) can detect this if environment variable `CDS_TEST_ENV_CHECK` is set. The previous code will then result into an error like that:

```sh
CDS_TEST_ENV_CHECK=y jest cds.test.test.js
```
```zsh
Detected cds.env loaded before running cds.test in different folder:
1. cds.env loaded from:  ./
2. cds.test running in:  cds/tests/bookshop

    at Test.in (node_modules/@sap/cds/lib/utils/cds-test.js:65:17)
    at test/cds.test.test.js:9:41
    at Object.describe (test/cds.test.test.js:5:1)

   5 | describe('cds.test', ()=>{
>  6 |   cds.env.fiori.lean_draft = true
     |       ^
   7 |   cds.test(__dirname)

  at env (test/cds.test.test.js:7:7)
  at Object.describe (test/cds.test.test.js:5:1)
```

A similar error would occur if one of the `cds` sub modules would be accessed, which frequently load `cds.env` in their global scope, like `cds.Service` in the following snippet:

```js
class MyService extends cds.Service {}  //> cds.env loaded from ./  [!code --]
cds.test(__dirname)                     //> target folder: __dirname
```

To fix this, always ensure your calls to `cds.test.in(folder)` or `cds.test(folder)` goes first, before anything else loading `cds.env`:

```js
cds.test(__dirname) //> always should go first
// anything else goes after that:
cds.env.fiori.lean_draft = true        // [!code ++]
class MyService extends cds.Service {} // [!code ++]
```

:::warning Do switch on `CDS_TEST_ENV_CHECK` !

We recommended to switch on `CDS_TEST_ENV_CHECK` in all your tests to detect such errors. It's likely to become default in upcoming releases.

:::



## Best Practices

### Check Status Codes Last

Avoid checking for single status codes. Instead, simply check the response data:

```js
const { data, status } = await GET `/catalog/Books`
expect(status).to.equal(200)   //> DON'T do that upfront // [!code --]
expect(data).to.equal(...)     //> do this to see what's wrong
expect(status).to.equal(200)   //> Do it at the end, if at all // [!code ++]
```

This makes a difference if there are errors: with the status code check, your test aborts with a useless _Expected: 200, received: xxx_ error, while without it, it fails with a richer error that includes a status text.

Note that by default, Axios throws errors for status codes `< 200` and `>= 300`. This can be [configured](https://github.com/axios/axios#handling-errors), though.



### Minimal Assumptions

When checking expected errors messages, only check for significant keywords. Don't hardwire the exact error text, as this might change over time, breaking your test unnecessarily.

**DON'T**{.bad} hardwire on overly specific error messages:

```js
await expect(POST(`/catalog/Books`,...)).to.be.rejectedWith(
  'Entity "CatalogService.Books" is readonly'
)
```

**DO**{.good} check for the essential information only:

```js
await expect(POST(`/catalog/Books`,...)).to.be.rejectedWith(
  /readonly/i
)
```

### Keep Test Code Environment Agnostic

Environment setup shouldn't be part of the test code itself. That should be handled by setup scripts like CI/CD pipelines.
This way, your tests remain isolated and reproducible across different setups.

::: code-group
```js [my.test.js]
// NO service bindings, env. variables, profiles, etc. here
// Do this outside in setup scripts etc.
describe(() => { cds.test(...) })
```
:::

[Learn how to setup integration tests with `cds bind`.](../advanced/hybrid-testing#integration-tests){.learn-more}


## Using `cds.test` in REPL

You can use `cds.test` in REPL, for example, by running this from your command line in [*cap/samples*](https://github.com/sap-samples/cloud-cap-samples):

```sh
[cap/samples] cds repl
Welcome to cds repl v7.1
```

```js
> var test = await cds.test('bookshop')
```

```log
[cds] - model loaded from 6 file(s):

  ./bookshop/db/schema.cds
  ./bookshop/srv/admin-service.cds
  ./bookshop/srv/cat-service.cds
  ./bookshop/app/services.cds
  ./../../cds/common.cds
  ./common/index.cds

[cds] - connect to db > sqlite { database: ':memory:' }
 > filling sap.capire.bookshop.Authors from ./bookshop/db/data/sap.capire.bookshop-Authors.csv
 > filling sap.capire.bookshop.Books from ./bookshop/db/data/sap.capire.bookshop-Books.csv
 > filling sap.capire.bookshop.Books.texts from ./bookshop/db/data/sap.capire.bookshop-Books_texts.csv
 > filling sap.capire.bookshop.Genres from ./bookshop/db/data/sap.capire.bookshop-Genres.csv
 > filling sap.common.Currencies from ./common/data/sap.common-Currencies.csv
 > filling sap.common.Currencies.texts from ./common/data/sap.common-Currencies_texts.csv
/> successfully deployed to sqlite in-memory db

[cds] - serving AdminService { at: '/admin', impl: './bookshop/srv/admin-service.js' }
[cds] - serving CatalogService { at: '/browse', impl: './bookshop/srv/cat-service.js' }

[cds] - server listening on { url: 'http://localhost:64914' }
[cds] - launched at 9/8/2021, 5:36:20 PM, in: 767.042ms
[ terminate with ^C ]
```

```js
> await SELECT `title` .from `Books` .where `exists author[name like '%Poe%']`
[ { title: 'The Raven' }, { title: 'Eleonora' } ]
```

```js
> var { CatalogService } = cds.services
> await CatalogService.read `title, author` .from `ListOfBooks`
[
  { title: 'Wuthering Heights', author: 'Emily Brontë' },
  { title: 'Jane Eyre', author: 'Charlotte Brontë' },
  { title: 'The Raven', author: 'Edgar Allen Poe' },
  { title: 'Eleonora', author: 'Edgar Allen Poe' },
  { title: 'Catweazle', author: 'Richard Carpenter' }
]
```



# Best Practices

From generic Node.js best practices like dependency management and error handling to CAP-specific topics like transaction handling and testing, this [video](https://www.youtube.com/watch?v=WTOOse-Flj8&t=87s) provides some tips and tricks to improve the developer experience and avoid common pitfalls, based on common customer issues. In the following section we explain these best practices.

## Managing Dependencies {#dependencies}

Projects using CAP need to manage dependencies to the respective tools and libraries in their _package.json_ and/or _pom.xml_ respectively. Follow the guidelines to make sure that you consume the latest fixes and avoid vulnerabilities and version incompatibilities. These guidelines apply to you as a _consumer_ of reuse packages as well as a _provider_ of such reuse packages.


### Always Use the _Latest Minor_ Releases &rarr; for Example, `^7.2.0` {#use-caret }

This applies to both, *@sap* packages as well as open source ones. It ensures your projects receive the latest features and important fixes during development. It also leverages [NPM's dedupe](https://docs.npmjs.com/cli/dedupe.html) to make sure bundles have a minimal footprint.

Example:

```json
"dependencies": {
  "@sap/cds": "^9.1.0",
  "@sap/some-reuse-package": "^1.1.0",
  "express": "^4.17.0"
}
```
::: tip We **recommend** using the caret form such as `^1.0.2`
Caret form is the default for `npm install`, as that format clearly captures the minimum patch version.
:::

### Keep Open Ranges When *Publishing* for Reuse {#publish }



Let's explain this by looking at two examples.

#### Bad {.bad}

Assume that you've developed a reuseable package, and consume a reuse package yourself. You decided to violate the previous rules and use exact dependencies in your _package.json_:

```json
"name": "@sap/your-reuse-package",
"version": "1.1.2",
"dependencies": {
  "@sap/cds": "3.0.3",
  "@sap/foundation": "2.0.1",
  "express": "4.16.3"
}
```

The effect would be as follows:

1. Consuming projects get duplicate versions of each package they also use directly, for example, `@sap/cds`, `@sap/foundation`, and `express`.
2. Consuming projects don't receive important fixes for the packages used in your _package.json_ unless you also provide an update.
3. It wouldn't be possible to reuse CDS models from common reuse packages (for example, would already fail for `@sap/cds/common`).

#### Good {.good}

Therefore, the rules when publishing packages for reuse are:

* **Keep** the open ranges in your _package.json_ (just don't touch them).
* **Do** an *npm update* before publishing and test thoroughly.
  (&rarr; ideally automated in your CI/CD pipeline).
* **Do** the vulnerability checks for your software and all open-source software used by you **or by packages you used** (&rarr; [Minimize Usage of Open Source Packages](#oss)).
* **Don't** do `npm shrinkwrap` &rarr; see also [npm's docs](https://docs.npmjs.com/cli/v10/configuring-npm/npm-shrinkwrap-json): *"It's discouraged for library authors to publish this file, ..."*

::: tip
If both your package and a consuming package reuse the same CDS models, loading those models would fail because it's impossible to automatically merge the two versions, nor is it possible to load two independent versions. The reason for this is that it's reusing models that share the **same** single definitions.
:::


### Lock Dependencies Before *Deploying* {#deploy }

When releasing a service or an application to end consumers, use `npm install` or `npm update` to produce a [_package-lock.json_](https://docs.npmjs.com/files/package-lock.json) file that freezes dependencies. This guarantees that it works correctly as it did the last time you tested it and checked it for vulnerabilities.

Overall, the process for your release should include these steps:

```sh
npm config set package-lock true  # enables package-lock.json
npm update   # update it with latest versions
git add package-lock.json # add it to version control

# conduct all test and vulnerability checks
```

The _package-lock.json_ file in your project root freezes all dependencies and is deployed with your application. Subsequent npm installs, such as by cloud deployers or build packs, always get the same versions, which you checked upon your release.

This ensures that the deployed tool/service/app doesn't receive new vulnerabilities, for example, through updated open source packages, without you being able to apply the necessary tests as prescribed by our security standards.

::: tip Run `npm update` frequently to receive latest fixes regularly
Tools like [renovate](https://github.com/renovatebot/renovate) or [GitHub's dependabot](https://docs.github.com/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically) can help you automate this process.

<div id="renovate-sap" />
<Fragment target="#renovate-sap">

Here at SAP, there is a [renovate deployment](https://github.tools.sap/OSPO/renovate-controller) available. <Internal />

</Fragment>

:::

### Minimize Usage of Open Source Packages {#oss _}

This rule for keeping open ranges for dependencies during development, as well as when publishing for reuse, also applies for open source packages.

Because open source packages are less reliable with respect to vulnerability checks, this means that end-of-chain projects have to ensure respective checks for all the open source packages they use directly, as well as those they 'inherit' transitively from reuse packages.

So, always take into account these rules:

* When releasing to end consumers, you always have to conduct vulnerability checks for all open source packages that you used directly or transitively.

* As a provider of reuse packages you should minimize the usage of open source packages to a reasonable minimum.

**Q:** Why not freeze open source dependencies when releasing for reuse?

**A:** Because that would only affect directly consumed packages, while packages from transitive dependencies would still reach your consumers.

A good approach is to also provide certain features in combination with third-party packages, but to keep them, and hence the dependencies, optional; for example, express.js does this.


### Upgrade to _Latest Majors_ as Soon as Possible {#upgrade _}

As providers of evolving SDKs we provide major feature updates, enhancements, and improvements in 6-12 month release cycles. These updates come with an increment of major release numbers.

At the same time, we can't maintain and support unlimited numbers of branches with fixes. The following rules apply:

* Fixes and nonbreaking enhancements are made available frequently in upstream release branches (current _major_).
* Critical fixes also reach recent majors in a 2-month grace period.

To make sure that you receive ongoing fixes, make sure to also adopt the latest major releases in a timely fashion in your actively maintained projects, that is, following the 6-12 month cycle.


### Additional Advice

**Using  _npm-shrinkwrap.json_** — only if you want to publish CLI tools or other 'sealed' production packages to npm.  Unlike _package-lock.json_, it _does_ get packaged and published to npm registries.  See the [npm documentation](https://docs.npmjs.com/cli/v8/configuring-npm/package-lock-json#package-lockjson-vs-npm-shrinkwrapjson) for more.


<div id="prerelease-sap" />
<Fragment target="#prerelease-sap">

**Working with prerelease snapshots or milestones** — sometimes you need the latest features or fixes, even though they haven't been released yet. Don't modify your dependencies in _package.json_ to do so, but simply change your registry temporarily for the respective pages to artifactory snapshots or milestones. <Internal />

Example:

```ini
@sap:registry=https://int.repositories.cloud.sap/artifactory/api/npm/build-milestones-npm
```

For example, you could do this in a project-level `.npmrc` file that you commit to your GitHub repository in a respective branch.

</Fragment>

## Securing Your Application

To keep builds as small as possible, the Node.js runtime doesn't bring any potentially unnecessary dependencies and, hence, doesn't automatically mount any express middlewares, such as the popular [`helmet`](https://www.npmjs.com/package/helmet).

However, application developers can easily mount custom or best-practice express middlewares using the [bootstrapping mechanism](./cds-server#cds-server).

Example:

```js
// local ./server.js
const cds = require('@sap/cds')
const helmet = require('helmet')

cds.on('bootstrap', app => {
  app.use(helmet())
})

module.exports = cds.server // > delegate to default server.js
```
{}

Consult sources such as [Express' **Production Best Practices: Security** documentation](https://expressjs.com/en/advanced/best-practice-security.html) for state of the art application security.

### Content Security Policy (CSP)

Creating a [Content Security Policy (CSP)](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP) is a major building block in securing your web application.

[`helmet`](https://www.npmjs.com/package/helmet) provides a default policy out of the box that you can also customize as follows:

```js
cds.on('bootstrap', app => {
  app.use(
    helmet({
      contentSecurityPolicy: {
        directives: {
          ...helmet.contentSecurityPolicy.getDefaultDirectives()
          // custom settings
        }
      }
    })
  )
})
```
Find required directives in the [OpenUI5 Content Security Policy documentation](https://openui5.hana.ondemand.com/topic/fe1a6dba940e479fb7c3bc753f92b28c) {.learn-more}

### Cross-Site Request Forgery (CSRF) Token

Protect against cross-side request forgery (CSRF) attacks by enabling CSRF token handling through the _App Router_.
::: tip For a SAPUI5 (SAP Fiori/SAP Fiori Elements) developer, CSRF token handling is transparent
There's no need to program or to configure anything in addition. In case the server rejects the request with _403_ and _“X-CSRF-Token: required”_, the UI sends a _HEAD_ request to the service document to fetch a new token.
:::

[Learn more about CSRF tokens and SAPUI5 in the **Cross-Site Scripting** documentation.](https://sapui5.hana.ondemand.com/#/topic/91f0bd316f4d1014b6dd926db0e91070){.learn-more}

Alternatively, you can add a CSRF token handler manually.

::: warning This request must never be cacheable
If a CSRF token is cached, it can potentially be reused in multiple requests, defeating its purpose of securing each individual request. Always set appropriate cache-control headers to `no-store, no-cache, must-revalidate, proxy-revalidate` to prevent caching of the CSRF token.
:::

#### Using App Router

The _App Router_ is configured to require a _CSRF_ token by default for all protected routes and all HTTP requests methods except _HEAD_ and _GET_. Thus, by adding the _App Router_ as described in the [Deployment Guide: Using App Router as Gateway](../guides/deployment/to-cf#add-app-router), endpoints are CSRF protected.

[Learn more about CSRF protection with the **App Router**](https://help.sap.com/docs/BTP/65de2977205c403bbc107264b8eccf4b/c19f165084d742e096c5d1625cecd2d4.html?q=csrf#loioc19f165084d742e096c5d1625cecd2d4__section_xj4_pcg_2z){.learn-more}

#### Manual Implementation

On the backend side, except for handling the _HEAD_ request mentioned previously, also the handlers for each _CSRF_ protected method and path should be added.
In the following example, the _POST_ method is protected.
::: tip
If you use SAP Fiori Elements, requests to the backend are sent as batch requests using the _POST_ method. In this case, an arbitrary _POST_ request should be protected.
:::

As already mentioned, in case the server rejects because of a bad CSRF token, the response with a status _403_ and a header _“X-CSRF-Token: required”_ should be returned to the UI. For this purpose, the error handling in the following example is extended:

```js
const csrfProtection = csrf({ cookie: true })
const parseForm = express.urlencoded({ extended: false })

cds.on('bootstrap', app => {
  app.use(cookieParser())

  // Must: Provide actual <service endpoint>s of served services.
  // Optional: Adapt for non-Fiori Elements UIs.
  .head('/<service endpoint>', csrfProtection, (req, res) => {
    res.set({
      'X-CSRF-Token': req.csrfToken(),
      'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate'
    }).send()
  })

  // Must: Provide actual <service endpoint>s of served services.
  // Optional: Adapt for non-Fiori Elements UIs.
  .post('/<service endpoint>/$batch', parseForm, csrfProtection, (req, res, next) => next())

  .use((err, req, res, next) => {
    if (err.code !== 'EBADCSRFTOKEN') return next(err)
    res.status(403).set('X-CSRF-Token', 'required').send()
  })
})
```

[Learn more about backend coding in the **csurf** documentation.](https://www.npmjs.com/package/csurf){.learn-more}
::: tip Use _App Router_ CSRF handling when scaling Node.js VMs horizontally
Handling CSRF at the _App Router_ level ensures consistency across instances. This avoids potential token mismatches that could occur if each VM handled CSRF independently.
:::


### Cross-Origin Resource Sharing (CORS)

With _Cross-Origin Resource Sharing_ (CORS) the server that hosts the UI can tell the browser about servers it trusts to provide resources. In addition, so-called "preflight" requests tell the browser if the cross-origin server will process a request with a specific method and a specific origin.

If not running in production, CAP's [built-in server.js](cds-server#built-in-server-js) allows all origins.

#### Custom CORS Implementation

For production, you can add CORS to your CAP server as follows:

```js
const ORIGINS = { 'https://example.com': 1 }
cds.on('bootstrap', app => app.use ((req, res, next) => {
  if (req.headers.origin in ORIGINS) {
    res.set('access-control-allow-origin', req.headers.origin)
    if (req.method === 'OPTIONS') // preflight request
      return res.set('access-control-allow-methods', 'GET,HEAD,PUT,PATCH,POST,DELETE').end()
  }
  next()
})
```

[Learn more about CORS in CAP in **this article by DJ Adams**](https://qmacro.org/blog/posts/2024/03/30/cap-cors-and-custom-headers/){.learn-more}

[Learn more about CORS in general in the **MDN Web Docs**.](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS){.learn-more}



#### Configuring CORS in App Router

The _App Router_ has full support for CORS. Thus, by adding the _App Router_ as described in the [Deployment Guide: Using App Router as Gateway](../guides/deployment/to-cf#add-app-router), CORS can be configured in the _App Router_ configuration.

[Learn more about CORS handling with the **App Router**](https://help.sap.com/docs/BTP/65de2977205c403bbc107264b8eccf4b/ba527058dc4d423a9e0a69ecc67f4593.html?q=allowedOrigin#loioba527058dc4d423a9e0a69ecc67f4593__section_nt3_t4k_sz){.learn-more}

::: warning Avoid configuring CORS in both _App Router_ and CAP server
Configuring CORS in multiple places can lead to confusing debugging scenarios. Centralizing CORS settings in one location decreases complexity, and thus, improves security.
:::




## Availability Checks

To proactively identify problems, projects should set up availability monitoring for all the components involved in their solution.

### Anonymous Ping

An *anonymous ping* service should be implemented with the least overhead possible. Hence, it should not use any authentication or authorization mechanism, but simply respond to whoever is asking.

From `@sap/cds^7.8` onwards, the Node.js runtime provides such an endpoint for availability monitoring out of the box at `/health` that returns `{ status: 'UP' }` (with status code 200).

You can override the default implementation and register a custom express middleware during bootstrapping as follows:

```js
cds.on('bootstrap', app => app.get('/health', (_, res) => {
  res.status(200).send(`I'm fine, thanks.`)
}))
```

More sophisticated health checks, like database availability for example, should use authentication to prevent Denial of Service attacks!


## Error Handling

Good error handling is important to ensure the correctness and performance of the running app and developer productivity.
We will give you a brief overview of common best practices.

### Error Types

We need to distinguish between two types of errors:

- Programming errors: These occur because of some programming mistakes (for example, `cannot read 'foo' of undefined`). They need to be fixed.
- Operational errors: These occur during the operation (for example, when a request is sent to an erroneous remote system). They need to be handled.

### Guidelines

#### Let It Crash

'Let it crash' is a philosophy coming from the [Erlang programming language](https://www.erlang.org/) (Joe Armstrong) which can also be (partially) applied to Node.js.

The most important aspects for programming errors are:

- Fail loudly: Do not hide errors and silently continue. Make sure that unexpected errors are correctly logged. Do not catch errors you can't handle.
- Don't program in a defensive way: Concentrate on your business logic and only handle errors if you know that they occur. Only use `try`/`catch` blocks when necessary.

Never attempt to catch and handle unexpected errors, promise rejections, etc. If it's unexpected, you can't handle it correctly. If you could, it would be expected (and should already be handled). Even though your apps should be stateless, you can never be 100% certain that any shared resource wasn't affected by the unexpected error. Hence, you should never keep an app running after such an event, especially in multi-tenant apps that bear the risk of information disclosure.

This will make your code shorter, clearer, and simpler.

#### Don't Hide Origins of Errors

If an error occurs, it should be possible to know the origin. If you catch errors and re-throw them without the original information, it becomes hard to find and fix the root cause.

Example:

```js
try {
  // something
} catch (e) {
  // augment instead of replace details
  e.message = 'Oh no! ' + e.message
  e.additionalInfo = 'This is just an example.'
  // re-throw same object
  throw e
}
```

In rare cases, throwing a new error is necessary, for example, if the original error has sensitive details that should not be propagated any further. This should be kept to an absolute minimum.

### Further Readings

The following articles might be of interest:
- [Error Handling in Node.js](https://web.archive.org/web/20220417042018/https://www.joyent.com/node-js/production/design/errors)
- [Let It Crash](https://wiki.c2.com/?LetItCrash)
- [Don't Catch Exceptions](https://wiki.c2.com/?DontCatchExceptions)
- [Report And Die](https://wiki.c2.com/?ReportAndDie)



## Timestamps

When using [timestamps](events#timestamp) (for example for managed dates) the Node.js runtime offers a way to easily deal with that without knowing the format of the time string. The `req` object contains a property `timestamp` that holds the current time (specifically `new Date()`, which is comparable to `CURRENT_TIMESTAMP` in SQL). It also stays the same until the request finished, so if it is used in multiple places in the same transaction or request it will always be the same.

Example:

```js
srv.before("UPDATE", "EntityName", (req) => {
  const now = req.timestamp;
  req.data.createdAt = now;
});
```

Internally the [timestamp](events#timestamp) is a JavaScript `Date` object, that is converted to the right format, when sent to the database. So if in any case a date string is needed, the best solution would be to initialize a Date object, that is then translated to the correct UTC String for the database.


## Custom Streaming <Beta /> { #custom-streaming-beta }

[Media Data](../guides/providing-services#serving-media-data) can be served from custom handlers of the type `READ`, `action`, or `function`.
Actions and functions support the same set of `media data` annotations.
```cds
@(Core.MediaType: 'text/csv', Core.ContentDisposition.Filename: 'Books.csv')
type csv:  LargeBinary;
entity Books { ... } actions {
  function csvExport () returns csv;
}
```
Alternatively, the return type can be annotated directly in the declarations of actions or functions.
```cds
function csvExport () returns @Core.MediaType LargeBinary;
```

When returning custom media data, content information can be configured as part of the handlers `result` object. 

When calling [`req.reply`](events#req-reply-results) in handlers, you can include options with an instance of [stream.Readable](https://nodejs.org/api/stream.html#class-streamreadable) to specify the [content disposition headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Disposition). In the following example, the options are specified in the `stream.Readable` instance named `myReadable` :

```js
srv.on('READ', 'Books', (req, next) => {
  req.reply(myReadable, {
    mimetype: 'image/jpeg', // > optional
    filename: 'cover.jpg', // > optional
  })
})
```

Alternatively, you can return an instance of [stream.Readable](https://nodejs.org/api/stream.html#class-streamreadable) (named `myReadable` in the example) directly and configure content disposition information by assigning relevant property values (`mimetype`, `filename`) directly to that object:

```js
srv.on('READ', 'Books', (req, next) => {
  if (coverImageIsRequested) {
    return Object.assign(myReadable, {
      mimetype: 'image/jpeg', // > optional
      filename: 'cover.jpg', // > optional
    })
  }
  return next()
})
```

:::details Compatibility option
If needed for compatibility reasons, convey the content information using a result object specifying the information as it would appear if extracted from the appropriate CDS annotations.
In the returned object, `value` is an instance of [stream.Readable](https://nodejs.org/api/stream.html#class-streamreadable) (named `myReadable` in the example) and the properties `$mediaContentType`, `$mediaContentDispositionFilename`, and `$mediaContentDispositionType` are used to set the respective headers.

```js
srv.on('getCoverImageFunction', 'Books', (req) => {
  return {
    value: myReadable,
    $mediaContentType: 'image/jpeg',
    $mediaContentDispositionFilename: 'cover.jpg', // > optional
    $mediaContentDispositionType: 'inline' // > optional
  }
})
```

:::

In addition, the Node.js runtime will respect manually set header values.

```js
srv.on('unboundAction', (req) => {
  cds.context.http?.res.setHeader('content-type', 'image/jpeg')
  cds.context.http?.res.setHeader('content-disposition', 'inline; filename="cover.jpg"')

  return myReadable
})
```

If no content information is provided in one of the ways listed above, the Node.js runtime will fall back to using content information found in annotations or as a last resort, try to assume defaults from context.

:::warning Limited feature-set in REST
For [`protocol: rest`](cds-serve#cds-protocols) stream responses are only available for operations. 
:::

## Custom $count { #custom-count }

When you write custom `READ` on-handlers, you should also support requests that contain `$count`, such as `GET /Books/$count` or `GET /Books?$count=true`. For more details, consider the following example:

```js
srv.on('READ', 'Books', function (req) {
  // simple '/$count' request
  if (req.query.SELECT.columns?.length === 1 && req.query.SELECT.columns[0].as === '$count')
    return [{ $count: 100 }]
  // support other '/$count' requests
  ...

  const resultSet = [ ... ]

  // request contains $count=true 
  if (req.query.SELECT.count === true) resultSet.$count = 100

  return resultSet
})
```


<div id="secondary-file">node.js/best-practices.fragment.md</div>




# CAP Service SDK for Java

Reference Documentation { .subtitle}

<span class="badges">

<a :href="`https://javadoc.io/doc/com.sap.cds/cds-services-api/${enc(versions.java_services)}/overview-summary.html`" target="_blank" rel="noopener noreferrer" class="no-ext-link"><img :src="`https://img.shields.io/badge/cds--services-${enc(versions.java_services)}-brightgreen.svg`" title="cds-services" crossorigin/></a>
<a :href="`https://javadoc.io/doc/com.sap.cds/cds4j-api/${enc(versions.java_cds4j)}/com/sap/cds/ql/package-summary.html`" target="_blank" rel="noopener noreferrer" class="no-ext-link"><img :src="`https://img.shields.io/badge/cds4j--api-${enc(versions.java_cds4j)}-brightgreen.svg`" title="cds4j-api" crossorigin/></a>

</span>



<br>
<IndexList :pages='pages' />



# Getting Started



How to start a new CAP Java project and how to run it locally.

## Introduction


The CAP Java SDK enables developing CAP applications in Java. While the [SAP Business Application Studio](https://help.sap.com/products/SAP%20Business%20Application%20Studio/9d1db9835307451daa8c930fbd9ab264/84be8d91b3804ab5b0581551d99ed24c.html) provides excellent support to develop CAP Java applications, you can also develop locally with Visual Studio Code.

The CAP Java SDK supports lean application design by its modular architecture, that means you pick the required features and add them to your application dependencies on demand.

It enables local development by supporting in-memory or file-based SQLite databases. At the same time, the CAP Java SDK enables switching to a productive environment, using, for example, SAP HANA as a database, easily by simply switching the application deployment configuration.

If you use Spring Boot, you find yourself directly at home when using the CAP Java SDK, as the framework integrates with Spring Boot features like transaction handling, auto-wiring and test support. While the CAP Java SDK is framework agnostic, it's also possible to develop plain Java applications or even integrate with other frameworks.

The CAP Java SDK comes with an OData V4 protocol adapter, but it's openly designed. You can add more protocol adapters in the future or provide even custom protocol adapters by the application.

It supports SAP BTP features like authentication and authorization based on XSUAA tokens. But you aren't locked in to SAP BTP using a CAP Java application.

<span id="inintro" />
<Fragment target="#inintro">

::: tip Internal information <Internal />
The CAP Java SDK also supports multitenancy.
:::

</Fragment>

Excited? The following sections describe how to set up a development environment to get you started.

## Setting Up Local Development { #local}



This section describes the prerequisites and tools to build a CAP application locally.

1. Install the CDS tools (`cds-dk`) by following the steps in the central *[Getting Started](../get-started/#setup)* guide.

2. Install a Java VM. At least, Java 17 is required. For example, [download](https://github.com/SAP/SapMachine/releases/latest) and [install](https://github.com/SAP/SapMachine/wiki/Installation) SapMachine 17.

3. [Install Apache Maven](https://maven.apache.org/download.cgi) (at least version 3.6.3 is required).

<span id="maven-sap" />
<Fragment target="#maven-sap">

::: tip SAP Build Landscape <Internal />
At SAP, configure Maven landscape by downloading this [settings.xml](https://int.repositories.cloud.sap/artifactory/build-releases/settings.xml) and save it to `<USER_HOME>/.m2/settings.xml`
:::

</Fragment>

4. Execute the following commands on the command line to check whether the installed tools are set up correctly:

    ```sh
    cds --version
    java --version
    mvn --version
    ```
::: tip
For a preconfigured environment, use [SAP Business Application Studio](../tools/cds-editors#bas), which comes with all the required tools preinstalled.
In older workspaces it might be necessary to explicitly set the JDK to version 17 with the command `Java: Set Default JDK`.
:::

## Starting a New Project { #new-project}


Take the following steps to set up a new CAP Java application based on Spring Boot from scratch. As a prerequisite, you've set up your [development environment](#local).

### Run the Maven Archetype { #run-the-cap-java-maven-archetype }

Use the [CAP Java Maven archetype](./developing-applications/building#the-maven-archetype) to bootstrap a new CAP Java project:

```sh
mvn archetype:generate -DarchetypeArtifactId="cds-services-archetype" -DarchetypeGroupId="com.sap.cds" -DarchetypeVersion="RELEASE" -DinteractiveMode=true
```

<div id="release-sap" />
<Fragment target="#release-sap">

::: tip Artifactory <Internal />
At SAP, if you're using the internal [artifactory repository](https://int.repositories.cloud.sap/) you need to explicitly exchange `RELEASE` with the [latest released version of `com.sap.cds:cds-services-bom`](https://javadoc.io/doc/com.sap.cds). Using `RELEASE`, the above command will install the internally available milestones of the next major release.
:::

</Fragment>

When prompted, specify the group ID and artifact ID of your application. The artifact ID also specifies the name of your projects root folder that is generated in your current working directory. For other values prompted, it's enough to simply confirm the default values.

Alternatively, you can use the CDS tools to bootstrap a Java project:

```sh
cds init <PROJECT-ROOT> --java
```
Afterwards, switch to the new project by calling `cd <PROJECT-ROOT>`. All following steps need to executed from this directory!

::: tip
You can call `cds help init` for more information on the available options.
:::

### Add a Sample CDS Model

You can use the [CDS Maven plugin](developing-applications/building#cds-maven-plugin) to add a sample CDS model after creating your project. Navigate to the root folder of your CAP Java project and execute the following Maven command:

```sh
mvn com.sap.cds:cds-maven-plugin:add -Dfeature=TINY_SAMPLE
```

### Add CloudFoundry target platform

Following the "[Grow As You Go](../about/#grow-as-you-go)" principle, the generated CAP Java project doesn't contain support for Cloud Foundry as the target platform. To enhance your project with dependencies required for Cloud Foundry, execute the goal `add` of the [CDS Maven plugin](./assets/cds-maven-plugin-site/add-mojo.html){target="_blank"} using the following command:

```sh
mvn com.sap.cds:cds-maven-plugin:add -Dfeature=CF
```

This command adds the following dependency to the pom.xml:

```xml
<dependency>
	<groupId>com.sap.cds</groupId>
	<artifactId>cds-starter-cloudfoundry</artifactId>
</dependency>
```
::: tip
CAP Java also provides a starter bundle for SAP BTP Kyma environment. See [CAP Starter Bundles](./developing-applications/building#starter-bundles#starter-bundles) for more details.
:::

### Project Layout

The generated project has the following folder structure:

```txt
<PROJECT-ROOT>/
├─ db/
└─ srv/
   ├─ src/main/java/
   ├─ src/gen/java/
   └─ node_modules/
```

The generated folders have the following content:

| Folder | Description |
| --- | --- |
| *db* | Contains content related to your database. A simple CDS domain model is included. |
 | *srv* | Contains the CDS service definitions and Java back-end code and the sample service model. |
| *srv/src/main/java* | Contains the Java source code of the `srv/` Maven project. |
| *srv/src/gen/java* | Contains the compiled CDS model and generated [accessor interfaces for typed access](./cds-data#typed-access) after building the project with `mvn compile` once. |
| *node_modules* | Generated when starting the build, containing the dependencies for the CDS tools (unless you specify `-Dcdsdk-global` [when starting the build](#build-and-run)). |




### Add an Integration Test Module (Optional)

Optionally, you can use the [CDS Maven plugin](./developing-applications/building#cds-maven-plugin) to enhance your CAP Java application with an additional Maven module to perform integration tests. To add such a module, go into the root folder of your CAP Java project and execute the following Maven command:

```sh
mvn com.sap.cds:cds-maven-plugin:add -Dfeature=INTEGRATION_TEST
```

This command also creates a new folder *integration-tests/src/test/java*, which contains integration test classes.

| Folder | Description  |
| -- | -- |
| *integration-tests/src/test/java* | Contains integration test classes. |

<span id="beforebuildnrun" />

### Build and Run

To build and run the generated project from the command line, execute:

```sh
mvn spring-boot:run
```
::: tip
To test whether the started application is up and running, open [http://localhost:8080](http://localhost:8080) in your browser.
Use user [`authenticated`](./security#mock-users) if a username is requested. You don't need to enter a password.
:::

### Supported IDEs

CAP Java projects can be edited best in a Java IDE. Leaving CDS support aside you could use any Java IDE supporting the import of Maven projects. But as CDS modeling and editing is a core part of CAP application development we strongly recommend to use an IDE with existing Java support:

* [SAP Business Application Studio](/tools/cds-editors#bas) is a cloud-based IDE with minimal local requirements and footprint. It comes pre packaged with all tools, libraries and extensions that are needed to develop CAP applications.
* [Visual Studio Code](/tools/cds-editors#vscode) is a free and very wide-spread code editor and IDE which can be extended with Java and CDS support. It offers first class CDS language support and solid Java support for many development scenarios.
* [IntelliJ Idea Ultimate](/tools/cds-editors#intellij) is one of the leading Java IDEs with very powerful debugging, refactoring and profiling support. Together with the CDS Plugin it offers the most powerful support for CAP Java application development.


#### Source Path Configuration and CDS build

Your IDE might show inline errors indicating missing classes. This happens because the generated Java files are missing.

To resolve this, open your terminal and execute `mvn compile` in your project root directory. This action performs a full build of your project. It's necessary because, although the IDE can construct the correct class path based on the project's dependencies, it doesn't initiate the CDS build or subsequent code generation. This is covered as part of the `mvn compile` call.

If you're using JetBrains' Intellij, you need to tell it to use the generated folder `srv/src/gen/java`. Do so by marking the directory as `Generated Sources Root`.  You can find this option in IntelliJ's project settings or by right-clicking on the folder and choosing `Mark Directory as`. By doing this, you ensure that the IntelliJ build includes the generated sources in the Java ClassPath.

#### Run and Test the Application

Once you've configured your application as described in the previous section, you can run your application in your IDE by starting the `main` method of your project's `Application.java`.

Then open the application in your browser at [http://localhost:8080/](http://localhost:8080).

## Sample Application { #sample}

Find [here](https://github.com/SAP-samples/cloud-cap-samples-java) the bookshop sample application based on CAP Java.

<div id="secondary-file">java/getting-started.fragment.md</div>


# Versions & Dependencies


Learn in this chapter about CAP Java versions and their dependencies.





## Versions { #versions }

CAP Java is pretty much aligned with the [Semantic Versioning Specification](https://semver.org).
Hence, the version identifier follows the pattern `MAJOR.MINOR.PATCH`:

- **Major versions** are delivered every year or even several years and might introduce [incompatible changes](../releases/schedule#cap-java) (for example, `2.0.0`).
Upcoming major versions are announced early.

- **Minor versions** are delivered on a [monthly basis](/releases/schedule#minor) (for example, `2.7.0` replacing `2.6.4`).
New features are announced in the [CAP Release notes](/releases/).

- **Patch versions** containing critical bugfixes are delivered [on demand](../releases/schedule#patch) (for example, `2.7.1` replacing `2.7.0`). Patches do not contain new features.

Find detailed information about versions and release in the [CAP release schedule](../releases/schedule#cap-java).

::: warning Consume latest versions
We strongly recommend to consume the latest minor version on a monthly basis to keep future migration efforts as small as possible.

Likewise, we strongly recommend to consume the latest patch version as soon as possible to receive critical bug fixes.
:::

### Active Version { #active-version }

New features are developed and delivered in the [active codeline](../releases/schedule#active) of CAP Java only.
That means the currently active codeline receives minor version updates as well as patches.
A new major version opens a new active codeline and the previous one is put into maintenance mode.

### Maintenance Version { #maintenance-version }

In the [maintenance codeline](../releases/schedule#maintenance-status) of CAP Java, only patch versions are delivered.
This version provides applications with a longer time horizon for migrating to a new major version.


<div id="milestones" />
<Fragment target="#milestones">

### Milestones <Internal /> { #milestones }

Milestones provide a weekly snapshot of the current development status of the active version.
They're helpful for applications to test new features in a preview mode before they're officially released.

::: warning New APIs offered in milestone versions are prior art and might be subject to change.

:::

To use a milestone version of CAP Java, it's required to configure the SAP internal `snapshot` or `milestone` repository:

- <https://int.repositories.cloud.sap/artifactory/build-milestones/>
- <https://int.repositories.cloud.sap/artifactory/build-snapshots/>

This configuration is done in the `~/.m2/settings.xml` according to the [documentation](https://maven.apache.org/settings.html).

::: tip Internal _settings.xml_
There's already a default [settings.xml](https://int.repositories.cloud.sap/artifactory/build-releases/settings.xml) available for internal usage at SAP.
:::

</Fragment>


## Maintain Dependencies { #dependencies }

### Minimum Versions

CAP Java uses various dependencies that are also used by the applications themselves.
If the applications decide to manage the versions of these dependencies, it's helpful to know the minimum versions of these dependencies that CAP Java requires.
The following table lists these minimum versions for various common dependencies, based on the latest release:

#### Active Version 4.x { #dependencies-version-4 }

| Dependency | Minimum Version | Recommended Version |
| --- | --- | --- |
| JDK | 17 | 21 |
| Maven | 3.6.3 | 3.9.9 |
| @sap/cds-dk | 8 | latest |
| @sap/cds-compiler | 5 | latest |
| Spring Boot | 3.0 | latest |
| XSUAA | 3.1 | latest |
| SAP Cloud SDK | 5.9 | latest |
| Java Logging | 3.7 | latest |
| Node.js | 20 | 22 |

#### Maintenance Version 3.10.x { #dependencies-version-3 }

| Dependency | Minimum Version | Recommended Version |
| --- | --- | --- |
| JDK | 17 | 21 |
| Maven | 3.6.3 | 3.9.9 |
| @sap/cds-dk | 7 | latest |
| @sap/cds-compiler | 4 | latest |
| Spring Boot | 3.0 | latest |
| XSUAA | 3.0 | latest |
| SAP Cloud SDK | 5.9 | latest |
| Java Logging | 3.7 | latest |
| Node.js | 18 | 20 |


### Consistent Versions

Some SDKs such as CAP Java or Cloud SDK provide a bunch of artifacts with a common version.
Mixing different versions of SDK artifacts often results in compiler errors or unpredictable runtime issues.

To help keeping the client configuration consistent, SDKs usually provide bill of material (BOM) poms as an optional maven dependency.
We strongly recommended to import available BOM poms.

Following example shows how BOM poms of `com.sap.cds`, `com.sap.cloud.sdk`, and `com.sap.cloud.security` can be added to the project's parent `pom.xml`:

::: code-group
```xml [pom.xml]
<dependencyManagement>
	<dependencies>
		
		<dependency>
			<groupId>com.sap.cds</groupId>
			<artifactId>cds-services-bom</artifactId>
			<version>${cds.services.version}</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>

		
		<dependency>
			<groupId>com.sap.cloud.sdk</groupId>
			<artifactId>sdk-modules-bom</artifactId>
			<version>${cloud.sdk.version}</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>

		
		<dependency>
			<groupId>com.sap.cloud.security</groupId>
			<artifactId>java-bom</artifactId>
			<version>${xsuaa.version}</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>
	</dependencies>
</dependencyManagement>
```
:::


### Update Versions

Regular [updates and patches](#versions) of CAP Java keeps your project in sync with the most recent Free and Open Source Software (FOSS) dependency versions.

However, a security vulnerability could be published, by one of your dependencies, in between CAP Java releases and in turn prevent your application from being released due to failing security scans.
In this case, applications have the following options:

- Wait for the next monthly CAP Java release with fixed dependencies.
- Specify a secure version of the vulnerable dependency explicitly. Do that at the beginning of the `dependencyManagement` section of the top-level *pom.xml* file of your application:

::: code-group
```xml [pom.xml]
<dependencyManagement>
   […]
   <dependency>
       <groupId>…</groupId>
       <artifactId>…</artifactId>
       <version>…</version>
   </dependency>
</dependencyManagement>
```
:::

Make sure that the updated version is compatible. When consuming a new CAP Java version, this extra dependency can be removed again.

<div id="in-update-versions" />
<Fragment target="#in-update-versions">

#### Updating Dependencies Automatically <Internal />

Updating FOSS dependencies can be automated using the [Renovate](https://github.tools.sap/OSPO/renovate-controller) bot.

Additionally, it can be used to update the explicitly specified [`@sap/cds-dk` version](/java/developing-applications/building#cds-maven-plugin) in `pom.xml`.

::: code-group

```xml [pom.xml]
<properties>
  […]
  <cds.services.version>2.2.0</cds.services.version>
  <spring.boot.version>3.1.3</spring.boot.version>
  <cds.install-cdsdk.version>7.2.0</cds.install-cdsdk.version>
</properties>
```

:::

With Renovate's default configuration, pull requests to update Maven dependencies are opened automatically.
This includes `cds-services` and `spring-boot`. However, `@sap/cds-dk` and Node.js are not Maven dependencies and aren't checked.

To have Renovate automatically open pull requests when new versions of `@sap/cds-dk` or Node.js are available, you can specify `customManagers` in the `renovate.json` configuration file.

::: code-group

```json [renovate.json]
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": [ "config:recommended" ],
  "rebaseWhen": "conflicted",
  "packageRules": [
    {
      "matchDepNames": ["@sap/cds-dk", "Node.js Version"],
      "rangeStrategy": "pin"
    }
  ],
  "customManagers": [
    {
      "customType": "regex",
      "fileMatch": [ "pom.xml" ],
      "matchStrings": [
        "<cds\\.install-cdsdk\\.version>(?<currentValue>[.\\d]*?)</cds\\.install-cdsdk\\.version>"
      ],
      "registryUrlTemplate": "https://int.repositories.cloud.sap/artifactory/api/npm/build-releases-npm/",
      "depNameTemplate": "@sap/cds-dk",
      "datasourceTemplate": "npm",
      "versioningTemplate": "npm"
    },
    {
      "customType": "regex",
      "fileMatch": [ "pom.xml" ],
      "matchStrings": [
        "<cds\\.install-node\\.nodeVersion>v(?<currentValue>[.\\d]*?)</cds\\.install-node\\.nodeVersion>"
      ],
      "depNameTemplate": "Node.js Version",
      "datasourceTemplate": "node-version",
      "versioningTemplate": "node"
    }
  ]
}
```

:::

> If you're using [XMake, keep your Node.js versions](https://github.tools.sap/OSPO/renovate-controller/blob/main/docs/xmake-node-version.md) in sync!

More documentation is available in [OSPO/renovate-controller](https://github.tools.sap/OSPO/renovate-controller).

</Fragment>


<div id="secondary-file">java/versions.fragment.md</div>


# Working with CDS Models


The Model Reflection API is a set of interfaces, which provide the ability to introspect a CDS model and retrieve details on the services, types, entities, and their elements that are defined by the model.

## The CDS Model

The interface `CdsModel` represents the complete CDS model of the CAP application and is the starting point for the introspection.

The `CdsModel` can be obtained from the `EventContext`:

 ```java
import com.sap.cds.services.handler.annotations.On;
import com.sap.cds.services.EventContext;
import com.sap.cds.reflect.CdsModel;

@On(event = "READ", entity = "CatalogService.Books")
public void readBooksVerify(EventContext context) {
    CdsModel model = context.getModel();
   ...
}
```

or, in Spring, be injected:

```java
@Autowired
CdsModel model;
```

On a lower level, the `CdsModel` can be obtained from the `CdsDataStoreConnector`, or using the `read` method from a [CSN](../cds/csn) String or [InputStream](https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html):

```java
InputStream csnJson = ...;
CdsModel model = CdsModel.read(csnJson);
```

::: tip
Instead of bare string literals, you can also use auto-generated string constants and interfaces in event handlers.

[Learn more about event handlers.](./event-handlers/){.learn-more}
:::

## Examples

The following examples are using this CDS model:

```cds
namespace my.bookshop;

entity Books {
  title  : localized String(111);
  author : Association to Authors;
  ...
}

entity Authors {
  key ID : Integer;
  ...
}

entity Orders {
  OrderNo  : String @title:'Order Number';
  ...
}
```

### Get and Inspect an Element of an Entity

In this example, we introspect the details of the type of the element `title` of the entity `Books`:

```java
CdsEntity books = model.getEntity("my.bookshop.Books");
CdsElement title = books.getElement("title");

boolean key = title.isKey();      // false
boolean localized = title.isLocalized(); // true
CdsType type = title.getType();   // CdsSimpleType

if (type.isSimple()) {   // true
  CdsSimpleType simple = type.as(CdsSimpleType.class);

  String typeName = simple.getQualifiedName();  // "cds.String"
  CdsBaseType baseType = simple.getType();      // CdsBaseType.STRING
  Class<?> javaType = simple.getJavaType();     // String.class
  Integer length = simple.get("length");        // 111
}
```

### Get and Inspect All Elements of an Entity

```java
CdsEntity books = model.getEntity("my.bookshop.Books");
Stream<CdsElement> elements = books.elements();
```

The method `elements()` returns a stream of all elements of the given entity, structured type, or event. It's important to note that the Model Reflection API doesn't guarantee the element order to be exactly like in the source CSN document. However, the order is guaranteed to be stable during multiple consecutive model reads.

::: tip
In case the element names are known beforehand it's recommended to access them by name through the `getElement(String name)` method.
:::

### Get and Inspect an Association Element of an Entity

We can also analyze the details of an association:

```java
CdsElement authorElement = book.getAssociation("author");
CdsAssociationType toAuthor = authorElement.getType();

CdsEntity author = toAuthor.getTarget(); // Entity: my.bookshop.Authors
boolean association = toAuthor.isAssociation();   // true
boolean composition = toAuthor.isComposition();   // false

Cardinality cardinality = toAuthor.getCardinality();
String sourceMax = cardinality.getSourceMax();    // "*"
String targetMin = cardinality.getTargetMin();    // "0"
String targetMax = cardinality.getTargetMax();    // "1"

Stream<CdsElement> keys = toAuthor.keys();  // Stream: [ ID ]
Optional<CqnExpression> onCondition = toAuthor.onCondition(); // empty
```

### Find an Annotation by Name and Get Its Value

Here, we programmatically check if the element `OrderNo` carries the annotation `title` and set the value of `displayName` depending on the presence of the
annotation:

```java
CdsEntity order = model.getEntity("my.bookshop.Orders");
CdsElement orderNo = order.getElement("OrderNo");

Optional<CdsAnnotation<String>> annotation = orderNo
        .findAnnotation("title");
String displayName = annotation.map(CdsAnnotation::getValue)
        .orElse(orderNo.getName());   // "Order Number"
```

### Filter a Stream of Entities by Namespace

The static method `com.sap.cds.reflect.CdsDefinition.byNamespace` allows to create a predicate to filter a stream of definitions
(for example, entities, elements, ...) for definitions contained in a given namespace:

```java
import static com.sap.cds.reflect.CdsDefinition.byNamespace;
...

Stream<CdsEntity> entities = model.entities()
    .filter(byNamespace("my.bookshop"));
```

### Get All Elements with Given Annotation

The static method `com.sap.cds.reflect.CdsAnnotatable.byAnnotation` allows to create a [predicate](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html) to filter a stream of annotatable model components (for example, entities, elements, ...) for components that carry a given annotation:

```java
import static com.sap.cds.reflect.CdsAnnotatable.byAnnotation;
...

CdsEntity order = model.getEntity("my.bookshop.Orders");
Stream<CdsElement> elements = order.elements()
    .filter(byAnnotation("title"));
```

## Feature Toggles

### Feature Toggles and Active Feature Set

[Feature toggles](../guides/extensibility/feature-toggles) allow to dynamically enable or disable parts of an application at runtime or to alter the behaviour depending on features.

Feature toggles can be used for different purposes. They can be used as release toggles to selectively enable some features for some customers only based on a deployment vector. Or they can be used as runtime toggles to dynamically enable or disable selected features for selected users.

CAP Java does not make any assumption _how_ the set of enabled features (_active feature set_) is determined. This could be based on user ID, user role, user tenant, or any other information such as an HTTP header or an external feature toggle service.

### Features in CDS Models

Features are modeled in CDS by dividing up CDS code concerning separate features into separate subfolders of a common `fts` folder of your project, as shown by the following example:

```txt
├─ [db]
│  ├─ my-model.cds
│  └─ ...
├─ [srv]
│  ├─ my-service.cds
│  └─ ...
└─ [fts]
   ├─ [X]
   │  ├─ model.cds
   │  └─ ...
   ├─ [Y]
   │  ├─ feature-model.cds
   │  └─ ...
   └─ [Z]
      ├─ wrdlbrmpft.cds
      └─ ...
```

In this example, three _CDS features_ `X`, `Y` and `Z` are defined. Note that the name of a feature (by which it is referenced in a _feature toggle_) corresponds to the name of the feature's subfolder. A CDS feature can contain arbitrary CDS code. It can either define new entities or extensions of existing entities.

The database schema resulting from CDS build at design time contains *all* features. This is required to serve the base model and all combinations of features at runtime.

### The Model Provider Service

![This graphic is explained in the accompanying text.](../assets/feature-toggles.drawio.svg)

At runtime, per request, an effective CDS model is used that reflects the active feature set. To obtain the effective model that the runtime delegates to the *Model Provider Service*, which uses this feature set to resolve the CDS model code located in the `fts` folder of the active features and compiles to effective CSN and EDMX models for the current request to operate on.

::: warning
The active feature set can't be changed within an active transaction.
:::

### Toggling SAP Fiori UI Elements

In an [SAP Fiori elements](https://experience.sap.com/fiori-design-web/smart-templates/) application, the UI is captured with annotations in the CDS model. Hence, toggling of [SAP Fiori elements annotations](../advanced/fiori#what-are-sap-fiori-annotations) is already leveraged by the above concept: To enable toggling of such annotations (and thus UI elements), it's required that the EDMX returned by the `$metadata` respects the feature vector. This is automatically achieved by maintaining different model variants according to activated features as described in the previous section.

### Features on the Database

As CDS features are reflected in database artifacts, the database needs to be upgraded when new features are _introduced_ in the CDS model. If a feature is _enabled_, the corresponding database artifacts are already present and no further database change is required.

Only when a particular feature is turned on, the application is allowed to access the corresponding part of the database schema. The CAP framework ensures this by exposing only the CDS model that corresponds to a certain feature vector. The CAP framework accesses database entities based on the currently active CDS model only. This applies in particular to `SELECT *` requests for which the CAP framework returns all columns defined in the current view on the model, and *not* all columns persisted on the database.

### Feature Toggles Info Provider

In CAP Java, the [active feature set](#feature-toggles-and-active-feature-set) in a particular request is represented by the [`FeatureTogglesInfo`](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/FeatureTogglesInfo.html). On each request, the runtime uses the [`FeatureTogglesInfoProvider`](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/FeatureTogglesInfoProvider.html) to create the request-dependent `FeatureTogglesInfo` object, which is exposed in the current `RequestContext` by [`getFeatureTogglesInfo()`](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/RequestContext.html#getFeatureTogglesInfo--).

By default all features are deactivated (`FeatureTogglesInfo` represents an empty set).

#### From Mock User Configuration

If mock users are used, a default [`FeatureToggleProvider`](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/runtime/FeatureTogglesInfoProvider.html) is registered, which assigns feature toggles to users based on the [mock user configuration](./security#mock-users). Feature toggles can be configured per user or [per tenant](./security#mock-tenants). The following configuration enables the feature `wobble` for the user `Bob` while for `Alice` the features `cruise` and `parking` are enabled:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  security:
    mock:
      users:
        - name: Bob
          tenant: CrazyCars
          features:
            - wobble
        - name: Alice
          tenant: SmartCars
          features:
            - cruise
            - parking
```
:::
#### Custom Implementation

Applications can implement a custom [`FeatureTogglesInfoProvider`](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/runtime/FeatureTogglesInfoProvider.html) that computes a `FeatureTogglesInfo` based on the request's [`UserInfo`](https://www.javadoc.io/static/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/UserInfo.html) and [`ParameterInfo`](https://www.javadoc.io/static/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/ParameterInfo.html).

The following example demonstrates a feature toggles info provider that enables the feature `isbn` if the user has the `expert` role:

```java
@Component
public class DemoFTProvider implements FeatureTogglesInfoProvider {
    @Override
    public FeatureTogglesInfo get(UserInfo userInfo, ParameterInfo paramInfo) {
        Map<String, Boolean> featureToggles = new HashMap<>();
        if (userInfo.hasRole("expert")) {
            featureToggles.put("isbn", true);
        }
        return FeatureTogglesInfo.create(featureToggles);
    }
}
```

This feature toggles provider is automatically registered and used as Spring bean by means of the annotation `@Component`. At each request, the CAP Java runtime calls the method `get()`, which determines the active features based on the logged in user's roles.

#### Defining Feature Toggles for Internal Service Calls

It is not possible to redefine the feature set within an active request context as this would result in a model change.
However, if there is no active request context such as in a new thread, you can specify the feature set while [Defining Request Contexts](./event-handlers/request-contexts#defining-requestcontext).

In the following example, a `Callable` is executed in a new thread resulting in an initial request context. In the definition of the request context the feature toggles are defined that will be used for the statement execution:

```java
@Autowired
CdsRuntime runtime;

@Autowired
PersistenceService db;

FeatureTogglesInfo isbn = FeatureTogglesInfo.create(Collections.singletonMap("isbn", true));

...

Future<Result> result = Executors.newSingleThreadExecutor().submit(() -> {
  return runtime.requestContext().featureToggles(isbn).run(rc -> {
    return db.run(Select.from(Books_.CDS_NAME));
  });
});
```

<div id="toggle-provider-sap" />
<Fragment target="#toggle-provider-sap">

### Deploy with Confidence <Internal />

[Deploy with Confidence (DwC)](https://pages.github.tools.sap/deploy-with-confidence/solar-system/documentation/) provides a [util-cap](https://github.tools.sap/deploy-with-confidence/spring-utils) library, which brings an implementation of `FeatureTogglesInfoProvider` that determines the feature set based on DwC headers.

</Fragment>

### Using Feature Toggles in Custom Code

Custom code, which depends on a feature toggle can evaluate the [`FeatureTogglesInfo`](https://www.javadoc.io/static/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/FeatureTogglesInfo.html) to determine if the feature is enabled. The `FeatureTogglesInfo` can be obtained from the [RequestContext](./event-handlers/request-contexts) or `EventContext` by the `getFeatureTogglesInfo()` method or by [dependency injection](./spring-boot-integration#exposed-beans). This is shown in the following example where custom code depends on the feature `discount`:

```java
@After
protected void subtractDiscount(CdsReadEventContext context) {
    if (context.getFeatureTogglesInfo().isEnabled("discount")) {
        // Custom coding executed when feature "discount" is active
        // ...
    }
}
```

<div id="secondary-file">java/reflection-api.fragment.md</div>


# Working with CDS Data



This section describes how CDS data is represented and used in CAP Java.



## Predefined Types

The [predefined CDS types](../cds/types) are mapped to Java types and as follows:

| CDS Type           | Java Type               | Remark                                                                   |
| ------------------ | ----------------------- | ------------------------------------------------------------------------ |
| `cds.UUID`         | `java.lang.String`      |                                                                          |
| `cds.Boolean`      | `java.lang.Boolean`     |                                                                          |
| `cds.UInt8`        | `java.lang.Short`       |                                                                          |
| `cds.Int16`        | `java.lang.Short`       |                                                                          |
| `cds.Int32`        | `java.lang.Integer`     |                                                                          |
| `cds.Integer`      | `java.lang.Integer`     |                                                                          |
| `cds.Int64`        | `java.lang.Long`        |                                                                          |
| `cds.Integer64`    | `java.lang.Long`        |                                                                          |
| `cds.Decimal`      | `java.math.BigDecimal`  |                                                                          |
| `cds.DecimalFloat` | `java.math.BigDecimal`  | deprecated                                                               |
| `cds.Double`       | `java.lang.Double`      |                                                                          |
| `cds.Date`         | `java.time.LocalDate`   | date without a time-zone (year-month-day)                                |
| `cds.Time`         | `java.time.LocalTime`   | time without a time-zone (hour-minute-second)                            |
| `cds.DateTime`     | `java.time.Instant`     | instant on the time-line with _sec_ precision                            |
| `cds.Timestamp`    | `java.time.Instant`     | instant on the time-line with _µs_ precision                             |
| `cds.String`       | `java.lang.String`      |                                                                          |
| `cds.LargeString`  | `java.lang.String`      | `java.io.Reader` <sup>(1)</sup> if annotated with `@Core.MediaType`      |
| `cds.Binary`       | `byte[]`                |                                                                          |
| `cds.LargeBinary`  | `byte[]`                | `java.io.InputStream` <sup>(1)</sup> if annotated with `@Core.MediaType` |
| `cds.Vector`       | `com.sap.cds.CdsVector` | for [vector embeddings](#vector-embeddings)                              |
| `cds.Map`          | `java.util.Map`         | for arbitrary [structured data](#structured-data)<sup>(2)</sup>          |

### SAP HANA-Specific Data Types

To facilitate using legacy CDS models, the following [SAP HANA-specific data types](../advanced/hana#hana-types) are supported:

| CDS Type            | Java Type              | Remark                                                              |
| ------------------- | ---------------------- | ------------------------------------------------------------------- |
| `hana.TINYINT`      | `java.lang.Short`      |                                                                     |
| `hana.SMALLINT`     | `java.lang.Short`      |                                                                     |
| `hana.SMALLDECIMAL` | `java.math.BigDecimal` |                                                                     |
| `hana.REAL`         | `java.lang.Float`      |                                                                     |
| `hana.CHAR`         | `java.lang.String`     |                                                                     |
| `hana.NCHAR`        | `java.lang.String`     |                                                                     |
| `hana.VARCHAR`      | `java.lang.String`     |                                                                     |
| `hana.CLOB`         | `java.lang.String`     | `java.io.Reader` <sup>(1)</sup> if annotated with `@Core.MediaType` |
| `hana.BINARY`       | `byte[]`               |                                                                     |


> <sup>(1)</sup> Although the API to handle large objects is the same for every database, the streaming feature, however, is supported (and tested) in **SAP HANA**, **PostgreSQL**, and **H2**. See section [Database Support in Java](./cqn-services/persistence-services#database-support) for more details on database support and limitations.
> <sup>(2)</sup> Serialized as JSON to a CLOB column or JSONB column (on Postgres)

::: warning
The framework isn't responsible for closing the stream when writing to the database. You decide when the stream is to be closed. If you forget to close the stream, the open stream can lead to a memory leak.
:::

These types are used for the values of CDS elements with primitive type. In the [Model Reflection API](./reflection-api), they're represented by the enum [CdsBaseType](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/reflect/CdsBaseType.html).

## Structured Data

In CDS, structured data is used as payload of *Insert*, *Update*, and *Upsert* statements. Also the query result of *Select* may be structured.
CAP Java represents data of entities and structured types as `Map<String, Object>` and provides the `CdsData` interface as an extension of `Map` with additional convenience methods.

In the following we use this CDS model:

```cds
entity Books {
    key ID     : Integer;
        title  : String;
        author : Association to one Authors;
}

entity Authors {
    key ID    : Integer;
        name  : String;
        books : Association to many Books on books.author = $self;
}

entity Orders {
    key ID     : Integer;
        header : Composition of one  OrderHeaders;
        items  : Composition of many OrderItems;
}

entity OrderHeaders {
    key ID     : Integer;
        status : String;
}

aspect OrderItems {
    key ID     : Integer;
        book   : Association to one Books;
}
```
[Find this source also in **cap/samples**.](https://github.com/sap-samples/cloud-cap-samples-java/blob/5396b0eb043f9145b369371cfdfda7827fedd039/db/schema.cds#L5-L22){ .learn-more}

In this model, there is a bidirectional many-to-one association between `Books` and `Authors`, which is managed by the `Books.author` association. The `Orders` entity owns the composition `header`, which relates it to the `OrderHeaders` entity, and the composition `items`, which relates the order to the `OrderItems`. The items are modeled using a managed composition of aspects.

::: tip
Use [Managed Compositions of Aspects](../guides/domain-modeling#composition-of-aspects) to model unidirectional one-to-many compositions.
:::

### Relationships to other entities

Relationships to other entities are modeled as associations or compositions. While _associations_ capture relationships between entities, _compositions_ constitute document structures through 'contained-in' relationships.

### Entities and Structured Types

Entities and structured types are represented in Java as a `Map<String, Object>` that maps the element names to the element values.

The following example shows JSON data and how it can be constructed in Java:

```json
{
    "ID"    : 97,
    "title" : "Dracula"
}
```

```java
Map<String, Object> book = new HashMap<>();
book.put("ID", 97);
book.put("title", "Dracula");
```

> Data of structured types and entities can be sparsely populated.

### Nested Structures and Associations

Nested structures and single-valued associations, are represented by elements where the value is structured. In Java, the value type for such a representation is a map.

The following example shows JSON data and how it can be constructed in Java:

```json
{
    "ID"     : 97,
    "author" : { "ID": 23, "name": "Bram Stoker" }
}
```

Using plain maps:
```java
Map<String, Object> author = new HashMap<>();
author.put("ID", 23);
author.put("name", "Bram Stoker");

Map<String, Object> book = new HashMap<>();
book.put("ID", 97);
book.put("author", author);
```

Using the `putPath` method of `CdsData`:
```java
CdsData book = Struct.create(CdsData.class);
book.put("ID", 97);
book.putPath("author.ID", 23);
book.putPath("author.name", "Bram Stoker");
```

Using the generated [accessor interfaces](#generated-accessor-interfaces):
```java
Authors author = Authors.create();
author.setId(23);
author.setName("Bram Stoker");
Books book = Books.create();
book.setId(97);
book.setAuthor(author);
```

A [to-many association](../cds/cdl#to-many-associations) is represented by a `List<Map<String, Object>>`.

The following example shows JSON data and how it can be constructed in Java:

```json
{
    "ID"    : 23,
    "name" : "Bram Stoker",
    "books" : [
        { "ID" : 97, "title" : "Dracula" },
        { "ID" : 98, "title" : "Miss Betty" }
    ]
}
```

```java
// java
Map<String, Object> book1 = new HashMap<>();
book1.put("ID", 97);
book1.put("title", "Dracula");

Map<String, Object> book2 = new HashMap<>();
book2.put("ID", 98);
book2.put("title", "Miss Betty");

Map<String, Object> author = new HashMap<>();
author.put("ID", 23);
author.put("name", "Bram Stoker");
author.put("books", Arrays.asList(book1, book2));
```

## CDS Data

In CAP Java data is represented in maps. To simplify data access in custom code, CAP Java additionally provides generated [accessor interfaces](#typed-access) which extend [CdsData](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/CdsData.html), enhancing the `Map` interface with path access to nested data and build-in serialization to JSON.

![This graphic is explained in the accompanying text.](./assets/accessor.drawio.svg)

The `Row`s of a [query result](./working-with-cql/query-execution#result) as well as the [generated accessor interfaces](#generated-accessor-interfaces) already extend `CdsData`. Using the helper class [Struct](#struct) you can extend any `Map<String, Object>` with the CdsData `interface`:

```java
Map<String, Object> map = new HashMap<>();
CdsData data = Struct.access(map).as(CdsData.class);
```

Or create an empty `CdsData` map using `Struct.create`:
```java
CdsData data = Struct.create(CdsData.class);
```

### Path Access

Manipulate deeply nested data using `CdsData.putPath`:
```java
data.putPath("author.name", "Bram Stoker");
```
This results in a nested data structure: `{ "author" : { "name" : "Bram Stoker" } }`.
The path access in `putPath` is null-safe, nested maps are created on the fly if required.

Read nested data using `CdsData.getPath`:
```java
String authorName = data.getPath("author.name");
```

To check if the data contains a value in a nested map with a specific path use `containsPath`:

```java
boolean b = data.containsPath("author.name");
```

To do a deep remove use `removePath`:

```java
String authorName = data.removePath("author.name");
```

Empty nested maps are automatically removed by `removePath`.
::: tip
Use path access methods of `CdsData` to conveniently manipulate nested data structures.
:::

### Serialization

CDS Data has built-in serialization to JSON, which is helpful for debugging:

```java
CdsData person = Struct.create(CdsData.class);
person.put("salutation", "Mr.");
person.putPath("name.first", "Frank"); // path access

person.toJson(); // { "salutation" : "Mr.", name : { "first" : "Frank" } }
```
::: warning
Avoid cyclic relationships between CdsData objects when using toJson.
:::

<div id="cdsdata-serialization-jsonconverter"/>


## Vector Embeddings <Beta /> { #vector-embeddings }

In CDS [vector embeddings](../guides/databases-hana#vector-embeddings) are stored in elements of type `cds.Vector`:

```cds
entity Books : cuid { // [!code focus]
  title         : String(111);
  description   : LargeString;  // [!code focus]
  embedding     : Vector(1536); // vector space w/ 1536 dimensions // [!code focus]
} // [!code focus]
```

In CAP Java, vector embeddings are represented by the `CdsVector` type, which allows a unified handling of different vector representations such as `float[]` and `String`:

```Java
// Vector embedding of text, for example, from SAP GenAI Hub or via LangChain4j
float[] embedding = embeddingModel.embed(bookDescription).content().vector();

CdsVector v1 = CdsVector.of(embedding); // float[] format
CdsVector v2 = CdsVector.of("[0.42, 0.73, 0.28, ...]"); // String format
```

You can use the functions, `CQL.cosineSimilarity` or `CQL.l2Distance` (Euclidean distance) in queries to compute the similarity or distance of embeddings in the vector space. To use vector embeddings in functions, wrap them using `CQL.vector`:

```Java
CqnVector v = CQL.vector(embedding);

Result similarBooks = service.run(Select.from(BOOKS).where(b ->
  CQL.cosineSimilarity(b.embedding(), v).gt(0.9))
);
```

You can also use parameters for vectors in queries:

```Java
var similarity = CQL.cosineSimilarity(CQL.get(Books.EMBEDDING), CQL.param(0).type(VECTOR));

CqnSelect query = Select.from(BOOKS)
  .columns(b -> b.title(), b -> similarity.as("similarity"))
  .where(b -> b.ID().ne(bookId).and(similarity.gt(0.9)))
  .orderBy(b -> b.get("similarity").desc());

Result similarBooks = db.run(select, CdsVector.of(embedding));
```

In CDS QL queries, elements of type `cds.Vector` are not included in select _all_ queries. They must be explicitly added to the select list:

```Java
CdsVector embedding = service.run(Select.from(BOOKS).byId(101)
  .columns(b -> b.embedding())).single(Books.class).getEmbedding();
```


## Data in CDS Query Language (CQL)

This section shows examples using structured data in [CQL](../cds/cql) statements.

### Deep Inserts through Compositions and Cascading Associations

*Deep Inserts* create new target entities along compositions and associations that [cascade](./working-with-cql/query-execution#cascading-over-associations) the insert operation.
In this example an order with a header in status 'open' is created via a deep insert along the `header` composition.

```java
OrderHeaders header = OrderHeaders.create();
header.setId(11);
header.setStatus("open");

Orders order = Orders.create();
order.setId(1);
order.setHeader(header);

Insert insert = Insert.into(ORDERS).entry(order);
```

### Setting Managed Associations to Existing Target Entities

If you're using associations that don't cascade the insert and update operations, those associations can only be set to existing target entities.
The data is structured in the same way as in deep inserts, but the insert operation is *flat*, only the target values that are required to set the association are considered, all other target values are ignored:

```java
Authors author = Authors.create();
author.setId(100);

Books book = Books.create();
book.setId(101);
book.setAuthor(author);

Insert insert = Insert.into(BOOKS).entry(book);
```
::: tip
Set managed associations using the _association element_ and avoid using generated foreign key elements.
:::

### Inserts through Compositions via Paths

To insert via compositions, use paths in `into`. In the following example we add an order item to the set of items of the order 100:

```java
OrderItems orderItem = OrderItems.create();
orderItem.setId(1);
orderItem.putPath("book.ID", 201); // set association to book 201

Insert.into(ORDERS, o -> o.filter(o.Id().eq(100)).items())
      .entry(orderItem);
```
::: tip
Access child entities of a composition using a path expression from the parent entity instead of accessing the child entities directly.
:::

### Select Managed Associations

To select the mapping elements of a managed association, simply add the [association](./working-with-cql/query-api#managed-associations-on-the-select-list) to the select list:

```java
CqnSelect select = Select.from(BOOKS).byId(123)
                         .columns(b -> b.author());

Row row = persistence.run(select).single();

Integer authorId = row.getPath("author.ID");
```
::: tip
Don't select from and rely on compiler generated foreign key elements of managed associations.
:::

### Select with Paths in Matching

Paths are also supported in [matching](./working-with-cql/query-api#using-matching), for example, to select all *orders* that are in status *canceled*:

```java
Map<String, Object> order = new HashMap<>();
order.put("header.status", "canceled");

CqnSelect select = Select.from("bookshop.Orders").matching(order);
Result canceledOrders = persistence.run(select);
```

## Typed Access

Representing data given as `Map<String, Object>` is flexible and interoperable with other frameworks. But it also has some disadvantages:

* Names of elements are checked only at runtime
* No code completion in the IDE
* No type safety

To simplify the handling of data, CAP Java additionally provides _typed_ access to data through _accessor interfaces_:

Let's assume following data for a book:

```java
Map<String, Object> book = new HashMap<>();
book.put("ID", 97);
book.put("title", "Dracula");
```

You can now either define an accessor interface or use a [generated accessor interface](#generated-accessor-interfaces).
If you define an interface yourself, it could look like the following example:

```java
interface Books extends Map<String, Object> {
  @CdsName("ID")   // name of the CDS element
  Integer getID();

  String getTitle();
  void setTitle(String title);
}
```

### Struct

At runtime, the `Struct.access` method is used to create a [proxy](#cds-data) that gives typed access to the data through the accessor interface:

```java
import static com.sap.cds.Struct.access;
...

Books book = access(data).as(Books.class);

String title = book.getTitle();   // read the value of the element 'title' from the underlying map
book.setTitle("Miss Betty");      // update the element 'title' in the underlying map

title = data.get("title");        // direct access to the underlying map

title = book.get("title");        // hybrid access to the underlying map through the accessor interface
```

To support _hybrid_ access, like simultaneous typed _and_ generic access, the accessor interface just needs to extend `Map<String, Object>`.
::: tip
The name of the CDS element referred to by a getter or setter, is defined through `@CdsName` annotation. If the annotation is missing, it's determined by removing the get/set from the method name and lowercasing the first character.
:::

### Generated Accessor Interfaces {#generated-accessor-interfaces}

For all structured types of the CDS model, accessor interfaces can be generated using the [CDS Maven Plugin](./cqn-services/persistence-services#staticmodel). The generated accessor interfaces allow for hybrid access and easy serialization to JSON.

By default, the accessor interfaces provide the setter and getter methods inspired by the JavaBeans specification.

Following example uses accessor interfaces that have been generated with the default (JavaBeans) style:

```java
    Authors author = Authors.create();
    author.setName("Emily Brontë");

    Books book = Books.create();
    book.setAuthor(author);
    book.setTitle("Wuthering Heights");
```

Alternatively, you can generate accessor interfaces in _fluent style_. In this mode, the getter methods are named after the property names. To enable fluent chaining, the setter methods return the accessor interface itself.

Following is an example of the fluent style:

```java
   Authors author = Authors.create().name("Emily Brontë");
   Books.create().author(author).title("Wuthering Heights");
```

The generation mode is configured by the property [`<methodStyle>`](./assets/cds-maven-plugin-site/generate-mojo.html#methodstyle){target="_blank"} of the goal `cds:generate` provided by the CDS Maven Plugin. The selected `<methodStyle>` affects all entities and event contexts in your services. The default value is `BEAN`, which represents JavaBeans-style interfaces.

Once, when starting a project, decide on the style of the interfaces that is best for your team and project. We recommend the default JavaBeans style.

The way the interfaces are generated determines only how data is accessed by custom code. It does not affect how the data is represented in memory and handled by the CAP Java runtime.

Moreover, it doesn't change the way how event contexts and entities, delivered by CAP, look like. Such interfaces from CAP are always modelled in the default JavaBeans style.

#### Renaming Elements in Java

Element names used in the CDS model might conflict with reserved [Java keywords](https://docs.oracle.com/javase/specs/jls/se13/html/jls-3.html#jls-3.9) (`class`, `private`, `transient`, etc.). In this case, the `@cds.java.name` annotation must be used to specify an alternative property name that will be used for the generation of accessor interfaces and [static model](./cqn-services/persistence-services#staticmodel) interfaces. The element name used as key in the underlying map for [dynamic access](#entities-and-structured-types) isn't affected by this annotation.

See the following example:

```cds
entity Equity {
  @cds.java.name : 'clazz'
  class : String;
}
```

```java
interface Equity {

  @CdsName("class")
  String getClazz();

  @CdsName("class")
  void setClazz(String clazz);

}
```

#### Renaming Types in Java

For entities and types it is recommended to use `@cds.java.this.name` to specify an alternative name for the accessor interfaces and [static model](./cqn-services/persistence-services#staticmodel) interfaces.
The annotation `@cds.java.this.name` - in contrast to `@cds.java.name` - is not propagated, along projections, includes or from types to elements.

::: warning Unexpected effects of `@cds.java.name` on entities and types
The annotation propagation behaviour applied to `@cds.java.name` can have unexpected side effects when used to rename entities or types,
as it is propagated along projections, includes or from structured types to (flattened) elements. Nevertheless it might be useful in simple 1:1-projection scenarios,
where the base entity and the projected entity should be renamed in the same way.
:::

See the following example, renaming an entity:

```cds
@cds.java.this.name: 'Book'
entity Books {
  // ...
}
```

```java
@CdsName("Books")
public interface Book extends CdsData {
  // ...
}
```

Here is another example, renaming a type:

```cds
@cds.java.this.name: 'MyName'
type Name {
  firstName: String;
  lastName: String;
}

entity Person {
  publicName: Name;
  secretName: Name;
}
```

```java
@CdsName("Name")
public interface MyName extends CdsData {
  // ...
}

@CdsName("Person")
public interface Person extends CdsData {
  String PUBLIC_NAME = "publicName";
  String SECRET_NAME = "secretName";

  MyName getPublicName();
  void setPublicName(MyName publicName);

  MyName getSecretName();
  void setSecretName(MyName secretName);
}
```

::: details See how the previous example would turn out with `@cds.java.name`

```cds
@cds.java.name: 'MyName'
type Name {
  firstName: String;
  lastName: String;
}

entity Person {
  publicName: Name;
  secretName: Name;

}
```

```java
@CdsName("Name")
public interface MyName extends CdsData {
  // ...
}

@CdsName("Person")
public interface Person extends CdsData {
  String MY_NAME = "publicName";
  String MY_NAME = "secretName";

  MyName getMyName();
  void setMyName(MyName myName);

  MyName getMyName();
  void setMyName(MyName myName);
}
```

Note, that the propagated annotation `@cds.java.name` creates attribute and method conflicts in `Person`.

:::


::: warning
This feature requires version 8.2.0 of the [CDS Command Line Interface](/tools/cds-cli).
:::

#### Entity Inheritance in Java

In CDS models it is allowed to extend a definition (for example, of an entity) with one or more named [aspects](../cds/cdl#aspects). The aspect allows to define elements or annotations that are common to all extending definitions in one place.

This concept is similar to a template or include mechanism as the extending definitions can redefine the included elements, for example, to change their types or annotations. Therefore, Java inheritance cannot be used in all cases to mimic the [include mechanism](../cds/cdl#includes). Instead, to establish Java inheritance between the interfaces generated for an aspect and the interfaces generated for an extending definition, the `@cds.java.extends` annotation must be used. This feature comes with many limitations and does not promise support in all scenarios.

The `@cds.java.extends` annotation can contain an array of string values, each of which denote the fully qualified name of a CDS definition (typically an aspect) that is extended. In the following example, the Java accessor interface generated for the `AuthorManager` entity shall extend the accessor interface of the aspect `temporal` for which the Java accessor interface `cds.gen.Temporal` is generated.

```cds
using { temporal } from '@sap/cds/common';

@cds.java.extends: ['temporal']
entity AuthorManager : temporal {
  key ID : Integer;
  name   : String(30);
}
```

The accessor interface generated for the `AuthorManager` entity is shown in the following sample:

```java
import cds.gen.Temporal;
import com.sap.cds.CdsData;
import com.sap.cds.Struct;
import com.sap.cds.ql.CdsName;
import java.lang.Integer;
import java.lang.String;

@CdsName("AuthorManager")
public interface AuthorManager extends CdsData, Temporal {
  String ID = "ID";

  String NAME = "name";

  @CdsName(ID)
  Integer getId();

  @CdsName(ID)
  void setId(Integer id);

  String getName();

  void setName(String name);

  static AuthorManager create() {
    return Struct.create(AuthorManager.class);
  }
}
```

In CDS, annotations on an entity are propagated to views on that entity. If a view projects different elements, the inheritance relationship defined on the underlying entity via `@cds.java.extends` does not hold for the view. Therefore, the `@cds.java.extends` annotation needs to be overwritten in the view definition.
In the following example, a view with projection is defined on the `AuthorManager` entity and the inherited annotation overwritten via `@cds.java.extends : null` to avoid the accessor interface of `AuthorManagerService` to extend the interface generated for `temporal`.

```cds
service Catalogue {
  @cds.java.extends : null
  entity AuthorManagerService as projection on AuthorManager {
    Id, name, validFrom,
  };
}
```

::: warning
The `@cds.java.extends` annotation does not support extending another entity.
:::


### Creating a Data Container for an Interface

To create an empty data container for an interface, use the `Struct.create` method:

```java
import static com.sap.cds.Struct.create;
...

Book book = create(Book.class);

book.setTitle("Dracula");
String title = book.getTitle();   // title: "Dracula"
```

Generated accessor interfaces contain a static `create` method that further facilitates the usage:

```java
Book book = Books.create();

book.setTitle("Dracula");
String title = book.getTitle();   // title: "Dracula"
```

If the entity has a single key, the generated interface has an additional static `create` method that has the key as the argument. For example, given that the `Book` entity has key `ID` of type `String`, you can create the entity and set a key like that:

```java
Book book = Books.create("9780141439846");

String id = book.getId(); // id: "9780141439846"
```

For entities that have more than one key, for example, for draft-enabled entities, the additional `create` method isn't generated and only the default one is available.

### Read-Only Access

Create a typed read-only view using `access`. Calling a setter on the view throws an exception.

```java
import static com.sap.cds.Struct.access;
...

Book book = access(data).asReadOnly(Book.class);

String title = book.getTitle();
book.setTitle("CDS4j");           // throws Exception
```

### Typed Streaming of Data

Data given as `Iterable<Map<String, Object>>` can also be [streamed](https://docs.oracle.com/javase/8/docs/api/?java/util/stream/Stream.html):

```java
import static com.sap.cds.Struct.stream;
...

Stream<Book> books = stream(data).as(Book.class);

List<Book> bookList = books.collect(Collectors.toList());
```

### Typed Access to Query Results

Typed access through custom or generated accessor interfaces eases the [processing of query result](working-with-cql/query-execution#typed-result-processing).

## Data Processor { #cds-data-processor}

The `CdsDataProcessor` allows to process deeply nested maps of CDS data, by executing a sequence of registered actions (_validators_, _converters_, and _generators_).

Using the `create` method, a new instance of the `CdsDataProcessor` can be created:

```java
CdsDataProcessor processor = CdsDataProcessor.create();
```

_Validators_, _converters_, and _generators_ can be added using the respective `add` method, which takes a filter and an action as arguments and is executed when the `filter` is matching.

```java
processor.addValidator(filter, action);
```

When calling the `process` method of the `CdsDataProcessor`, the actions are executed sequentially in order of the registration.

```java
List<Map<String, Object>> data;  // data to be processed
CdsStructuredType rowType;       // row type of the data

processor.process(data, rowType);
```

The process method can also be used on CDS.ql results that have a row type:

```java
CqnSelect query; // some query
Result result = service.run(query);

processor.process(result);
```

### Element Filters

Filters can be defined as lambda expressions on `path`, `element`, and `type`, for instance:

```java
(path, element, type) -> element.isKey()
   && type.isSimpleType(CdsBaseType.STRING);
```
which matches key elements of type String.

- `path` describes the path from the structured root type of the data to the parent type of `element` and provides access to the data values of each path segment
- `element` is the CDS element
- `type`
  - for primitive elements the element's CDS type
  - for associations the association's target type
  - for arrayed elements the array's item type


### Data Validators

_Validators_ validate the values of CDS elements matching the filter. New _validators_ can be added using the `addValidator` method.
The following example adds a _validator_ that logs a warning if the CDS element `quantity` has a negative value. The warning message contains the `path` to the `element`.

```java
processor.addValidator(
   (path, element, type) -> element.getName().equals("quantity"), // filter
   (path, element, value) -> {                               // validator
      if ((int) value < 0) {
         log.warn("Negative quantity: " + path.toRef());
      }
   });
```

By default, validators are called if the data map _contains_ a value for an element. This can be changed via the _processing mode_, which can be set to:

- `CONTAINS` (default): The validator is called for declared elements for which the data map contains any value, including `null`.
- `NOT_NULL`: The validator is called for declared elements for which the data map contains a non-null value.
- `NULL`: The validator is called for declared elements for which the data map contains `null` or no value mapping, using `ABSENT` as a placeholder value.
- `DECLARED`: The validator is called for all declared elements, using `ABSENT` as a placeholder value for elements with no value mapping.

```java
processor.addValidator(
   (p, e, t) -> e.isNotNull(), // filter
   (p, e, v) -> { // validator
      throw new RuntimeException(e.getName() + " must not be null or absent");
   }, Mode.NULL);
```

### Data Converters

_Converters_ convert or remove values of CDS elements matching the filter and are only called if the data map contains a value for the element matching the filter. New _converters_ can be added using the `addConverter` method. The following example adds a _converter_ that formats elements with name `price`.

```java
processor.addConverter(
   (path, element, type)  -> element.getName().equals("price"), // filter
   (path, element, value) -> formatter.format(value));       // converter
```

To remove a value from the data, return `Converter.REMOVE`.
The following example adds a _converter_ that removes values of associations and compositions.

```java
processor.addConverter(
   (path, element, type)  -> element.getType().isAssociation(), // filter
   (path, element, value) -> Converter.REMOVE);                // remover
```

### Data Generators

_Generators_ generate the values for CDS elements matching the filter and are missing in the data or mapped to null.
New _generators_ can be added using the `addGenerator` method.
The following example adds a UUID generator for elements of type UUID that are missing in the data.

```java
processor.addGenerator(
   (path, element, type)   -> type.isSimpleType(UUID),       // filter
   (path, element, isNull) -> isNull ? null : randomUUID()); // generator
```

## Diff Processor

To react on changes in entity data, you need to compare the image of an entity after a certain operation with the image before the operation. To facilitate this task, use the [`CdsDiffProcessor`](https://www.javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/CdsDiffProcessor.html), similar to the [Data Processor](/java/cds-data#cds-data-processor). The Diff Processor traverses through two images (entity data maps) and allows to register handlers that react on changed values.

Create an instance of the `CdsDiffProcessor` using the `create()` method:

```java
CdsDiffProcessor diff = CdsDiffProcessor.create();
```

You can compare the data represented as [structured data](/java/cds-data#structured-data), which is a result of the CQN statements or arguments of event handlers. For a comparison with the `CdsDiffProcessor`, the data maps that are compared need to adhere to the following requirements:

- The data map must include values for all key elements.
- The names in the data map must match the elements of the entity.
- Associations must be represented as [nested structures and associations](/java/cds-data#nested-structures-and-associations) according to the associations` cardinalities.

The [delta representation](/java/working-with-cql/query-api#deep-update-delta) of collections is also supported.
Results of the CQN statements fulfill these conditions if the type [that comes with the result](/java/working-with-cql/query-execution#introspecting-the-row-type) is used, not the entity type.

To run the comparison, call the `process()` method and provide the new and old image of the data as a `Map` (or a collection of them) and the type of the compared entity:

```java
List<Map<String, Object>> newImage;
List<Map<String, Object>> oldImage;
CdsStructuredType type;

diff.process(newImage, oldImage, type);
```

```java
Result newImage = service.run(Select.from(...));
Result oldImage = service.run(Select.from(...));

diff.process(newImage, oldImage, newImage.rowType());
```

:::tip Comparing draft-enabled entities
If you compare the active image of a draft-enabled entity with the inactive one, make sure that the `IsActiveEntity` values are either absent or the same in both images.
:::

In case one of the images is empty, the `CdsDiffProcessor` traverses through the existing image treating it as an addition or removal mirroring the logic accordingly.

Changes detected by `CdsDiffProcessor` are reported to one or more visitors implementing the interface [`CdsDiffProcessor.DiffVisitor`](https://www.javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/CdsDiffProcessor.DiffVisitor.html).

The visitor is added to `CdsDiffProcessor` with the `add()` method before starting the processing.

```java
diff.add(new DiffVisitor() {
  @Override
  public void changed(Path newPath, Path oldPath, CdsElement element, Object newValue, Object oldValue) {
      // changes
  }

  @Override
  public void added(Path newPath, Path oldPath, CdsElement association, Map<String, Object> newValue) {
      // additions
  }

  @Override
  public void removed(Path newPath, Path oldPath, CdsElement association, Map<String, Object> oldValue) {
      // removals
  }
});
```

The visitor can be added together with the [element filter](/java/cds-data#element-filters) that limits the subset of changes reported to the visitor.

```java
diff.add(
  new Filter() {
    @Override
    public boolean test(Path path, CdsElement element, CdsType type) {
        return true;
    }
  },
  new DiffVisitor() {
    ...
  }
);
```

You may add as many visitors as you need by chaining the `add()` calls.
Each instance of the `CdsDiffProcessor` can have its own set of visitors added to it.

If your visitors need to be stateful, prefer one-time disposable objects for them. `CdsDiffProcessor` does not manage their state.

All values are compared using the standard Java `equals()` method, including elements with a structured or arrayed type.

### Implementing a DiffVisitor

Additions and removals in the entity image are reported as calls to the methods `added()` or `removed()`.
The called methods always receive the complete added or removed content for the entity or an association.

The methods `added()` and `removed()` have the following arguments:

- `newPath` and the `oldPath` as instances of [`Path`](https://www.javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/cqn/Path.html) reflecting the new and old image of the entity.
- `association` as an instance of [`CdsElement`](https://www.javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/reflect/CdsElement.html) given that the association is present.
- Changed data as a `Map`, as either the `newValue` or `oldValue`.

The instances of the `Path` represent the placement of the changed item within the whole entity as a prefix to the data that is either added or removed. While these paths always have the same structure, `oldPath` and `newPath` can have empty values, which represent the absence of data.

The `association` value for `added()` and `removed()` is only provided if data is compared along associations or compositions. Null value represents the complete entity that is added or removed.

Let's break it down with the examples:

Given that we have a collection of books each has a composition of many editions.

+ When a new book is added to the collection, the method `added()` is called once with the `Path` instance with one segment representing a book as the `newPath`, `association` will be null and the `newValue` will also be the content of the book.

  Old image (primary keys are omitted for brevity) of the book collection is:
  ```json
    [
      {
        "title": "Wuthering Heights",
        "editions": []
      }
    ]
  ```
  New image of the book collection is:
  ```json
    [
      {
        "title": "Wuthering Heights",
        "editions": []
      },
      {
        "title": "Catweazle",
        "editions": []
      }
    ]
  ```
  The content of the entity that visitor will observe in the `added()` method as `newValue`:
  ```json
    {
      "title": "Catweazle",
      "editions": []
    }
  ```
  `association` is null in this exact case.

+ When new editions are added to two of the books in the collection, one per each book, the method `added()` is called twice with the `Path` instance with two segments representing the book and the association to the edition. The association element is the value of the argument `association`, the data of the edition is the `newValue`. In this case, each added edition is accompanied by the content of the respective book.

  Old image of the book collection is:
  ```json
    [
      {
        "title": "Wuthering Heights",
        "editions": []
      },
      {
        "title": "Catweazle",
        "editions": []
      }
    ]
  ```

  New image of the book collection is:
  ```json
    [
      {
      "title": "Wuthering Heights",
        "editions": [
          {
            "title": "Wuthering Heights: 100th Anniversary Edition"
          }
        ]
      },
      {
        "title": "Catweazle",
        "editions": [
          {
            "title": "Catweazle: Director's Cut"
          }
        ]
      }
    ]
  ```
  In the first `added()` call, the first added edition will be available and the paths will have the first book as the root.

  ```json
  {
    "title": "Wuthering Heights: 100th Anniversary Edition"
  }
  ```

  In the second call - the second added edition with the second book as the root of the path.

  ```json
  {
    "title": "Catweazle: Director's Cut"
  }
  ```

+ Given the previous example, there are two new editions added to one of the books: the `added()` method will be called once per edition added. Path instances with same book (same primary key) tell you which edition belongs to which book.

  Old image is the same as before, new image of the book collection is:
  ```json
    [
      {
        "title": "Wuthering Heights",
        "editions": [
          {
            "title": "Wuthering Heights: 100th Anniversary Edition"
          }
        ]
      },
      {
        "title": "Catweazle",
        "editions": [
          {
            "title": "Catweazle: Director's Cut"
          },
          {
            "title": "Catweazle: Complete with Extras"
          }
        ]
      }
    ]
  ```

  First `added()` call will observe the new edition of the first book:

  ```json
  {
    "title": "Wuthering Heights: 100th Anniversary Edition"
  }
  ```

  The following two calls will observe each added edition of the second book:
  ```json
  {
    "title": "Catweazle: Director's Cut"
  }
  ```

  ```json
  {
    "title": "Catweazle: Complete with Extras"
  }
  ```

Method `changed()` is called for each change in the element values and has the following arguments:

- A pair of `Path` instances (`newPath` and `oldPath`) reflecting the new and old data of the entity.
- The changed element as an instance of [`CdsElement`](https://www.javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/reflect/CdsElement.html).
- The new and old value as `Object` instances.

Paths have the same target, that is, the entity where changed element is. But their values represent the old and new image of the entity as a whole including non-changed elements.
You may expect that each change is visited at most once.

Let's break it down with the examples:

Given the collection of books with editions, as before.

  ```json
    [
      {
        "title": "Wuthering Heights",
        "editions": [
          {
            "title": "Wuthering Heights: 100th Anniversary Edition"
          }
        ]
      },
      {
        "title": "Catweazle",
        "editions": [
          {
            "title": "Catweazle: Director's Cut"
          }
        ]
      }
    ]
  ```

+ When book title is changed from one value to the other, the method `changed()` is called once with both `Path` instances representing a book images, element `title` is available as an instance of `CdsElement`, the new and old value of the title are available as `newValue` and `oldValue`.

  New image:
  ```json
    [
      {
        "title": "Wuthering Heights",
        "editions": [
          {
            "title": "Wuthering Heights: 100th Anniversary Edition"
          }
        ]
      },
      {
        "title": "Catweazle, the series",
        "editions": [
          {
            "title": "Catweazle: Director's Cut"
          }
        ]
      }
    ]
  ```

  The Diff Visitor will observe the `Catweazle, the series` and `Catweazle` as the new and the old value.

+ When title of the edition is changed for one of the books, the `changed()` method is called once, the paths include the book and the edition. Element reference and values are set accordingly.

  New image:
  ```json
    [
      {
        "title": "Wuthering Heights",
        "editions": [
            {
              "title": "Wuthering Heights: 100th Anniversary Edition"
            }
        ]
      },
      {
        "title": "Catweazle",
        "editions": [
          {
            "title": "Catweazle: Unabridged"
          }
        ]
      }
    ]
  ```

  Visitor will observe the `Catweazle: Unabridged` and `Catweazle: Director's Cut` as the new and the old value.

For changes in the associations, when association data is present in both images, even if key values are different, the `change()` method
will always be called for the content of the association traversing it value-by-value. In case data is absent in one of them, the `added()` or `removed()` will be called instead.

Several visitors added to the `CdsDiffProcessor` are called one by one, but you should not expect the guaranteed order of the calls for them. Consider them as an independent.

:::danger Immutable data
Do not modify the state of the images inside the visitors. Consider the data presented to it immutable.
:::

### Filtering for DiffVisitor

Element filters are useful if you want to extract some common condition out of your visitor implementation so that you don't have to branch in all methods of your visitor.

As a general rule, you may assume that element filter is called at least once for each changed value you have in your
image and the visitor supplied next to the filter is called for elements where the element filter condition is evaluated to `true`.

In the implementation of the filter you can use the definition of the
[`CdsElement`](https://www.javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/reflect/CdsElement.html), its type
or a [`Path`](https://www.javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/cqn/Path.html) to decide if you want your visitor to be notified about the detected change.

In simple cases, you may use the element and its type to limit the visitor so that it observes only elements having a certain annotation
or having a certain common type, for example, only numbers.

If you compare a collection of books to find out of there is a differences in it, but you are only interested in authors, you can write a filter using the entity
type that is either the target of some association or the parent of the current element.

```java
diff.add(new Filter() {
  @Override
  public boolean test(Path path, CdsElement element, CdsType type) {
    return element.getType().isAssociation()
            && element.getType().as(CdsAssociationType.class).getTarget().getQualifiedName().equals(Authors_.CDS_NAME)
            || path.target().type().equals(Authors_.CDS_NAME);
  }
}, ...);
```

Filters cannot limit the nature of the changes your visitor will observe and are always positive.

### Deep Traversal {#cds-diff-processor-deep-traversal}

For documents that have a lot of associations or a compositions and are changed in a deep way you might want to see additions for each level separately.

To enable this, you create an instance of `CdsDiffProcessor` like that:

```java
CdsDiffProcessor diff = CdsDiffProcessor.create().forDeepTraversal();
```

In this mode, the methods `added()` and `removed()` are called not only for the root of the added or removed data, but also traverse the added or removed data, entity by entity.

It's useful, when you want to track the additions and removals of certain entities on the leaf levels or as part of visitors tailored for generic use cases.

## Media Type Processing { #mediatypeprocessing}

The data for [media type entity properties](../guides/providing-services#serving-media-data) (annotated with `@Core.MediaType`) - as with any other CDS property with primitive type - can be retrieved by their CDS name from the [entity data argument](./event-handlers/#pojoarguments). See also [Structured Data](#structured-data) and [Typed Access](#typed-access) for more details. The Java data type for such byte-based properties is `InputStream`, and for character-based properties it is `Reader` (see also [Predefined Types](#predefined-types)).

Processing such elements within a custom event handler requires some care though, as such an `InputStream` or `Reader` is *non-resettable*. That means, the data can only be read once. This has some implications you must be aware of, depending on what you want to do.

Let's assume we have the following CDS model:

```cds
entity Books : cuid, managed {
  title         : String(111);
  descr         : String(1111);
  coverImage    : LargeBinary @Core.MediaType: 'image/png';
}
```

When working with media types, we can differentiate upload and download scenarios. Both have their own specifics on how we can deal with the stream.

### No Custom Processing

#### Media Upload

If you just want to pass the uploaded stream to the persistence layer of the CAP architecture to have the data written into the database, you don't have to implement any custom handler. This is the simplest scenario and our default `On` handler already takes care of that for you.

#### Media Download

For the download scenario, as well, you don't need to implement any custom handler logic. The default `On` handler reads from the database and passes the stream to the client that requested the media type element.

### Custom Processing

#### Media Upload

If you want to override the default logic to process the uploaded stream with custom logic (for example, to parse a stream of CSV data), the best place to do that is in a custom `On` handler, as the following examples shows:

```java
@On(event = CqnService.EVENT_UPDATE)
public void processCoverImage(CdsUpdateEventContext context, List<Books> books) {
	books.forEach(book -> {
		InputStream is = book.getCoverImage();
		// ... your custom code fully consuming the input stream
	});
	context.setResult(books);
}
```
::: warning
After you have fully consumed the stream in your handler logic, passing the same `InputStream` or `Reader` instance for further consumption would result in no bytes returned, because a *non-resettable* stream can only be consumed once. In particular, make sure that the default `On` handler is not called after your custom processing.
:::

Using a custom `On` handler and setting `context.setResult(books)` prevents the execution of the default `On` handler.

#### Media Download

The previous described approach is only useful when uploading data. If you need custom processing for media downloads, have a look at the approach using a stream proxy described below.



### Pre- or Post-Processing Using a Stream Proxy

The following sections describe how to pre-process an uploaded stream of data before it gets persisted or how to post-process a downloaded stream of data before it's handed over to the client. For example, this is useful if you want to send uploaded data to a virus scanner, before persisting it on the database.

This requires that the stream is consumed by several parties (for example, the virus scanner and the persistence layer). To achieve this, implement a proxy that wraps the original `InputStream` or `Reader` instance and executes the processing logic within the `read()` methods on the data read directly. Such a proxy can be implemented by extending a [FilterInputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/FilterInputStream.html), a [ProxyInputStream](https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/input/ProxyInputStream.html), a [FilterReader](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/FilterReader.html) or a [ProxyReader](https://commons.apache.org/proper/commons-io/apidocs/org/apache/commons/io/input/ProxyReader.html).

The following example uses a [FilterInputStream](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/io/FilterInputStream.html):

```java
public class CoverImagePreProcessor extends FilterInputStream {

	public CoverImagePreProcessor(InputStream wrapped) {
		super(wrapped);
	}

	@Override
	public int read() throws IOException {
		int nextByte = super.read();

		// ... your custom processing code on nextByte

		return nextByte;
	}

	@Override
	public int read(byte[] bts, int off, int len) throws IOException {
		int bytesRead = super.read(bts, off, len);

		// ... your custom processing code on bts array

		return bytesRead;
	}
}
```

This proxy is then used to wrap the original `InputStream`. This works for both upload and download scenarios.

#### Media Upload

For uploads, you can either use a custom `Before` or `On` handler to wrap the proxy implementation around the original stream before passing it to its final destination.

Using a custom `Before` handler makes sense if the stream's final destination is the persistence layer of the CAP Java SDK, which writes the content to the database. Note that the pre-processing logic in this example is implemented in the `read()` methods of the `FilterInputStream` and is only called when the data is streamed, during the `On` phase of the request:

```java
@Before(event = CqnService.EVENT_UPDATE)
public void preProcessCoverImage(CdsUpdateEventContext context, List<Books> books) {
	books.forEach(book -> {
		book.setCoverImage(new CoverImagePreProcessor(book.getCoverImage()));
	});
}
```

The original `InputStream` is replaced by the proxy implementation in the `coverImage` element of the `book` entity and passed along. Every further code trying to access the `coverImage` element will use the proxy implementation instead.

Using a custom `On` handler makes sense if you want to prevent that the default `On` handler is executed and to control the final destination for the stream. You then have the option to pass the streamed data on to some other service for persistence:

```java
@On(event = CqnService.EVENT_UPDATE)
public Result processCoverImage(CdsUpdateEventContext context, List<Books> books) {
	books.forEach(book -> {
		book.setCoverImage(new CoverImagePreProcessor(book.getCoverImage()));
	});

	// example for invoking some CQN-based service
	return service.run(Update.entity(Books_.CDS_NAME).entries(books));
}
```

#### Media Download

For download scenarios, the stream to wrap is only available in `After` handlers as shown in this example:

```java
@After(event = CdsService.EVENT_READ)
public void preProcessCoverImage(CdsReadEventContext context, List<Books> books) {
	books.forEach(book -> {
		book.setCoverImage(new CoverImagePreProcessor(book.getCoverImage()));
	});
}
```

### Reminder

::: tip _Be aware_ 
in which event phase you do the actual consumption of the `InputStream` or `Reader` instance that is passed around. Once fully consumed, it can no longer be read from in remaining event phases.
:::



# Working with CDS CQL

Learn here about working with CDS CQL.



<IndexList :pages='pages' />



# Building CQL Statements


API to fluently build [CQL](../../cds/cql) statements in Java.

## Introduction

The [CDS Query Language (CQL)](../../cds/cql) statement builders allow to fluently construct [CQL](../../cds/cql) statements, which can be [executed](query-execution) by [CDS Services](../cqn-services/#cdsservices).

## Concepts

### The CQL Statement Builders

Use the builder classes `Select`, `Insert`, `Upsert`, `Update`, and `Delete` to construct [CQL](../../cds/cql) statements.
The following example shows a [CQL](../../cds/cql) query and how it's constructed with the `Select` builder:

```sql
-- CQL
SELECT from bookshop.Books { title } where ID = 101
```

```java
// Java CQL (dynamic)
Select.from("bookshop.Books").columns("title").byId(101);
```

Instead of using strings to refer to CDS entities and elements, you can also build statements using constants and interfaces [generated](../cqn-services/persistence-services#staticmodel) from the CDS model:

```java
import static bookshop.Bookshop_.BOOKS;

// Java CQL (static)
Select.from(BOOKS).columns(b -> b.title()).byId(101);
```

Using the static model has several advantages:

* The names of entities and elements are checked at design time.
* Use code completion in the IDE.
* Predicates and expressions can be composed in a type-safe way.
* More compact code.
::: tip
In general, it's recommended to use the static style when implementing business logic that requires accessing particular elements of entities. Using the dynamic style is appropriate for generic code.
:::

### Lambda Expressions

To construct complex statements, the [CQL](../../cds/cql) builders leverage [lambda expressions](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html) to fluently compose [expressions](#expressions) and [path expressions](#path-expressions) that are used in the statements' clauses.

```sql
-- CQL
SELECT from bookshop.Books { title } where year < 2000
```

```java
// Java CQL
Select.from(BOOKS)
    .columns(b -> b.title().as("Book"))
    .where(b -> b.year().lt(2000));
```

Here, the lambda expression `b -> b.title().as("Book")` references the element `title` of the entity Book `b` under the alias 'Book'. This aliased reference is put on the query's [select list](#projections) using the `columns` method.

The lambda expression `b -> b.year().lt(2000)` defines a predicate that compares the book's element `year` with the value 2000, which is then used to define the [where clause](#where-clause) of the select statement.

### Path Expressions

Use path expressions to access elements of [related](../../cds/cdl#associations) entities. The following example selects books with authors starting with 'A'.

```java
// Java CQL (static)
Select.from(BOOKS)
    .columns(b -> b.title(), b -> b.author().name().as("author"))
    .where(b -> b.author().name().startsWith("A"));

// Java CQL (dynamic)
Select.from("bookshop.Books")
    .columns(b -> b.get("title"), b -> b.get("author.name").as("author"))
    .where(b -> b.to("author").get("name").startsWith("A"));
```

The CQL query accesses the `name` element of the `Authors` entity, which is reached from `Books` via the `author` [association](../../cds/cdl#associations). In the dynamic CQL builders, you can follow associations and compositions using the `to` method or use `get` with a path using a dot to separate the segments.

### Target Entity Sets {#target-entity-sets}

All [CDS Query Language (CQL)](/cds/cql) statements operate on a _target entity set_, which is specified via the `from`, `into`, and `entity` methods of `Select`/`Delete`, `Insert`/`Upsert`, and `Update` statements.

In the simplest case, the target entity set identifies a complete CDS entity set:

```java
import static bookshop.Bookshop_.BOOKS;

// static
Select.from(BOOKS);

// dynamic
Insert.into("bookshop.Books").entry(book);

Update.entity("bookshop.Authors").data(author);
```

The _target entity set_ can also be defined by an [entity reference](#entity-refs), which allows using paths over associations and _infix filters_. Entity references can be defined inline using lambda expressions.

```sql
-- CQL
SELECT from Orders[3].items { quantity, book.title as book }
```

```java
// Java CQL
Select.from(ORDERS, o -> o.filter(o.id().eq(3)).items())
    .columns(i -> i.quantity(),
             i -> i.book().title().as("book"));
```

The _target entity set_ in the query is defined by the entity reference in the from clause. The reference targets the `items` of the `Order` with ID 3 via an _infix filter_. From this target entity set (of type `OrderItems`), the query selects the `quantity` and the `title` of the `book`. Infix filters can be defined on any path segment using the `filter` method, which overwrites any existing filter on the path segment. Defining an infix filter on the last path segment is equivalent to adding the filter via the statement's `where` method. However, inside infix filters, path expressions are not supported.

In the [CDS Query Language (CQL)](/cds/cql) builder, the lambda expression `o -> o.filter(o.id().eq(3)).items()` is evaluated relative to the root entity `Orders` (o). All lambda expressions that occur in the other clauses of the query are relative to the target entity set `OrderItems`, for example, `i -> i.quantity()` accesses the element `quantity` of `OrderItems`.
::: tip
To target components of a structured document, we recommend using path expressions with infix filters.
:::


### Filters {#target-entity-filters}

Besides using infix filters in path expressions, the `Select`, `Update`, and `Delete` builders support filtering the [target entity set](#target-entity-sets) via the `where` method. Using `where` is equivalent to defining an infix filter on the last segment of a path expression in the statement's `from` / `entity` clause. For statements that have both, an infix filter on the last path segment and a `where` filter, the resulting target filter is the conjunction (`and`) of the infix filter and the `where` filter.
For simple filters, you can use `byId`, `matching`, or `byParams` as an alternative to `where`. All of these filter methods overwrite existing filters, except for infix filters.


#### Using `where` {#concepts-where-clause}

Using the `where` method, you can define complex predicate [expressions](#expressions) to compose the filter:

```java
Select.from(BOOKS)
   .where(b -> b.author().name().eq("Twain")
     .and(b.title().startsWith("A").or(b.title().endsWith("Z"))));
```

#### Using `byID`

To find an entity with a single key element via its key value, you can use the `byId` method. The following example retrieves the `Author` entity with key 101.

```java
Select.from("bookshop.Authors").byId(101);
```
::: tip
The `byId` method isn't supported for entities with compound keys.
:::

#### Using `matching`

`matching` is a query-by-example style alternative to define the `where` clause. This method adds a predicate to the query that filters out all entities where the elements' values are equal to values given by a key-value filter map. The filter map can contain path keys, referring to elements of an associated entity. In the following example, `bookshop.Books` has a to-one association to the `Author` entity and the path `author.name` refers to the name element within the `Author` entity.

```java
Map<String, Object> filter = new HashMap<>();
filter.put("author.name", "Edgar Allen Poe");
filter.put("stock", 0);

Select.from("bookshop.Books").matching(filter);
```

#### Using `byParams`

`byParams` simplifies filtering by parameters as an alternative to `where` and `CQL.param`:

```java
import static bookshop.Bookshop_.BOOKS;

// using where
Select.from(BOOKS)
    .where(b -> b.title().eq(param("title"))
           .and(b.author().name().eq(param("author.name"))));

// using byParams
Select.from(BOOKS).byParams("title", "author.name");
```

### Parameters

The [CQL](../../cds/cql) builders support [parameters](#expr-param) in the `where` clause and in infix filters for [parameterized execution](query-execution#parameterized-execution):

The following example selects the books of the `Author` with name 'Jules Verne'.

```java
import static com.sap.cds.ql.CQL.param;

CqnSelect q = Select.from(BOOKS).where(b -> b.author().name().eq(param(0)));
dataStore.execute(q, "Jules Verne");
```

As an alternative, the where clauses can be constructed using the `byParams` method.

```java
CqnSelect q = Select.from(BOOKS).byParams("author.name");
dataStore.execute(q, singletonMap("author.name", "Jules Verne"));
```

Parameterized infix filters can be constructed using the `filterByParams` method. Path expressions are not supported.
The following example selects the books of the `Author` with ID 101.

```java
CqnSelect q = Select.from(AUTHORS, o -> o.filterByParams("ID").books());
dataStore.execute(q, singletonMap("ID", 101));
```

### Constant and Non-Constant Literal Values

In addition to parameters, the [CQL](../../cds/cql) builders also support literal values, which are already known at design time. These can be constructed using `CQL.constant()`  for constant literals and `CQL.val()` for non-constant literals:

```java
import static com.sap.cds.ql.CQL.val;

Select.from(BOOKS).columns(b -> b.title(), val("available").as("status"))
	.where(b -> b.stock().gt(0));
```

In case your application runs against a SQL datastore, for example SAP HANA, the CDS runtime takes literal values constructed with `CQL.val(value)` as a hint to bind the value to a parameter marker. The binding is handled implicitly and not explicitly as with `CQL.param()`.

The `CQL.constant(value)` method gives the hint that the literal value should be handled as a constant. For SQL datastores this means that the value is rendered directly into the SQL statement.

```java
import static com.sap.cds.ql.CQL.constant;

Select.from(BOOKS).columns(b -> b.title())
	.where(b -> b.cover().eq(constant("paperback")));
```

It strongly depends on your application's domain model and business logic, which one of the methods is to be preferred. As a rule of thumb:

* Use `val()` for values that change at runtime or depend on external input.
* Only use `constant()` for values that don't change at runtime and _don't depend on external input_.

With constant literals directly rendered into the statement, a SQL datastore has better options optimizing the statement. On the other hand, using constant literals limits the data store's options to cache statements.
::: warning
Constant literals are directly rendered into SQL and therefore **must not** contain external input!
:::

## Select

### Source

The source of the select statement determines the data set to which the query is applied. It's specified by the `from` method.

#### `FROM` Entity Set {#from-entity-set}

Typically a select statement selects from an [entity set](#target-entity-sets):

```sql
--CQL query
SELECT from bookshop.Books { title, author.name }
```

```java
// Query Builder API (dynamic usage)

CqnSelect query = Select.from("bookshop.Books")
    .columns("title", "author.name");
```

#### `FROM` Reference {#from-reference}

The source can also be defined by a [path expression](#path-expressions) referencing an entity set.

This query selects from the items of the order 23.

```sql
--CQL query
SELECT from Orders[ID = 23]:items
```

```java
// Query Builder API (static usage)
import static bookshop.Bookshop_.ORDERS;

Select.from(ORDERS, o -> o.filter(o.ID().eq(23)).items());
```

#### `FROM` Subquery {#from-select}

It's also possible to execute a nested select where an _outer_ query operates on the result of a _subquery_.

```sql
--CQL query
SELECT from (SELECT from Authors order by age asc limit 10) order by name
```

```java
// Query Builder API
CqnSelect youngestAuthors = Select.from(AUTHORS).orderBy(a -> age()).limit(10);
Select.from(youngestAuthors).orderBy("name");
```

This subquery selects the youngest authors, which the outer query [sorts](#ordering-and-pagination) by name.

Limitations:
* The subquery must not expand [to-many associations](../../cds/cdl#to-many-associations).
* The outer query can only be defined with the dynamic builder style.


### Projections {#projections}

By default, `Select` statements return all elements of the target entity. You can change this by defining a projection
via the `columns` method of the `Select` builder. Elements can be addressed via their name, including path expressions such as _author.name_:

```java
CqnSelect query = Select.from("bookshop.Books")
    .columns("title", "author.name");
```

To define more complex projections and benefit from code completion, use lambda expressions:

```java
// dynamic
Select.from("bookshop.Books")
    .columns(b -> b.get("title"),
             b -> b.get("author.name").as("authorName"));
```

```java
// static
import static bookshop.Bookshop_.BOOKS;

Select.from(BOOKS)
    .columns(b -> b.title(),
             b -> b.author().name().as("authorName"));
```

The path expression `b.author().name()` is automatically evaluated at runtime. For an SQL data store, it's converted to a LEFT OUTER join.

#### Deep Read with `expand` {#expand}

Use `expand` to read deeply structured documents and entity graphs into a structured result.

```java
// Java example
// using expand
import static bookshop.Bookshop_.AUTHORS;

Select.from(AUTHORS)
    .columns(a -> a.name().as("author"),
             a -> a.books().expand(
                      b -> b.title().as("book"),
                      b -> b.year()));
```

It expands the elements `title`, and `year` of the `Books` entity into a substructure with the name of the association `books`:

```json
[
  {
    "author" : "Bram Stoker",
    "books" :
    [
      {
        "title" : "Dracula",
        "year" : 1897
      },
      {
        "title" : "Miss Betty",
        "year" : 1898
      }
    ]
  }, ...
]
```

<span id="indeepread" />
<Fragment target="#indeepread">

::: info <Beta />

See, how this query can be expressed in CQL using [nested expands](/cds/cql#nested-expands):

```sql
-- CQL example
-- using expand
SELECT from Authors { name as author, books { title as book, year } }
```

:::

</Fragment>

To only expand entities that fulfill a certain condition, use [infix filters](#target-entity-sets) on the association:

```java
Select.from(AUTHORS)
    .columns(a -> a.name(),
             a -> a.books()
                   .filter(b -> b.year().eq(1897))
                   .expand(b -> b.title()))
    .where(a -> name().in("Bram Stroker", "Edgar Allen Poe"));
```

This query expands only books that were written in 1897:

```json
[
  {
    "name" : "Bram Stoker",
    "books" : [ { "title" : "Dracula" } ]
  },
  {
    "name" : "Edgar Allen Poe",
    "books" : [ ]
  }
]
```

Expands can be nested and have an alias, for example, to further expand the publisher names of the author's books:

```java
Select.from(AUTHORS)
    .columns(a -> a.name(),
             a -> a.books().as("novels").expand(
                      b -> b.title(),
                      b -> b.publisher().expand(p -> p.name())));
```

Which returns a deeply structured result:

```json
[
  {
    "name" : "Bram Stoker",
    "novels" :
    [
      {
        "title" : "Dracula",
        "publisher" : { "name": "Constable" }
      }, ...
    ]
  }, ...
]
```

To expand all non-association elements of an associated entity, use the `expand()` method without parameters after the association you want to expand.
For example, the following query expands _all_ elements of the book's author:

```java
Select.from(BOOKS)
      .columns(b -> b.title(),
               b -> b.author().expand());
```

To expand all first level associations of an entity, use `expand()` on the entity level:

```java
Select.from(BOOKS).columns(b -> b.expand());
```

::: warning Don't use distinct together with expand
The `distinct` clause removes duplicate rows from the root entity and effectively aggregates rows. Expanding child entities from aggregated rows is not well-defined and can lead to issues that can be resolved by removing distinct.
:::

::: tip Resolving duplicates in to-many expands
Duplicates in to-many expands can occur on associations that are mapped as many-to-many without using a [link entity](../../guides/domain-modeling#many-to-many-associations) and don't correctly define the source cardinality. This can be resolved by adding the cardinality in the CDS model: `Association [*,*] to Entity`.
:::

##### Optimized Expand Execution {#expand-optimization}

For *to-one expands*:
- The expand item list mustn't contain any literal value.
- The expand item list mustn't contain expression.

For *to-many expands*:
- The `on` condition of the association must only use equality predicates and conjunction (`AND`).
- The `from` clause isn't a [subquery](#from-select).
- The `where` clause doesn't contain [path expressions](#path-expressions).
- The query doesn't use [groupBy](#group-by) or `distinct`.
- The `columns`/`items` clause must contain at least one [element reference](#element-references).

In case the default query optimization leads to issues, annotate the association with
`@cds.java.expand: {using: 'parent-keys'}` to fall back to the unoptimized expand execution
and make sure the parent entity has all key elements exposed.

#### Flattened Results with `inline` {#inline}

To flatten deeply structured documents or include elements of associated entities into a flat result,
you can use `inline` as a short notation for using multiple paths.

```java
// Java example
import static bookshop.Bookshop_.AUTHORS;

// using multiple path expressions
Select.from(AUTHORS)
    .columns(a -> a.name(),
             a -> a.books().title().as("book"),
             a -> a.books().year());

// using inline
Select.from(AUTHORS)
    .columns(a -> a.name(),
             a -> a.books().inline(
                      b -> b.title().as("book"),
                      b -> b.year()));
```

Both queries are equivalent and have the same result: a _flat_ structure:

```json
[
  {
    "name" : "Bram Stoker",
    "book" : "Dracula",
    "year" : 1897
  },
  {
    "name" : "Bram Stoker",
    "book" : "Miss Betty",
    "year" : 1898
  }
]
```

<span id="inflattenedresults" />
<Fragment target="#inflattenedresults">

::: info <Beta />

See, how these queries can be expressed in CQL using [nested inlines](/cds/cql#nested-inlines):

```sql
-- CQL example
-- using multiple path expressions
SELECT from Authors { name, books.title as book, books.year }

-- using inline
SELECT from Authors { name, books.{ title as book, year } }
```

:::

</Fragment>

#### Managed Associations on the Select List

To select the key elements of a [managed to-one association](../../cds/cdl#managed-associations)'s target entity, simply put the association on the select list. This will return the target key elements as structured result:

```java
// dynamic
Select.from("bookshop.Books")
      .columns(b -> b.get("author"));

// static
import static bookshop.Bookshop_.BOOKS;

CqnSelect q = Select.from(BOOKS)
    .columns(b -> b.author());

Row book = dataStore.execute(q).single();
Object authorId = book.get("author.Id"); // path access
```

::: tip
Only to-one associations that are mapped via the primary key elements of the target entity are supported on the select list. The execution is optimized and gives no guarantee that the target entity exists, if this is required use expand or enable [integrity constraints](../../guides/databases#database-constraints) on the database.
:::


### Filtering and Searching { #filtering}

The `Select` builder supports [filtering](#target-entity-filters) the target entity set via `where`, `byId`, `matching` and `byParams`. In contrast to infix filters, `where` filters of `Select` statements support path expressions. Additionally, `Select` supports `search` clauses.

The `search` method adds a predicate to the query that filters out all entities where any searchable element contains a given [search term](#search-term) or matches a [search expression](#search-expression).

1. Define searchable elements {#searchable-elements}

By default all elements of type `cds.String` of an entity are searchable. However, using the `@cds.search` annotation the set of elements to be searched can be defined. You can extend the search also to associated entities. For more information on `@cds.search`, refer to [Search Capabilities](../../guides/providing-services#searching-data).

Consider following CDS Entity. There are two elements, `title` and `name`, of type String, making them both searchable by default.

```cds
entity Book {
  key ID : Integer;
  name   : String;
  title  : String;
}
```
In the following example, element `title` is included in `@cds.search`. Only this particular element is searchable then.

```cds
@cds.search: {title}
entity Book {
  key ID : Integer;
  name   : String;
  title  : String;
}
```

<div id="infilteringandsearching" />
<Fragment target="#infilteringandsearching">

  In addition to a shallow search (where the search is done on the `target entity set`) you can also perform search over associated entities.

  Let's consider a CDS model that is more complex. It consists of 2 entities and an association between them:

```cds
@cds.search: {author}
entity Book {
  key ID : Integer;
  name   : String;
  title  : String;
  author : Association to Author;
}

entity Author {
  key ID : Integer;
  name   : String;
}
```

Referring to the association `author` in `@cds.search` declares that the search is to be extended. Therefore, all elements of the `Author` entities that are reached through the association `author` are searchable.

</Fragment>


2. Construct queries with `search`

Let's consider the following Book entity once again:

```cds
entity Book {
  key ID : Integer;
  name   : String;
  title  : String;
}
```

* Use search terms {#search-term}

The following Select statement shows how to search for an entity containing the single _search term_ "Allen".

```java
// Book record - (ID, title, name) VALUES (1, "The greatest works of James Allen", "Unwin")

Select.from("bookshop.Books")
        .columns("id", "name")
        .search("Allen");
```

> The element `title` is [searchable](#searchable-elements), even though `title` isn't selected.

* Use search expressions {#search-expression}

It's also possible to create a more complex _search expression_ using `AND`, `OR`, and `NOT` operators. Following examples show how you can search for entities containing either term "Allen" or "Heights".

```java
// Book records -
// (ID, title, name) VALUES (1, "The greatest works of James Allen", "Unwin")
// (ID, title, name) VALUES (2, "The greatest works of Emily Bronte", "Wuthering Heights")

Select.from("bookshop.Books")
        .columns("id", "name")
        .search(term -> term.has("Allen").or(term.has("Heights")));
```


#### Using `where` Clause {#where-clause}

In a where clause, leverage the full power of [CDS Query Language (CQL)](/cds/cql) [expressions](#expressions) to compose the query's filter:

```java
Select.from("bookshop.Books")
	.where(b -> b.get("ID").eq(251).or(
              b.get("title").startsWith("Wuth")));
```

### Grouping

The Query Builder API offers a way to group the results into summarized rows (in most cases these are aggregate functions) and apply certain criteria on it.

Let's assume the following dataset for our examples:

|ID  |NAME  |
|----|------|
|100 |Smith |
|101 |Miller|
|102 |Smith |
|103 |Hugo  |
|104 |Smith |

#### Group By

The `groupBy` clause groups by one or more elements and usually involves aggregate [functions](query-api#scalar-functions), such as `count`, `countDistinct`, `sum`, `max`, `avg`, and so on. It returns one row for each group.

In the following example, we select the authors' name and, using the aggregate function `count`, determine how many authors with the same name exist in `bookshop.Authors`.

```java
import com.sap.cds.ql.CQL;

Select.from("bookshop.Authors")
	.columns(c -> c.get("name"), c -> CQL.count(c.get("name")).as("count"))
	.groupBy(g -> g.get("name"));
```

If we execute the query on our dataset, we get the following result:

|name  |count|
|------|-----|
|Smith |3    |
|Miller|1    |
|Hugo  |1    |


#### Having

To filter the [grouped](#group-by) result, `having` is used. Both, `having` and `where`, filter the result before `group by` is applied and can be used in the same query.

The following example selects authors where count is higher than 2:

```java
Select.from("bookshop.Authors")
    .columns(c -> c.get("name"), c -> func("count", c.get("name")).as("count"))
    .groupBy(c -> c.get("name"))
    .having(c -> func("count", c.get("name")).gt(2));
```

If we execute the query on our dataset, we get the following result:

|name  |count|
|------|-----|
|Smith |3    |


### Ordering and Pagination

The Query Builder API allows to specify the sort order of query results. The _sort specification_ governs, according to which elements the result is sorted, and which sort order (ascending or descending) is applied.

By default `Select` returns the rows in no particular order.

#### Order By

To ensure a specific order in a query use [`orderBy`](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Select.html#orderBy-java.util.function.Function...-), which allows sorting by one or more columns in ascending or descending order.

```java
Select.from("bookshop.Books")
    .columns(c -> c.get("ID"), c -> c.get("title"))
    .orderBy(c -> c.get("ID").desc(), c -> c.get("title").asc());
```

You can order by the alias of a column of the select list or a column that is defined as a result of the function call.

```java
Select.from("bookshop.Person")
    .columns(p -> p.get("name").toUpper().as("aliasForName"))
    .orderBy(p -> p.get("aliasForName").asc());
```

Aliases of columns have precedence over the element names when `orderBy` is evaluated.

::: warning
Aliases may shadow elements names. To avoid shadowing, don't use element names as aliases.
::::

On SAP HANA, the user's locale is passed to the database, resulting in locale-specific sorting of string-based columns.

By default, `null` values come before non-`null` values when sorting in ascending order and after non-`null` values when sorting in descending order. Use the `ascNullsLast` and `descNullsFirst` methods if you need to change this behavior.

The following query would sort `null` values for the element `nickname` last:

```java
Select.from("bookshop.Person")
    .orderBy(p -> p.get("name").asc(), p -> c.get("nickname").ascNullsLast());
```

If we execute the query on our dataset, we get the following result:

| name    | nickname |
| --------|----------|
| William | Bill     |
| William | null     |

#### Pagination

Pagination (dividing the result set into discrete subsets of a certain size) can be achieved by using [limit](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Select.html#limit-int-int-), which has the following optional parameters:
* `rows`: A number of rows to be returned. It's useful when dealing with large amounts of data, as returning all records in one shot can impact performance.
* `offset`: A particular number of rows to be skipped.

The following example selects all books, skip the first 20 rows, and return only 10 subsequent books:

```java
Select.from("bookshop.Books").limit(10, 20);
```

In this example, it's assumed that the total number of books is more or equal to 20. Otherwise, result set is empty.
::: tip
The pagination isn't stateful. If rows are inserted or removed before a subsequent page is requested, the next page could contain rows that were already contained in a previous page or rows could be skipped.
:::

### Pessimistic Locking { #write-lock}

Use the `lock()` method to enforce [Pessimistic Locking](../../guides/providing-services#select-for-update).

The following example shows how to build a select query with an _exclusive_ (write) lock. The query tries to acquire a lock for a maximum of 5 seconds, as specified by an optional parameter `timeout`:

```java
Select.from("bookshop.Books").byId(1).lock(5);
...
Update.entity("bookshop.Books").data("price", 18).byId(1);
```

To set a _shared_ (read) lock, specify the lock mode `SHARED` in the lock method:

```java
import static com.sap.cds.ql.cqn.CqnLock.Mode.SHARED;

Select.from("bookshop.Books").byId(1).lock(SHARED);
```

Not every entity exposed via a CDS entity can be locked with the `lock()` clause. To use the `lock()` clause, databases require that the target of such statements is represented by one of the following:
- a single table
- a simple view, so that the database can unambiguously identify which rows to lock

Views that use joins, aggregate data, include calculated or coalesced fields cannot be locked. Some databases might have additional restrictions or limitations specific to them.

There are few notable examples of such restrictions:

* You cannot use the `lock()` together with a `distinct()` or a `groupBy()`.
* You cannot use the `lock()` in a statement with the subquery as a source.
* Localized entities can be locked only if your query is run without a locale, as described in the chapter: [Modifying Request Context](../event-handlers/request-contexts#modifying-requestcontext). Alternatively, they can be locked by removing the localized element from the select list (columns).
* Entities that contain "on-read" calculated elements can't be locked when the statement references them in the select list or a filter.

As a general rule, prefer the statements that select primary keys with a simple condition, such as `byId` or `matching`, to select the target entity set that is locked.

## Insert

The [Insert](../../cds/cqn#insert) statement inserts new data into a target entity set.
An `Insert` statement is created by the [Insert](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Insert.html) builder class.

The target of the insert is specified by the `into` method.

As in the following example, the target of the insert can be specified by a fully qualified entity name or by a [CdsEntity](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/reflect/CdsEntity.html) you obtain from the [Reflection API](../../node.js/cds-reflect):

```java
Map<String, Object> book = new HashMap<>();
book.put("ID", 101);
book.put("title", "Capire");

CqnInsert insert = Insert.into("bookshop.Books").entry(book);
```

 or it can be a [path expression](#path-expressions), for example to add an item for Order 1001:

 ```java
import static bookshop.Bookshop_.ORDERS;

Insert.into(ORDERS, o -> o.matching(Map.of("ID", 1001))).items())
	.entry(Map.of("book", Map.of("ID", 251), "amount", 1));
```


### Single Insert

To insert a single entry, provide the data as a map to the [entry](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Insert.html#entry-java.util.Map-) method:

```java
Map<String, Object> book;
book.put("ID", 101);
book.put("title", "Capire 2");

CqnInsert insert = Insert.into("bookshop.Books").entry(book);
```

### Bulk Insert

`Insert` also supports a bulk operation. Here the data is passed as an Iterable of maps to the [entries](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Insert.html#entries-java.lang.Iterable-) method:

```java
import static bookshop.Bookshop_.BOOKS;

var data = List.of(
	Map.of("ID", 101, "title", "Capire"),
	Map.of("ID", 103, "title", "CAP Java"));

CqnInsert insert = Insert.into(BOOKS).entries(data);
```
::: tip
A bulk insert can also perform deep inserts.
:::

### Deep Insert

To build a deep insert, the input data maps can contain maps or list of maps as values, such as items of an order. By default, the insert operation cascades over compositions only. To cascade it also over selected associations, use the [@cascade](query-execution#cascading-over-associations) annotation.

CDS Model:

```cds
entity Orders {
  key OrderNo : String;
  Items       : Composition of many OrderItems on Items.parent = $self;
  ...
}
entity OrderItems {
  key ID : Integer;
  book   : Association to Books;
  quantity : Integer;
  ...
}
```
[Find this source also in **cap/samples**.](https://github.com/sap-samples/cloud-cap-samples-java/blob/5396b0eb043f9145b369371cfdfda7827fedd039/db/schema.cds#L24-L36){.learn-more}


Java:

```java
import static bookshop.Bookshop_.ORDERS;

var items = List.of(Map.of("ID", 1, "book_ID", 101, "quantity", 1));
var order = Map.of("OrderNo", "1000", "Items", items);

CqnInsert insert = Insert.into(ORDERS).entry(order);
```
::: tip
On SQL data stores the execution order of the generated insert statements is parent first.
:::

## Upsert { #upsert}

[Upsert](../../cds/cqn#upsert) updates existing entities or inserts new ones if they don't exist in the database.
`Upsert` statements are created with the [Upsert](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Upsert.html) builder and are translated into DB native upsert statements by the CAP runtime whenever possible.

The main use case of upsert is data replication.

If upsert data is incomplete only the given values are updated or inserted, which means the `Upsert` statement has "PATCH semantics".
::: warning
Upsert is **not** equivalent to Insert, even if an entity doesn't exist in the database.
:::

The following actions are *not* performed on Upsert:
 * UUID key values are _not generated_.
 * The `@cds.on.insert` annotation is _not handled_.
 * Elements are _not initialized_ with default values if the element's value is not given.
 * Generic CAP handlers, such as audit logging, are not invoked.

`Upsert` statements don't have a where clause. Just as with bulk [Updates](#bulk-update) and
[Inserts](#single-insert), the key values of the entity that is upserted are extracted from the data.
::: tip
The upsert data must contain values for all mandatory and key elements.
:::


### Single Upsert

To upsert a single entry, provide the data as a map to the [entry](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Upsert.html#entry-java.util.Map-) method:

```java
import static bookshop.Bookshop_.BOOKS;
import bookshop.Books;

Books book = Books.create();
book.setId(101);
book.setTitle("CAP for Beginners");

CqnUpsert upsert = Upsert.into(BOOKS).entry(book);
```

### Bulk Upsert

The `Upsert` also supports bulk operations. Here an `Iterable` of data maps is passed to the [entries](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Upsert.html#entries-java.lang.Iterable-) method:

```java
import static bookshop.Bookshop_.BOOKS;
import bookshop.Books;

Books b1 = Books.create(101);
b1.setTitle("Odyssey");

Books b2 = Books.create(103);
b2.put("title", "Ulysses");

List<Books> data = Arrays.asList(b1, b2);

CqnUpsert upsert = Upsert.into(BOOKS).entries(data);
```
::: tip
Bulk upserts with entries updating/inserting the same set of elements can be executed more efficiently than individual upsert operations and bulk upserts with heterogeneous data.
:::


### Deep Upsert { #deep-upsert}

Upsert can operate on deep [document structures](../cds-data#nested-structures-and-associations) modeled via [compositions](../../guides/domain-modeling#compositions), such as an `Order` with many `OrderItems`.
Such a _Deep Upsert_ is similar to [Deep Update](#deep-update), but it creates the root entity if it doesn't exist and comes with some [limitations](#upsert) as already mentioned.

The [full set](#deep-update-full-set) and [delta](#deep-update-delta) representation for to-many compositions are supported as well.
::: warning
Upsert doesn't allow changing the key of a child of a composition `of one`.
:::

## Update

Use the [Update](../../cds/cqn#update) statement to update existing entities with new data. The update data can be partial (patch semantics), elements without update values keep their old value, except for elements annotated with `@cds.on.update`, which are updated with the annotation value.

Depending on the filter condition, the `Update` can target [individual](#update-individual-entities) or [multiple](#searched-update) entity records.
::: tip
Check the [row count](query-execution#batch-execution) of the update result to get the number of updated records. It is 0 if no entity matched the filter condition.
:::

Use the [Update](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Update.html) builder to create an update statement.

### Updating Individual Entities {#update-individual-entities}

The target entity set of the update is specified by the [entity](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Update.html#entity-java.lang.String-) method.

In the following example, the update target is an entity of the [static model](../cqn-services/persistence-services#staticmodel). The update data is provided as a map to the [data](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Update.html#data-java.util.Map-) method, using [accessor interfaces](../cds-data#typed-access) to construct the data in a typed way. The filter condition of the update is constructed from the key values in the update data:

```java
import static bookshop.Bookshop_.BOOKS;
import bookshop.Books;

Books book = Books.create();
book.setId(100); // key value filter in data
book.setTitle("CAP Matters");

CqnUpdate update = Update.entity(BOOKS).data(book);
```

As an alternative to adding the key values to the data, you can use the [byId](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Update.html#byId-java.lang.Object-) filter for entities with a single key element or [matching](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Update.html#matching-java.util.Map-) for entities with compound key.

```java
Update.entity(BOOKS)
   .data("title", "CAP Matters").byId(100);
```

Furthermore, you can use filters in [path expressions](#path-expressions) to specify the update target:

```java
Update.entity(BOOKS, b -> b.matching(Books.create(100)))
   .data("title", "CAP Matters");
```

::: danger
If key values are not contained in the data and no filter (`where`, `byId`, `matching`) is specified a [searched update](#searched-update) is performed, which updates _all_ entities with the given data.
:::

### Update with Expressions {#update-expressions}

The [data](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Update.html#data(java.util.Map)), [entry](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Update.html#entry(java.util.Map)), and  [entries](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Update.html#entries(java.lang.Iterable)) methods allow to specify the new values as plain Java values. In addition/alternatively you can use the `set` method to specify the new [value](#values) as a [CqnValue](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/cqn/CqnValue.html), which can even be an [arithmetic expression](#arithmetic-expressions). This allows, for example, to decrease the stock of Book 101 by 1:

```java
// dynamic
Update.entity(BOOKS).byId(101).set("stock", CQL.get("stock").minus(1));

// static
Update.entity(BOOKS).byId(101).set(b -> b.stock(), s -> s.minus(1));
```

You can also combine update data with expressions:

```java
Update.entity(BOOKS).where(b -> b.stock().eq(0))
   .data("available", true)
   .set(b -> b.stock(), s -> s.plus(CQL.param("addStock")));
```

### Deep Update { #deep-update}

Use deep updates to update _document structures_. A document structure comprises a single root entity and one or multiple related entities that are linked via compositions into a [contained-in-relationship](../../guides/domain-modeling#compositions). Linked entities can have compositions to other entities, which become also part of the document structure.

By default, only target entities of [compositions](../../guides/domain-modeling#compositions) are updated in deep updates. Nested data for managed to-one associations is used only to [set the reference](../cds-data#setting-managed-associations-to-existing-target-entities) to the given target entity. This can be changed via the [@cascade](query-execution#cascading-over-associations) annotation.

For to-many compositions there are two ways to represent changes in the nested entities of a structured document: *full set* and *delta*.  In contrast to *full set* representation which describes the target state of the entities explicitly, a change request with *delta* payload describes only the differences that need to be applied to the structured document to match the target state. For instance, in deltas, entities that are not included remain untouched, whereas in full set representation they are deleted.

#### Full Set Representation { #deep-update-full-set}

In the update data, nested entity collections in **full set** representation have to be _complete_. All pre-existing entities that are not contained in the collection are deleted.
The full set representation requires the runtime to execute additional queries to determine which entities to delete and is therefore not as efficient to process as the [delta representation](#deep-update-delta).

Given the following *Order*:

```json
{
   "OrderNo": "1000",
   "status": "new",
   "createdAt": "2020-03-01T12:21:34.000Z",
   "items": [{"Id":1, "book":{"ID":100}, "quantity":1},
             {"Id":2, "book":{"ID":200}, "quantity":2},
             {"Id":3, "book":{"ID":200}, "quantity":3}]
}
```

Do a deep update `Update.entity(ORDERS).data(order)` with the following order data:

```json
{
   "OrderNo": "1000",
   "status": "in process",
   "items": [{"Id":1, "quantity":2},
             {"Id":4, "book":{"ID":400}, "quantity":4}]
}
```
> Constructed using `CdsData`, `CdsList` and the generated [accessor interfaces](../cds-data#typed-access).

See the result of the updated *Order*:

```json
{
   "OrderNo": "1000",
   "status": "in process",
   "createdAt": "2020-03-01T12:21:34.000Z",
   "items": [{"Id":1, "book":{"ID":100}, "quantity":2},
             {"Id":4, "book":{"ID":400}, "quantity":4}]
}
```

- Order `status` changed to "in process"
- Item 1 `quantity` changed to 2
- Items 2 and 3 removed from `items` and deleted
- Item 4 created and added to `items`


#### Delta Representation { #deep-update-delta}

In **delta** representation, nested entity collections in the update data can be partial: the runtime only processes entities that are contained in the collection but entities that aren't contained remain untouched.
Entities that shall be removed need to be included in the list and explicitly _marked for removal_.

Using the same sample _Order_ as in the previous full-set chapter, do a deep delta update with the following update data:

```java
import static com.sap.cds.CdsList.delta;

Order order = Order.create(1000);
order.setStatus("in process");
OrderItem item1 = OrderItem.create(1);
item1.setQuantity(2);
OrderItem item2 = OrderItem.create(2);
OrderItem item4 = OrderItem.create(4);
item4.setBook(Book.create(400));
item4.setQuantity(4);

// items delta with order item 2 marked for removal
order.setItems(delta(item1, item2.forRemoval(), item4));

Update.entity(ORDER).data(order);
```
> Create delta collections via `CdsList` and `CdsData`.

The deep update with order items in delta representation has similar effects as the update with items in full set representation. The only difference is that `OrderItem 3` is not deleted.


### Bulk Update: Update Multiple Entity Records with Individual Data {#bulk-update}

To update multiple entity records with individual update data, use the [entries](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Update.html#entries-java.lang.Iterable-) method and provide the key values of the entities in the data.
The individual update entries can be [deep](#deep-update). The following example illustrates this, using the generated accessor interfaces. The statement updates the status of order 1 and 2 and the header comment of order 3:

```java
Orders o1 = Orders.create(1);
o1.setStatus("canceled");

Orders o2 = Orders.create(2);
o2.setStatus("in process");

Orders o3 = Orders.create(3);
o3.put("header.comment", "Deliver with Order 2");

List<Orders> orders = Arrays.asList(o1, o2, o3);
CqnUpdate update = Update.entity(ORDERS).entries(orders);
```
::: tip
In general, a bulk update can be executed more efficiently than multiple individual updates,
especially if all bulk update entries update the same set of elements.
:::


### Update Multiple Entity Records with the same Data

To update multiple entity records with the same update data, use searched or batch updates.

#### Searched Update {#searched-update}

Use the [where](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Update.html#where-java.util.function.Function-) clause or [matching](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/Update.html#matching-java.util.Map-) to update _all_ entities that match the [filter](#expressions) with _the same_ update data. In the following example, the `stock` of all books with the title containing *CAP* is set to 100:

```java
Update.entity(BOOKS).data("stock", 100)
   .where(b -> b.title().contains("CAP"));
```

#### Parameterized Batch Update {#batch-update}

Use `CQL.param` in the `where` clause or `byParams` to create a parameterized update statement to execute the statement with one or multiple [parameter value sets](query-execution#batch-execution).

```java
// using where
CqnUpdate update = Update.entity(BOOKS).data("stock", 0)
    .where(b -> b.title().eq(CQL.param("title"))
           .and(b.author().name().eq(CQL.param("author.name"))));

// using byParams
CqnUpdate update = Update.entity(BOOKS).data("stock", 0)
    .byParams("title", "author.name");

Map<String, Object> paramSet1 = new HashMap<>();
paramSet1.put("author.name", "Victor Hugo");
paramSet1.put("title", "Les Misérables");
Map<String, Object> paramSet2 = new HashMap<>();
paramSet2.put("author.name", "Emily Brontë");
paramSet2.put("title", "Wuthering Heights");

Result result = service.run(update, asList(paramSet1, paramSet2));
```

## Delete

The [Delete](../../cds/cqn#delete) operation can be constructed as follows:

```cds
// CDS model
entity Orders {
  key OrderNo : String;
  Items       : Composition of many OrderItems on Items.parent = $self;
  ...
}
entity OrderItems {
  book   : Association to Books;
  ...
}
```

```java
// dynamic
CqnDelete delete = Delete.from("my.bookshop.Orders")
    .where(b -> b.get("OrderNo").eq(1000));
```

```java
// static
import static bookshop.Bookshop_.ORDERS;

CqnDelete delete = Delete.from(ORDERS)
    .where(b -> b.OrderNo().eq(1000));
```

By default, delete operations are cascaded along compositions. In the example, the `delete` statement would delete the order with id 1000 including its items, but no books since this relationship is modeled as an association. To enable cascading deletes over selected associations, use the [@cascade](query-execution#cascading-over-associations) annotation.

### Using `matching`

As an alternative to `where`, you can use `matching` to define the delete filter based on a map. In the following example, the entity `bookshop.Article` has a composite primary key made up of `ID` and `journalID`.

```java
import static com.sap.cds.ql.CQL.param;

Map<String, Object> params = new HashMap<>();
params.put("ID", param("ID"));
params.put("journalID", 101);

// using matching
CqnDelete delete = Delete.from("bookshop.Article").matching(params);

// using where
CqnDelete delete = Delete.from("bookshop.Article")
	.where(t -> t.get("ID").eq(param("ID"))
	.and(t.get("journalID").eq(101)));

// execution
Map<String, Object> row1 = singletonMap("ID", 1);
Map<String, Object> row2 = singletonMap("ID", 2);
dataStore.execute(delete, asList(row1, row2));
```

#### Using `byParams`

To delete multiple records of an entity you can use `byParams` as an alternative to parameters in `matching`/`where`. The records are then identified by the parameter values, which are given on statement [execution](query-execution#batch-execution):

```java
import static bookshop.Bookshop_.BOOKS;

// using where
Delete.from(BOOKS)
    .where(b -> b.title().eq(param("title"))
           .and(b.author().name().eq(param("author.name"))));

// using byParams
Delete.from(BOOKS).byParams("title", "author.name");
```

## Expressions

The Query Builder API supports using expressions in many places. Expressions consist of [values](#values), which can be used, for example, in [Select.columns](#projections) to specify the select list of the statement. Values can also be used in [predicates](#predicates) that allow, for example, to specify filter criteria for [Select](#select) or [Delete](#delete) statements.

### Entity References {#entity-refs}

Entity references specify entity sets. They can be used to define the target entity set of a [CQL](../../cds/cql) statement. They can either be defined inline using lambda expressions in the Query Builder (see [Target Entity Sets](#target-entity-sets)) or via the `CQL.entity` method, which is available in an _untyped_ version as well as in a _typed_ version that uses the generated [model interfaces](../cqn-services/persistence-services#model-interfaces). The following example shows an entity reference describing the set of *authors* that have published books in the year 2020:

```java
import com.sap.cds.ql.CQL;

// bookshop.Books[year = 2020].author // [!code focus]
Authors_ authors = CQL.entity(Books_.class).filter(b -> b.year().eq(2020)).author(); // [!code focus]

// or as untyped entity ref
StructuredType<?> authors =
   CQL.entity("bookshop.Books").filter(b -> b.get("year").eq(2020)).to("author");

// SELECT from bookshop.Books[year = 2020]:author { name } // [!code focus]
Select.from(authors).columns("name"); // [!code focus]
```

You can also get [entity references](query-execution#entity-refs) from the result of a CDS QL statement to address an entity via its key values in other statements.


### Values

Use values in a query's [select list](#projections) as well as in order-by. In addition, values are useful to compose filter [expressions](#expressions).

#### Element References

Element references reference elements of entities. To compose an element reference, the Query Builder API uses lambda expressions. Here the function `b -> e.title()` accesses the book's title. The dynamic usage `b.to("author").get("name")` accesses the name of a book's author, as a shortcut `b.get("author.name")` can be used.

```java
import static com.sap.cds.ql.CQL.literal;

Select.from(BOOKS)
      .columns(b -> b.title(),
               b -> b.author().name());
```

---

#### Literal Values

Specify values that are already known when the query is built. The `val` method of `CQL` is used to create a literal value that can be used in the Query Builder API:

```java
import static com.sap.cds.ql.CQL.val;

Select.from(EMPLOYEE)
      .columns(e -> e.name())
      .where(e -> val(50).gt(e.age()));
```

Alternatively, the factory methods for comparison predicates directly accept Java values. The query could also be written as:

```java
Select.from(EMPLOYEE)
      .columns(e -> e.name())
      .where(e -> e.age().le(50));
```

Use `CQL.constant` if the literal value shall be treated as [constant](#constant-and-non-constant-literal-values).

---

#### List Values

Combine multiple values with `CQL.list` to a list value (row value), which you can use in comparisons.

For example, the following query returns all sales after Q2/2012:

```java
import static com.sap.cds.ql.CQL.*;

CqnListValue props = list(get("year"), get("quarter"));
CqnListValue vals  = list(val(2012), val(2));
CqnSelect q = Select.from(SALES).where(comparison(props, GT, vals));
```
You can also compare multiple list values at once using an [`IN` predicate](#in-predicate).
#### Parameters {#expr-param}

The [`param`](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/CQL.html#param--) method can be statically imported from the helper class [CQL](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/CQL.html). It provides an option to use a parameter marker in a query that is bound to an actual value only upon query execution. Using parameters you can execute a query multiple times with different parameter values.

Parameters are either _indexed_ or _named_. Using _indexed_ parameters means, the values are bound to the parameters according to their index. Using _named_ parameters means, the values are given as a map:

```java
// indexed
import static com.sap.cds.ql.CQL.param;

Select.from("bookshop.Authors")
      .where(a -> a.firstName().eq(param(0)).and(
                  a.lastName().eq(param(1))));
dataStore.execute(query, "Paul", "Mueller");
```

```java
// named
import static com.sap.cds.ql.CQL.param;

Select.from("bookshop.Authors")
      .where(a -> a.firstName().eq(param("first")).and(
                  a.lastName().eq(param("last"))));

Map<String, Object> paramValues = new HashMap<>();
paramValues.put("first", "Paul");
paramValues.put("last", "Mueller");

dataStore.execute(query, paramValues);
```
::: tip
When using named parameters, `Update` and `Delete` statements can be executed as [batch](query-execution#batch-execution)) with multiple parameter sets.
:::


#### Scalar Functions

Scalar functions are values that are calculated from other values. This calculation can be executing a function on the underlying data store or applying an operation, like an addition, to its parameters. The Query Builder API supports the generic `func` function, as well as a number of build-in functions.

* Generic Scalar Function

    The generic function `func`, creates a scalar function call that is executed by the underlying data store. The first argument, being the native query language function name, and the remaining arguments are passed on as arguments of the specified function. In the following example, the native query language `count` function is called on the `name` element. This function returns the count of number of elements with name `Monika`.

    ```java
    import static com.sap.cds.ql.CQL.func;
    Select.from(EMPLOYEE)
      .columns(e -> e.name(), e -> func("COUNT", e.name()).as("count"))
      .where(e -> e.name().eq("Monika"));
    ```

* To Lower

    The `toLower` function is a built-in string function for converting a given string value to lower case using the rules of the underlying data store.

    ```java
    import static com.sap.cds.ql.CQL.toLower;
    Select.from(EMPLOYEE).columns(e -> e.name())
      .where(e -> e.name().endsWith(toLower("IKA")));
    ```

    In the following example, the `toLower` function is applied on the `name` element before applying the equals predicate.

    ```java
    Select.from(EMPLOYEE).columns(e -> e.name())
      .where(e -> e.name().toLower().eq("monika"));
    ```

* To Upper

    The `toUpper` function is a built-in string function for converting a given string value to upper case using the rules of the underlying data store.

    ```java
    import static com.sap.cds.ql.CQL.toUpper;
    Select.from(EMPLOYEE).columns(e -> e.name())
      .where(e -> e.name().endsWith(toUpper("ika")));
    ```

    In the following example, the `toUpper` function is applied on the `name` element before applying the equals predicate.

    ```java
    Select.from(EMPLOYEE).columns(e -> e.name())
      .where(e -> e.name().toUpper().eq("MONIKA"));
    ```

* Substring

    The `substring` method creates an expression for substring extraction from a string value. Extract a substring from a specified starting position of either a given length or to the end of the string. The first position is zero.

    ```java
    Select.from("bookshop.Authors")
      .columns(a -> a.get("name").substring(0,2).as("shortname"))
    ```
    In the following example, the `substring` function is applied as part of a predicate to test whether a subset of characters matches a given string.

    ```java
    Select.from("bookshop.Authors")
      .where(e -> e.get("name").substring(2).eq("ter"));
    ```

#### Case-When-Then Expressions

Use a case expression to compute a value based on the evaluation of conditions. The following query converts the stock of Books into a textual representation as 'stockLevel':

```java
Select.from(BOOKS).columns(
  b -> b.title(),
  b -> b.when(b.stock().lt(10)).then("low")
        .when(b.stock().gt(100)).then("high")
        .orElse("medium").as("stockLevel").type(CdsBaseType.STRING));
```

#### Arithmetic Expressions

Arithmetic Expressions are captured by scalar functions as well:

* Plus

    Function `plus` creates an arithmetic expression to add a specified value to this value.

    ```java
    // SELECT from Author {id + 2 as x : Integer}
    Select.from(AUTHOR)
      .columns(a -> a.id().plus(2).as("x"));
    ```

* Minus
    Function `minus` creates an arithmetic expression to subtract a specified value with this value.

    ```java
    Select.from("bookshop.Authors")
      .columns("name")
      .limit(a -> literal(3).minus(1));
    ```

* Times

    Function `times` creates an arithmetic expression to multiply a specified value with this value. In the following example, `p` is an Integer parameter value passed when executing the query.

    ```java
    Parameter<Integer> p = param("p");
    Select.from(AUTHOR)
      .where(a -> a.id().between(10, p.times(30)));
    ```

* Divided By

    Function `dividedBy` creates an arithmetic expression to divide this value with the specified value.

    ```java
    Select.from(AUTHOR)
      .where(a -> a.id().between(10, literal(30).dividedBy(2)));
    ```

### Predicates

Predicates are expressions with a Boolean value, which are used in [filters](#where-clause) to restrict the result set or to specify a [target entity set](#target-entity-sets).

#### `Comparison Operators` {#comparison-operators}

These comparison operators are supported:

<table>
<thead>
<tr>
<th colspan="2" align=center>Operator</th><th/><th/>
</tr>
<tr>
<th>
    CAP Java
</th>
<th>
    CDL
</th>
<th>
    Description
</th>
<th>
     Example
</th>
</tr>
</thead>

<tbody>
<tr>
<td>EQ</td><td>=</td>
<td>
    Test if this value equals a given value. NULL values might be treated as unknown resulting in a <i>three-valued logic</i> as in SQL.
</td>
<td align="left">
<code>Select.from("bookshop.Books")
  .where(b -> b.get("stock")
  .<span class="na">eq</span>(15));</code>
</td>
</tr>

<tr>
<td>NE</td><td>&lt;&gt;</td>
<td>
    Test if this value is NOT equal to a given value. NULL values might be treated as unknown resulting in a <i>three-valued logic</i> as in SQL.
</td>
<td>
<code>Select.from("bookshop.Books")
  .where(b -> b.get("stock")
  .<span class="na">ne</span>(25));</code>
</td>
</tr>

<tr>
<td>IS</td><td>==</td>
<td>
    Test if this value equals a given value. NULL values are treated as any other value (<i>Boolean logic</i>).
</td>
<td>

<code>Select.from("bookshop.Books")
  .where(b -> b.get("stock")
  .<span class="na">is</span>(15));</code>

</td>
</tr>

<tr>
<td>IS NOT</td><td>!=</td>
<td>
    Test if this value is NOT equal to a given value. NULL values are treated as any other value (<i>Boolean logic</i>).
</td>
<td>

<code>Select.from("bookshop.Books")
  .where(b -> b.get("stock")
  .<span class="na">isNot</span>(25));</code>

</td>
</tr>

<tr>
<td>GT</td><td>&gt;</td>
<td>
    Test if this value is greater than a given value.
</td>
<td>

<code>Select.from("bookshop.Books")
  .where(b -> b.get("stock")
  .<span class="na">gt</span>(5));</code>

</td>
</tr>

<tr>
<td>GE</td><td>&gt;=</td>
<td>
    Test if this value is greater than or equal to a given value.
</td>
<td>

<code>Select.from("bookshop.Books")
  .where(b -> b.get("stock")
  .<span class="na">ge</span>(5));</code>

</td>
</tr>

<tr>
<td>LT</td><td>&lt;</td>
<td>
    Test if this value is less than a given value.
</td>
<td>

<code>Select.from("bookshop.Books")
  .where(b -> b.get("stock")
  .<span class="na">lt</span>(5));</code>

</td>
</tr>

<tr>
<td>LE</td><td>&lt;=</td>
<td>
    Test if this value is less than or equal to a given value.
</td>
<td>

<code>Select.from("bookshop.Books")
  .where(b -> b.get("stock")
  .<span class="na">le</span>(5));</code>

</td>
</tr>

<tr>
<td colspan="2">
BETWEEN
</td>
<td>
    Test if this value is between<sup>1</sup> a range of values.
</td>
<td>

<code>Select.from("bookshop.Books")
  .where(b -> b.get("stock")
  .<span class="na">between</span>(5, 10));</code>

</td>
</tr>
</tbody>
</table>

<sup>1</sup> upper and lower bound are included

#### `IN` Predicate

The `IN` predicate tests if a value is equal to any value in a given list. 

The following example, filters for books written by Poe or Hemingway:

```java
Select.from(BOOKS)
  .where(b -> b.author().name().in("Poe", "Hemingway"));
```

The values can also be given as a list:

```java
List<String> authorNames = List.of("Poe", "Hemingway");

Select.from(BOOKS)
  .where(b -> b.author().name().in(authorNames));
```

You can also use the `IN` predicate to compare multiple [list values](#list-values) at once - for example to efficiently filter by multiple key value sets:

```java
import static com.sap.cds.ql.CQL.*;

CqnListValue elements = list(get("AirlineID"), get("ConnectionID"));
CqnListValue lh454  = list(val("LH"), val(454));
CqnListValue ba119  = list(val("BA"), val(119));

Select.from(FLIGHT_CONNECTION).where(in(elements, List.of(lh454, ba119)));
```

#### `IN` Subquery Predicate

Use the `in` subquery to test if an element (or tuple of elements) of an outer query is contained in the result of a subquery.

```java
// fluent style
Select.from(AUTHORS).where(author -> author.name().in(
    Select.from(JOURNALISTS).columns(journalist -> journalist.name())
));
```

In this example we check whether the tuple (`firstName`, `lastName`) is contained in the result of the subquery:

```java
// generic tree style via CQL api
CqnListValue fullName = CQL.list(CQL.get("firstName"), CQL.get("lastName"));
CqnSelect subquery = Select.from("socialmedia.Journalists").columns("firstName", "lastName");
Select.from("bookshop.Authors").where(CQL.in(fullName, subquery));
```

#### `ETag Predicate` {#etag-predicate}

The [ETag predicate](query-execution#etag-predicate) specifies expected ETag values for [conflict detection](query-execution#optimistic) in an [update](#update) or [delete](#delete) statement:

```java
Instant expectedLastModification = ...;
Update.entity(ORDER)
      .entry(newData)
      .where(o -> o.id().eq(85).and(o.eTag(expectedLastModification)));
```

You can also use the `eTag` methods of the `CQL` interface to construct an ETag predicate in [tree style](#cql-helper-interface):

```java
import static com.sap.cds.ql.CQL.*;

Instant expectedLastModification = ...;
Update.entity(ORDER)
      .entry(newData)
      .where(and(get("id").eq(85), eTag(expectedLastModification)));
```

#### `Logical Operators` {#logical-operators}

Predicates can be combined using logical operators:

<table>
<thead>
<tr>
<th>
    Operator
</th>
<th>
    Description
</th>
<th>
     Example
</th>
</tr>
</thead>

<tbody>
<tr>
<td>
AND
</td>
<td>
    Returns a predicate that represents a logical AND of this predicate and another.
</td>
<td>

<code>Select.from("bookshop.Authors")
.where(a ->
  a.get("name").eq("Peter)
   .<span class="na">and</span>(a.get("Id").eq(1)));</code>

</td>
</tr>

<tr>
<td>
OR
</td>
<td>
    Returns a predicate that represents a logical OR of this predicate and another.
</td>
<td>

<code>Select.from("bookshop.Authors")
.where(a ->
  a.get("name").eq("Peter)
   .<span class="na">or</span>(a.get("Id").eq(1)));</code>

</td>
</tr>

<tr>
<td>
NOT
</td>
<td>
    Returns a predicate that represents the logical negation of this predicate.
</td>
<td>

<code>Select.from("bookshop.Authors")
.where(a ->
  <span class="na">not</span>(a.get("Id").eq(3)));</code>

</td>
</tr>
</tbody>
</table>

#### `Predicate Functions` {#predicate-functions}

These boolean-valued functions can be used in filters:

<table>
<thead>
<tr>
<th>
    Operator
</th>
<th>
    Description
</th>
<th>
     Example
</th>
</tr>
</thead>

<tbody>
<tr>
<td>
CONTAINS
</td>
<td>
    Test if this string value contains a given substring.
</td>
<td>

<code>Select.from(EMPLOYEE)
  .where(e -> e.name()
  .<span class="na">contains</span>("oni"));</code>

</td>
</tr>

<tr>
<td>
STARTS WITH
</td>
<td>
    Test if this string value starts with a given prefix.
</td>
<td>

<code>Select.from("bookshop.Books")
  .where(b -> b.get("title")
  .<span class="na">startsWith</span>("The"));</code>

</td>
</tr>

<tr>
<td>
ENDS WITH
</td>
<td>
    Test if this string value ends with a given suffix.
</td>
<td>

<code>Select.from("bookshop.Books")
  .where(b -> b.get("title")
  .<span class="na">endsWith</span>("Raven"));</code>

</td>
</tr>
</tbody>
</table>

#### `matchesPattern` Predicate {#matches-pattern}

The `matchesPattern` predicate is applied to a String value and tests if it matches a given regular expression.

The regular expressions are evaluated on the database. Therefore, the supported syntax of the regular expression and the options you can use depends on the database you are using.

For example, following code matches title of the book that contains the word "CAP" in the title:

```java
Select.from("bookshop.Books").where(t -> t.get("title").matchesPattern("CAP"));
```

::: tip
As a general rule, consider regular expressions as a last resort. They are powerful, but also complex and hard to read. For simple string operations, prefer other simpler functions like `contains`.
::::

In the following example, the title of the book must start with the letter `C` and end with the letter `e` and contains any number of letters in between:

```java
Select.from("bookshop.Books").where(t -> t.get("title").matchesPattern("^C\\w*e$"));
```

The behavior of the regular expression can be customized with the options that can be passed as a second argument of the predicate. The set of the supported options and their semantics depends on the underlying database.

For example, the following code matches that the title of the book begins with the word "CAP" while ignoring the case of the letters:

```java
Select.from("bookshop.Books").where(t -> t.get("title").matchesPattern(CQL.val("^CAP.+$"), CQL.val("i")));
```

#### `anyMatch/allMatch` Predicate {#any-match}

The `anyMatch` and `allMatch` predicates are applied to an association and test if _any_ instance/_all_ instances of the associated entity set match a given filter condition. They are supported in filter conditions of [Select](#select), [Update](#update) and [Delete](#delete) statements.

This query selects the Authors that have written any book in the year 2000 that is published by a publisher starting with 'X':

```java
import static bookshop.Bookshop_.AUTHORS;

Select.from(AUTHORS)
  .where(a -> a.books().anyMatch(b ->
    b.year().eq(2000).and(b.publisher().name().startsWith("X"))));
```

The next statement deletes all Authors that have published all their books with publisher 'A':

```java
Delete.from(AUTHORS).where(a -> a.books().allMatch(b -> b.publisher().name().eq("A")));
```

The reference, to which `anyMatch`/`allMatch` is applied, may navigate multiple path segments. The following query selects all authors, for which the publisher of all books is named "CAP Publications":

```java
Select.from(AUTHORS).where(a -> a.books().publisher().allMatch(p -> p.name().eq("CAP Publications")));
```

This is equivalent to

```java
Select.from(AUTHORS).where(a -> a.books().allMatch(b -> b.publisher().name().eq("CAP Publications")));
```

Like in the previous example, a reference used in a match predicate filter may navigate to-one associations. Nested match predicates need to be used, if you want to express a condition in a match predicate filter on a reference that navigates to-many associations. The following example selects authors that have written a book where the word "unicorn" occurs on all pages:

```java
Select.from(AUTHORS).where(a -> a.books().anyMatch(
    b -> b.pages().allMatch(p ->
        p.text().contains("unicorn"))));
```

#### `EXISTS` Subquery {#exists-subquery}

An `exists` subquery is used to test if a subquery returns any records. Typically a subquery is correlated with the enclosing _outer_ query.
You construct an `exists` subquery with the [`exists`](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/StructuredType.html#exists-java.util.function.Function-) method, which takes a [function](#lambda-expressions) that creates the subquery from a reference to the _outer_ query. To access elements of the outer query from within the subquery, this _outer_ reference must be used:

```java
import static bookshop.Bookshop_.AUTHORS;
import static socialmedia.Journalists_.JOURNALISTS;

// fluent style
Select.from(AUTHORS)
  .where(author -> author.exists($outer ->
      Select.from(JOURNALISTS).where(journalist -> journalist.name().eq($outer.name()))
    )
  );
```

This query selects all authors with the name of an journalist.
::: tip
With an `exists` subquery, you can correlate entities that aren't linked with associations.
:::

When using the [tree-style API](#composing-predicates) the _outer_ query is addressed by the special reference name `"$outer"`:

```java
// tree style
CqnSelect subquery =
  Select.from("Journalists")
        .where(a -> a.get("name").eq(CQL.get("$outer.name")));
Select.from("Authors").where(CQL.exists(subquery));
```

> **Note:** Chaining `$outer` in nested subqueries is not supported.

## Parsing CQN

[CQL](../../cds/cql) queries can also be constructed from a [CQN](../../cds/cqn) string<sup>*</sup>:

```java
String cqnQuery = """
    {'SELECT': {'from': {'ref': ['my.bookshop.Books']},
    'where': [{'ref': ['title']}, '=', {'val': 'Capire'}]}}
    """;
CqnSelect query = Select.cqn(cqnQuery);
```

> <sup>*</sup> For readability reasons, we used single quotes instead of double quotes as required by the JSON specification.

The constructed queries can then be modified using the query builder API:

```java
String cqnQuery = ...
CqnSelect query = Select.cqn(cqnQuery).columns("price");
```

For `Insert`, `Update`, and `Delete` this is supported as well.

## CQL Expression Trees { #cql-helper-interface}

As an alternative to fluent API the [CQL](../../cds/cql) statement can be built, copied, and modified using [CQL Interface](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/CQL.html), which allows to build and reuse the parts of the statement.

### Composing Predicates

As opposed to fluent API it's possible to build the queries in a tree-style. Consider the following example:

```java
// CQL: SELECT from Books where year >= 2000 and year <= 2010
//
//                      AND
//                       |
//             +---------+---------+
//             |                   |
//             =>                 <=
//             |                   |
//        +----+----+         +----+----+
//        |         |         |         |
//      year       2000      year     2010

import static com.sap.cds.ql.CQL.*;
import com.sap.cds.sql.cqn.CqnComparisonPredicate;

CqnValue year = get("year");
CqnPredicate filter = and(comparison(year, Operator.GE, val(2000)), comparison(year, Operator.LE, val(2010)));
```

In the previous example using the `CQL.and`, a predicate limiting the `year` between 2000 and 2010 was built.

Using CQL Interface can be handy when the part of the statement should be built on the fly based on some condition. The following example demonstrates that, showing the usage of a `CQL.in` expression:

```java
// CQL: SELECT from Books where year >= 2000 and year <= 2010
//                         OR
//      SELECT from Books where year in (2000, 2001, ...)

List<Integer> years = ...;
List<Value<Integer>> yearValues = years.stream().map(y -> val(y)).collect(toList());
CqnElementRef year = CQL.get("year");

CqnPredicate filter;
if (years.isEmpty()) {
   filter = and(comparison(year, Operator.GE, val(2000)), comparison(year, Operator.LE, val(2010)));
} else {
   filter = CQL.in(year, yearValues);
}

Select.from("bookshop.Books").where(filter);
```

#### Connecting Streams of Predicates

You can leverage the Java Stream API to connect a stream of predicates with `AND` or `OR` using the `Collector`s `withAnd` or `withOr`. In this example we build a predicate that tests if a Person matches any first name/last name pair in a list:

```java
List<Name> names = ...
CqnPredicate filter =
  names.stream()
       .map(n -> CQL.and(
           CQL.get("firstName").eq(n.first()),
           CQL.get("lastName").eq(n.last())))
       .collect(CQL.withOr());
```

### Working with Select List Items

In addition to `CQL.get`, which creates a reference to a particular element, it's also possible to reference all elements using `CQL.star` method and use the expands as well. The next example demonstrates how to select all elements of `Book` and expand elements of associated `Author` of the book with `CQL.to(...).expand`:

```java
// SELECT from Books {*, author {*}}

Expand<?> authorItems = CQL.to("author").expand();
Select.from("bookshop.Books").columns(CQL.star(), authorItems);
```

### Using Functions and Arithmetic Expressions

CQL Interface provides multiple well-known functions such as: `min`, `max`, `average`, and so on. The following example shows how to use the function call to query the `min` and `max` stock of the `Books`:

```java
// CQL: SELECT from Books { MIN(stock) as minStock, MAX(stock) as maxStock }

CqnElementRef stock = CQL.get("stock");
Select.from("bookshop.Books").columns(
   CQL.min(stock).as("minStock"),
   CQL.max(stock).as("maxStock"));
```

In addition to that it's also possible to build a custom function using `CQL.func`:

```java
// CQL: SELECT from Books { LENGTH(title) as titleLength }

CqnElementRef title = CQL.get("title");
Select.from("bookshop.Books").columns(func("LENGTH", title).as("titleLength"));
```

Other than `CQL.func`, which returns a value, the `CQL.booleanFunc` constructs the function, which returns a predicate and thus can be used in `where` clause of a query. In the following example, SAP HANA function `CONTAINS` is used to execute fuzzy search on the column of the entity:

```java
Select.from("bookshop.Books")
   .where(e -> booleanFunc("CONTAINS",
            Arrays.asList(CQL.get(Books.TITLE).asRef(), val("Wuthering"), plain("FUZZY(0.5)"))));
```

Assume the `Book` has an element `price : Decimal`. One can calculate the discount price by subtracting the fixed value. This can be done using `CQL.expression`:

```java
// CQL: SELECT from Books { *, price - 5 as discountPrice }

CqnSelectListValue discountPrice = CQL.expression(
   CQL.get("price"), Operator.SUB, CQL.val(5)).as("discountPrice"); // Price reduced by 5
Select.from("bookshop.Books").columns(CQL.star(), discountPrice);
```

When using custom functions or expressions, you sometimes want to ensure that the return value is typed with a specific CDS type. You can use a CDL cast for this, by leveraging the `type` method.
By default, values returned by custom functions or expressions are not typed. If no explicit CDL cast is applied, the representation of the return value in Java is dependent on the database and its JDBC driver implementation.
In the following example, the result of the `ADD_SECONDS` function is ensured to be represented as a CDS `Timestamp` type. This ensures the return value is typed as an `Instant` in Java.

```java
// CQL: SELECT from Books { ADD_SECONDS(modifiedAt, 30) as addedSeconds : Timestamp }

CqnElementRef modified = CQL.get("modifiedAt");
Select.from("bookshop.Books").columns(
   CQL.func("ADD_SECONDS", modified, CQL.constant(30))
      .type(CdsBaseType.TIMESTAMP).as("addedSeconds"));
```

## Copying & Modifying CDS QL Statements {#copying-modifying-cql-statements}

Use [`CQL::copy`](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/CQL.html#copy-S-com.sap.cds.ql.cqn.Modifier-) and a modifier to copy and modify CDS QL statements and their components such as values and predicates:

```java
import com.sap.cds.ql.CQL;

// CQL: SELECT from Books where title = 'Capire'
CqnSelect query = Select.from(BOOKS).where(b -> b.title().eq("Capire"));
CqnSelect copy  = CQL.copy(query, modifier);  // implement Modifier
```

By overriding the default implementations of the `Modifier` interface, different parts of a statement or predicate can be replaced in the copy.

The following sections show some common examples of statement modifications, for a complete list of modifier methods, check the [Modifier](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/cqn/Modifier.html) interface.

### Replacing Predicates {#modify-where}

The following modifier replaces the `where` clause of the copy with a new predicate that connects the `where` clause of the query with `or` to `title = 'CAP Java'`.

```java
import com.sap.cds.ql.CQL;

// query: SELECT from Books where title = 'Capire'
// copy:  SELECT from Books where title = 'Capire' or title = 'CAP Java'

CqnSelect copy = CQL.copy(query, new Modifier() {
   @Override
   public Predicate where(Predicate where) {
      return CQL.or(where, CQL.get("title").eq("CAP Java"));
   }
});
```

To replace comparison predicates, override the [`Modifier::comparison`](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/cqn/Modifier.html#comparison-com.sap.cds.ql.Value-com.sap.cds.ql.cqn.CqnComparisonPredicate.Operator-com.sap.cds.ql.Value-) method. The following modifier replaces the value of the `title` comparison with `'CAP'`.

```java
// query: SELECT from Books where title = 'Capire'
// copy:  SELECT from Books where title = 'CAP'

CqnSelect copy = CQL.copy(query, new Modifier() {
   @Override
   public Predicate comparison(Value<?> lhs, Operator op, Value<?> rhs) {
      if (lhs.isRef() && lhs.asRef().lastSegment().equals("title")) {
         rhs = CQL.val("CAP");
      }
      return CQL.comparison(lhs, op, rhs);
   }
});
```

### Replacing References {#modify-ref}

References to elements and structured types are _immutable_. You can replace them by overriding the `Modifier::ref` methods.

The following modifier replaces the ref to the `Books` entity (1) in the copy of the query with a new ref that has a filter `year > 2000` and replaces the `title` ref (2) with a new ref with "book" as alias.

```java
// query: SELECT from Books { title }
// copy:  SELECT from Books[year > 2000] { title as book }

CqnSelect copy = CQL.copy(query, new Modifier() {
   @Override // (1)
   public CqnStructuredTypeRef ref(CqnStructuredTypeRef ref) {
      return CQL.to(ref.firstSegment())
            .filter(CQL.get("year").gt(2000))
            .asRef();
   }

   @Override // (2)
   public CqnValue ref(CqnElementRef ref) {
      return CQL.get(ref.segments()).as("book");
   }
});
```

### Modify the Select List {#modify-select}

The modifier can also be used to add or remove select list items via [`Modifier::items`](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/cqn/Modifier.html#items-java.util.List-):

```java
// query: SELECT from Books where title = 'Capire'
// copy:  SELECT from Books {title, author {name}} where title = 'Capire'

CqnSelect copy = CQL.copy(query, new Modifier() {
   @Override
   public List<CqnSelectListItem> items(List<CqnSelectListItem> items) {
      items.add(CQL.get("title"));                // add title
      items.add(CQL.to("author").expand("name")); // expand author name
      return items;
   }
});
```

### Modify the Order-By Clause {#modify-order-by}

To modify the `orderBy` clause of a query, override [`Modifier::orderBy`](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/cqn/Modifier.html#orderBy-java.util.List-):

```java
// query: SELECT from Books where title = 'Capire'
// copy:  SELECT from Books where title = 'Capire' ORDER BY title desc

CqnSelect copy = CQL.copy(query, new Modifier() {
   @Override
   public List<CqnSortSpecification> orderBy(List<CqnSortSpecification> order) {
      order.add(CQL.get("title").desc());
      return order;
   }
});
```

<div id="secondary-file">java/working-with-cql/query-api.fragment.md</div>


# Executing CQL Statements


API to execute CQL statements on services accepting CQN queries.

## Query Execution { #queries}

[CDS Query Language (CQL)](./query-api) statements can be executed using the `run` method of any [service that accepts CQN queries](../cqn-services/#cdsservices):

```java
CqnService service = ...

CqnSelect query = Select.from("bookshop.Books")
    .columns("title", "price");

Result result = service.run(query);
```


### Parameterized Execution

Queries, as well as update and delete statements, can be parameterized with _named_, or _indexed parameters_. Update and delete statements with _named_ parameters can be executed in batch mode using multiple parameter sets.

#### Named Parameters

The following statement uses two parameters named *id1* and *id2*. The parameter values are given as a map:

```java
import static com.sap.cds.ql.CQL.param;

CqnDelete delete = Delete.from("bookshop.Books")
    .where(b -> b.get("ID").eq(param("id1"))
            .or(b.get("ID").eq(param("id2"))));

Map<String, Object> paramValues = new HashMap<>();
paramValues.put("id1", 101);
paramValues.put("id2", 102);

Result result = service.run(delete, paramValues);
```
::: warning
The parameter value map **must** be of type `Map<String, Object>`, otherwise the map is interpreted as a single positional/indexed parameter value, which results in an error.
:::

#### Indexed Parameters

The following statement uses two indexed parameters defined through `param(i)`:

```java
import static com.sap.cds.ql.CQL.param;

CqnDelete delete = Delete.from("bookshop.Books")
    .where(b -> b.get("ID").in(param(0), param(1)));

Result result = service.run(delete, 101, 102);
```

Before the execution of the statement the values 101 and 102 are bound to the defined parameters.


#### Batch Execution

Update and delete statements with _named parameters_ can be executed as batch with multiple parameter sets.
The named parameters example from above can be expressed using batch delete with a single parameter and two value sets:

```java
import static com.sap.cds.ql.CQL.param;

CqnDelete delete = Delete.from("bookshop.Books").byParams("ID");

Map<String, Object> paramSet1 = singletonMap("ID", 101);
Map<String, Object> paramSet1 = singletonMap("ID", 102);

Result result = service.run(query, asList(paramSet1, paramSet2));
long deletedRows = result.rowCount();
```

From the result of a batch update/delete the total number of updated/deleted rows can be determined by [rowCount()](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/Result.html#rowCount--), and [rowCount(batchIndex)](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/Result.html#rowCount-int-) returns the number of updated/deleted rows for a specific parameter set of the batch.
The number of batches can be retrieved via the [batchCount()](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/Result.html#batchCount--) method. Batch updates also return the update data.

The maximum batch size for update and delete can be configured via `cds.sql.max-batch-size` and has a default of 1000.


#### Querying Parameterized Views on SAP HANA { #querying-views}

To query [views with parameters](../../advanced/hana#views-with-parameters) on SAP HANA, build a select statement and execute it with [named parameter](#named-parameters) values that correspond to the view's parameters.

Let's consider the following `Books` entity and a parameterized view `BooksView`, which returns the `ID` and `title` of `Books` with `stock` greater or equal to the value of the parameter `minStock`:

```cds
entity Books {
    key ID : UUID;
    title  : String;
    stock  : Integer;
}

entity BooksView(minStock : Integer) as
   SELECT from Books {ID, title} where stock >= :minStock;
```

To query `BooksView` in Java, run a select statement and provide values for all view parameters:

```java
CqnSelect query = Select.from("BooksView");
var params = Map.of("minStock", 100);

Result result = service.run(query, params);
```

### Query Hints { #hana-hints}

To add a hint clause to a statement, use the `hints` method and prefix the [SAP HANA hints](https://help.sap.com/docs/HANA_CLOUD_DATABASE/c1d3f60099654ecfb3fe36ac93c121bb/4ba9edce1f2347a0b9fcda99879c17a1.htmlS) with `hdb.`:

```java
Select.from(BOOKS).hints("hdb.USE_HEX_PLAN", "hdb.ESTIMATION_SAMPLES(0)");
```
::: warning No external input in SQL for SAP HANA
Hints prefixed with `hdb.` are directly rendered into SQL for SAP HANA and therefore **must not** contain external input!
:::

### Data Manipulation

The CQN API allows to manipulate data by executing insert, update, delete, or upsert statements.

#### Update

The [update](./query-api) operation can be executed as follows:

```java
Map<String, Object> book = Map.of("title", "CAP");

CqnUpdate update = Update.entity("bookshop.Books").data(book).byId(101);
Result updateResult = service.run(update);
```

The update `Result` contains the data that is written by the statement execution. Additionally to the given data, it may contain values generated for [managed data](../../guides/domain-modeling#managed-data) and foreign key values.

The [row count](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/Result.html#rowCount()) of the update `Result` indicates how many rows where updated during the statement execution:


```java
CqnUpdate update = ...

long rowCount = service.run(update).rowCount();
```

If no rows are touched the execution is successful but the row count is 0.

:::warning Update with expressions
The setters of an [update with expressions](../working-with-cql/query-api#update-expressions) are evaluated on the database. The result of these expressions is not contained in the update result.
:::

### Structured Documents

It's possible to work with structured data as the insert, update, and delete operations cascade along *compositions*.

#### Cascading over Associations { #cascading-over-associations}

By default, *insert*, *update* and *delete* operations cascade over [compositions](../../guides/domain-modeling#compositions) only. For associations, this can be enabled using the `@cascade` annotation.

::: warning Avoid cascading over associations
Cascading operations over associations isn't considered good practice and should be avoided.
:::

Annotating an *association* with `@cascade: {insert, update, delete}` enables deep updates/upserts through this association.
Given the following CDS model with two entities and an association between them, only *insert* and *update* operations are cascaded through `author`:

```cds
entity Book {
  key ID : Integer;
  title  : String;

  @cascade: {insert, update}
  author : Association to Author;
}

entity Author {
  key ID : Integer;
  name   : String;
}
```

::: warning _Warning_
- For inactive draft entities `@cascade` annotations are ignored.

- The `@cascade` annotation is not respected by foreign key constraints on the database. To avoid unexpected behaviour you might have to disable a foreign key constraint with [`@assert.integrity:false`](../../guides/databases#database-constraints).
:::

#### Deep Insert / Upsert { #deep-insert-upsert}

[Insert](./query-api#insert) and [upsert](./query-api#upsert) statements for an entity have to include the keys and (optionally) data for the entity's composition targets. The targets are inserted or upserted along with the root entity.

```java
Iterable<Map<String, Object>> books;

CqnInsert insert = Insert.into("bookshop.Books").entries(books);
Result result = service.run(insert);

CqnUpsert upsert = Upsert.into("bookshop.Books").entries(books);
Result result = service.run(upsert);
```


#### Cascading Delete

The [delete](./query-api) operation is cascaded along the entity's compositions. All composition targets that are reachable from the (to be deleted) entity are deleted as well.

The following example deletes the order with ID *1000* including all its items:

```java
CqnDelete delete = Delete.from("bookshop.Orders").matching(singletonMap("OrderNo", 1000));
long deleteCount = service.run(delete).rowCount();
```

## Views and Projections { #views }

With CDS [views](../../cds/cdl#views-projections) you can derive new entities from existing ones, for example to rename or exclude certain elements, or to add [virtual elements](../../cds/cdl#virtual-elements-in-views) for specific use cases.

From the CDS model the CDS compiler generates [DDL](../../guides/databases?impl-variant=java#generating-sql-ddl) files, which include SQL views for the CDS views. These views are deployed to the [database](../cqn-services/persistence-services#database-support) and used by the CAP runtime to read data.

For *read-only* views, you can use the full feature set of [selects](../../cds/cdl#as-select-from), including *aggregations* to summarize, as well as *joins* and *unions* to combine data from multiple entities. However, such complex views are *not writable* and require a schema redeployment if the view definition is changed.

::: warning Annotate read-only views and elements
Use the `@readonly` annotation to indicate that a view or a view element is not writable, as this is not automatically detected by the CDS compiler.
:::

To [write data](#updatable-views) or [delete](#delete-via-view) through views, only use simple [projections](../../cds/cdl#as-projection-on). The CAP Java runtime attempts to resolve the CDS views to their underlying persistence entities, rewriting the statement and data accordingly, which is not supported for complex views.

For simple [projections](../../cds/cdl#as-projection-on), the generation of SQL views can be avoided by using [runtime views](#runtimeviews). This allows you to change the view definition without redeploying the database schema and is the prerequisite for lightweight extensibility via predefined extension fields.

::: tip Prefer simple views
Apply the *Interface Segregation Principle*: design multiple simple views, each for a specific use case ([Single-Purposed Services](../../guides/providing-services#single-purposed-services)), rather than one complex view for many scenarios.
:::
::: warning Avoid selecting paths over to-many Associations
Do not use [path expressions](../../cds/cql#path-expressions-in-all-other-clauses) over [*to-many associations*](../../cds/cdl#to-many-associations) in the select clause of CDS views. This blocks write operations and may cause performance issues due to record duplication on read.
:::
::: warning Avoid composition definitions in views
Avoid [defining](../../cds/cql#association-definitions) new *compositions* in CDS views and prefer *associations* instead, as [deep write](#updatable-views) and [cascading delete](#delete-via-view) are only supported for compositions in persistence entities.
:::

### Write through Views { #updatable-views }

You can run [insert](./query-api#insert), [upsert](./query-api#upsert), and [update](./query-api#update) statements on CDS views that are writable on the database or can be resolved to a single persistence entity by the CAP Java runtime.

CDS views must fulfill the following requirements to be resolvable:

- The view is a simple [projection](../../cds/cdl#as-projection-on), not using *aggregations*, *join*, *union*, or *where*.
- The projection includes all *not null* elements (incl. keys), unless they have a default or generated value.
- The projection does not include [path expressions](../../cds/cql#path-expressions) using *to-many* associations.

If the runtime cannot resolve a view, the write operation is executed directly on the database view and the execution depends on the [database](../cqn-services/persistence-services#database-support) support.

For example, the following CDS model defines two resolvable views on the `Order` entity, which has a to-many *items* and a to-one *header* composition to a Header entity with a to-one customer *association*. In the projection, you can use path expressions as shown by *headerStatus* (writable) and *customerName* (read-only):

```cds
// CDS views supporting write operations
entity OrderView1 as projection on Order excluding { createdBy };

entity OrderView2 as projection on OrderView1 {
  key ID,
      header.status          as headerStatus,  // writable composition path
      header.customer.name   as customerName @readonly,
      items                  as lineItems,        // writable composition
      toUpper(shipToCountry) as country : String  // ignored on write
};
```
```sql
UPDATE entity OrderView2
  { ID: 42, headerStatus: 'Processing', lineItems: [{ID: 1, book:251}] }
```
- Data for elements corresponding to *expressions* and *functions* (*country*) is ignored.
- [Deep write](./query-execution#deep-insert-upsert) via (aliased) compositions (*lineItems*) is supported if there are corresponding compositions (*items*) in the underlying entity definition. Deep write via compositions that are only defined in the view (for example via [mixins](../../cds/cql#association-definitions)) is not supported and the data is ignored.
- [Path expressions](../../cds/cql#path-expressions) over compositions *of one* (*header.status*) are writable. For [inserts](./query-api#insert), the view must expose all *not null* elements of the target entity and the data must include values for all of them. In the example above, the order header must have a generated key to support inserting new orders with a value for *headerStatus*.

    ::: warning Path Expressions over Associations
    Path expressions navigating *associations* (*header.customer.name*) are [not writable](#cascading-over-associations) by default. To avoid issues on write, annotate them with [@readonly](../../guides/providing-services#readonly).
    :::

### Delete through Views { #delete-via-view }

The CAP Java runtime attempts to resolve [deletes](./query-api#delete) on CDS views to the underlying persistence entity definitions and the [write through views](#updatable-views) restrictions apply accordingly.

If a view cannot be resolved, the delete operation is executed directly on the database view and the execution depends on the [database](../cqn-services/persistence-services#database-support) support.

::: danger Delete cascades on persistence entity level
[Cascading delete](./query-execution#cascading-delete) is applied on persistence entity level only, including compositions that are excluded from the view.
Compositions that are [added](../../cds/cql#association-definitions) in CDS views, as well as changes to compositions (such as filters and redirects) are not considered.
:::

For example, the following CDS model defines `Order` with header and items, and `OrderView` which excludes header and exposes items as `lineItems`:

```cds
entity Order : cuid, managed {
      header : Composition of one OrderHeader;
      items  : Composition of many OrderItem on items.parent = $self;
}
entity OrderView as projection on db.Order {
  ID,
  items as lineItems,
  delivery : Composition of one Delivery on delivery.order = $self
}
```
```sql
DELETE from OrderView where ID = 42
```
The delete operation is resolved to the underlying `Order` entity with ID *42* and cascades over the `header` and `items` compositions. The `delivery` composition, which is only defined in the view, is ignored and does not cascade the delete operation to `Delivery`.

### Runtime Views { #runtimeviews }

To add or update CDS views without redeploying the database schema, annotate them with [@cds.persistence.skip](../../guides/databases#cds-persistence-skip). This advises the CDS compiler to skip generating database views for these CDS views. Instead, CAP Java resolves them *at runtime* on each request.

Runtime views must be simple [projections](../../cds/cdl#as-projection-on), not using *aggregations*, *join*, *union* or *subqueries* in the *from* clause, but may have a *where* condition if they are only used to read. On write, the restrictions for [write through views](#updatable-views) apply in the same way as for standard CDS views. However, if a runtime view cannot be resolved, a fallback to database views is not possible, and the statement fails with an error.

CAP Java provides two modes for resolving runtime views during read operations: [cte](#rtview-cte) and [resolve](#rtview-resolve). 

::: details Changing the runtime view mode
To globally set the runtime view mode, use the property `cds.sql.runtimeView.mode` with value `cte` (the default) or `resolve` in the *application.yml*. To set the mode for a specific runtime view, annotate it with `@cds.java.runtimeView.mode: cte|resolve`.

To set the mode for a specific query, use a [hint](#hana-hints):

```Java
Select.from(BooksWithLowStock).hint("cds.sql.runtimeView.mode", "resolve");
```
:::

The next two sections introduce both modes using the following CDS model and query:

```cds
entity Books {
  key ID     : UUID;
      title  : String;
      stock  : Integer;
      author : Association to one Authors;
}
@cds.persistence.skip
entity BooksWithLowStock as projection on Books {
    ID, title, author.name as author
} where stock < 10; // makes the view read only
```
```sql
SELECT from BooksWithLowStock where author = 'Kafka'
```


#### Read in `cte` mode { #rtview-cte }

This is the default mode since CAP Java `4.x`. The runtime translates the [view definition](#runtimeviews) into a _Common Table Expression_ (CTE) and sends it with the query to the database.

```sql
WITH BOOKSWITHLOWSTOCK_CTE AS (
    SELECT B.ID,
           B.TITLE,
           A.NAME AS "AUTHOR"
      FROM BOOKS B
      LEFT OUTER JOIN AUTHOR A ON B.AUTHOR_ID = A.ID
     WHERE B.STOCK < 10
)
SELECT ID, TITLE, AUTHOR AS "author"
  FROM BOOKSWITHLOWSTOCK_CTE
 WHERE A.NAME = ?
```

::: tip CAP Java 3.10
Enable *cte* mode with *cds.sql.runtimeView.mode: cte*
:::

#### Read in `resolve` mode { #rtview-resolve }

The runtime _resolves_ the [view definition](#runtimeviews) to the underlying persistence entities and executes the query directly against the corresponding tables.

```sql
SELECT B.ID, B.TITLE, A.NAME AS "author"
  FROM BOOKS AS B
  LEFT OUTER JOIN AUTHORS AS A ON B.AUTHOR_ID = A.ID
 WHERE B.STOCK < 10 AND A.NAME = ?
```

::: info Limitations of `resolve` mode
Using associations that are only [defined](../../cds/cql#association-definitions) in the view, as well as complex draft queries are not supported in *resolve* mode.
:::
::: info Pessimistic locking on PostgreSQL
On PostgreSQL, some [pessimistic locking](#pessimistic-locking) queries on runtime views navigating associations require the *cte* mode.
:::

### Draft Queries on Views { #draft-views }

When draft-enabling a CDS view, the CDS Compiler creates a corresponding draft persistence table for this view. [Draft activate](../fiori-drafts#editing-drafts) updates the active entity via the view. 

That means:
<br>
-> [Draft-enabled](../fiori-drafts#reading-drafts) CDS views must fulfill all requirements of [updatable views](#updatable-views).
{.indent}

Remember to run draft specific queries through the [Draft Service](../fiori-drafts#draftservices) or [Application Service](../cqn-services/application-services#application-services). The [Persistence Service](../cqn-services/persistence-services) only works for non-draft specific queries.


::: tip Draft queries on runtime views
If you define runtime views on [draft-enabled](../fiori-drafts#reading-drafts) entities and want to run draft specific queries on these views, set the [*cds.drafts.persistence*](../fiori-drafts#reading-drafts) configuration to `split`.
:::

::: warning Avoid draft-enabling runtime views
Draft-enabling runtime views is only supported in [*CTE*](#rtview-cte) mode and requires a schema deployment to update the draft table when the runtime view is changed.
:::

### Views on Remote Services

When delegating queries between Application Services and Remote Services, statements are resolved to the targeted service's entity definition by the CAP Java runtime. 

For read, the CDS views are resolved similar to the runtime view [resolve](#rtview-resolve) mode. For write operations, views targeting *remote OData* services must fulfill the following:

- all requirements of [writable views](#updatable-views)
- not include [calculated elements](../../cds/cdl#calculated-elements)

If a view cannot be resolved, read and write operations are rejected.


## Concurrency Control

Concurrency control allows protecting your data against unexpected concurrent changes.

### Optimistic Locking {#optimistic}

Use _optimistic_ concurrency control to detect concurrent modification of data _across requests_. The implementation relies on an _ETag_, which changes whenever an entity instance is updated. Typically, the ETag value is stored in an element of the entity.

#### Optimistic Concurrency Control in OData

In the [OData protocol](../../guides/providing-services#etag), the implementation relies on `ETag` and `If-Match` headers in the HTTP request.

The `@odata.etag` annotation indicates to the OData protocol adapter that the value of an annotated element should be [used as the ETag for conflict detection](../../guides/providing-services#etag):

{#on-update-example}

```cds
entity Order : cuid {
    @odata.etag
    @cds.on.update : $now
    @cds.on.insert : $now
    modifiedAt : Timestamp;
    product : Association to Product;
}
```

#### The ETag Predicate {#etag-predicate}

An ETag can also be used programmatically in custom code. Use the `CqnEtagPredicate` to specify the expected ETag values in an update or delete operation. ETag checks are not executed on upsert. You can create an ETag predicate using the `CQL.eTag` or the `StructuredType.eTag` methods.

```java
PersistenceService db = ...
Instant expectedLastModification = ...;
CqnUpdate update = Update.entity(ORDER).entry(newData)
                         .where(o -> o.id().eq(85).and(
                                     o.eTag(expectedLastModification)));

Result rs = db.execute(update);

if (rs.rowCount() == 0) {
    // order 85 does not exist or was modified concurrently
}
```

In the previous example, an `Order` is updated. The update is protected with a specified ETag value (the expected last modification timestamp). The update is executed only if the expectation is met.

::: warning Application has to check the result
No exception is thrown if an ETag validation does not match. Instead, the execution of the update (or delete) succeeds but doesn't apply any changes. Ensure that the application checks the `rowCount` of the `Result` and implement your error handling. If the value of `rowCount` is 0, that indicates that no row was updated (or deleted).
:::


#### Providing new ETag Values with Update Data

A convenient option to determine a new ETag value upon update is the [@cds.on.update](../../guides/domain-modeling#cds-on-update) annotation as in the [example above](#on-update-example). The CAP Java runtime automatically handles the `@cds.on.update` annotation and sets a new value in the data before the update is executed. Such _managed data_ can be used with ETags of type `Timestamp` or `UUID` only.

We do not recommend providing a new ETag value by custom code in a `@Before`-update handler. If you do set a value explicitly in custom code and an ETag element is annotated with `@cds.on.update`, the runtime does not generate a new value upon update for this element. Instead, the value that comes from your custom code is used.

#### Runtime-Managed Versions <Beta />

Alternatively, you can store ETag values in _version elements_. For version elements, the values are exclusively managed by the runtime without the option to set them in custom code. Annotate an element with `@cds.java.version` to advise the runtime to manage its value.

```cds
entity Order : cuid {
    @odata.etag
    @cds.java.version
    version : Int32;
    product : Association to Product;
}
```

Compared to `@cds.on.update`, which allows for ETag elements with type `Timestamp` or `UUID` only, `@cds.java.version` additionally supports all integral types `Uint8`, ... `Int64`. For timestamp, the value is set to `$now` upon update, for elements of type UUID a new UUID is generated, and for elements of integral type the value is incremented.

Version elements can be used with an [ETag predicate](#etag-predicate) to programmatically check an expected ETag value. Moreover, if additionally annotated with `@odata.etag`, they can be used for [conflict detection](../../guides/providing-services#etag) in OData.

##### Expected Version from Data

If the update data contains a value for a version element, this value is used as the _expected_ value for the version. This allows using version elements in a programmatic flow conveniently:

```java
PersistenceService db = ...
CqnSelect select = Select.from(ORDER).byId(85);
Order order = db.run(select).single(Order.class);

order.setAmount(5000);

CqnUpdate update = Update.entity(ORDER).entry(order);
Result rs = db.execute(update);

if (rs.rowCount() == 0) {
    // order 85 does not exist or was modified concurrently
}
```

During the execution of the update statement it's asserted that the `version` has the same value as the `version`, which was read previously and hence no concurrent modification occurred.

The same convenience can be used in bulk operations. Here the individual update counts need to be introspected.

```java
CqnSelect select = Select.from(ORDER).where(o -> amount().gt(1000));
List<Order> orders = db.run(select).listOf(Order.class);

orders.forEach(o -> o.setStatus("cancelled"));

Result rs = db.execute(Update.entity(ORDER).entries(orders));

for(int i = 0; i < orders.size(); i++) if (rs.rowCount(i) == 0) {
    // order does not exist or was modified concurrently
}
```

> If an [ETag predicate is explicitly specified](#providing-new-etag-values-with-update-data), it overrules a version value given in the data.


### Pessimistic Locking { #pessimistic-locking}

Use database locks to ensure that data returned by a query isn't modified in a concurrent transaction.
_Exclusive_ locks block concurrent modification and the creation of any other lock. _Shared_ locks, however, only block concurrent modifications and exclusive locks but allow the concurrent creation of other shared locks.

To lock data:
1. Start a transaction (either manually or let the framework take care of it).
2. Query the data and set a lock on it.
3. Perform the processing and, if an exclusive lock is used, modify the data inside the same transaction.
4. Commit (or roll back) the transaction, which releases the lock.

To be able to query and lock the data until the transaction is completed, just call a [`lock()`](./query-api#write-lock) method and set an optional parameter `timeout`.

In the following example, a book with `ID` 1 is selected and locked until the transaction is finished. Thus, one can avoid situations when other threads or clients are trying to modify the same data in the meantime:

```java
// Start transaction
// Obtain and set a write lock on the book with id 1
	service.run(Select.from("bookshop.Books").byId(1).lock());
	...
// Update the book locked earlier
	Map<String, Object> data = Collections.singletonMap("title", "new title");
	service.run(Update.entity("bookshop.Books").data(data).byId(1));
// Finish transaction
```

The `lock()` method has an optional parameter `timeout` that indicates the maximum number of seconds to wait for the lock acquisition. If a lock can't be obtained within the `timeout`, a `CdsLockTimeoutException` is thrown. If `timeout` isn't specified, a database-specific default timeout will be used.

The parameter `mode` allows to specify whether an `EXCLUSIVE` or a `SHARED` lock should be set.


## Using I/O Streams in Queries

As described in section [Predefined Types](../cds-data#predefined-types) it's possible to stream the data, if the element is annotated with `@Core.MediaType`. The following example demonstrates how to allocate the stream for element `coverImage`, pass it through the API to an underlying database and close the stream.

Entity `Books` has an additional annotated element `coverImage : LargeBinary`:

```cds
entity Books {
  key ID : Integer;
  title  : String;
  ...
  @Core.MediaType
  coverImage : LargeBinary;
}
```

Java snippet for creating element `coverImage` from file `IMAGE.PNG` using `java.io.InputStream`:

```java
// Transaction started

Result result;
try (InputStream resource = getResource("IMAGE.PNG")) {
    Map<String, Object> book = new HashMap<>();
    book.put("title", "My Fancy Book");
    book.put("coverImage", resource);

    CqnInsert insert = Insert.into("bookshop.Books").entry(book);
    result = service.run(insert);
}

// Transaction finished
```

## Using Native SQL

CAP Java doesn't have a dedicated API to execute native SQL Statements. However, when using Spring as application framework you can leverage Spring's features to execute native SQL statements. See [Execute SQL statements with Spring's JdbcTemplate](../cqn-services/persistence-services#jdbctemplate) for more details.


## Query Result Processing { #result}

The result of a query is abstracted by the `Result` interface, which is an iterable of `Row`. A `Row` is a `Map<String, Object>` with additional convenience methods and extends [CdsData](../cds-data#cds-data).

You can iterate over a `Result`:

```java
Result result = ...

for (Row row : result) {
  System.out.println(row.get("title"));
}
```

Or process it with the [Stream API](https://docs.oracle.com/javase/8/docs/api/?java/util/stream/Stream.html):

```java
Result result = ...

result.forEach(r -> System.out.println(r.get("title")));

result.stream().map(r -> r.get("title")).forEach(System.out::println);
```

If your query is expected to return exactly one row, you can access it with the `single` method:

```java
Result result = ...

Row row = result.single();
```

If it returns a result, like a `find by id` would, you can obtain it using `first`:

```java
Result result = ...

Optional<Row> row = result.first();
row.ifPresent(r -> System.out.println(r.get("title")));
```

The `Row`'s `getPath` method supports paths to simplify extracting values from nested maps. This also simplifies extracting values from results with to-one expands using the generic accessor. Paths with collection-valued segments and infix filters are not supported.

```java
CqnSelect select = Select.from(BOOKS).columns(
     b -> b.title(), b -> b.author().expand()).byId(101);
Row book = dataStore.execute(select).single();

String author = book.getPath("author.name");
```

### Null Values

A result row _may_ contain `null` values for an element of the result if no data is present for the element in the underlying data store.

Use the `get` methods to check if an element is present in the result row:

  ```java
  if (row.get("name") == null) {
     // handle mising value for name
  }
  ```

Avoid using `containsKey` to check for the presence of an element in the result row. Also, when iterating the elements of the row, keep in mind, that the data _may_ contain `null` values:

  ```java
  row.forEach((k, v) -> {
    if (v == null) {
     // handle mising value for element v
    }
 });
  ```

### Typed Result Processing

The element names and their types are checked only at runtime. Alternatively you can use interfaces to get [typed access](../cds-data#typed-access) to the result data:

```java
interface Book {
  String getTitle();
  Integer getStock();
}

Row row = ...
Book book = row.as(Book.class);

String title = book.getTitle();
Integer stock = book.getStock();
```

Interfaces can also be used to get a typed list or stream over the result:

```java
Result result = ...

List<Book> books = result.listOf(Book.class);

Map<String, String> titleToDescription =
  result.streamOf(Book.class).collect(Collectors.toMap(Book::getTitle, Book::getDescription));
```

For the entities defined in the data model, CAP Java SDK can generate interfaces for you through [a Maven plugin](../cqn-services/persistence-services#staticmodel).


### Entity References {#entity-refs}

For result rows that contain all key values of an entity, you get an [entity reference](./query-api#entity-refs) via the `ref()` method. This reference addresses the entity via the key values from the result row.

```java
// SELECT from Author[101]
CqnSelect query = Select.from(AUTHOR).byId(101);
Author authorData = service.run(query).single(Author.class);

String authorName = authorData.getName();    // data access
Author_ author    = authorData.ref();        // typed reference to Author[101]
```

Similar for untyped results:

```java
Row authorData = service.run(query).single();
StructuredType<?> author = authorData.ref(); // untyped reference to Author[101]
```

This also works for `Insert` and `Update` results:

```java
CqnUpdate update = Update.entity(AUTHOR).data("name", "James Joyce").byId(101);
Author_ joyce = service.run(update).single(Author.class).ref();
```

Using entity references you can easily write CDS QL statements targeting the source entity:

```java
// SELECT from Author[101].books { sum(stock) as stock }
CqnSelect q = Select.from(joyce.books())
     .columns(b -> func("sum", b.stock()).as("stock"));

CqnInsert i = Insert.into(joyce.books())
     .entry("title", "Ulysses");

CqnUpdate u = Update.entity(joyce.biography())
     .data("price", 29.95);

CqnDelete d = Delete.from(joyce.address())
     .where(b -> b.stock().lt(1));
```

### Introspecting the Row Type

The `rowType` method allows to introspect the element names and types of a query's `Result`. It returns a `CdsStructuredType` describing the result in terms of the [Reflection API](../reflection-api):

```java
CqnSelect query = Select.from(AUTHOR)
     .columns(a -> a.name().as("authorName"), a -> a.age());

Result result = service.run(query);

CdsStructuredType rowType = result.rowType();
rowType.elements(); // "authorName", "age"
rowType.getElement("age").getType().getQualifiedName();  // "cds.Integer"
rowType.findElement("ID"); // Optional.empty()
```



# Introspecting CQL Statements


API to introspect CDS Query Language (CQL) statements in Java.


## Introduction

Handlers of [CQN-based services](../cqn-services/#cdsservices) often need to understand the incoming CQN statements.

The statement analysis can be done in two different ways. Depending on the complexity of the statement it can be done using:

- CQN Analyzer: A specialized API to extract filter values from filter predicates of queries, and to analyze the structure and filters of references
- CQN Visitor: A general purpose API, to traverse CQN token trees such as expressions, predicates, values etc.

### CqnAnalyzer vs. CqnVisitor

The `CqnAnalyzer` allows for analysis and extraction of element values for most of the queries, but it comes with some limitations. The main rule here is:

::: tip
The value of an element reference in a `where` and `filter` predicate must be unambiguously identified.
:::

This implies the following:

- The operator of comparison predicate must be either `eq` or `is`:

```java
Select.from("bookshop.Book").where(b -> b.get("ID").eq(42));
```

- Only the conjunction `and` is used to connect predicates:

```java
Select.from("bookshop.Book")
	.where(b -> b.get("ID").eq(42).and(b.get("title").is("Capire")));
```

This rule also applies to all segments of all references of the query, be it simple query or the one with path expression:

```java
Select.from("bookshop.Book",
	b -> b.filter(b.get("ID").eq(41))
		.to("author").filter(a -> a.get("Id").eq(1)));
```

### When to Use What

Use `CqnAnalyzer` when element references of the query are:
 - Unambiguously mapped to a value by: a comparison predicate using `eq` or `is`, used in `byId`, or a `matching` clause
 - Used in conjunction (`and`) predicates

Use `CqnVisitor` when element references of the query are:
- Compared with `lt`, `gt`, `le`, `ge`, `ne`, `isNot` operator
- Used within `in`
- Negated with `not`
- Used in `search`
- Used in functions
- Used in subqueries
- Referencing elements of an associated entity


## CqnAnalyzer

The [CQL](../../cds/cql) introspection API allows to analyze [CQL](../../cds/cql) statements and extract values and information on the CDS entities in references.

The [CqnAnalyzer](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/cqn/CqnAnalyzer.html) can be constructed from a [CDS model](../reflection-api#the-cds-model):

```java
import com.sap.cds.ql.cqn.CqnAnalyzer;

CdsModel cdsModel = context.getModel();
CqnAnalyzer cqnAnalyzer = CqnAnalyzer.create(cdsModel);
```

Furthermore, the static `isCountQuery(cqn)` method can be used to check if a [CQL](../../cds/cql) query only returns a single count:

```java
// cqn: Select.from("Books").columns(CQL.count().as("bookCount"));
boolean isCount = CqnAnalyzer.isCountQuery(cqn);  // true
```

### Usage

Given the following CDS model and CQL query:

```cds
entity Orders {
  key OrderNo : String;
  Items       : Composition of many OrderItems on Items.parent = $self;
  ...
}
entity OrderItems {
  key ID : Integer;
  book   : Association to Books;
  ...
}
```

[Find this source also in **cap/samples**.](https://github.com/sap-samples/cloud-cap-samples-java/blob/5396b0eb043f9145b369371cfdfda7827fedd039/db/schema.cds#L31-L36){.learn-more}


```sql
--CQL query
SELECT from Orders[OrderNo = '42']:items[ID = 1]
```

the corresponding CQN statement can be analyzed using the `analyze` method of the `CqnAnalyzer`:

```java
CqnStatement cqn = context.getCqn();

AnalysisResult result = cqnAnalyzer.analyze(cqn.ref());
```

### Resolving CDS Entities

Based on the `AnalysisResult`, information on the CDS entities can be accessed through the [Reflection API](../reflection-api):


```java
CdsEntity order = result.rootEntity();   // Orders
CdsEntity item  = result.targetEntity(); // OrderItems
```

### Extracting Filter Values

A non-complex filter predicate might map (restrict) some element to a particular _filter value_. If some filter values can be _unambiguously_ determined, the `CqnAnalyzer` can extract these filter values and return them as a `Map`. A filtered data set will contain only data that matches the filter values.

Examples:

```sql
WHERE name = 'Sue'
WHERE name = 'Bob' AND age = 50
WHERE name = 'Alice' AND (age = 25 OR age = 35)
WHERE name = 'Alice' AND age = 25 OR name = 'Alice' AND age = 35
```

The first example above maps `name` to `Sue`. The second example maps `name` to 'Bob' and `age` to 50. In the third example only `name` is unambigously mapped to 'Alice' but a value for `age` can't be extracted. The fourth example is equivalent to the third.

The key values of the entities can be extracted as a map using the `rootKeys` and `targetKeys` method of the `AnalysisResult` object:

```java
Map<String, Object> rootKeys = result.rootKeys();
String orderNo = (String) rootKeys.get("OrderNo"); // 42

Map<String, Object> targetKeys  = result.targetKeys();
Integer itemId = (Integer) targetKeys.get("ID");   // 1
```

To extract all filter values of the target entity including non-key values, the `targetValues` method can be used:

```java
Map<String, Object> filterValues = result.targetValues();
```

For `CqnSelect`, `CqnUpdate`, and `CqnDelete`, values can also be extracted from the statement's `where` condition:

```sql
--CQL query
SELECT from Orders[OrderNo = '42'].items where ID = 3 and status = 'open'
```

```java
CqnSelect select = context.getCqn();
AnalysisResult result = cqnAnalyzer.analyze(select);

Map<String, Object> targetKeys = result.targetKeys();
Integer itemId = (Integer) targetKeys.get("ID");   // 3

Map<String, Object> filterValues = result.targetValues();
String status = (String) filterValues.get("status");   // 'open'
```

### Using the Iterator

The methods prefixed with `root` and `target` access the first respectively last segment of the CQN statement's reference.
If the reference has more than two segments, such as:

```sql
--CQL query
SELECT from Orders[OrderNo = '42']:items[ID = 1].book
```

the segment `items` can be analyzed using an iterator:

```java
Iterator<ResolvedSegment> iterator = result.iterator();
CdsEntity order = iterator.next().entity();
CdsEntity item  = iterator.next().entity();
CdsEntity book  = iterator.next().entity();
```

or a reverse iterator starting from the last segment:

```java
Iterator<ResolvedSegment> iterator = result.reverse();
CdsEntity book  = iterator.next().entity();
CdsEntity item  = iterator.next().entity();
CdsEntity order = iterator.next().entity();
```

In the same way, also the filter values for each segment can be extracted using the `values` and `keys` method instead of the `entity` method.

## CqnVisitor

`CqnVisitor` interface is part of a public API, which allows to traverse CQN token trees such as expressions, predicates, values etc. It follows the Visitor design pattern.

When a visitor is passed to a token's `accept` method, it is traversed through the token's expression tree. Generally the `accept` methods of the token's children are called first (depth-first). Afterwards the `visit` method that is most specific to the token is invoked. Classes implementing the `CqnVisitor` interface may override the default `visit` method to perform arbitrary operations.

### Fields of Application

It is a powerful tool, which can be handy to introspect the complex queries and its compound parts. It can be used to analyze the information about:
- Element references
- Expand associations
- Connective predicates (`and`, `or`)
- Comparison predicates with binary (`gt`, `lt`, `ne`, etc.) and unary (`not`) operators
- `search` and `in` predicates
- Functions and expressions
- Literals and parameters

### Usage

In the following example, the `CqnVisitor` is used to evaluate whether the data matches a given filter expression.

#### Data

```java
List<Map<String, Object>> books = new ArrayList<>();
books.add(ImmutableMap.of("title", "Catweazle", "stock", 3));
books.add(ImmutableMap.of("title", "The Raven", "stock", 42));
books.add(ImmutableMap.of("title", "Dracula", "stock", 66));
```

#### Filter

```java
Predicate titles = CQL.get("title").in("Catweazle", "The Raven");
Predicate stock = CQL.get("stock").gt(10);

// title IN ('Catweazle', 'The Raven') AND stock > 10
Predicate filter = CQL.and(titles, stock);
```

The `filter` consists of three predicates, substituting the following tree:

```zsh
                                       AND
                    ┌───────────────────┴───────────────────┐
                    IN                                      GT
        ┌───────────┴───────────┐                   ┌───────┴───────┐
      title        ['Catweazle', 'The Raven']     stock             10
```

which corresponds to the following CQN token tree (numbers in brackets show the visit order):

```txt
                            CqnConnectivePredicate (8)
                  ┌───────────────────┴───────────────────┐
            CqnInPredicate (4)                  CqnComparisonPredicate (7)
      ┌───────────┴───────────┐               ┌───────────┴───────────┐
CqnElementRef (1)     CqnLiteral (2, 3)  CqnElementRef (5)      CqnLiteral (6)
```

#### Visitor

As already mentioned, the `CqnAnalyzer` is not suitable to analyze such a predicate, as neither the element `title` nor `stock` is uniquely restricted to a single value.

To overcome this issue a `CqnVisitor` is to be implemented to evaluate whether the `data` meets the filter expression. The visitor has access to the `data` that is checked. To respect the depth-first traversal order, it uses a `stack` to store intermediate results:

```java
class CheckDataVisitor implements CqnVisitor {
    private final Map<String, Object> data;
    private final Deque<Object> stack = new ArrayDeque<>();

    CheckDataVisitor(Map<String, Object> data) {
        this.data = data;
    }

    boolean matches() {
        return (Boolean) stack.pop();
    }
    ...
}
```

On the leaf-level, the stack is used to store the concrete values from both data payload and filter expression:

```java
@Override
public void visit(CqnElementRef ref) {
    Object dataValue = data.get(ref.displayName());
    stack.push(dataValue);
}

@Override
public void visit(CqnLiteral<?> literal) {
    stack.push(literal.value());
}
```

When visiting the predicates, the values are popped from the stack and evaluated based on the predicate type and comparison operator. The `Boolean` result of the evaluation is pushed to the stack:

```java
@Override
public void visit(CqnInPredicate in) {
    List<Object> values = in.values().stream()
            .map(v -> stack.pop()).collect(toList());
    Object value = stack.pop();
    stack.push(values.stream().anyMatch(value::equals));
}

@Override
public void visit(CqnComparisonPredicate comparison) {
    Comparable rhs = (Comparable) stack.pop();
    Comparable lhs = (Comparable) stack.pop();
    int cmp = lhs.compareTo(rhs);
    switch (comparison.operator()) {
    case EQ:
        stack.push(cmp == 0);
        break;
    case GT:
        stack.push(cmp > 0);
        break;
    // ...
    }
}
```

The `visit` method of the `CqnConnectivePredicate` pops the `Boolean` evaluation results from the stack, applies the corresponding logical operator, and pushes the result to the stack:

```java
@Override
public void visit(CqnConnectivePredicate connect) {
    Boolean rhs = (Boolean) stack.pop();
    Boolean lhs = (Boolean) stack.pop();
    switch (connect.operator()) {
    case AND:
        stack.push(lhs && rhs);
        break;
    case OR:
        stack.push(lhs || rhs);
        break;
    }
}
```

The whole process can be considered as a reduce operation when traversing the tree from bottom to top.

To evaluate whether given `data` matches the filter expression, an instance `v` of the visitor is created. Afterwards the filter's accept method traverses its expression tree with the visitor, which evaluates the expression during the traversal:

```java
for (Map<String, Object> book : books) {
    CheckDataVisitor v = new CheckDataVisitor(book);
    filter.accept(v);
    System.out.println(book.get("title") + " " +
            (v.matches() ? "match" : "no match"));
}
```

The output will be:

```txt
Catweazle	no match
The Raven	match
Dracula		no match
```



# Services


[Services](../about/best-practices#services) are one of the core concepts of CAP. This section describes how services are represented in the CAP Java SDK and how their event-based APIs can be used. One of the key APIs provided by services is the uniform query API based on [CQN statements](working-with-cql/query-api).

## An Event-Based API

Services dispatch events to [Event Handlers](event-handlers/), which implement the behaviour of the service.
A service can process synchronous as well as asynchronous events and offers a user-friendly API layer around these events.

Every service implements the [Service](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/Service.html) interface, which offers generic event processing capabilities through its [emit(EventContext)](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/Service.html#emit-com.sap.cds.services.EventContext-) method.
The [Event Context](event-handlers/#eventcontext) contains information about the event and its parameters.
The `emit` method takes care of dispatching an Event Context to all event handlers registered on the respective event and is the central API to process asynchronous and synchronous events.

Usually service implementations extend the `Service` interface to provide a custom, user-friendly API layer on top of the `emit()` method. Examples are the [Application Service](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/ApplicationService.html), [Persistence Service](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/persistence/PersistenceService.html), and [Remote Service](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/RemoteService.html), which offer a common CQN query execution API for their CRUD events.
However, also technical components are implemented as services, for example the [AuthorizationService](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/authorization/AuthorizationService.html) or the [MessagingService](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/messaging/MessagingService.html).

### Using Services

Often times your Java code needs to interact with other services. The [ServiceCatalog](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/ServiceCatalog.html) provides programmatic access to all available services.
The Service Catalog can be accessed from the [Event Context](event-handlers/#eventcontext) or from the [CdsRuntime](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/runtime/CdsRuntime.html).

```java
ServiceCatalog catalog = context.getServiceCatalog();
Stream<Service> allServices = catalog.getServices();
Stream<ApplicationService> appServices = catalog.getServices(ApplicationService.class);
```

To look up a service in the Service Catalog, you need to know its name.
Application Services are created with the fully qualified name of their CDS definition by default:

```java
ApplicationService adminService = catalog.getService(ApplicationService.class, "AdminService");
```

As of version 2.4.0, the [CAP Java SDK Maven Plugin](./developing-applications/building#cds-maven-plugin) is capable of generating specific interfaces for services in the CDS model. These service interfaces also provide Java methods for actions and functions, which allows easily calling actions and functions with their parameters. These specific interfaces can also be used to get access to the service:

```java
AdminService adminService = catalog.getService(AdminService.class, "AdminService");
```

Technical services, like the Persistence Service have a `DEFAULT_NAME` constant defined in their interface:

```java
PersistenceService db = catalog.getService(PersistenceService.class, PersistenceService.DEFAULT_NAME);
```

When running in Spring, all services are available as Spring beans. Dependency injection can therefore be used to get access to the service objects:

```java
@Component
public class EventHandlerClass implements EventHandler {

    @Autowired
    private PersistenceService db;

    @Autowired
    @Qualifier("AdminService")
    private ApplicationService adminService;

}
```

Instead of the generic service interface, also the more specific service interfaces can be injected:

```java
@Component
public class EventHandlerClass implements EventHandler {

    @Autowired
    private PersistenceService db;

    @Autowired
    private AdminService adminService;

}
```
::: tip
For the injection of specific service interfaces the annotation `@Qualifier` is usually not required.
:::

## CQN-based Services

The most used services in CAP are the [CQN-based services](cqn-services/) which define APIs accepting CQN queries:

- [Application Services](cqn-services/application-services) exposed CDS services to clients.
- [Persistence Services](cqn-services/persistence-services) are CQN-based database clients.
- [Remote Services](cqn-services/remote-services) are CQN-based clients for remote APIs

## Application Lifecycle Service

The Application Lifecycle Service emits events when the `CdsRuntime` is fully initialized, but the application is not started yet, or when the application is stopped.
Its API and events are defined in the [ApplicationLifecycleService](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/application/ApplicationLifecycleService.html) interface.
You can use these events to register an event handler which performs custom initialization or shutdown logic.
In addition the Application Lifecycle Service provides an event to globally adapt the error response handling.

[Learn more about adapting the error response handling in section Indicating Errors.](./event-handlers/indicating-errors#errorhandler){.learn-more}



# CQN Services { #cdsservices }


The most used services in CAP are the CQN-based services. The most prominent of these are the Application Service, Persistence Service, and Remote Service.
Those services can handle CRUD events by accepting CQN statements. They all implement the common interface [CqnService](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/CqnService.html), which defines the CQN-based APIs.
::: tip
To learn more about how to run queries on these services, see sections [Building CQN Queries](../working-with-cql/query-api) and [Executing CQN Queries](../working-with-cql/query-execution).
:::

## Application Services

[Application Services](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/ApplicationService.html) define the APIs that are exposed by a CAP application to its clients. They're backed by a [CDS Service](../../cds/cdl#services) definition in the CDS model, which defines the structure of the API.
Consequently, they only accept CQN statements targeting entities that are defined as part of their service definition. Typically these services are served by protocol adapters, such as OData V4, which use their CQN-based APIs.

[Learn more about adding business logic to Application Services.](./application-services){.learn-more}

Application Services are automatically augmented with generic providers (built-in event handlers), which handle common aspects such as [authorization](../../guides/security/authorization), [input validation](../../guides/providing-services#input-validation), [implicit pagination](../../guides/providing-services#implicit-pagination) and many more.
Their default ON event handler delegates CQN statements to the Persistence Service.

[Learn more about these capabilities in our Cookbooks.](../../guides/){.learn-more}

The creation of Application Services can be customized through configuration. By default an Application Service is created for every service that is defined in the CDS model.
Through configuration, it's also possible to create multiple Application Services based on the same model definition.

[Learn more about the configuration possibilities in our CDS Properties Reference.](../developing-applications/properties){.learn-more}

### Draft Services { #draftservices}

If an Application Service is created based on a service definition, that contains a draft-enabled entity, it also implements the [DraftService](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/draft/DraftService.html) interface.
This interface provides an API layer around the [draft-specific events](../fiori-drafts#draftevents), and allows to create new draft entities, patch, cancel or save them, and put active entities back into edit mode.

[Learn more about Draft Services in section Fiori Drafts.](../fiori-drafts){.learn-more}

## Persistence Services { #persistenceservice}

[Persistence Services](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/persistence/PersistenceService.html) are CQN-based database clients. CAP applications most commonly use SQL databases like SAP HANA in production.
For test and development, it's also possible to use a light-weight, in-memory database such as [H2](https://www.h2database.com). The CAP Java SDK therefore provides a JDBC-based Persistence Service implementation out of the box.
However, also other Persistence Service implementations based on NoSQL databases, such as MongoDB, are possible, even if not provided by the CAP Java SDK ready to use.

[Learn more about supported databases and their restrictions.](./persistence-services#database-support){.learn-more}

A Persistence Service isn't bound to a specific service definition in the CDS model. It's capable of accepting CQN statements targeting any entity or view that is stored in the corresponding database.

Transaction management is built in to Persistence Services. They take care of lazily initializing and maintaining database transactions as part of the active changeset context.

Some generic providers are registered on Persistence Services instead of on Application Services, like the ones for [managed data](../../guides/domain-modeling#managed-data).
This ensures that the functionality is also triggered, when directly interacting with a Persistence Service.

The Persistence Service is used when implementing event handlers for Application Services, for example when additional data needs to be read when performing custom validations.
Additionally, the default ON event handler of Application Services delegates CQN statements to the default Persistence Service.

[Learn more about how Persistence Services are created and configured.](./persistence-services){.learn-more}

## Remote Services

[Remote Services](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/RemoteService.html) are CQN-based clients for remote APIs, for example OData. They're backed by a [CDS Service](../../cds/cdl#services) definition, that reflects the structure of the remote API. The CDS service definition is usually [imported](../../guides/using-services#external-service-api), for example from an EDMX specification.

They can be used when integrating APIs provided by the application with APIs provided by other applications or micro-services. This integration can happen synchronously by delegating CQN statements from Application Services to Remote Services or asynchronously by using Remote Services to replicate data into the applications own persistence.

Remote Services need to be explicitly configured and are never created automatically. The configuration of a Remote Service specifies the destination where the remote API is available and its protocol type.
It's also possible to create multiple Remote Services with different destinations based on the same model definition.
If a Remote Service is created for a service definition in the CDS model, no Application Service is automatically created for that definition.

[Learn more about how to configure and use Remote Services.](./remote-services){.learn-more}



# Persistence Services


Persistence Services are CQN-based database clients. This section describes which database types are supported, how datasources to these databases are created and how they are turned into Persistence Services.

## Database Support { #database-support}

CAP Java has built-in support for various databases. This section describes the different databases and any differences between them with respect to CAP features. There's out of the box support for SAP HANA with CAP currently as well as H2 and SQLite. However, it's important to note that H2 and SQLite aren't enterprise grade databases and are recommended for non-productive use like local development or CI tests only. PostgreSQL is supported in addition, but has various limitations in comparison to SAP HANA, most notably in the area of schema evolution.

### SAP HANA Cloud

SAP HANA Cloud is the CAP standard database recommended for productive use with needs for schema evolution and multitenancy. Noteworthy:

1. Write operations through views that can't be resolved by the CAP runtime are passed through to SAP HANA Cloud. Limitations are described in the [SAP HANA Cloud documentation](https://help.sap.com/docs/HANA_CLOUD_DATABASE/c1d3f60099654ecfb3fe36ac93c121bb/20d5fa9b75191014a33eee92692f1702.html#loio20d5fa9b75191014a33eee92692f1702__section_trx_ckh_qdb).

2. [Shared locks](../working-with-cql/query-execution#pessimistic-locking) are supported on SAP HANA Cloud only.

3. When using `String` elements in locale-specific ordering relations (`>`, `<`, ... , `between`), a statement-wide collation is added, which can have negative impact on the performance. If locale-specific ordering isn't required for specific `String` elements, annotate the element with `@cds.collate: false`.

```cds
entity Books : cuid {
    title        : localized String(111);
    descr        : localized String(1111);
    @cds.collate : false // [!code focus]
    isbn         : String(40);  // does not require locale-specific handling // [!code focus]
}
```
> When disabling locale-specific handling for a String element, binary comparison is used, which is generally faster but results in *case-sensitive* order (A, B, a, b).

::: info Disable Collating
To disable collating for all queries, set [`cds.sql.hana.ignoreLocale`](../developing-applications/properties#cds-sql-hana-ignoreLocale) to `true`.
:::

4. SAP HANA supports _Perl Compatible Regular Expressions_ (PCRE) for regular expression matching. If you need to match a string against a regular expression and are not interested in the exact number of the occurrences, consider using lazy (_ungreedy_) quantifiers in the pattern or the option `U`.

### PostgreSQL

CAP Java SDK is tested on [PostgreSQL](https://www.postgresql.org/) 15 and supports most of the CAP features. Known limitations are:

1. No locale specific sorting. The sort order of queries behaves as configured on the database.
2. Write operations through CDS views are only supported for views that can be [resolved](../working-with-cql/query-execution#updatable-views) or are [updatable](https://www.postgresql.org/docs/14/sql-createview.html#SQL-CREATEVIEW-UPDATABLE-VIEWS) in PostgreSQL.
3. The CDS type `UInt8` can't be used with PostgreSQL, as there's no `TINYINT`. Use `Int16` instead.
4. [Multitenancy](../../guides/multitenancy/) and [extensibility](../../guides/extensibility/) aren't yet supported on PostgreSQL.

### H2 Database

[H2](https://www.h2database.com/html/main.html) is the recommended in-memory database for local development and testing with CAP Java. There's no production support for H2 from CAP and there are the following limitations:

1. H2 only supports database-level collation and the default sort order is by ASCII-code. You can set a [collation](https://www.h2database.com/html/commands.html#set_collation) to sort using dictionary order instead.
2. Case-insensitive comparison isn't yet supported.
3. By default, views aren't updatable on H2. However, the CAP Java SDK supports some views to be updatable as described [here](../working-with-cql/query-execution#updatable-views).
4. Although referential and foreign key constraints are supported, H2 [doesn't support deferred checking](https://www.h2database.com/html/grammar.html#referential_action). As a consequence, schema SQL is never generated with referential constraints.
5. In [pessimistic locking](../working-with-cql/query-execution#pessimistic-locking), _shared_ locks are not supported but an _exclusive_ lock is used instead.
6. The CDS type `UInt8` can't be used with H2, as there is no `TINYINT`. Use `Int16` instead.
7. For regular expressions, H2's implementation is compatible with Java's: the matching behaviour is an equivalent of the `Matcher.find()` call for the given pattern.

::: warning
Support for localized and temporal data via session context variables requires H2 v2.2.x or later.
:::

### SQLite

CAP supports [SQLite](https://www.sqlite.org/index.html) out of the box. When working with Java, it's [recommended](../../guides/databases-sqlite?impl-variant=java#sqlite-in-production) to use SQLite only for development and testing purposes.

CAP does support most of the major features on SQLite, although there are a few shortcomings that are listed here:

1. SQLite has only limited support for concurrent database access. You're advised to limit the connection pool to *1* as shown above (parameter `maximum-pool-size: 1`), which effectively serializes all database transactions.
2. The predicate function `contains` is supported. However, the search for characters in the word or phrase is case-insensitive in SQLite.
3. SQLite doesn't support [pessimistic locking](../working-with-cql/query-execution#pessimistic-locking).
4. Streaming of large object data isn't supported by SQLite. Hence, when reading or writing data of type `cds.LargeString` and `cds.LargeBinary` as a stream, the framework temporarily materializes the content. Thus, storing large objects on SQLite can impact the performance.
5. Sorting of character-based columns is never locale-specific but if any locale is specified in the context of a query then case insensitive sorting is performed.
6. Views in SQLite are read-only. However, the CAP Java SDK supports some views to be updatable as described in [Updatable Views](../working-with-cql/query-execution#updatable-views).
7. Foreign key constraints are supported, but are disabled by default. To activate the feature using JDBC URL, append the `foreign_keys=on` parameter to the connection URL, for example, `url=jdbc:sqlite:file:testDb?mode=memory&foreign_keys=on`. For more information, visit the [SQLite Foreign Key Support](https://sqlite.org/foreignkeys.html) in the official documentation.
8. CAP enables regular expressions on SQLite via a Java implementation. The matching behaviour is an equivalent of the `Matcher.find()` call for the given pattern.

## Datasources

Java Applications usually connect to SQL databases through datasources (`java.sql.DataSource`).
The CAP Java SDK can auto-configure datasources from service bindings and pick up datasources configured by Spring Boot.
These datasources are used to create Persistence Services, which are CQN-based database clients.

### Datasource Configuration

Datasources are usually backed by a connection pool to ensure efficient access to the database.
If datasources are created from a service binding the connection pool can be configured through the properties `cds.dataSource.<service-instance>.<pool-type>.*`.
An example configuration could look like this:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  dataSource:
    my-service-instance:
      hikari:
        maximum-pool-size: 20
```
:::

Supported pool types for single tenant scenarios are `hikari`, `tomcat`, and `dbcp2`. For a multitenant scenario `hikari`, `tomcat`, and `atomikos` are supported. The corresponding pool dependencies need to be available on the classpath. You can find an overview of the available pool properties in the respective documentation of the pool. For example, properties supported by Hikari can be found [here](https://github.com/brettwooldridge/HikariCP#gear-configuration-knobs-baby).

It is also possible to configure the database connection itself. For Hikari this can be achieved by using the `data-source-properties` section. Properties defined here are passed to the respective JDBC driver, which is responsible to establish the actual database connection. The following example sets such a [SAP HANA-specific configuration](https://help.sap.com/docs/SAP_HANA_PLATFORM/0eec0d68141541d1b07893a39944924e/109397c2206a4ab2a5386d494f4cf75e.html):

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  dataSource:
    my-service-instance:
      hikari:
        data-source-properties:
          packetSize: 300000
```
:::

### SAP HANA

#### Service Bindings

SAP HANA can be configured when running locally as well as when running productively in the cloud. The datasource is auto-configured based on available service bindings in the `VCAP_SERVICES` environment variable or locally the _default-env.json_. This only works if an application profile is used, that doesn't explicitly configure a datasource using `spring.datasource.url`. Such an explicit configuration always takes precedence over service bindings from the environment.

Service bindings of type *service-manager* and, in a Spring-based application, *hana* are used to auto-configure datasources. If multiple datasources are used by the application, you can select one auto-configured datasource to be used by the default Persistence Service through the property `cds.dataSource.binding`.

#### Configure the DDL generation

Advise the CDS Compiler to generate _tables without associations_, as associations on SAP HANA are not used by CAP Java:

::: code-group
```json [.cdsrc.json]
{ "sql": { "native_hana_associations" : false } }
```
:::

#### SQL Optimization Mode

By default, the SAP HANA adapter in CAP Java generates SQL that is optimized for the new [HEX engine](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-performance-guide-for-developers/query-execution-engine-overview) in SAP HANA Cloud. To generate SQL that is compatible with SAP HANA 2.x ([HANA Service](https://help.sap.com/docs/HANA_SERVICE_CF/6a504812672d48ba865f4f4b268a881e/08c6e596b53843ad97ae68c2d2c237bc.html)) and [SAP HANA Cloud](https://www.sap.com/products/technology-platform/hana.html), set the (deprecated) [CDS property](../developing-applications/properties#cds-properties):

```yaml
cds.sql.hana.optimizationMode: legacy
```

Use the [hints](../working-with-cql/query-execution#hana-hints) `hdb.USE_HEX_PLAN` and `hdb.NO_USE_HEX_PLAN` to overrule the configured optimization mode per statement.

::: warning Rare error in `HEX` mode
In some corner cases, particularly when using [native HANA views](../../advanced/hana#create-native-sap-hana-objects), queries in `HEX` optimization mode may fail with a "hex enforced but cannot be selected" error. This is the case if the statement execution requires the combination of HEX only features with other features that are not yet supported by the HEX engine. If CAP detects this error it will, as a fallback, execute the query in _legacy_ mode.
If you know upfront that a query can't be executed by the HEX engine, you can add a `hdb.NO_USE_HEX_PLAN` hint to the query, so the SQL generator won't use features that require the HEX engine.
:::

### PostgreSQL { #postgresql-1 }

PostgreSQL can be configured when running locally as well as when running productively in the cloud. Similar to HANA, the datasource is auto-configured based on available service bindings, if the feature `cds-feature-postgresql` is added.

#### Initial Database Schema

To generate a `schema.sql` for PostgreSQL, use the dialect `postgres` with the `cds deploy` command: `cds deploy --to postgres --dry`. The following snippet configures the [cds-maven-plugin](../developing-applications/building#cds-maven-plugin) accordingly:

::: code-group
```xml [srv/pom.xml]
<execution>
	<id>schema.sql</id>
	<goals>
		<goal>cds</goal>
	</goals>
	<configuration>
		<commands>
			<command>deploy --to postgres --dry --out "${project.basedir}/src/main/resources/schema.sql"</command>
		</commands>
	</configuration>
</execution>
```
:::

The generated `schema.sql` can be automatically deployed by Spring if you configure the [sql.init.mode](https://docs.spring.io/spring-boot/how-to/data-initialization.html#howto.data-initialization.using-basic-sql-scripts) to `always`.

Using the `@sap/cds-dk` you can add PostgreSQL support to your CAP Java project:
```sh
cds add postgres
```

::: warning
Automatic schema deployment isn't suitable for productive use. Consider using production-ready tools like Flyway or Liquibase. See more on that in the [Database guide for PostgreSQL](../../guides/databases-postgres.md?impl-variant=java#deployment-using-liquibase)
:::

#### Configure the Connection Data Explicitly { #postgres-connection }

If you don't have a compatible PostgreSQL service binding in your application environment, you can also explicitly configure the connection data of your PostgreSQL database in the _application.yaml_:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
---
spring:
  config.activate.on-profile: postgres
  datasource:
    url: <url>
    username: <user>
    password: <password>
    driver-class-name: org.postgresql.Driver
```
:::

### H2

For local development, [H2](https://www.h2database.com/) can be configured to run in-memory or in the file-based mode.

To generate a `schema.sql` for H2, use the dialect `h2` with the `cds deploy` command: `cds deploy --to h2 --dry`. The following snippet configures the [cds-maven-plugin](../developing-applications/building#cds-maven-plugin) accordingly:

::: code-group
```xml [srv/pom.xml]
<execution>
	<id>schema.sql</id>
	<goals>
		<goal>cds</goal>
	</goals>
	<configuration>
		<commands>
			<command>deploy --to h2 --dry --out "${project.basedir}/src/main/resources/schema.sql"</command>
		</commands>
	</configuration>
</execution>
```
:::

In Spring, H2 is automatically initialized in-memory when present on the classpath. See the official [documentation](https://www.h2database.com/html/features.html) for H2 for file-based database configuration.

Using the `@sap/cds-dk` you can add H2 support to your CAP Java project:
```sh
cds add h2
```

### SQLite

#### Initial Database Schema

To generate a `schema.sql` for SQLite, use the dialect `sqlite` with the `cds deploy` command: `cds deploy --to sqlite --dry`. The following snippet configures the [cds-maven-plugin](../developing-applications/building#cds-maven-plugin) accordingly:

::: code-group
```xml [srv/pom.xml]
<execution>
	<id>schema.sql</id>
	<goals>
		<goal>cds</goal>
	</goals>
	<configuration>
		<commands>
			<command>deploy --to sqlite --dry --out "${project.basedir}/src/main/resources/schema.sql"</command>
		</commands>
	</configuration>
</execution>
```
:::

Using the `@sap/cds-dk` you can add SQLite support to your CAP Java project:
```sh
cds add sqlite
```

#### File-Based Storage

The database content is stored in a file, `sqlite.db` as in the following example. Since the schema is initialized using `cds deploy` command, the initialization mode is set to `never`:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
---
spring:
  config.activate.on-profile: sqlite
  sql:
    init:
      mode: never
  datasource:
    url: "jdbc:sqlite:sqlite.db"
    driver-class-name: org.sqlite.JDBC
    hikari:
      maximum-pool-size: 1
```
:::

#### In-Memory Storage

The database content is stored in-memory only. The schema initialization done by Spring, executes the `schema.sql` script. Hence, the initialization mode is set to `always`. If Hikari closes the last connection from the pool, the in-memory database is automatically deleted. To prevent this situation, set `max-lifetime` to *0*:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
---
spring:
  config.activate.on-profile: default
  sql:
    init:
      mode: always
  datasource:
    url: "jdbc:sqlite:file::memory:?cache=shared"
    driver-class-name: org.sqlite.JDBC
    hikari:
      maximum-pool-size: 1
      max-lifetime: 0
```
:::

## Persistence Services

Persistence Services are CQN-based database clients. You can think of them as a wrapper around a datasource, which translates CQN to SQL.
In addition, Persistence Services have built-in transaction management. They take care of lazily initializing and maintaining database transactions as part of the active changeset context.

[Learn more about ChangeSet Contexts and Transactions.](../event-handlers/changeset-contexts){.learn-more}

A Persistence Service isn't bound to a specific service definition in the CDS model. It's capable of accepting CQN statements targeting any entity or view that is stored in the corresponding database.
All Persistence Service instances reflect on the same CDS model. It is the responsibility of the developer to decide which artifacts are deployed into which database at deploy time and to access these artifacts with the respective Persistence Service at runtime.

### The Default Persistence Service { #default-persistence-service}

The default Persistence Service is used by the generic handlers of Application Services to offer out-of-the-box CRUD functionality.
The name of the default Persistence Service is stored in the global constant [`PersistenceService.DEFAULT_NAME`](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/persistence/PersistenceService.html#DEFAULT_NAME).

If only a single datasource exists in the application the CAP Java SDK creates the default Persistence Service from it.
This is usually the case when specifying a datasource through Spring Boot's configuration (`spring.datasource.url` or auto-configured H2) or when having a single database service binding.

If multiple datasources exist in the application, the CAP Java SDK needs to know for which the default Persistence Service should be created, otherwise the application startup will fail.
By setting the property `cds.dataSource.binding` the datasource created from the specified database service binding is marked as primary.
If the datasource to be used is directly created as a bean in Spring Boot you need to ensure to mark it as primary using Spring Boot's `@Primary` annotation.

### Additional Persistence Services

For each non-primary database service binding a Persistence Service is automatically created. The name of the Persistence Service is the name of the service binding.
It is possible to configure how Persistence Services are created.

To change the name of a Persistence Service you can specify it in your configuration and connect it explicitly with the corresponding database service binding.
The following configuration creates a Persistence Service named "my-ps" for the service binding "my-hana-hdi":

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  persistence.services:
    my-ps:
      binding: "my-hana-hdi"
```
:::

You can also disable the creation of a Persistence Service for specific database service bindings.
The following configuration disables the creation of a Persistence Service for the service binding "my-hana-hdi":

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  persistence.services:
    my-hana-hdi:
      enabled: false
```
:::

To create a non-default Persistence Service for a datasource explicitly created as Spring bean a configuration is required.
The following examples shows a Java example to register such a datasource bean:

```java
@Configuration
public class DataSourceConfig {

    @Bean
    public DataSource customDataSource() {
        return DataSourceBuilder.create()
            .url("jdbc:sqlite:sqlite.db")
            .build();
    }

}
```

In the configuration you need to refer to the name of the datasource:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  persistence.services:
    my-ps:
      dataSource: "customDataSource"
```
:::

::: tip
Any usage of non-default Persistence Services needs to happen in custom handlers.
:::

### Example: Multitenant Application with Tenant-independent Datasource

A common scenario for multiple Persistence Services is in multitenant applications, which require an additional tenant-independent database.
These applications usually use the Service Manager to maintain a dedicated SAP HANA HDI container for each tenant.
However, additional tenant-independent data needs to be stored in a separate HDI container, shared by all tenants.

When running such a scenario productively it is as easy as binding two database service bindings to your application: The Service Manager binding and the additional HDI container binding.
The only configuration required in that scenario is to mark the Service Manager binding as the primary one, in order to create the default Persistence Service from it:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
spring:
  config.activate.on-profile: cloud
cds:
  dataSource:
    binding: "my-service-manager-binding"
```
:::

At deploy time it is currently recommended to deploy all CDS entities into both the tenant-dependent as well as the tenant-independent databases.
At runtime you need to ensure to access the tenant-dependent entities through the default Persistence Service and the tenant-independent entities through the additional Persistence Service.

#### Local Development and Testing with MTX

In case you are testing your multitenant application locally with the setup described in [Local Development and Testing](../../guides/multitenancy/#test-locally), you need to perform additional steps to create an in-memory tenant-independent datasource.

To create an in-memory datasource, initialized with the SQL schema, add the following configuration to your Spring Boot application:

```java
@Configuration
public class DataSourceConfig {

    @Bean
    @ConfigurationProperties("app.datasource.tenant-independent")
    public DataSourceProperties tenantIndependentDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    public DataSource tenantIndependentDataSource() {
        return tenantIndependentDataSourceProperties()
            .initializeDataSourceBuilder()
            .build();
    }

    @Bean
    public DataSourceInitializer tenantIndependentInitializer() {
        ResourceDatabasePopulator resourceDatabasePopulator = new ResourceDatabasePopulator();
        resourceDatabasePopulator.addScript(new ClassPathResource("schema.sql"));

        DataSourceInitializer dataSourceInitializer = new DataSourceInitializer();
        dataSourceInitializer.setDataSource(tenantIndependentDataSource());
        dataSourceInitializer.setDatabasePopulator(resourceDatabasePopulator);
        return dataSourceInitializer;
    }

}
```

You can then refer to that datasource in your Persistence Service configuration and mark the auto-configured MTX SQLite datasource as primary:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
spring:
  config.activate.on-profile: local-mtxs
cds:
  persistence.services:
    tenant-independent:
      dataSource: "tenantIndependentDataSource"
  dataSource:
    binding: "mtx-sqlite"
```
:::

#### Local Development and Testing without MTX

In case you're testing your application in single-tenant mode without MTX sidecar you need to configure two in-memory databases.
The primary one is used for your tenant-dependant persistence and the secondary one for your tenant-independent persistence.

Due to the way the Spring Boot DataSource auto-configuration works, you can't use the configuration property `spring.datasource.url` for one of your datasources.
Spring Boot doesn't pick up this configuration anymore, as soon as you explicitly define another datasource, which is required in this scenario.

You therefore need to define the configuration for two datasources. In addition, you need to define the transaction manager for the primary datasource.

```java
@Configuration
public class DataSourceConfig {

    /**
     * Configuration of tenant-dependant persistence
     */

    @Bean
    @Primary
    @ConfigurationProperties("app.datasource.tenant-dependent")
    public DataSourceProperties tenantDependentDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    @Primary
    public DataSource tenantDependentDataSource() {
        return tenantDependentDataSourceProperties()
            .initializeDataSourceBuilder()
            .build();
    }

    @Bean
    @Primary
    public DataSourceTransactionManager tenantDependentTransactionManager() {
        return new DataSourceTransactionManager(tenantDependentDataSource());
    }

    /**
     * Configuration of tenant-independent persistence
     */

    @Bean
    @ConfigurationProperties("app.datasource.tenant-independent")
    public DataSourceProperties tenantIndependentDataSourceProperties() {
        return new DataSourceProperties();
    }

    @Bean
    public DataSource tenantIndependentDataSource() {
        return tenantIndependentDataSourceProperties()
            .initializeDataSourceBuilder()
            .build();
    }

    @Bean
    public DataSourceInitializer tenantIndependentInitializer() {
        ResourceDatabasePopulator resourceDatabasePopulator = new ResourceDatabasePopulator();
        resourceDatabasePopulator.addScript(new ClassPathResource("schema.sql"));

        DataSourceInitializer dataSourceInitializer = new DataSourceInitializer();
        dataSourceInitializer.setDataSource(tenantIndependentDataSource());
        dataSourceInitializer.setDatabasePopulator(resourceDatabasePopulator);
        return dataSourceInitializer;
    }

}
```

The primary datasource is automatically picked up by the CAP Java SDK. The secondary datasource needs to be referred in your Persistence Service configuration:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
spring:
  config.activate.on-profile: local
cds:
  persistence.services:
    tenant-independent:
      dataSource: "tenantIndependentDataSource"
```
:::

## Native SQL

### Native SQL with JDBC Templates { #jdbctemplate}

The JDBC template is the Spring API, which in contrast to the CQN APIs allows executing native SQL statements and call stored procedures (alternative to [Native HANA Object](../../advanced/hana#create-native-sap-hana-objects)). It seamlessly integrates with Spring's transaction and connection management. The following example shows the usage of `JdbcTemplate` in the custom handler of a Spring Boot enabled application. It demonstrates the execution of the stored procedure and native SQL statement.

```java
@Autowired
JdbcTemplate jdbcTemplate;
...

public void setStockForBook(int id, int stock) {
   jdbcTemplate.update("call setStockForBook(?,?)", id, stock);  // Run the stored procedure `setStockForBook(id in number, stock in number)`
}

public int countStock(int id) {
   SqlParameterSource namedParameters = new MapSqlParameterSource().addValue("id", id);
   return jdbcTemplate.queryForObject(
      "SELECT stock FROM Books WHERE id = :id", namedParameters, Integer.class); // Run native SQL
}
```

See [Class JdbcTemplate](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/core/JdbcTemplate.html) for more details.


### Using CQL with a Static CDS Model { #staticmodel}

The static model and accessor interfaces can be generated using the [CDS Maven Plugin](../developing-applications/building#cds-maven-plugin).

::: warning _❗ Warning_
Currently, the generator doesn't support using reserved [Java keywords](https://docs.oracle.com/javase/specs/jls/se13/html/jls-3.html#jls-3.9) as identifiers in the CDS model. Conflicting element names can be renamed in Java using the [@cds.java.name](../cds-data#renaming-elements-in-java) annotation. For entities it is recommended to use [@cds.java.this.name](../cds-data#renaming-types-in-java).
:::

#### Static Model in the Query Builder

The [Query Builder API](../working-with-cql/../working-with-cql/query-api) allows you to dynamically create [CDS Query Language (CQL)](/cds/cql) queries using entity and element names given as strings:

```java
Select.from("my.bookshop.Books")
  .columns("title")
  .where(book -> book.to("author").get("name").eq("Edgar Allan Poe"));
```

This query is constructed dynamically. It's checked only at runtime that the entity `my.bookshop.Authors` actually exists
and that it has the element `name`.  Moreover, the developer of the query doesn't get any code completion at design time. These disadvantages are avoided by using a static model to construct the query.

#### Model Interfaces

The static model is a set of interfaces that reflects the structure of the CDS model in Java (like element references with their types, associations, etc.) and allow to fluently build queries in a type-safe way. For every entity in the model, the model contains a corresponding `StructuredType` interface, which
represents this type. As an example, for this CDS model the following model interfaces are generated:

CDS model

```cds
namespace my.bookshop;

entity Books {
  key ID : Integer;
  title  : String(111);
  author : Association to Authors;
}

entity Authors {
  key ID : Integer;
  name   : String(111);
  books  : Association to many Books on books.author = $self;
}
```
[Find this source also in **cap/samples**.](https://github.com/sap-samples/cloud-cap-samples-java/blob/5396b0eb043f9145b369371cfdfda7827fedd039/db/schema.cds#L5-L21){.learn-more}

Java

```java
@CdsName("my.bookshop.Books")
public interface Books_ extends StructuredType<Books_> {
  ElementRef<Integer> ID();
  ElementRef<String> title();
  Authors_ author();
  Authors_ author(Function<Authors_, Predicate> filter);
}
```

```java
@CdsName("my.bookshop.Authors")
public interface Authors_ extends StructuredType<Authors_> {
  ElementRef<Integer> ID();
  ElementRef<String> name();
  Books_ books();
  Books_ books(Function<Books_, Predicate> filter);
}
```

####  Accessor Interfaces

The corresponding data is captured in a data model similar to JavaBeans. These beans are interfaces generated by the framework, providing the data access methods - getters and setters - and containing the CDS element names as well. The instances of the data model are created by the [CDS Query Language (CQL)](/cds/cql) Execution Engine (see the following example).

Note the following naming convention: the model interfaces, which represent the structure of the CDS Model, always end with an underscore, for example `Books_`. The accessor interface, which refers to data model, is simply the name of the CDS entity - `Books`.

The following data model interface is generated for `Books`:

```java
@CdsName("my.bookshop.Books")
public interface Books extends CdsData {

  String ID = "ID";
  String TITLE = "title";
  String AUTHOR = "author";

  Integer getID();
  void setID(Integer id);

  String getTitle();
  void setTitle(String title);

  Authors getAuthor();
  void setAuthor(Map<String, ?> author);
}
```

#### Javadoc comments

The static model and accessor interfaces can be extended with [Javadoc comments](../../cds/cdl#doc-comment).

Currently, the generator supports Javadoc comments using the interface and getter/setter methods. The following example shows Javadoc comments defined in the CDS model and how they appear in the generated interfaces.

```cds
namespace my.bookshop;
/**
 * The creator/writer of a book, article, or document.
 */
entity Authors {
  key ID : Integer;
  /**
   * The name of the author.
   */
  name : String(30);
}
```

```java
/**
 * The creator/writer of a book, article, or document.
 */
@CdsName("my.bookshop.Authors")
public interface Authors extends CdsData {

  String ID = "ID";
  String NAME = "name";

  Integer getId();
  void setId(Integer id);
  /**
   * The name of the author.
   */
  String getName();
  /**
   * The name of the author.
   */
  void setName(String name);
}
```

#### Usage

In the query builder, the interfaces reference entities. The interface methods can be used in
lambda expressions to reference elements or to compose path expressions:

```java
// Note the usage of model interface `Books_` here
Select<Books_> query = Select.from(Books_.class)
  .columns(book -> book.title())
  .where  (book -> book.author().name().eq("Edgar Allan Poe"));

// After executing the query the result can be converted to
// a typed representation List of Books.
List<Books> books = dataStore.execute(query).listOf(Books.class);
```



# Application Services


Application Services define the APIs that a CAP application exposes to its clients, for example through OData. This section describes how to add business logic to these services, by extending CRUD events and implementing actions and functions.

## Handling CRUD Events { #crudevents}

Application Services provide a [CQN query API](./index#cdsservices). When running a CQN query on an Application Service CRUD events are triggered.
The processing of these events is usually extended when adding business logic to the Application Service.

The following table lists the static event name constants that exist for these event names on the [CqnService](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/CqnService.html) interface and their corresponding [event-specific Event Context interfaces](../event-handlers/#eventcontext). These constants and interfaces should be used, when registering and implementing event handlers:

| Event | Constant | Event Context |
| --- | --- | --- |
| CREATE | `CqnService.EVENT_CREATE` | [CdsCreateEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/CdsCreateEventContext.html) |
| READ | `CqnService.EVENT_READ` | [CdsReadEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/CdsReadEventContext.html) |
| UPDATE | `CqnService.EVENT_UPDATE` | [CdsUpdateEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/CdsUpdateEventContext.html) |
| UPSERT | `CqnService.EVENT_UPSERT` | [CdsUpsertEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/CdsUpsertEventContext.html) |
| DELETE | `CqnService.EVENT_DELETE` | [CdsDeleteEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/CdsDeleteEventContext.html) |

The following example shows how these constants and Event Context interfaces can be leveraged, when adding an event handler to be run when new books are created:

```java
@Before(event = CqnService.EVENT_CREATE, entity = Books_.CDS_NAME)
public void createBooks(CdsCreateEventContext context, List<Books> books) { }
```

::: tip
To learn more about the entity data argument `List<Books> books` of the event handler method, have a look at [this section](../event-handlers/#pojoarguments).
:::

### OData Requests

Application Services are used by OData protocol adapters to expose the Application Service's API as an OData API on a path with the following pattern:

```txt
http(s)://<application_url>/<base_path>/<service_name>
```

|Parameter | Description
| --- | --- |
|`<base_path>`     |  For the OData V2 and OData V4 protocol adapters, `<base_path>` can be configured with the application configuration properties `cds.odataV2.endpoint.path` and `cds.odataV4.endpoint.path` respectively. Please see [CDS Properties](../developing-applications/properties) for their default values.       |
|`<service_name>`     | The name of the Application Service, which by default is the fully qualified name of its definition in the CDS model. However, you can override this default per service by means of the `@path` annotation (see [Service Definitions in CDL](../../cds/cdl#service-definitions)).        |

[Learn more about how OData URLs are configured.](application-services#serve-configuration){.learn-more}

The OData protocol adapters use the CQN query APIs to retrieve a response for the requests they receive.
They transform OData-specific requests into a CQN query, which is run on the Application Service.

The following table shows which CRUD events are triggered by which kind of OData request:

| HTTP Verb | Event | Hint |
| --- | --- | --- |
| POST | CREATE | |
| GET | READ | The same event is used for reading a collection or a single entity |
| PATCH | UPDATE | If the update didn't find an entity, a subsequent `CREATE` event is triggered |
| PUT | UPDATE | If the update didn't find an entity, a subsequent `CREATE` event is triggered |
| DELETE | DELETE | |

> In CAP Java versions < 1.9.0, the `UPSERT` event was used to implement OData V4 `PUT` requests. This has been changed, as the semantics of `UPSERT` didn't really match the semantics of the OData V4 `PUT`.

### Deeply Structured Documents

Events on deeply structured documents, are only triggered on the target entity of the CRUD event's CQN statement.
This means, that if a document is created or updated, events aren't automatically triggered on composition entities.
Also when reading a deep document, leveraging `expand` capabilities, `READ` events aren't triggered on the expanded entities.
The same applies to a deletion of a document, which doesn't automatically trigger `DELETE` events on composition entities to which the delete is cascaded.

When implementing validation logic, this can be handled like shown in the following example:

```java
@Before(event = CqnService.EVENT_CREATE, entity = Orders_.CDS_NAME)
public void validateOrders(List<Orders> orders) {
    for(Orders order : orders) {
        if (order.getItems() != null) {
            validateItems(order.getItems());
        }
    }
}

@Before(event = CqnService.EVENT_CREATE, entity = OrderItems_.CDS_NAME)
public void validateItems(List<OrderItems> items) {
    for(OrderItems item : items) {
        if (item.getQuantity() <= 0) {
            throw new ServiceException(ErrorStatuses.BAD_REQUEST, "Invalid quantity");
        }
    }
}
```

In the example, the `OrderItems` entity exists as a composition within the `Items` element of the `Orders` entity. When creating an order a deeply structured document can be passed, which contains order items.
For this reason, the event handler method to validate order items (`validateItems`) is called as part of the order validation (`validateOrders`).
In case an order item is directly created (for example through a containment navigation in OData V4) only the event handler for validation of the order items is triggered.


## Result Handling

`@On` handlers for `READ`, `UPDATE`, and `DELETE` events _must_ set a result, either by returning the result, or using the event context's `setResult` method.

### READ Result

`READ` event handlers must return the data that was read, either as an `Iterable<Map>` or [Result](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/Result.html) object created via the [ResultBuilder](#result-builder-read). For queries with inline count, a `Result` object _must_ be used as the inline count is obtained from the `Result` interface.

`READ` event handlers are also called, for OData `/$count` requests. These requests determine the total amount of entity instances of a specific entity. When handling these requests in a custom `@On` event handler a `Map` with a single key `count` needs to be returned as a result:

```java
@On(entity = MyEntity_.CDS_NAME)
List<Map<String, Object>> readMyEntity(CdsReadEventContext context) {
	if (CqnAnalyzer.isCountQuery(context.getCqn())) {
		int count = 100; // determine correct count value
		return List.of(Collections.singletonMap("count", count));
	}
	// handle non /$count requests
}
```

### UPDATE and DELETE Results

`UPDATE` and `DELETE` statements have an optional filter condition (where clause) which determines the entities to be updated/deleted. Handlers _must_ return a `Result` object with the number of entities that match this filter condition and have been updated/deleted. Use the [ResultBuilder](#result-builder) to create the `Result` object.

::: warning _❗ Warning_<br>
If an event handler for an `UPDATE` or `DELETE` event does not specify a result the number of updated/deleted rows is automatically set to 0 and the OData protocol adapter will translate this into an HTTP response with status code `404` (Not Found).
:::

### INSERT and UPSERT Results

Event handlers for `INSERT` and `UPSERT` events can return a result representing the data that was inserted/upserted.

A failed insert is indicated by throwing an exception, for example, a `UniqueConstraintException` or a `CdsServiceException` with error status `CONFLICT`.

### Result Builder { #result-builder}

When implementing custom `@On` handlers for CRUD events, a `Result` object can be constructed with the [ResultBuilder](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ResultBuilder.html).

The semantics of the constructed `Result` differ between the CRUD events.
Clients of Application Services, for example the OData protocol adapters, rely on these specific semantics for each event.
It is therefore important that custom ON handlers fulfill these semantics as well, when returning or setting a `Result` using the `setResult()` method of the respective event context.

The following table lists the events and the expected `Result`:

| Event | Expected Semantic | `ResultBuilder` method |
| --- | --- | --- |
| CREATE | The data of all created entity rows | `insertedRows` |
| READ | The data of all read entity rows and (if requested) the inline count | `selectedRows` |
| UPDATE | The number of updated entity rows and (optionally) the updated data | `updatedRows` |
| UPSERT | The data of all upserted entity rows | `insertedRows` |
| DELETE | The number of deleted entity rows | `deletedRows` |

Use the `selectedRows` or `insertedRows` method for query and insert results, with the data given as `Map` or list of maps:

```java
import static java.util.Arrays.asList;
import static com.sap.cds.ResultBuilder.selectedRows;

Map<String, Object> row = new HashMap<>();
row.put("title", "Capire");
Result res = selectedRows(asList(row)).result();
context.setResult(res);   // CdsReadEventContext
```
{ #result-builder-read}

For query results, the inline count can be set through the `inlineCount` method:

```java
Result r = selectedRows(asList(row)).inlineCount(inlineCount).result();
```
{ #result-builder-update}

For update results, use the `updatedRows` method with the update count and the update data:

```java
import static com.sap.cds.ResultBuilder.updatedRows;

int updateCount = 1;  // number of updated rows
Map<String, Object> data = new HashMap<>();
data.put("title", "CAP Java");
Result r = updatedRows(updateCount, data).result();
```

For delete results, use the `deletedRows` method and provide the number of deleted rows:

```java
import static com.sap.cds.ResultBuilder.deletedRows;

int deleteCount = 7;
Result r = deletedRows(deleteCount).result();
```

## Actions and Functions { #actions}

[Actions](../../cds/cdl#actions) and [Functions](../../cds/cdl#actions) enhance the API provided by an Application Service with custom operations. They have well-defined input parameters and a return value, that are modelled in CDS.
Actions or functions are handled - just like CRUD events - using event handlers. To trigger an action or function on an Application Service an event with the action's or function's name is emitted on it.

### Implement Event Handler

The CAP Java runtime doesn't provide any default `On` handlers for actions and functions. For each action or function an event handler of the [`On`](../event-handlers/#on) phase should be defined, which implements the business logic and provides the return value of the operation, if applicable. The event handler needs to take care of [completing the event processing](../event-handlers/#eventcompletion). If an action or function is __bound to an entity__, the entity needs to be specified while registering the event handler. The following example shows how to implement an event handler for an action:

Given this CDS model:

```cds
service CatalogService {
    entity Books {
        key ID: UUID;
        title: String;
    } actions {
      action review(stars: Integer) returns Reviews;
    };

    entity Reviews {
        book : Association to Books;
        stars: Integer;
    }
}
```

The `cds-maven-plugin` generates event context interfaces for the action or function, based on its CDS model definition. These event context interfaces provide direct access to the parameters and the return value of the action or function.
For bound actions or functions the event context interface provides a [CqnSelect](../working-with-cql/query-api#select) statement, which targets the entity on which the action or function was triggered.

Action-specific event context, generated by the CAP Java SDK Maven Plugin:

```java
@EventName("review")
public interface ReviewEventContext extends EventContext {

    // CqnSelect that points to the entity the action was called on
    CqnSelect getCqn();
    void setCqn(CqnSelect select);

    // The 'stars' input parameter
    Integer getStars();
    void setStars(Integer stars);

    // The return value
    void setResult(Reviews review);
    Reviews getResult();

}
```

The event handler registration and implementation is as follows:

```java
@Component
@ServiceName(CatalogService_.CDS_NAME)
public class CatalogServiceHandler implements EventHandler {

    @On(event = "review", entity = Books_.CDS_NAME)
    public void reviewAction(ReviewEventContext context) {
        CqnSelect selectBook = context.getCqn();
        Integer stars = context.getStars();
        Reviews review = ...; // create the review
        context.setResult(review);
    }

}
```

### Trigger Action or Function

As of version 2.4.0, the [CAP Java SDK Maven Plugin](../developing-applications/building#cds-maven-plugin) is capable of generating specific interfaces for services in the CDS model. These service interfaces also provide Java methods for actions and functions, which allow direct access to the action's or function's parameters. You can just call them in custom Java code. If an action or function is bound to an entity, the first argument of the method is an entity reference providing the required information to address the entity instance.

Given the same CDS model as in the previous section, the corresponding generated Java service interface looks like the following:

```java
@CdsName(CatalogService_.CDS_NAME)
public interface CatalogService extends CqnService {

  @CdsName(ReviewContext.CDS_NAME)
  Reviews review(Books_ ref, @CdsName(ReviewContext.STARS) Integer stars);

  interface Application extends ApplicationService, CatalogService {
  }

  interface Remote extends RemoteService, CatalogService {
  }
}
```

In the custom handler class, the specific service interface can be injected as it is already known for generic service interfaces:

```java
  ...
  @Autowired
  private CatalogService catService;
  ...
```

Now, just call the review action from custom handler code:

```java
  ...
  private void someCustomMethod() {
    String bookId = "myBookId";
    Books_ ref = CQL.entity(Books_.class).filter(b -> b.ID().eq(bookId));
    this.catService.review(ref, 5);
  }
  ...
```

Alternatively, the event context can be used to trigger the action or function. This approach is useful for generic use cases, where typed interfaces are not available. The event context needs to be filled with the parameter values and emitted on the service:

```java
    EventContext context = EventContext.create("review", "CatalogService.Books");
    context.put("cqn", Select.from("CatalogService.Books").byId("myBookId"));
    context.put("rating", review.getRating());

    this.catService.emit(context);

    Map<String, Object> result = (Map<String, Object>) context.get("result");
```


## Best Practices and FAQs

This section summarizes some best practices for implementing event handlers and provides answers to frequently asked questions.

1. On which service should I register my event handler?

    Event handlers implementing business or domain logic should be registered on an Application Service.
    When implementing rather technical requirements, like triggering some code whenever an entity is written to the database, you can register event handlers on the Persistence Service.

2. Which services should my event handlers usually interact with?

    The CAP Java SDK provides [APIs](../services) that can be used in event handlers to interact with other services.
    These other services can be used to request data, that is required by the event handler implementation.

    If you're implementing an event handler of an Application Service, and require additional data of other entities part of that service for validation purposes, it's a good practice to read this data from the database using the [Persistence Service](../cqn-services/#persistenceservice). When using the Persistence Service, no user authentication checks are performed.

    If you're mashing up your service with another Application Service and also return data from that service to the client, it's a good practice to consume the other service through its service API. This keeps you decoupled from the possibility that the service might be moved into a dedicated micro-service in the future ([late-cut micro services](../../about/best-practices#agnostic-by-design)) and automatically lets you consume the business or domain logic of that service.
    If you do not require this decoupling, you can also access the service's entities directly from the database.

    In case you're working with draft-enabled entities and your event handler requires access to draft states, you should use the [Draft Service](../fiori-drafts#draftservices) to query and interact with drafts.

3. How should I implement business or domain logic shared across services?

    In general, it's a good practice to design your services with specific use cases in mind. Nevertheless, it might be necessary to share certain business or domain logic across multiple services.
    To achieve this, simple utility methods can be implemented, which can be called from different event handlers.

    If the entities for which a utility method is implemented are different projections of the same database-level entity, you can manually map the entities to the database-level representation and use this to implement your utility method.

    If they're independent from each other, a suitable self-defined representation needs to be found to implement the utility method.


## Serve Configuration

Configure how application services are served. You can define per service which ones are served by which protocol adapters. In addition, you configure on which path they are available. Finally, the combined path an application service is served on, is composed of the base path of a protocol adapter and the relative path of the application service.

### Configure Base Path { #configure-base-path}

Each protocol adapter has its own and unique base path.

By default, the CAP Java SDK provides protocol adapters for OData V4 and V2 and the base paths of both can be configured with [CDS Properties](../developing-applications/properties) in the _application.yaml_:

| Protocol | Default base path | CDS Property                                                                      |
|----------|-------------------|-----------------------------------------------------------------------------------|
| OData V4 | `/odata/v4`       | [`cds.odataV4.endpoint.path`](../developing-applications/properties#cds-odataV4-endpoint-path) |
| OData V2 | `/odata/v2`       | [`cds.odataV2.endpoint.path`](../developing-applications/properties#cds-odataV2-endpoint-path) |

The following example shows, how to deviate from the defaults:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  odataV4.endpoint.path: '/api'
  odataV2.endpoint.path: '/api-v2'
```
:::

### Configure Path and Protocol

With the annotation `@path`, you can configure the relative path of a service under which it's served by protocol adapters. The path is appended to the protocol adapter's base path.

With the annotations `@protocol` or `@protocols`, you can configure a list of protocol adapters a service should be served by. By default, a service is served by all installed protocol adapters. If you explicitly define a protocol, the service is only served by that protocol adapter.

In the following example, the service `CatalogService` is available on the combined paths `/odata/v4/browse` with OData V4 and `/odata/v2/browse` with OData V2:

```cds
@path : 'browse'
@protocols: [ 'odata-v4', 'odata-v2' ]
service CatalogService {
    ...
}
```

The same can also be configured in the _application.yaml_ in the `cds.application.services.<key>.serve` section. Replace `<key>` with the service name to configure path and protocols:

```yml
cds.application.services.CatalogService.serve:
  path: 'browse'
  protocols:
    - 'odata-v4'
    - 'odata-v2'
```

You can also disable serving a service if needed:

```cds
@path : 'browse'
@protocol: 'none'
service InternalService {
    ...
}
```

[Learn more about all `cds.application.services.<key>.serve` configuration possibilities.](../developing-applications/properties#cds-application-services-<key>-serve){.learn-more}


### Configure Endpoints

With the annotations `@endpoints.path` and `@endpoints.protocol`, you can provide more complex service endpoint configurations. Use them to serve an application service on different paths for different protocols. The value of `@endpoints.path` is appended to the [protocol adapter's base path](#configure-base-path).

In the following example, the service `CatalogService` is available on different paths for the different OData protocols:

```cds
@endpoints: [
  {path : 'browse', protocol: 'odata-v4'},
  {path : 'list', protocol: 'odata-v2'}
]
service CatalogService {
    ...
}
```

The `CatalogService` is accessible on the combined path `/odata/v4/browse` with the OData V4 protocol and on `/odata/v2/list` with the OData V2 protocol.

The same can also be configured in the _application.yaml_ in the `cds.application.services.<key>.serve.endpoints` section. Replace `<key>` with the service name to configure the endpoints:

```yml
cds.application.services.CatalogService.serve.endpoints:
  - path: 'browse'
    protocol: 'odata-v4'
  - path: 'list'
    protocol: 'odata-v2'
```

[Learn more about all `cds.application.services.<key>.serve.endpoints` configuration possibilities.](../developing-applications/properties#cds-application-services-<key>-serve-endpoints){.learn-more}



# Remote Services


Remote Services are CQN-based clients to remote APIs that a CAP application consumes. This section describes how to configure and use these services.

The CAP Java SDK supports _Remote Services_ for OData V2 and V4 APIs out of the box.
The CQN query APIs enable [late-cut microservices](../../guides/providing-services#late-cut-microservices) with simplified mocking capabilities. Regarding multitenant applications, these APIs keep you extensible, even towards remote APIs. In addition, they free developers from having to map CQN to OData themselves.

Cross-cutting aspects like security are provided by configuration. Applications do not need to provide additional code. The CAP Java SDK leverages the [SAP Cloud SDK](https://sap.github.io/cloud-sdk) and in particular its destination capabilities to cover these aspects.

Destinations in the Cloud SDK are the means to express and define connectivity to a remote endpoint including authentication details. Cloud SDK destinations can be created from various sources such as [SAP BTP Destination Service](#destination-based-scenarios) or [Service Bindings](#service-binding-based-scenarios). They can also be defined and registered [programmatically](#programmatic-destination-registration) in code. The application can choose the best fitting option for their scenario. Every Remote Service internally uses a destination for connectivity.

On top of that CAP integrates nicely with Cloud SDK, for example, ensuring automatic propagation of tenant and user information from the _Request Context_ to the Cloud SDK.

![This graphic depicts the integration of SAP Cloud SDK into SAP CAP Java.](../assets/remote%20services.drawio.svg){ class="mute-dark"}

CAP's clear recommendation is to use _Remote Services_ over directly using the SAP Cloud SDK. However, if you can't leverage CQN-based _Remote Services_, refer to [native consumption with Cloud SDK](#native-consumption) for details.

::: tip
To learn more about how to use _Remote Services_ end to end read the [Consuming Services cookbook](../../guides/using-services).
:::

## Remote OData Services

To enable _Remote Services_ for OData V2 or V4 APIs in an application, add the following Maven dependency to your project:

```xml
<dependency>
    <groupId>com.sap.cds</groupId>
    <artifactId>cds-feature-remote-odata</artifactId>
    <scope>runtime</scope>
</dependency>
```
_Remote Services_ need to be configured explicitly in your application configuration. The configuration needs to define two main aspects:

1. The CDS service definition of the remote API from the CDS model.
1. The (BTP or programmatic) destination or service binding of the remote API and its protocol type.

The following example, shows how you can configure _Remote Services_ in Spring Boot's _application.yaml_ based on a destination:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  remote.services:
    API_BUSINESS_PARTNER:
      type: "odata-v2"
      destination:
        name: "s4-business-partner-api"
```
:::

Remote Services use a CDS service definition from the CDS model as a specification of the remote API. This API specification is required to properly translate CQN statements into respective OData V2 and V4 requests.

By default the CDS service definition is looked up in the CDS model using the name of the _Remote Service_.
The name can be explicitly configured using the `name` property.
It defaults to the YAML key of the remote service configuration section (here: `API_BUSINESS_PARTNER`).

The `type` property defines the protocol used by the remote API. The CAP Java SDK currently supports `odata-v4` (default) or `odata-v2`.

::: tip
You can use the `cds import` command to generate a CDS service definition from an EDMX API specification.
To learn more about this, have a look at the section [Importing Service Definitions](../../guides/using-services#import-api).
:::

[Learn about all `cds.remote.services` configuration possibilities in our **CDS Properties Reference**.](../developing-applications/properties#cds-remote-services){.learn-more}

### Configuring CDS Service Name

The CDS service definition is, by default, looked up in the CDS model using the name of the _Remote Service_.

However, the name of the _Remote Service_ needs to be unique, as it's also used to look up the service in Java.
Therefore, it's possible to explicitly configure the name of the CDS service definition from the CDS model using the `model` property.
This is especially useful when creating multiple _Remote Services_ for the same API with different destinations:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  remote.services:
    bupa-abc:
      model: "API_BUSINESS_PARTNER"
      destination:
        name: "s4-business-partner-api-abc"
    bupa-def:
      model: "API_BUSINESS_PARTNER"
      destination:
        name: "s4-business-partner-api-def"
```
:::

### Using Service Bindings { #service-binding-based-scenarios }

If the remote API is running on SAP BTP, it's likely that you can leverage Service Binding-based _Remote Services_.
The CAP Java SDK extracts the relevant information from the service binding to connect to the remote API.
Service-binding-based _Remote Services_ are simple to use, as the service binding abstracts from several aspects of remote service communication.
For instance, it provides authentication information and the URL of the service.
In contrast to destinations, it can be created and refreshed as part of the application lifecycle, that is, application deployment.
Hence, the location and security aspects of remote services are transparent to CAP applications in the case of service bindings.

#### Binding to a Reuse Service

If the remote API is exposed by a BTP reuse service, a service broker typically provides means to create service instances of the BTP service.
The CAP application requires a service binding to this service to consume the remote API as a _Remote Service_.

These service instances of BTP services provide the URL of the remote API in their service binding.
Therefore, you only need to specify the binding name in the `application.yaml` configuration, like in the following example:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  remote.services:
    SomeReuseService:
      binding:
        name: some-service-binding
```
:::

:::details If binding structure isn't understood ...
In some cases, SAP Cloud SDK doesn't understand the service binding structure of the specific BTP service.
In that case it's required to contribute a mapping by the means of Cloud SDK's `PropertySupplier`.
This `PropertySupplier` needs to be registered with the Cloud SDK once at application startup.

```java
static {
    OAuth2ServiceBindingDestinationLoader.registerPropertySupplier(
        options -> options.getServiceBinding().getTags().contains("<bindingTag>"),
            SomeReuseServiceOAuth2PropertySupplier::new);
}
```

The `<bindingTag>` needs to be replaced by the concrete name of the tag provided in the binding of the BTP service. Alternatively, a check on the service name can be chosen as well.
The class `SomeReuseServiceOAuth2PropertySupplier` needs to be provided by you extending the Cloud SDK base class `DefaultOAuth2PropertySupplier`.

[Learn more about registering OAuth2PropertySupplier in the **SAP Cloud SDK documentation**.](https://sap.github.io/cloud-sdk/docs/java/features/connectivity/service-bindings#customization){.learn-more}
:::

#### Binding to a Service with Shared Identity

If the remote API is available within the same SaaS application and using the same (shared) service instance of XSUAA or Identity (IAS) for authentication, no service broker-based reuse service is required.
The _Remote Service_ can be configured using the shared service instance as binding (here: `shared-xsuaa`):

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  remote.services:
    OtherCapService:
      binding:
        name: shared-xsuaa
        options:
          url: https://url-of-the-second-cap-application
```
:::

The plain service binding of XSUAA or IAS does not contain the URL of the remote API. Therefore, it needs to be explicitly configured in the `options` section.
Since the URL is typically not known during development, you can define it as an environment variable. For the previous example, use `CDS_REMOTE_SERVICES_OTHERCAPSERVICE_BINDING_OPTIONS_URL`.

[Learn more about Binding From Environment Variables in the Spring Boot documentation.](https://docs.spring.io/spring-boot/reference/features/external-config.html#features.external-config.typesafe-configuration-properties.relaxed-binding.environment-variables){.learn-more}

:::tip
Remote APIs which require IAS-based authentication might expect certificate based client authentication in addition to the IAS-based JWT token, see [ProofOfPossession validation](https://github.com/SAP/cloud-security-services-integration-library/tree/main/java-security#proofofpossession-validation).
CAP _Remote Services_ automatically takes care of this by initiating a mutual TLS handshake with the remote API.
:::

#### Configuring the Authentication Strategy

While service bindings typically provide authentication details, they don't predetermine the user propagation and authentication strategy, for example, technical user or named user flow.
The parameter `onBehalfOf` in the `binding` configuration section allows to define these strategies.

The following options are available:

- `currentUser`: Use the user of the current [Request Context](/java/event-handlers/request-contexts). This propagates the named user if available or falls back to a (tenant-specific) technical user otherwise. (default)
- `systemUser`: Use a (tenant-specific) technical user, based on the tenant set in the current Request Context.
- `systemUserProvider`: Use a technical user of the provider tenant. This is especially helpful on an internal communication channel that is not authorized tenant-specifically.

### Using Destinations { #destination-based-scenarios }

If your _remote API_ is not using Service Bindings, you typically need to separately obtain the URL and additional metadata like credentials from the service provider. You can store these in destinations of SAP BTP Destination Service or [programmatically register a destination](#programmatic-destination-registration) with Cloud SDK to make them available for usage in your CAP application.

Based on the following configuration, a destination with name `s4-business-partner-api` is looked up using the Cloud SDK:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  remote.services:
    API_BUSINESS_PARTNER:
      type: "odata-v2"
      destination:
        name: s4-business-partner-api
```
:::

#### Consuming APIs from Other IAS-Applications
If your CAP application is using IAS and you want to call a _remote API_ that is provided by another IAS-based application (ie. Application2Application scenario), you can utilize a simplified security configuration in the destination.
As a pre-requisite, your CAP application and the called application need to trust the same IAS tenant and you need to define a dependency in IAS to consume the respective API provided by the _remote API_.

Create a destination configuration with the following parameters:

- _URL_: `<url-of-the-remote-api>`
- _Authentication_: `NoAuthentication`
- Additional Properties:
  - _cloudsdk.ias-dependency-name_: `<name-of-the-ias-dependency>`

At runtime, this destination configuration will use the bound `identity` service instance's credentials to request a token for the _remote API_.

[Learn more about consuming APIs from other IAS-Applications in the **SAP Cloud Identity Services documentation**.](https://help.sap.com/docs/cloud-identity-services/cloud-identity-services/consume-apis-from-other-applications){.learn-more}

#### Retrieve Destinations

The CAP Java SDK obtains the destination for a _Remote Service_ from the `DestinationAccessor` using the name that is configured in the _Remote Service_'s destination configuration.

If you're using the SAP BTP Destination Service, this is the name you used when you defined the destination there. To properly resolve the destination from SAP BTP Destination Service [additional Cloud SDK dependencies](#cloud-sdk-dependencies) are required.

In multitenant scenarios, the SAP BTP Destination Service tries to look up the destination from the subaccount of the current tenant, set on the `RequestContext`. This is not restricted to subscriber tenants, but also includes the provider tenant. Retrieval strategies are part of a set of configuration options provided by the Cloud SDK, which are exposed by CAP Java as part of the configuration for _Remote Services_. For details refer to the section about [destination strategies](#destination-strategies).

::: tip
As a prerequisite for destination lookup in subscriber accounts, the CAP application needs to define a dependency to the Destination service for their subscriptions, for example, in the SaaS registry. This can be enabled by setting the `cds.multiTenancy.dependencies.destination` to `true` in the configuration.
:::

[Learn more about destinations in the **SAP Cloud SDK documentation**.](https://sap.github.io/cloud-sdk/docs/java/features/connectivity/sdk-connectivity-destination-service){.learn-more}

### Configuring the URL

The destination or service binding configuration provides the base URL to the OData V2 or V4 service, that should be used by the _Remote Service_.
The full service URL however is built from three parts:

1. The URL provided by the destination or the service binding configuration.
1. An optional URL suffix provided in the _Remote Service_ http configuration under the `suffix` property.
1. The name of the service, either obtained from the optional `service` configuration property or the fully qualified name of the CDS service definition.

Consider this example:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  remote.services:
    API_BUSINESS_PARTNER:
      http:
        suffix: "/sap/opu/odata/sap"
      destination:
        name: s4-business-partner-api
```
:::

In this case, the destination with name `s4-business-partner-api` would be obtained from the `DestinationAccessor`.
Given that this destination holds the URL `https://s4.sap.com`, the resulting service URL for OData requests would be `https://s4.sap.com/sap/opu/odata/sap/API_BUSINESS_PARTNER`.

<div id="remote-rfc-services" />
<Fragment target="#remote-rfc-services">

## Remote RFC Services<Beta /><Internal />

To enable _Remote Services_ for RFC APIs in an application, add the following Maven dependency to your project:

```xml
<dependency>
    <groupId>com.sap.cds</groupId>
    <artifactId>cds-feature-remote-rfc</artifactId>
    <scope>runtime</scope>
</dependency>
```

The CAP Java remote RFC feature uses [JCo](https://support.sap.com/en/product/connectors/jco.html#section) to invoke functions on remote RFC systems and currently only includes a so-called _JCo embedding_ for the Cloud Foundry runtime environment. That JCo embedding uses destinations on the _SAP BTP Destination Service_ to look up metadata for connecting to the target RFC system.

As it builds upon the _Remote Services_ concept it's configured similarly to what is required for a remote OData API, by defining the two main aspects of a _Remote Service_:

1. The CDS service definition of the remote RFC API from the CDS model.
1. The destination of the remote API and its protocol type RFC.

### Getting the CDS Model of the Remote RFC API

There a two ways of acquiring the CDS model of the remote RFC API. Using `cds import`, which requires direct access to the RFC target system, or, if the RFC target system is on-premise and only reachable through the _SAP Cloud Connector_, using a _ SAP Business Application Studio (BAS)_ devspace with enabled productivity tools.

#### Using SAP Business Application Studio

Currently SAP Business Application Studio only allows to import a remote RFC API into a _CAP Node.js_ project. So for now, we have to create a new CAP Node.js project in a **Full-Stack Application Using Productivity Tools** devspace. In the [service center](https://help.sap.com/docs/bas/sap-business-application-studio/explore-services-using-service-center) tab, the required RFC function module can then be selected and [imported into the CAP project](https://help.sap.com/docs/bas/sap-business-application-studio/sap-system-service-provider?q=productivity+tool#service-actions-for-development) by using the button `Add to CAP project`.

This creates a CDS file in the CAP Node.js project, which then be copied to your _CAP Java_ project into the `srv/external` folder, as shown in the following exemplary project file structure:

```zsh
srv/             # your project's srv folder
├─ external.cds  # cds service definition
└─ external/     # srv/external folder
   └─ SYS.cds    # cds file created by rfc import
```

From there it can be imported into a CDS service definition of the `srv/` folder:

::: code-group
```cds [external.cds]
using { SYS } from './external/SYS';
```
:::

As all `*.cds` files under `srv/` are included by default into the project's CDS model representation. The name `SYS` corresponds in this example to the service name in the `SYS.cds` file:

::: code-group
```cds [SYS.cds]
@cds.external : true
@protocol : 'rfc'
service SYS {};
```
:::

#### Using CDS Import

Getting a CDS model of the RFC API via `cds import` requires the the [@sap/cds-rfc](https://github.tools.sap/cap/cds-rfc) integration plugin. This plugin requires a module that is only available through a dedicated NPM registry, only available for SAP customers. For details on how to set this up, see [Supported Platforms and Download Channels](https://github.tools.sap/cap/cds-rfc#supported-platforms-and-download-channels).

::: warning Needs direct access to target
Using `cds import` to acquire a CDS model of the remote RFC API only works if the target RFC system is directly reachable from your local machine.
:::

Add the npm package to the CAP project:

```sh
npm add @sap/cds-rfc
```

Update the `cds import` CLI in `@sap/cds-dk` to latest:

```sh
npm install -g @sap/cds-dk
```

Follow the link to [configure system access](https://github.tools.sap/cap/cds-rfc#configure-system-access) for the RFC target system. 

Now, you're all set up and can import the CDS model of the remote RFC API:
```sh
cds import --from rfc --as cds --name BAPI_USER_GET_DETAIL --destination SYS
```

This produces a CDS file that you can place into the `srv/external` folder.

From there it can be imported into a CDS service definition of the `srv/` folder:

::: code-group
```cds [external.cds]
using { SYS } from './external/SYS';
```
:::

As all `*.cds` files under `srv/` are included by default into the project's CDS model representation. The name `SYS` corresponds in this example to the service name in the `SYS.cds` file:

::: code-group
```cds [SYS.cds]
@cds.external : true
@protocol : 'rfc'
service SYS {};
```
:::

### Configuring the Remote RFC Service

The following example shows how you can configure a _remote RFC service_ in Spring Boot's _application.yaml_ based on a _BTP destination_ looked up from the _SAP BTP Destination Service_ by its name:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  remote.services:
    SYS:
      type: "rfc"
      destination:
        name: "S4H"
```
:::

Equivalent to remote OData, _remote RFC services_ use a CDS service definition from the CDS model as a specification of the remote API. This API specification is required to properly translate CQN statements into respective RFC requests. See also [Configuring Remote OData Services](#remote-odata-services).

By default the CDS service definition is looked up in the CDS model using the name of the _Remote Service_.
The name can be explicitly configured using the `name` property.
It defaults to the YAML key of the remote service configuration section (here: `SYS`).

The `type` property defines the protocol used by the remote API and for RFC APIs this has to be `rfc`.

The `destination.name` property refers to the destination to be looked up from the SAP BTP Destination Service.

#### Using BTP Destination and Cloud Connector

Typically, a remote RFC system is on-premise and only reachable through the [Cloud Connector](https://help.sap.com/docs/CP_CONNECTIVITY/cca91383641e40ffbe03bdc78f00f681/e6c7616abb5710148cfcf3e75d96d596.html).

This means that, besides having a configured destination in the _SAP BTP Destination Service_ and a configured _Cloud Connector_, CAP Java applications need to use BTP Service Bindings. These bindings connect to both a Destination Service and a Cloud Connectivity instance.

The JCo embedding for Cloud Foundry relies on _VCAP_SERVICES_ in the runtime environment. So, it needs to be told which keys in _VCAP_SERVICES_ refer to the XSUAA, the Cloud Connectivity, and the Destination Service instance, by setting the following environment variables:

- xsuaa_connectivity_instance_name
- connectivity_instance_name
- destination_instance_name

This can be done in the _mta.yaml_ file as in the following example:

::: code-group
```yaml [mta.yaml]
modules:
  - name: srv
    type: java
    path: srv
    parameters:
      memory: 1024M
      disk-quota: 512M
      buildpacks:
        - sap_java_buildpack_jakarta
    properties:
      SPRING_PROFILES_ACTIVE: cloud
      JBP_CONFIG_COMPONENTS: "jres: ['com.sap.xs.java.buildpack.jre.SAPMachineJRE']"
      JBP_CONFIG_SAP_MACHINE_JRE: '{ version: 21.+ }'
      xsuaa_connectivity_instance_name: rfc-srv-auth # [!code focus]
      connectivity_instance_name: rfc-srv-connectivity # [!code focus]
      destination_instance_name: rfc-srv-destination # [!code focus]
    requires:
      - name: rfc-srv-auth
      - name: rfc-srv-connectivity
      - name: rfc-srv-destination
...
resources:
  - name: rfc-srv-auth
    type: org.cloudfoundry.managed-service
    parameters:
      service: xsuaa
      service-plan: broker
      config:
        tenant-mode: shared
        xsappname: rfc-srv-${org}-${space}
      path: ./xs-security.json
  - name: rfc-srv-destination
    type: org.cloudfoundry.managed-service
    parameters:
      service: destination
      service-plan: lite
  - name: rfc-srv-connectivity
    type: org.cloudfoundry.managed-service
    parameters:
      service: connectivity
      service-plan: lite
```
:::

#### Using Local Destination Configuration

If an SAP Cloud Connector is not required to reach the target RFC system, you can configure the destination of the remote RFC API in your _application.yaml_ and access it without a deployment to Cloud Foundry.

In order to do so, you need to exclude the JCo embeddings for Cloud Foundry that come with `cds-feature-remote-rfc` and add a JCo embedding that let's you configure a destination locally:

::: code-group
```xml [srv/pom.xml]
<dependencies>
  <dependency>
    <groupId>com.sap.cds</groupId>
    <artifactId>cds-feature-remote-rfc</artifactId>
    <scope>runtime</scope>
    <exclusions>
      <exclusion>
        <groupId>com.sap.conn.jco-cloud</groupId>
        <artifactId>com.sap.conn.jco.cloud</artifactId>
      </exclusion>
      <exclusion>
        <groupId>com.sap.conn.jco-cloud</groupId>
        <artifactId>com.sap.conn.jco.cloud.rt.cloud</artifactId>
      </exclusion>
    </exclusions>
  </dependency>
  <dependency> 
    <groupId>com.sap.conn.jco</groupId> 
    <artifactId>sapjco3</artifactId> 
    <version>${sapjco3.version}</version> 
  </dependency> 
</dependencies>
```
:::

::: tip
Check for available versions of `com.sap.conn.jco:sapjco3` on Artifactory.
:::


Now, you can configure the destination under the `cds.remote.services.system.destination.properties` property in the `application.yaml`, as in the following example:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds.remote.services:
  SYS:
    type: "rfc"
    destination:
      properties:
      '[jco.client.ashost]': ...
      '[jco.client.client]': ...
      '[jco.client.sysnr]': ...
      ...
```
:::

These are all passed directly to the `DestinationDataProvider` of the JCo API to connect to the remote RFC system. For supported properties, also check the [JCo documentation (standalone version)](https://support.sap.com/content/dam/support/en_us/library/ssp/products/connectors/jco/jco_31_documentation.pdf).

</Fragment>

## Consuming Remote Services

_Remote Services_ can be used in your CAP application just like any other [service that accepts CQN queries](/java/cqn-services/):

```java
@Autowired
@Qualifier(ApiBusinessPartner_.CDS_NAME)
CqnService bupa;

CqnSelect select = Select.from(ABusinessPartnerAddress_.class)
    .where(a -> a.BusinessPartner().eq("4711"));

ABusinessPartnerAddress address = bupa.run(select)
    .single(ABusinessPartnerAddress.class);
```
::: tip
To learn more about how to build and run CQN queries, see sections [Building CQN Queries](../working-with-cql/query-api) and [Executing CQN Queries](../working-with-cql/query-execution).
:::

Keep in mind that _Remote Services_ are simply clients to remote APIs.
CAP doesn't automatically forward CQN queries to these services. Developers need to explicitly call and use these _Remote Services_ in their code.
However, as _Remote Services_ are based on the common CQN query APIs it's easy to use them in event handlers of your [Application Services](application-services).
::: warning
In case data from _Remote Services_ should be combined with data from the database custom coding is required.
Refer to the [Integrate and Extend guide](../../guides/using-services#integrate-and-extend) for more details.
:::

### Consuming Media Elements

#### Reading Media Elements

To read a [media elements](/guides/providing-services#annotating-media-elements) of an entity, you need to create a CQN statement that targets a single instance of this entity via its primary key in its `from()` clause and include _one_ media element in the select list.
Otherwise, the statement will be interpreted as a regular read and will not return values for media elements. Bulk reads are not supported.

Given the following model:

```cds
entity Media {
   key ID: UUID;

   @Core.MediaType: 'image/png'
   image: LargeBinary;
}
```

If you want to read `image` of this entity, you need to create a statement like this:

```java
Select.from(Media_.class, m -> m.filter(f -> f.ID().eq("..."))).columns(Media_::image);
```

If the entity has multiple media elements (in OData V4), you can read them one by one with dedicated statements each targeting a single element.
The OData call generated by CAP is an equivalent of the direct [read of the media property value](/guides/providing-services#reading-media-resources)

The content of the media element is returned as an `InputStream` or `Reader` that is not buffered and must be consumed so that the HTTP connection can be released.
In addition, content type and file name are returned back if corresponding elements of your entity exist.

#### Writing Media Elements

You write [media elements](/guides/providing-services#annotating-media-elements) with `Update` statements. Statements still need to target a single entity instance and
must include a single value for the media element as `InputStream` or `Reader`. Optionally the content type can be provided, if a corresponding element exists.
Batched or bulk updates are not supported and rejected.

If the value of the element is set to `null`, it is interpreted as a deletion of the media element value. An explicit `DELETE` request is sent to the media element URL in that case.

::: warning Mixing media and non-media elements
If the payload contains values for other elements as well, the statement is treated as a regular update and values for media elements are ignored.
:::

For example, the following statement updates the value of the element `image` in the remote service:

```java
Media payload = Media.create();
payload.setId(...);
payload.setImage(...);

Update.entity(Media_.class).entry(payload);
```

Updates are translated to OData requests to [update the media element value](/guides/providing-services#updating-media-resources) or [delete the value](/guides/providing-services#deleting-media-resources).

:::tip Creating an entity with media elements
`Insert` statements do not support media elements. Values for media elements need to be provided in a subsequent update.
:::

## Cloud SDK Integration

### Maven Dependencies {#cloud-sdk-dependencies}

The CAP Java SDK only includes the minimum SAP Cloud SDK dependencies required out of the box.
In case you want to leverage features from SAP Cloud SDK, like the [programmatic destination registration](#programmatic-destination-registration) or integration with SAP BTP Destination Service, you need to add additional dependencies.

It's recommended to add the SAP Cloud SDK BOM to the dependency management section of your application's parent POM.
If you're also using the CDS Services BOM or the Spring Boot dependencies BOM, it's recommended to add the SAP Cloud SDK BOM after these:

```xml
<dependencyManagement>
    
    
    <dependencies>
        <dependency>
            <groupId>com.sap.cloud.sdk</groupId>
            <artifactId>sdk-bom</artifactId>
            <version>use-latest-version-here</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

[Learn more about dependency management of **SAP Cloud SDK**.](https://sap.github.io/cloud-sdk/docs/java/guides/manage-dependencies/){.learn-more}

To enable [programmatic destination registration](#programmatic-destination-registration), add this additional dependency to your project:

```xml
<dependency>
    <groupId>com.sap.cloud.sdk.cloudplatform</groupId>
    <artifactId>cloudplatform-connectivity</artifactId>
</dependency>
```

To integrate with SAP BTP Destination Service on Cloud Foundry, add this additional dependency to your project:

```xml
<dependency>
    <groupId>com.sap.cloud.sdk.cloudplatform</groupId>
    <artifactId>scp-cf</artifactId>
</dependency>
```

### Configuring Destination Strategies { #destination-strategies }

When loading destinations from SAP BTP Destination Service, you can specify a [destination retrieval strategy](https://sap.github.io/cloud-sdk/docs/java/features/connectivity/sdk-connectivity-destination-service#retrieval-strategy-options) and a [token exchange strategy](https://sap.github.io/cloud-sdk/docs/java/features/connectivity/sdk-connectivity-destination-service#token-exchange-options).

These strategies can be set in the destination configuration of the _Remote Service_:

```yml [srv/src/main/resources/application.yaml]
cds:
  remote.services:
    API_BUSINESS_PARTNER:
      destination:
        name: "s4-business-partner-api"
        retrievalStrategy: "AlwaysProvider"
        tokenExchangeStrategy: "ExchangeOnly"
```

::: tip
Values for destination strategies have to be provided in pascal case.
:::

### Programmatic Destination Registration

You can also programmatically build destinations and add them to the `DestinationAccessor` to make them available for _Remote Services_.
You can easily register an event handler that is executed during startup of the application and build custom destinations:

```java
@Component
@ServiceName(ApplicationLifecycleService.DEFAULT_NAME)
public class DestinationConfiguration implements EventHandler {

    @Value("${api-hub.api-key:}")
    private String apiKey;

    @Before(event = ApplicationLifecycleService.EVENT_APPLICATION_PREPARED)
    public void initializeDestinations() {
        if(apiKey != null && !apiKey.isEmpty()) {
            DefaultHttpDestination httpDestination = DefaultHttpDestination
                .builder("https://sandbox.api.sap.com/s4hanacloud")
                .header("APIKey", apiKey)
                .name("s4-business-partner-api").build();

            DestinationAccessor.prependDestinationLoader(
                new DefaultDestinationLoader().registerDestination(httpDestination));
        }
    }

}
```

[Find out how to create destinations for different authentication types](#programmatic-destinations){.learn-more}
[Learn more about using destinations](../../guides/using-services#using-destinations){.learn-more}

Note that you can leverage Spring Boot's configuration possibilities to inject credentials into the destination configuration.
The same mechanism can also be used for the URL of the destination by also reading it from your application configuration (for example environment variables or _application.yaml_).
This is especially useful when integrating micro-services, which may have different URLs in productive environments and test environments.

## Native Service Consumption { #native-consumption }

If you need to call an endpoint that you cannot consume as a _Remote Service_, you can fall back to leverage Cloud SDK APIs. Based on the Cloud SDK's `HttpClientAccessor` API, you can resolve an `HttpClient` that you can use to execute plain HTTP requests against the remote API.

However, this involves low-level operations like payload de-/serialization. Usage of CAP's _Remote Service_ is encouraged whenever possible to free the developer from these.

[Learn more about HttpClientAccessor in the **SAP Cloud SDK documentation**.](https://sap.github.io/cloud-sdk/docs/java/features/connectivity/http-client){.learn-more}

### Using Service Bindings { #native-bindings }

If the URL and credentials of the remote API are available as a service binding, you can create a Cloud SDK destination for the service binding using the `ServiceBindingDestinationLoader` API. Based on this, it's possible to create an instance of `HttpClient` using the `HttpClientAccessor`:

```java
ServiceBinding binding = ...;
HttpDestination destination = ServiceBindingDestinationLoader.defaultLoaderChain().getDestination(
        ServiceBindingDestinationOptions
          .forService(binding)
          .onBehalfOf(OnBehalfOf.TECHNICAL_USER_CURRENT_TENANT)
          .build());

HttpClient httpClient = HttpClientAccessor.getHttpClient(destination);
...
```

[Learn more about HttpClientAccessor in the **SAP Cloud SDK documentation**.](https://sap.github.io/cloud-sdk/docs/java/features/connectivity/http-client){.learn-more}

To be able to resolve a service binding into a Cloud SDK destination, a `OAuth2PropertySupplier` might need to be registered with Cloud SDK.

```java
static {
    OAuth2ServiceBindingDestinationLoader.registerPropertySupplier(
        options -> options.getServiceBinding().getTags().contains("<bindingTag>"),
            BizPartnerOAuth2PropertySupplier::new);
}
```

[Learn more about registering OAuth2PropertySupplier in the **SAP Cloud SDK documentation**.](https://sap.github.io/cloud-sdk/docs/java/features/connectivity/service-bindings#customization){.learn-more}

### Using Destinations { #native-destinations }

If the URL and credentials of the remote API are configured as a destination in SAP BTP Destination Service, you can use Cloud SDK's `DestinationAccessor` API to load the destination based on its name. In a second step, `HttpClientAccessor` is used to create an instance of `HttpClient`:

::: code-group
```java [Cloud SDK v4]
HttpDestination destination = DestinationAccessor.getDestination("<destinationName>").asHttp();
HttpClient httpClient = HttpClientAccessor.getHttpClient(destination);
...
```
```java [Cloud SDK v5]
Destination destination = DestinationAccessor.getDestination("<destinationName>");
HttpClient httpClient = HttpClientAccessor.getHttpClient(destination);
...
```
::::

### Programmatic Destinations { #programmatic-destinations }

The following example code snippets show how to programmatically create a destination for different authentication types.
You can [register](#programmatic-destination-registration) these destinations with the `DestinationAccessor` to use them with _Remote Services_ or use them natively with the `HttpClientAccessor` to obtain `HttpClient` instances.

Use the following example if the remote API supports basic authentication:
```java
DefaultHttpDestination
  .builder("https://example.org")
	.basicCredentials("user", "password")
	.name("my-destination").build();
```

Use the following example if you can directly forward the token from the current security context:
```java
DefaultHttpDestination
  .builder("https://example.org")
	.authenticationType(AuthenticationType.TOKEN_FORWARDING)
	.name("my-destination").build();
```

Use the following example if you want to call the remote API using a technical user:
```java
ClientCredentials clientCredentials =
        new ClientCredentials("clientid", "clientsecret");

OAuth2DestinationBuilder
        .forTargetUrl("https://example.org")
        .withTokenEndpoint("https://xsuaa.url")
        .withClient(clientCredentials, OnBehalfOf.TECHNICAL_USER_CURRENT_TENANT)
        .property("name", "my-destination")
        .build();
```

Use the following example if you need to exchange the token from the security context (that is, user token exchange):
```java
ClientCredentials clientCredentials =
        new ClientCredentials("clientid", "clientsecret");

OAuth2DestinationBuilder
        .forTargetUrl("https://example.org")
        .withTokenEndpoint("https://xsuaa.url")
        .withClient(clientCredentials, OnBehalfOf.NAMED_USER_CURRENT_TENANT)
        .property("name", "my-destination")
        .build();
```

<div id="secondary-file">java/cqn-services/remote-services.fragment.md</div>


# Event Handlers


This section describes how to register event handlers on services. In CAP everything that happens at runtime is an [event](../../about/best-practices#events) that is sent to a [service](../../about/best-practices#services).
With event handlers, the processing of these events can be extended or overridden. Event handlers can be used to handle CRUD events, implement actions and functions, and to handle asynchronous events from a messaging service.

## Introduction to Event Handlers

CAP allows you to register event handlers for [events](../../about/best-practices#events) on [services](../../about/best-practices#services). An event handler is simply a Java method.
Event handlers enable you to add custom business logic to your application by either extending the processing of an event, or by completely overriding its default implementation.

::: tip
Event handlers are a powerful means to extend CAP. Did you know that most of the built-in features provided by CAP are implemented using event handlers?
:::

Common events are the CRUD events (`CREATE`, `READ`, `UPDATE`, `DELETE`), which are handled by the different kinds of [CQN-based services](../cqn-services/#cdsservices).
These events are most typically triggered when an HTTP-based protocol adapter (for example OData V4) executes a CQN statement on an Application Service to fulfill the HTTP request.
The CAP Java SDK provides a lot of built-in event handlers (also known as [Generic Providers](../../guides/providing-services)) that handle CRUD operations out of the box and implement the handling of many CDS annotations.
Applications most commonly use event handlers on CRUD events to _extend_ the event processing by using the [`Before`](#before) and [`After`](#after) phase.

[Actions](../../cds/cdl#actions) and [Functions](../../cds/cdl#actions) that are defined by an Application Service in its model definition are mapped to events as well.
Therefore, to implement the business logic of an action or function, you need to register event handlers as well.
Event handlers that implement the core processing of an event should be registered using the [`On`](#on) phase.

Events in CAP can have parameters and - in case they're synchronous - a return value. The CAP Java SDK uses [Event Contexts](#eventcontext) to provide a type-safe way to access parameters and return values.
In the case of CRUD events the corresponding Event Contexts provide, for example, access to the CQN statement. Event Contexts can be easily obtained in an event handler.

## Event Phases { #phases}

Events are processed in three phases that are executed consecutively: `Before`, `On`, and `After`. When registering an event handler the phase in which the event handler should be called, needs to be specified.
The CAP Java SDK provides an annotation for each event phase ([`@Before`](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/handler/annotations/Before.html), [`@On`](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/handler/annotations/On.html), and [`@After`](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/handler/annotations/After)).
These [annotations](#handlerannotations) can be used on event handler methods to indicate which phase of the event processing the method handles.

It's possible to register multiple event handlers for each event phase. Handlers within the same event phase are never executed concurrently.
In case concurrency is desired, it needs to be explicitly implemented within an event handler.
Note that by default there is no guaranteed order in which the handlers of the same phase are called.

The following subsections describe the semantics of the three phases in more detail.

### Before { #before}

The `Before` phase is the first phase of the event processing. This phase is intended for filtering, validation, and other types of preprocessing of the incoming parameters of an event.
There can be an arbitrary number of `Before` handlers per event.

The processing of the `Before` phase is completed when one of the following conditions applies:
- All registered `Before` handlers were successfully called. Execution continues with the `On` phase.
- A handler [completes the event processing](#eventcompletion) by setting a return value or setting the state of an event to completed.
  In this case, any remaining registered `Before` and `On` handlers are skipped and execution continues with the `After` phase.
- A handler throws an exception. In this case, event processing is terminated immediately.

### On { #on}

The `On` phase is started after the `Before` phase, as long as no return value is yet provided and no exception occurred. It's meant to implement the core processing of the event.
There can be an arbitrary number of `On` handlers per event, although as soon as the first `On` handler successfully completes the event processing, all remaining `On` handlers are skipped.

The `On` phase is completed when one of the following conditions applies:
- A handler [completes the event processing](#eventcompletion) by setting a result value or setting the state of an event to completed.
  In this case, any remaining registered `On` handlers are skipped and execution continues with the `After` phase.
- A handler throws an exception. In this case, event processing is terminated immediately.

In case of synchronous events, if after the `On` phase, no handler completed the event processing, it's considered an error and the event processing is aborted with an exception.
However, when registering an `On` handler for an asynchronous event it is not recommended to complete the event processing, as other handlers might not get notified of the event anymore.
In that case CAP ensures to auto-complete the event, once all `On` handlers have been executed.

### After { #after}

The `After` phase is only started after the `On` phase is completed successfully. Handlers are therefore guaranteed to have access to the result of the event processing.
This phase is useful for post-processing of the return value of the event or triggering side-effects.
A handler in this phase can also still abort the event processing by throwing an exception. No further handlers of the `After` phase are called in this case.

## Event Contexts { #eventcontext}

The [EventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/EventContext.html) is the central interface, that provides information about the event to the event handler.
The EventContext interface is a general interface that can be used with every event, it provides:
- Name of the event
- Entity targeted by the event
- Service the event was sent to
- Parameters and return value
- Request Context: User information, tenant-specific CDS model, headers and query parameters
- ChangeSet Context: Transactional boundaries of the event
- Service Catalog
- CDS Runtime

Parameters and the return value can be obtained and stored as key-value pairs in the Event Context using its `get` and `put` methods.

```java
EventContext context = EventContext.create("myEvent", null);

// set parameters
context.put("parameter1", "MyParameter1");
context.put("parameter2", 2);

srv.emit(context); // process event

// access return value
Object result = context.get("result");
```

Using the `get` and `put` methods has several drawbacks: The API is not type-safe and it's not clear what the correct keys for different event parameters are.
To solve these issues, it is possible to overlay the general Event Context with an event-specific Event Context, which provides typed getters and setters for the parameters of a specific event.
For each event that the CAP Java SDK provides out of the box (for example the [CRUD events](../cqn-services/application-services#crudevents)) a corresponding Event Context is provided.

Let's have a look at an example. The [CdsReadEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/CdsReadEventContext.html) interface is the `READ` event-specific Event Context.
As one of the parameters of the `READ` event is a [CqnSelect](../../cds/cqn#select), it provides a `CqnSelect getCqn()` method. The return value of a `READ` event is a [Result](../working-with-cql/query-execution#result).
The context therefore also provides a `Result getResult()` and a `setResult(Result r)` method. You can use the `as` method provided by the general Event Context to overlay it:

```java
CdsReadEventContext context = genericContext.as(CdsReadEventContext.class);
CqnSelect select = context.getCqn();
context.setResult(Collections.emptyList());
Result result = context.getResult();
```

The getter and setter methods, still operate on the simple get/put API shown in the previous example. They just provide a type-safe layer on top of it.
The `as` method uses Java Proxies behind the scenes. Therefore, an interface definition is all that is required to enable this functionality.

::: tip
Use these event-specific type-safe Event Context interfaces whenever possible.
:::

For actions or functions defined in the CDS model the [CAP Java SDK Maven Plugin](../developing-applications/building#cds-maven-plugin) can automatically generate Event Context objects, which provide type-safe access to the action or function parameters and allow to set the return values.

### Completing the Event Processing { #eventcompletion}

The Event Context also provides means to indicate the completion of the core processing of the event. This is important to finish the [`On`](#on) phase of a synchronous event.
In case the synchronous event does not have a return value the `setCompleted()` method should be used to indicate the completion of the core processing of the event.

```java
context.setCompleted();
```

In case the synchronous event has a return value the `setResult(...)` method of the event-specific Event Context automatically triggers the `setCompleted()` method as well.

```java
context.setResult(myResult);
```

### Explicitly Proceeding the On Handler Execution { #proceed-on }

An event handler registered to the [`On phase`](#on) can call `proceed()` on the Event Context to explicitly proceed executing the remaining registered [`On`](#on) handlers.
This allows the handler to pre- and post-process the Event Context in a single method, without fully overwriting the core processing of the event.
It also enables catching and handling exceptions thrown by an underlying handler.

```java
@On(event = "myEvent")
void wrapMyEvent(EventContext context) {
    context.put("param", "Adjusted"); // pre-process
    context.proceed(); // delegate to underlying handler
    context.put("result", 42); // post-process
}
```

Calling `proceed()` from a [`Before`](#before) or [`After`](#after) event handler is not allowed and will raise an exception.
If an [`On`](#on) handler has already [completed](#eventcompletion) the event processing, calling `proceed()` will not have any effects.

### Defining Custom EventContext Interfaces { #customeventcontext}

In certain cases you might want to define your own custom event-specific Event Context interfaces. Simply define an interface, which extends the general `EventContext` interface.
Use the `@EventName` annotation to indicate for which event this context should be used.
Getters and setters defined in the interface automatically operate on the `get` and `put` methods of the general Event Context.
In case you want to define the key they use for this, you can use the `@CdsName` annotation on the getter and setter method.

```java
@EventName("myEvent")
public interface MyEventContext extends EventContext {

    static MyEventContext create() {
        return EventContext.create(MyEventContext.class, null);
    }

    @CdsName("Param")
    String getParam();
    void setParam(String param);

    void setResult(Integer result);
    Integer getResult();

}
```

::: tip
For actions or functions defined in the CDS model the [CAP Java SDK Maven Plugin](../developing-applications/building#cds-maven-plugin) can automatically generate Event Context objects, which provide type-safe access to the action or function parameters and allow to set the return values.
:::


## Event Handler Classes { #handlerclasses}

Event handler classes contain one or multiple event handler methods. You can use them to group event handlers, for example for a specific service.
The class can also define arbitrary methods, which aren't event handler methods, to provide functionality reused by multiple event handlers.

In Spring Boot, event handler classes are Spring beans. This enables you to use the full range of Spring Boot features in your event handlers, such as [Dependency Injection](https://www.baeldung.com/spring-dependency-injection) or [Scopes](https://www.baeldung.com/spring-bean-scopes).

The following [example](https://github.com/SAP-samples/cloud-cap-samples-java/blob/f1f18b8fd015257d33606864481ac5e6ec082b45/srv/src/main/java/my/bookshop/handlers/AdminServiceHandler.java) defines an event handler class:

::: code-group
```java [AdminServiceHandler.java]
import org.springframework.stereotype.Component;
import com.sap.cds.services.handler.EventHandler;
import com.sap.cds.services.handler.annotations.ServiceName;

@Component
@ServiceName("AdminService")
public class AdminServiceHandler implements EventHandler {
  // ...
}
```
:::

- The annotation `@Component` instructs Spring Boot to create a bean instance from this class.
- The `EventHandler` marker interface is required for CAP to identify the class as an event handler class among all beans and scan it for event handler methods.
- The optional `@ServiceName` annotation can be used to specify the default service, which event handlers are registered on. It's possible to override this value for specific event handler methods.

::: tip
The CAP Java SDK Maven Plugin generates interfaces for services in the CDS model. These interfaces provide String constants with the fully qualified name of the service.
If the service name is based on the CDS model, it's recommended to use these constants with the `@ServiceName` annotation.
:::

It is possible to specify multiple service names. Event handlers are registered on all of these services.


```java
@ServiceName({"AdminService", "CatalogService"})
```

The `type` attribute of the `@ServiceName` annotation can be used to register event handlers on all services of a certain type:


```java
@ServiceName(value = "*", type = ApplicationService.class)
```

## Event Handler Annotations { #handlerannotations}

Event handler methods need to be annotated with one of the following annotations: [`@Before`](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/handler/annotations/Before.html), [`@On`](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/handler/annotations/On.html), or [`@After`](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/handler/annotations/After).
The annotation defines, during which [phase](#phases) of the event processing the event handler is called.

Each of these annotations can define the following attributes:
- `service`: The services the event handler is registered on. It's optional, if a `@ServiceName` annotation is specified on class-level.

- `serviceType`: The type of services the event handler is registered on, for example, `ApplicationService.class`. Can be used together with `service = "*"` to register an event handler on all services of a certain type.

- `event`: The events the event handler is registered on. The event handler is invoked in case any of the events specified matches the current event. Use `*` to match any event.
  It's optional, if the event can be inferred through an [Event Context argument](#contextarguments) in the handler signature.

- `entity`: The target entities that the event handler is registered on. The event handler is invoked in case any of the entities specified matches the current entity. Use `*` to match any entity.
  It's optional, if the entity can be inferred through a [POJO-based argument](#pojoarguments) in the handler signature. If no value is specified or can be inferred, it defaults to `*`.

::: tip
The interfaces of different service types provide String constants for the events they support (see for example the [CqnService](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/CqnService.html)).
The CAP Java SDK Maven Plugin generates interfaces for entities in the CDS model, which provide String constants with their fully qualified name.
It is recommended to use these constants with the `event` or `entity` attributes of the annotations.
:::


```java
// registers on multiple events
@Before(event = { "CREATE", "UPDATE" }, entity = "AdminService.Books")

// overrides the default service on class-level
// registers on any entity
@On(service = "CatalogService", event = "READ")

// usage of String constants is recommended
@After(event = CqnService.EVENT_READ, entity = Books_.CDS_NAME)
```

## Event Handler Method Signatures { #handlersignature}

The most basic signature of an event handler method is `public void process(EventContext context)`. However, event-specific Event Context and entity data arguments and return values are supported as well and can be freely combined.
It is even valid for event handler methods to have no arguments at all. Handler methods don't necessarily have to be public methods. They can also be methods with protected, private, or package visibility.

### Event Context Arguments { #contextarguments}

The [Event Context](#eventcontext) is the central interface that provides information about the event to the event handler.
An event handler can get access to the general `EventContext` by simply declaring an argument of that type in its method:

```java
@Before(event = CqnService.EVENT_READ, entity = Books_.CDS_NAME)
public void readBooks(EventContext context) { }
```

It is also possible to directly refer to event-specific Event Context interfaces in your arguments. In that case the general Event Context is automatically overlaid with the event-specific one:

```java
@Before(event = CqnService.EVENT_READ, entity = Books_.CDS_NAME)
public void readBooks(CdsReadEventContext context) { }
```

If an event-specific Event Context argument is used and the event handler annotation declares an event as well, the argument is automatically validated during startup of the application.
Alternatively it is possible to let CAP infer the event for the event handler registration from the Event Context argument:

```java
@Before(entity = Books_.CDS_NAME)
public void readBooks(CdsReadEventContext context) { }
```

::: tip
The mapping between an Event Context interface and an event, is based on the `@EventName` annotation of the Event Context interface.
:::

In case an event handler is registered on multiple events only the general Event Context argument can be used.
At runtime, the corresponding event-specific Event Context can be overlaid explicitly, if access to event-specific parameters is required:

```java
@Before(event = { CqnService.EVENT_CREATE, CqnService.EVENT_UPDATE }, entity = Books_.CDS_NAME)
public void changeBooks(EventContext context) {
    if(context.getEvent().equals(CqnService.EVENT_CREATE)) {
        CdsCreateEventContext ctx = context.as(CdsCreateEventContext.class);
        // ...
    } else {
        CdsUpdateEventContext ctx = context.as(CdsUpdateEventContext.class);
        // ...
    }
}
```

### Entity Data Arguments { #pojoarguments}

When adding business logic to an Application Service, event handlers most commonly need to access entity data.
Entity data can be directly accessed in the event handler method, by using an argument of type `CdsData`:

```java
@Before(event = { CqnService.EVENT_CREATE, CqnService.EVENT_UPDATE },
        entity = Books_.CDS_NAME)
public void changeBooks(List<CdsData> data) { }
```
> The `CdsData` interface extends `Map<String, Object>` with some additional JSON serialization capabilities and therefore provides a generic data access capability.

The CAP Java SDK Maven Plugin can generate data accessor interfaces for entities defined in the CDS model. These interfaces allow for a [typed access](../cds-data#typed-access) to data and can be used in arguments as well:

```java
@Before(event = { CqnService.EVENT_CREATE, CqnService.EVENT_UPDATE },
        entity = Books_.CDS_NAME)
public void changeBooks(List<Books> books) { }
```

::: tip
To learn more about typed access to data and how entity data is handled in CAP Java SDK, have a look at [Working with Data](../cds-data).
:::

If an entity data argument is used and the event handler annotation declares an entity as well, the argument is automatically validated during startup of the application.
Alternatively it is possible to let CAP infer the entity for the event handler registration from the entity data argument:

```java
@Before(event = { CqnService.EVENT_CREATE, CqnService.EVENT_UPDATE })
public void changeBooks(List<Books> books) { }
```

::: tip
The mapping between a data accessor interface and an entity, is based on the `@CdsName` annotation of the accessor interface.
:::

Entity data arguments only work on [CRUD events](../cqn-services/application-services#crudevents) of [CQN-based services](../cqn-services/#cdsservices). In addition they work with the [draft-specific CRUD events](../fiori-drafts#draftevents) provided by Draft Services.

The origin from which the entity data is provided depends on the phase of the event processing.
During the `Before` and `On` phase it is obtained from the CQN statement. The CQN statement contains the entity data that was provided by the service client.
However, during the `After` phase the entity data is obtained from the `Result` object, which is provided as the return value of the event to the service client.
Some CQN statements such as for example `CqnSelect`, which is used with `READ` events, don't allow to carry data. In these cases entity data arguments are set to `null`.

There are different flavors of entity data arguments. Besides using `List<Books>`, it's also possible to use `Stream<Books>`:

```java
@Before(event = { CqnService.EVENT_CREATE, CqnService.EVENT_UPDATE })
public void changeBooks(Stream<Books> books) { }
```

It is also possible to use non-collection-based entity arguments, such as `Books`. However, if multiple data rows are available at runtime an exception will be thrown in that case:

```java
@Before(event = { CqnService.EVENT_CREATE, CqnService.EVENT_UPDATE })
public void changeBook(Books book) { }
```

::: tip
Entity data arguments are safely modifiable.
During the `Before` and `On` phase changes affect the data carried by the CQN statement.
During the `After` phase changes affect the return value of the event.
:::

### Entity Reference Arguments

You can get an entity reference reflecting the reference of the currently processed CQN statement, by declaring a corresponding argument in your method signature.

```java
@After(event = CqnService.EVENT_UPDATE, entity = Books_.CDS_NAME)
public void changedBook(CqnStructuredTypeRef ref) { }
```

The CAP Java SDK Maven Plugin can generate query builder interfaces for entities defined in the CDS model. These interfaces allow you to build [type-safe queries](../working-with-cql/query-api#concepts) and can be used in arguments as well:

```java
@After(event = CqnService.EVENT_UPDATE, entity = Books_.CDS_NAME)
public void changedBook(Books_ ref) { }
```

If an entity reference argument is used, CAP can infer the entity for the event handler registration from the entity reference argument:

```java
@After(event = CqnService.EVENT_UPDATE)
public void changedBook(Books_ ref) { }
```

::: tip Mapping uses `@CdsName` annotation
The mapping between a query builder interface and an entity is based on the `@CdsName` annotation of the query builder interface.
:::

Entity data arguments work on all events that operate with a `CqnStatement`. This is the case for all CRUD events and custom bound actions or functions.

You can directly use these references to build further queries in your event handlers:

```java
@After(event = CqnService.EVENT_UPDATE)
public void changedBook(Books_ ref) {
  var select = Select.from(ref).columns(b -> b.title());
}
```

### Service Arguments { #servicearguments }

The CAP Java SDK Maven Plugin can [generate service interfaces](../cqn-services/application-services#trigger-action-or-function) for services defined in the CDS model.

To easily access these generated application-specific interfaces, you can declare corresponding arguments in your method signature.
The same approach works for generic interfaces like `CqnService` or `DraftService`.

The service instances that can be provided to the event handler are always the service instances that are processing the event.

```java
@After(event = CqnService.EVENT_UPDATE)
public void changedBook(Books book, AdminService service) { }
```

### Return Values

The return value of an event can be set by returning a value in an event handler method:

```java
@On(entity = Books_.CDS_NAME)
public Result readBooks(CdsReadEventContext context) {
    return db.run(context.getCqn());
}
```

In case an event handler method of the `Before` or `On` phase has a return value it automatically [completes the event processing](#eventcompletion), once it's executed.
Event handler methods of the `After` phase that have a return value, replace the return value of the event.

For [CRUD events](../cqn-services/application-services#crudevents) and [draft-specific CRUD events](../fiori-drafts#draftevents), return values that extend `Iterable<? extends Map<String, Object>>` are supported. The `Result` object or a list of entity data (for example `List<Books>`) fulfill this requirement.

```java
@On(entity = Books_.CDS_NAME)
public List<Books> readBooks(CdsReadEventContext context) {
    Books book = Struct.create(Books.class);
    // ...
    return Arrays.asList(book);
}
```

::: tip
To learn how to build your own Result objects, have a look at [Result Handling](../cqn-services/application-services#result-handling)
:::

For custom actions or functions, you can directly return the return value of the corresponding action or function in your event handler:

Given the following CDS model:
```cds
service World {
  function hello() returns String;
}
```

The event handler can directly return a `String`, which corresponds to the return type of the `hello` function:
```java
@On(event = "hello")
public String hello() {
  return "Hello World";
}
```

### Ordering of Event Handler Methods

You can influence the order in which the event handlers are executed by means of CAP annotation [@HandlerOrder](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/handler/annotations/HandlerOrder.html). It defines the order of handler methods within each phase of events. You may use constants `HandlerOrder.EARLY` or `HandlerOrder.LATE` to place one handler earlier or later relative to the handlers without the annotation. Note that handlers with the same `@HandlerOrder` are executed in a deterministic, but arbitrary sequence.

Generic handlers typically are executed by the framework before `HandlerOrder.EARLY` and after `HandlerOrder.LATE`:

1. Generic framework handlers
2. Custom handlers, annotated with `HandlerOrder.EARLY`
3. Custom handlers for phases `@Before`, `@On`, and `@After`
4. Custom handlers, annotated with `HandlerOrder.LATE`
5. Generic framework handlers


For example, in the following snippet, several methods are bound to the same phase of the `READ` event for the same entity and are executed one after another:

```java

@After(event = CqnService.EVENT_READ, entity = Books_.CDS_NAME)
@HandlerOrder(HandlerOrder.EARLY)
public void firstHandler(EventContext context) {
    // This handler is executed first
}

@After(event = CqnService.EVENT_READ, entity = Books_.CDS_NAME)
public void defaultHandler(EventContext context) {
    // This one is the second
}

@After(event = CqnService.EVENT_READ, entity = Books_.CDS_NAME)
@HandlerOrder(HandlerOrder.LATE)
public void lastHandler(EventContext context) {
    // This one is the last
}

```

CAP Java always executes event handlers in the order specified by the annotations, even if the handlers are defined in separate classes.

In addition, CAP Java respects the [Spring Framework annotation `@Order`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/core/annotation/Order.html) and executes the handlers, that are registered in such annotated beans, in the order defined by that annotation. If the `@HandlerOrder` annotation is specified, this overrides the order defined by `@Order`.



# Indicating Errors


Learn about the error handling capabilities provided by the CAP Java SDK.

## Overview

The CAP Java SDK provides two different ways to indicate errors:
- By throwing an exception: This completely aborts the event processing and rollbacks the transaction.
- By using the [Messages](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/messages/Messages.html) API: This adds errors, warnings, info, or success messages to the currently processed request, but doesn't affect the event processing or the transaction.

The message texts for both exceptions and the Messages API can use formatting and localization.

## Exceptions

Any exception that is thrown by an event handler method aborts the processing of the current event and causes any active transaction to be rolled back.
To indicate further details about the error, such as a suggested mapping to an HTTP response code, the CAP Java SDK provides a generic unchecked exception class, called [ServiceException](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/ServiceException.html).
It's recommended to use this exception class, when throwing an exception in an event handler.

When creating a new instance of `ServiceException` you can specify an [ErrorStatus](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/ErrorStatus.html) object, through which an internal error code and a mapping to an HTTP status code can be indicated.
An enum [ErrorStatuses](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/ErrorStatuses.html) exists, which lists many useful HTTP error codes already.
If no such error status is set when creating the ServiceException, it defaults to an internal server error (HTTP status code 500).

```java
// default error status
throw new ServiceException("An internal server error occurred", originalException);
// specifying an error status
throw new ServiceException(ErrorStatuses.CONFLICT, "Not enough stock available");
// specifying an error status and the original exception
throw new ServiceException(ErrorStatuses.BAD_REQUEST, "No book title specified", originalException);
```

The OData adapters turn all exceptions into an OData error response to indicate the error to the client.

## Messages

The [Messages](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/messages/Messages.html) API allows event handlers to add errors, warnings, info, or success messages to the currently processed request. Adding info, warning or success messages doesn't affect the event processing or the transaction. For error messages by default a `ServiceException` is thrown at the end of the `Before` handler phase.

The `Messages` interface provides a logger-like API to collect these messages. Additional optional details can be added to the [Message](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/messages/Message.html) using a builder API.
You can access the `Messages` API from the Event Context:

```java
context.getMessages().success("The order was successfully placed");
```

In Spring, you can also access it using Dependency Injection:

```java
@Autowired
Messages messages;

messages.warn("No book title specified");
messages.error("The book is no longer available").code("BNA").longTextUrl("/help/book-not-available");
```

The OData V4 adapter collects these messages and writes them into the `sap-messages` HTTP header by default.
However, when an OData V4 error response is returned, because the request was aborted by an exception, the messages are instead written into the `details` section of the error response.
Writing the messages into explicitly modeled messages properties isn't yet supported.

SAP Fiori uses these messages to display detailed information on the UI. The style how a message appears on the UI depends on the severity of the message.

### Throwing a ServiceException from Error Messages { #throwing-a-serviceexception-from-messages}

It is also possible to throw a [ServiceException](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/ServiceException.html) from error messages. This can, for example, be useful to cancel a request after collecting multiple validation errors. The individual validation checks will collect error messages in the `Messages` API. After the validation checks have been run, you call the `throwIfError()` method. Only if error messages have been collected, this method cancels the request with a [ServiceException](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/ServiceException.html):

```java
// throw a ServiceException, if any error messages have been added to the current request
messages.throwIfError();
```

If there are any collected error messages, this method creates a [ServiceException](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/ServiceException.html) from _one_ of these error messages.
The OData adapter turns this exception into an OData error response to indicate the error to the client. The remaining error messages are written into the `details` section of the error response.

`Messages.throwIfError()` is automatically called at the end of the `Before` handler phase to abort the event processing in case of errors. It is recommended to use the Messages API for validation errors and rely on the framework calling `Messages.throwIfError()` automatically, instead of throwing a `ServiceException`.


## Formatting and Localization

Texts passed to both `ServiceException` and the `Messages` API can be formatted and localized.
By default, you can use [SLF4J's messaging formatting style](https://www.slf4j.org/api/org/slf4j/helpers/MessageFormatter.html) to format strings passed to both APIs.

```java
// message with placeholders
messages.warn("Can't order {} books: Not enough on stock", orderQuantity);
// on ServiceException last argument can always be the causing exception
throw new ServiceException(ErrorStatuses.BAD_REQUEST, "Invalid number: '{}'", wrongNumber, originalException);
```

You can localize these strings, by putting them into property files and passing the key of the message from the properties file to the API instead of the message text.

When running your application on Spring, the CAP Java SDK integrates with [Spring's support for handling text resource bundles](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.internationalization). This handling by default expects translated texts in a `messages.properties` file under `src/main/resources`.

The texts defined in the resource bundles can be formatted based on the syntax defined by `java.text.MessageFormat`.
When the message or exception text is sent to the client it's localized using the client's locale, as described [in the Localization Cookbook](../../guides/i18n#user-locale).

::: code-group
```properties [messages.properties]
my.message.key = This is a localized message with {0} parameters
```

```properties [messages_de.properties]
my.message.key = Das ist ein übersetzter Text mit {0} Parametern
```
:::


```java
// localized message with placeholders
messages.warn("my.message.key", paramNumber);
// localized message with placeholders and additional exception
throw new ServiceException(ErrorStatuses.BAD_REQUEST, "my.message.key", paramNumber, originalException);
```

### Translations for Validation Error Messages { #ootb-translated-messages }

CAP Java provides out-of-the-box translation for error messages that originate from input validation annotations such as `@assert...` or `@mandatory` and security annotations `@requires` and `@restrict`.

The error messages are optimized for UI scenarios and avoid any technical references to entity names or element names. Message targets are used where appropriate to allow the UI to show the error message next to the affected UI element.
You can disable these translated error messages by setting [<Config java>cds.errors.defaultTranslations.enabled: false</Config>](../developing-applications/properties#cds-errors-defaultTranslations-enabled).

### Provide custom error messages

By default, CAP Java provides error messages in several languages. If an error message or translation isn't sufficient for an application, it can be overwritten with a custom error message. Applications can provide the new error message under the respective error code in the application's `messages.properties` resource bundle under `src/main/resources`.
To know which error codes and messages are available by default, you can have a look at the Java enumeration `com.sap.cds.services.utils.CdsErrorStatuses` with your favorite IDE. This enumeration shows all available error codes and messages that are used by the CAP Java runtime.

## Target

When SAP Fiori interprets messages it can handle an additional `target` property, which, for example, specifies which element of an entity the message refers to. SAP Fiori can use this information to display the message along the corresponding field on the UI.
When specifying messages in the `sap-messages` HTTP header, SAP Fiori mostly ignores the `target` value.
Therefore, specifying the `target` can only correctly be used when throwing a `ServiceException` as SAP Fiori correctly handles the `target` property in OData V4 error responses.

A message target is always relative to an input parameter in the event context.
For CRUD-based events this is always the `cqn` parameter, which represents and carries the payload of the request.
For actions or functions, a message target can either be relative to the entity to which the action or function is bound (represented by the `cqn` parameter) or relative to a parameter of the action or function.
In case of actions and functions SAP Fiori also requires the message target to be prefixed with the action or function's binding parameter or parameter names.

When creating a message target, the correct parameter needs to be selected to specify what the relative message target path refers to.
By default a message target always refers to the CQN statement of the event. In case of CRUD events this is the targeted entity. In case of bound actions and functions this is the entity that the action or function was bound to.
As CRUD event handlers are often called from within bound actions or functions (e.g. `draftActivate`), CAP's OData adapter adds a parameter prefix to a message target referring to the `cqn` parameter only when required.

::: info
When using the `target(String)` API, which specifices the full target as a `String`, no additional parameter prefixes are added by CAP's OData adapter. The `target` value is used as specified.
:::

Let's illustrate this with the following example:

```cds
entity Books : cuid, managed {
    title  : localized String(111);
    descr  : localized String(1111);
    author : Association to Authors;
}

entity Authors : cuid, managed {
    name         : String(111);
    dateOfBirth  : Date;
    placeOfBirth : String;
    books        : Association to many Books
                       on books.author = $self;
}

entity Reviews : cuid, managed {
    book   : Association to Books;
    rating : Rating;
    title  : String(111);
    text   : String(1111);
}

service CatalogService {
    type Reviewer {
        firstName : String;
        lastName  : String;
    }
    entity Books as projection on my.Books excluding {
        createdBy,
        modifiedBy
    } actions {
        action addReview(reviewer : Reviewer, rating : Integer,
          title : String, text : String) returns Reviews;
    };
}
```

Here, we have a `CatalogService` that exposes et al. the `Books` entity and a `Books` bound action `addReview`.

### CRUD Events

Within a `Before` handler that triggers on inserts of new books a message target can only refer to the `cqn` parameter:

``` java
@Before
public void validateTitle(CdsCreateEventContext context, Books book) {
    // ...

    // event context contains the "cqn" key

    // implicitly referring to cqn
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "No title specified")
        .messageTarget(b -> b.get("title"));

    // which is equivalent to explicitly referring to cqn
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "No title specified")
        .messageTarget("cqn", b -> b.get("title"));

    // which is the same as using plain string
    // assuming direct POST request
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "No title specified")
        .messageTarget("title");

    // which is the same as using plain string
    // assuming surrounding bound action request with binding parameter "in",
    // e.g. draftActivate
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "No title specified")
        .messageTarget("in/title");
}
```

Instead of using the generic API for creating the relative message target path, CAP Java SDK also provides a typed API backed by the CDS model:

``` java
@Before
public void validateTitle(CdsCreateEventContext context, Books book) {
    // ...

    // implicitly referring to cqn
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "No title specified")
        .messageTarget(Books_.class, b -> b.title());
}
```

This also works for nested paths with associations:

``` java
@Before
public void validateAuthorName(CdsCreateEventContext context, Books book) {
    // ...

    // using un-typed API
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "No title specified")
        .messageTarget(b -> b.to("author").get("name"));

    // using typed API
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "No author name specified")
        .messageTarget(Books_.class, b -> b.author().name());
}
```

### Bound Actions and Functions


The same applies to message targets that refer to an action or function input parameter:

``` java
@Before
public void validateReview(BooksAddReviewContext context) {
    // ...

    // event context contains the keys "reviewer", "rating", "title", "text",
    // which are the input parameters of the action "addReview"

    // referring to action parameter "reviewer", targeting "firstName"
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "Invalid reviewer first name")
        .messageTarget("reviewer", r -> r.get("firstName"));

    // which is equivalent to using the typed API
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "Invalid reviewer first name")
        .messageTarget(BooksAddReviewContext.REVIEWER, Reviewer_.class, r -> r.firstName());

    // targeting "rating"
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "Invalid review rating")
        .messageTarget("rating");

    // targeting "title"
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "Invalid review title")
        .messageTarget("title");

     // targeting "text"
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "Invalid review text")
        .messageTarget("text");
}
```

If a message target refers to the `cqn` of the event context, for bound actions and functions that means, that the message target path is relative to the bound entity.

For the `addReview` action that is the `Books` entity, as in the following example:

``` java
@Before
public void validateReview(BooksAddReviewContext context) {
    // ...

    // referring to the bound entity `Books`
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "Invalid book description")
        .messageTarget(b -> b.get("descr"));

    // or (using the typed API, referring to "cqn" implicitly)
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "Invalid book description")
        .messageTarget(Books_.class, b -> b.descr());

    // which is the same as using plain string
    throw new ServiceException(ErrorStatuses.BAD_REQUEST, "Invalid book description")
        .messageTarget("in/descr");
}
```

::: tip
The previous examples showcase the target creation with the `ServiceException` API, but the same can be done with the `Message` API and the respective `target(...)` methods.
:::


## Error Handler { #errorhandler}

An [exception](#exceptions) thrown in an event handler will stop the processing of the request. As part of that, protocol adapters trigger the `ERROR_RESPONSE` event of the [Application Lifecycle Service](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/application/ApplicationLifecycleService.html). By default, this event combines the thrown exception and the [messages](#messages) from the `RequestContext` in a list to produce the error response. OData V4 and V2 protocol adapters will use this list to create an OData error response with the first entry being the main error and the remaining entries in the details section.

You can add event handlers using the `@After` phase for the `ERROR_RESPONSE` event to augment or change the error responses:
- Method `getException()` of [ErrorResponseEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/application/ErrorResponseEventContext.html) returns the exception that triggered the event.
- Method `getEventContexts()` of [ServiceException](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/ServiceException.html) contains the list of [event contexts](../event-handlers/#eventcontext), identifying the chain of processed events that led to the error. The first entry in the list is the context closest to the origin of the exception.

You can use the exception and the list of events contexts (with service, entity and event name) to selectively apply your custom error response handling. Some exceptions, however, may not be associated with a context and the list of contexts will be empty for them.

The list of messages available via `getResult().getMessages()` of the `ErrorResponseEventContext` contains the messages (see [Messages API](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/messages/Message.html)) the protocol adapter will use to generate the final error response. You can remove, reorder or add new messages to this list by using `Message.create()` . You can also override the resulting HTTP status with method `getResult().setHttpStatus()`. Use only statuses that indicate errors, meaning status code 400 or higher.

::: warning
Don't create new messages in the `Messages` of the `RequestContext` (also available through `context.getMessages()`). They will not be included in the response. Only the result provided by the `ErrorResponseEventContext` is considered by the protocol adapter.
:::

In case your implementation of the error handler throws an exception, returns no messages or sets a non-error HTTP status, the error response will default to a generic internal server error with HTTP status 500 and will not display any error details.

The following example of a simple error handler overrides the standard message text of authorization errors. Technically, it replaces the first message, that is the main error in OData, in the response with a new message that has a custom text, **only** for exceptions with error code `CdsErrorStatuses.EVENT_FORBIDDEN`.

```java
@Component
@ServiceName(ApplicationLifecycleService.DEFAULT_NAME)
public class SimpleExceptionHandler implements EventHandler {

  @After
  public void overrideMissingAuthMessage(ErrorResponseEventContext context) {
    if (context.getException().getErrorStatus().equals(CdsErrorStatuses.EVENT_FORBIDDEN)) {
        context.getResult().getMessages().set(0,
            Message.create(Message.Severity.ERROR,
            "You cannot execute this action"));
    }
  }
}
```

The second example shows how to override validation messages triggered by the annotation `@assert.range` for a certain entity. The exception [triggered by CAP](#throwing-a-serviceexception-from-messages) contains a reference to the event context that can be used to identify the target entity. The target of each message can be used to identify the affected field, but keep in mind that targets are always relative to the root entity of the request. That means in case of deep inserts or updates, you need to match not only the entity that has annotations but also the parent entities.

```java
@Component
@ServiceName(ApplicationLifecycleService.DEFAULT_NAME)
public class ExceptionServiceErrorMessagesHandler implements EventHandler {

  @After
  public void overrideValidationMessages(ErrorResponseEventContext context) {
    context.getException().getEventContexts().stream().findFirst().ifPresent(originalContext -> {
      if (Books_.CDS_NAME.equals(originalContext.getTarget().getQualifiedName())) { // filter by entity
        List<Message> messages = context.getResult().getMessages();
        for(int i=0; i<messages.size(); ++i) {
          Message message = messages.get(i);
          if (CdsErrorStatuses.VALUE_OUT_OF_RANGE.getCodeString().equals(message.getCode())) { // filter by error code
            if (Books.PRICE.equals(message.getTarget().getRef().targetSegment().id())) { // filter by target
              messages.set(i, Message.create(Message.Severity.ERROR, "The exceptional price is not in defined range!", message));
            } else if (Books.STOCK.equals(message.getTarget().getRef().targetSegment().id())) {
              messages.set(i, Message.create(Message.Severity.ERROR, "The exceptional stock of specified items is not available!", message));
            }
          }
        }
      }
    });
  }
}
```

::: tip
If you replace the message with a new one, make sure that you copy the code and target of the original. Otherwise, SAP Fiori clients may not be able to display them properly. Use method `Message.create(Severity severity, String text, Message message)` to create a new message and copy all additional attributes from the existing one.
:::



# Request Contexts


Request Contexts span the execution of multiple events on (different) services. They provide a common context to these events, by providing user or tenant information or access to headers or query parameter.


## Overview

When [events](../../about/best-practices#events) are processed on [services](../services), [event context](../event-handlers/#eventcontext) objects are used to store information related to a specific event.
However, when processing an HTTP request in a protocol adapter or receiving an asynchronous event from a messaging system not only a single event is triggered. Other services, like the [Persistence Service](../cqn-services/persistence-services) or additional technical services might be involved in processing. All of these services and their event handler need access to certain overarching metadata, such as user information, the selected locale, the tenant, and its (extended) CDS model or headers and query parameters.

The CAP Java SDK manages and exposes this kind of information by means of [RequestContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/RequestContext.html) instances. They define a scope that is typically determined by the context of a single HTTP request. The active Request Context can be accessed from the Event Context. However, those two are managed independently, as Event Contexts are passed along event handlers, while Request Contexts are maintained as thread-locals. For example, the Persistence Service requires the tenant to be set correctly in the Request Context in order to access the tenant-specific persistence.

Inside an event handler, it's guaranteed that a Request Context is available. How to access the exposed information is described in detail in [Accessing Request Contexts](#reading-requestcontext).

Usually, the protocol adapter opens a *single* Request Context that makes the request's parameters available to CAP services used during request processing. In contrast, an OData `$batch` request sequentially opens *different*  Request Contexts with divergent parameters for the different requests inside the batch. This behaviour ensures that Event Handlers triggered by the individual requests can only access the relevant parameters.

In general, it's possible to explicitly define (nested) Request Contexts and control their scope of validity. For example, in some cases an application might be required to break out from the current tenant to access a shared, tenant-independent persistence. All events triggered within the same context also share the same parameters. This is described in detail in [Defining Request Contexts](#defining-requestcontext).

How to propagate Request Context instances to several threads is explained in [Passing Request Contexts to Threads](#threading-requestcontext), and [Registering Global Parameter Providers](#global-providers) shows how you can influence or even override the standard way of retrieving the parameters from the request.

## Accessing Request Contexts { #reading-requestcontext}

The Request Context provides information about the request's parameters as well as the current user:
- [UserInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/UserInfo.html): Exposes an API to fetch data of the (authenticated) user such as the logon name, id, CAP roles, and the tenant.
- [ParameterInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/ParameterInfo.html): Exposes an API to retrieve additional request data such as header values, query parameters, and the locale.
- [AuthenticationInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/authentication/AuthenticationInfo.html): Exposes an API to retrieve the authentication claims according to the authentication strategy. Can be used for user propagation.
- [FeatureTogglesInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/FeatureTogglesInfo.html): Exposes an API to retrieve activated feature toggles of the request.

In addition, it provides access to the [CDS model](../working-with-cql/query-introspection), which specifically can be dependent on tenant information or feature toggles.

You can get instances from the [Event Context](../event-handlers/#eventcontext):

```java
@Before(event = CqnService.EVENT_READ)
public void beforeRead(CdsReadEventContext context) {
    UserInfo userInfo = context.getUserInfo();
    boolean isAuthenticated = userInfo.isAuthenticated();

    ParameterInfo parameterInfo = context.getParameterInfo();
    Locale locale = parameterInfo.getLocale();

    // OAuth2 authentication provided:
    AuthenticationInfo authInfo = context.getAuthenticationInfo();
    JwtTokenAuthenticationInfo jwtTokenInfo = authInfo.as(JwtTokenAuthenticationInfo.class);
    String jwtToken = jwtTokenInfo.getToken();

    FeatureTogglesInfo ftsInfo = context.getFeatureTogglesInfo();
    if (ftsInfo.isEnabled("experimental")) {
      // ...
    }
}
```

When running in Spring, you can also use Dependency Injection:

```java
@Autowired
UserInfo userInfo;

@Autowired
ParameterInfo parameterInfo;

@Autowired
AuthenticationInfo authInfo;

@Autowired
FeatureTogglesInfo ftsInfo;


@Before(event = CqnService.EVENT_READ)
public void beforeRead() {
    boolean isAuthenticated = userInfo.isAuthenticated();
    Locale locale = parameterInfo.getLocale();
    // ...
}
```

[UserInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/UserInfo.html) reflects the minimal API, which is required by generic CAP handlers (for example, for authorization). Depending on the configured authentication strategy, a lot more useful information might be presented in the user claim. For instance, XSUAA users additionally bear email, given, and family name etc. You can retrieve these properties with `userInfo.getAdditionalAttribute("<property-name>")`.
To establish type-safe access, additional attributes may also be accessed via custom extensions of `UserInfo`. To map XSUAA users, interface `XsuaaUserInfo` is available by default. You can create `XsuaaUserInfo` instances either by calling `userInfo.as(XsuaaUserInfo.class)` or by Spring injection:

```java
@Autowired
XsuaaUserInfo xsuaaUserInfo;

@Before(event = CqnService.EVENT_READ)
public void beforeRead() {
	boolean isAuthenticated = xsuaaUserInfo.isAuthenticated();
	String email = xsuaaUserInfo.getEmail();
	String givenName = xsuaaUserInfo.getGivenName();
	String familyName = xsuaaUserInfo.getFamilyName();
    // ...
}
```

The same functionality is provided for arbitrary custom interfaces, which are extensions of `UserInfo`.

[ParameterInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/ParameterInfo.html) provides access to request-specific information.
For example, if the request is processed by an HTTP-based protocol adapter, `ParameterInfo` provides access to the HTTP request information. It exposes the [correlation ID](../operating-applications/observability#correlation-ids), the locale, the headers, and the query parameters of a request.

[AuthenticationInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/authentication/AuthenticationInfo.html) stores the authentication claims of the authenticated user. For instance, if OAuth2-based authentication is used, this is a JWT token (for example, XSUAA or IAS). You can call `is(Class<? extends AuthenticationInfo>)` to find the concrete `AuthenticationInfo` type.
[JwtTokenAuthenticationInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/authentication/JwtTokenAuthenticationInfo.html) represents a JWT token, but [BasicAuthenticationInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/authentication/BasicAuthenticationInfo.html) can be observed on requests with basic authentication (for example, test scenario with mock users). The method `as(Class<? extends AuthenticationInfo>)` helps to perform the downcast to a concrete subtype.

## Defining New Request Contexts { #defining-requestcontext}

The CAP Java SDK allows you to create new Request Contexts and define their scope. This helps you to control, which set of parameters is used when events are processed by services.

There are a few typical use cases in a CAP-based, multitenant application on SAP BTP in which creation of new Request Contexts is necessary. These scenarios are identified by a combination of the user (technical or named) and the tenant (provider or subscribed).

![A named user can switch to a technical user in the same/subscriber tenant using the systemUser() method. Also, a named user can switch to a technical user in the provider tenant using the systemUserProvider() method. In addition technical users provider/subscriber tenants can switch to technical users on provider/subscriber tenants using the methods systemUserProvider() or systemUser(tenant).](./assets/requestcontext.drawio.svg)

When calling CAP Services, it's important to call them in an appropriate Request Context. Services might, for example,  trigger HTTP requests to external services by deriving the target tenant from the current Request Context.

The `RequestContextRunner` API offers convenience methods that allow an easy transition from one scenario to the other.

| Method               | Description                                                                                                                          |
|----------------------|--------------------------------------------------------------------------------------------------------------------------------------|
| systemUserProvider() | Switches to a technical user targeting the provider account.                                                                         |
| systemUser()         | Switches to a technical user and preserves the tenant from the current `UserInfo` (for example downgrade of a named user Request Context). |
| systemUser(tenant)   | Switches to a technical user targeting a given subscriber account.                                                                   |
| anonymousUser()      | Switches to an anonymous user.                                                                                                       |
| privilegedUser()     | Elevates the current `UserInfo` to by-pass all authorization checks.                                                                 |

::: info Note
The [RequestContextRunner](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/runtime/RequestContextRunner.html) API does not allow you to create a Request Context based on a named user. Named user contexts are only created by the CAP Java framework as initial Request Context is based on appropriate authentication information (for example, JWT token) attached to the incoming HTTP request.
:::

In the following a few concrete examples are given:
- [Switching to Technical User](#switching-to-technical-user)
- [Switching to Provider Tenant](#switching-to-provider-tenant)
- [Switching to a Specific Technical Tenant](#switching-to-a-specific-technical-tenant)

### Switching to Technical User

![The graphic is explained in the accompanying text.](./assets/nameduser.drawio.svg)

The incoming JWT token triggers the creation of an initial RequestContext with a named user. Accesses to the database in the OData Adapter as well as the custom `On` handler are executed within <i>tenant1</i> and authorization checks are performed for user <i>JohnDoe</i>. An additionally defined `After` handler wants to call out to an external service using a technical user without propagating the named user <i>JohnDoe</i>.
Therefore, the `After` handler needs to create a new Request Context. To achieve this, it's required to call `requestContext()` on the current `CdsRuntime` and use the `systemUser()` method to remove the named user from the new Request Context:

```java
@After(entity = Books_.CDS_NAME)
public void afterHandler(EventContext context){
    runtime.requestContext().systemUser().run(reqContext -> {
        // call technical service
        ...
    });
}
```
### Switching to Technical Provider Tenant {#switching-to-provider-tenant}

![The graphic is explained in the accompanying text.](./assets/switchprovidertenant.drawio.svg)

The application offers an action for one of its CDS entities. Within the action, the application communicates with a remote CAP service using an internal technical user from the provider account. The corresponding `on` handler of the action needs to create a new Request Context by calling `requestContext()`. Using the `systemUserProvider()` method, the existing user information is removed and the tenant is automatically set to the provider tenant. This allows the application to perform an HTTP call to the remote CAP service, which is secured using the pseudo-role `internal-user`.

```java
@On(entity = Books_.CDS_NAME)
public void onAction(AddToOrderContext context){
    runtime.requestContext().systemUserProvider().run(reqContext -> {
        // call remote CAP service
        ...
    });
}
```
### Switching to a Specific Technical Tenant

![The graphic is explained in the accompanying text.](./assets/switchtenant.drawio.svg)

The application is using a job scheduler that needs to regularly perform tasks on behalf of a certain tenant. By default, background executions (for example in a dedicated thread pool) aren't associated to any subscriber tenant and user. In this case, it's necessary to explicitly define a new Request Context based on the subscribed tenant by calling `systemUser(tenantId)`. This ensures that the Persistence Service performs the query for the specified tenant.

```java
runtime.requestContext().systemUser(tenant).run(reqContext -> {
    return persistenceService.run(Select.from(Books_.class))
        .listOf(Books.class);
});
```
## Modifying Request Contexts { #modifying-requestcontext}

Besides the described common use cases, it's possible to modify parts of an existing Request Context. To manually add, modify or reset specific attributes within the scope of a new Request Context, you can use the [RequestContextRunner](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/runtime/RequestContextRunner.html) API.

```java
List<Books> readBooksNotLocalized(EventContext context) {
  return context.getCdsRuntime().requestContext()
    .modifyParameters(param -> param.setLocale(null))
    .run(newContext -> {
      return persistenceService.run(Select.from(Books_.class))
        .listOf(Books.class);
    });
}
```

In the example, executing the CQN Select query on the Persistence Service needs to run inside a Request Context without locale in order to retrieve unlocalized data. Before the execution, the newly created context that wraps the functional code, can be modified arbitrarily:

- `modifyParameters()`: Add, modify, or remove (single) parameters.
- `clearParameters()`: Resets all parameters.
- `providedParameters()`: Resets the parameters according to the registered `ParameterInfoProvider`.

Similarly, it's possible to fully control the `UserInfo` instance provided in the RequestContext. It's guaranteed, that the original parameters aren't touched by the nested `RequestContext`. In addition, all original parameter values, which aren't removed or modified are visible in the nested scope. This enables you to either define the parameters from scratch or just to put a modification layer on top.

Some more examples:

- `modifyUser(user -> user.removeRole("read").setTenant(null).run(...)`: Creates a context with a user that is similar to the outer context but without role `read` and tenant.
- `modifyParameters(param -> param.setHeader("MY-HEADER", "my value"))`: Adds or sets a header parameter `MY-HEADER:my value`.

The modifications can be combined arbitrarily in fluent syntax.

### Request Context Inheritance

When creating a new Request Context all information that is stored in it is obtained through _providers_, see also [Registering Global Providers](#global-providers).
Any modifications that you perform are applied on the information obtained by these providers. However:
- A new nested Request Context, created within a scope that already has a Request Context, inherits copies of all values from its parent Request Context.
- Modifications in that scenario are applied on the inherited information.

Special care needs to be taken with regard to the CDS model and feature toggles.
- Both of these are _only_ determined in the initial Request Context.
- It's not possible to modify the CDS Model and feature toggles when creating a nested Request Context.

There's one exception to that rule: When modifying the user's tenant the CDS model is also redetermined.

::: tip
When changing the user's tenant it's required to open a new [ChangeSet](./changeset-contexts#changeset-contexts), to ensure that database transactions and connections are directed to the new tenant. In case you miss this step CAP Java SDK detects this error and prevent any database access to avoid leaking information between tenants.
:::

## Registering Global Providers { #global-providers}

The CAP Java SDK ensures that each Request Context provides non-null values of the objects stored in it. Hence, if a service is called outside the scope of an existing Request Context, the runtime implicitly creates a Request Context for that service call. To accomplish the initialization of a Request Context, the CAP Java SDK uses provider APIs, such as [UserInfoProvider](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/runtime/UserInfoProvider.html) or [ParameterInfoProvider](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/runtime/ParameterInfoProvider.html). The default providers registered with the `CdsRuntime` usually derive the required information from the HTTP request, if available.

These provider interfaces allow for customization. That means, the way how `UserInfo` or `ParameterInfo` are initially determined, can be modified or replaced.

For example, in some scenarios the user information can't be derived from a principal attached to the current thread, as done in the default `UserInfoProvider`. Authentication is done outside the service and user information is passed via dedicated header parameters. A custom provider to support this could look like in this sketch:

```java
@Component
@Order(1)
public class HeaderBasedUserInfoProvider implements UserInfoProvider {

    @Autowired
    HttpServletRequest req; // accesses current HTTP request

    @Override
    public UserInfo get() {
        if (RequestContextHolder.getRequestAttributes() != null) {
            // only within request thread req is available
            return UserInfo.create()
                .setTenant(req.getHeader("custom-tenant-header"))
                .setName(req.getHeader("custom-username-header"));
        }
        return UserInfo.create();
    }
}
```

It's allowed to define several providers of the same type. In Spring, the provider with the lowest `@Order` is first. In plain Java, the order is given by registration order. You can reuse the provider with lower priority and build a modified result. To accomplish this, remember the previous provider instance, which is passed during registration via `setPrevious()` method call. Such a chain of providers can be used to normalize user names or adjust user roles to match specific needs.

```java
@Component
public class CustomUserInfoProvider implements UserInfoProvider {

    private UserInfoProvider previousProvider;

    @Override
    public UserInfo get() {
        ModifiableUserInfo userInfo = UserInfo.create();
        if (previousProvider != null) {
            UserInfo previous = previousProvider.get();
            if (previous != null) {
                userInfo = previous.copy();
            }
        }
        if (userInfo != null) {
            // Normalize user name
            userInfo.setName(userInfo.getName().toLowerCase(Locale.ENGLISH));
        }

        return userInfo;
    }

    @Override
    public void setPrevious(UserInfoProvider previous) {
        this.previousProvider = previous;
    }
}
```

## Passing Request Contexts to Threads { #threading-requestcontext}

CAP service calls can be executed in different threads. In most cases the Request Context from the parent thread - typically the worker thread executing the request - needs to be propagated to one or more child threads. Otherwise, required parameter and user information might be missing, for example, when authorizing CRUD events or creating tenant-specific database connections.

To propagate the parent context, create an instance of `RequestContextRunner` in the *parent* thread and open a new `RequestContext` with `run()` method in the *child* thread. This way all parameters from the parent context are also available in the context of one or more spawned threads, as demonstrated in the following example:

```java
RequestContextRunner runner = runtime.requestContext();
Future<Result> result = Executors.newSingleThreadExecutor().submit(() -> {
	return runner.run(threadContext -> {
		return persistenceService.run(Select.from(Books_.class));
	});
});
```

Even though the `threadContext` variable isn't directly used in the example, executing the `run` method takes care of populating the Request Context to the thread-local store of the child thread. The Persistence Service then internally uses the thread-local store to access the Request Context in order to access the currently active tenant.

You're free to modify the parameters by means of the API described in [Defining Request Contexts](#defining-requestcontext) in addition. But be aware that `providedParameters()` resp. `providedUser()` might lead to unexpected behavior as typically the [standard providers](#global-providers) require to run in the context of the original worker thread to access request-local data.



# ChangeSet Contexts


ChangeSet Contexts are an abstraction around transactions. This chapter describes how ChangeSets are related to transactions and how to manage them with the CAP Java SDK.

## Overview

ChangeSet Contexts are used in the CAP Java SDK as a light-weight abstraction around transactions. They are represented by the [ChangeSetContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/changeset/ChangeSetContext.html) interface.
ChangeSet Contexts only define transactional boundaries, but do not define themselves how a transaction is started, committed or rolled back.
They are therefore well suited to plug in different kinds of transaction managers to integrate with different kinds of transactional resources.

The currently active ChangeSet Context can be accessed from the [Event Context](../event-handlers/#eventcontext):

```java
context.getChangeSetContext();
```

## Defining ChangeSet Contexts { #defining-changeset-contexts}

When [events](../../about/best-practices#events) are processed on [services](../services) the CAP Java SDK ensures that a ChangeSet Context is opened.
If no ChangeSet Context is active the processing of an event ensures to open a new ChangeSet Context. This has the effect, that by default a ChangeSet Context is opened around the outermost event that was triggered on any service.
This ensures that every top-level event is executed with its own transactional boundaries.

For example, if a `CREATE` event is triggered on an Application Service, which is split into multiple `CREATE` events to different entities on the Persistence Service, the processing of the `CREATE` event on the Application Service ensures to open a new ChangeSet Context around all of these events. All interactions with the Persistence Service and therefore all interactions with the database, happen in a single transaction, which is committed, when the processing of the `CREATE` event on the Application Service finishes. In general, this frees event handler implementations to worry about transactions.

Nevertheless you can explicitly define ChangeSet Contexts. It is also possible to nest these ChangeSet Contexts, allowing for suspending previous transactions.
The [CdsRuntime](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/runtime/CdsRuntime.html) provides an API to define a new ChangeSet Context:

```java
runtime.changeSetContext().run(context -> {
    // executes inside a dedicated ChangeSet Context
});
```

The code that is executed inside the `java.util.function.Function` or `java.util.function.Consumer` that is passed to the `run()` method, is executed in a dedicated ChangeSet Context.

## Reacting on ChangeSets

It is possible to register listeners on the ChangeSet Context to perform certain actions shortly before the transaction will be committed or after the transaction was committed or rolled-back.
The [ChangeSetListener](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/changeset/ChangeSetListener.html) interface can be used for this case. It allows to register a listener, which is executed shortly before the ChangeSet is closed (`beforeClose()`) or one, that is executed after the ChangeSet was closed (`afterClose(boolean)`). The `afterClose` method has a boolean parameter, which indicates if the ChangeSet was completed successfully (`true`) or failed and rolled-back (`false`).

```java
ChangeSetContext changeSet = context.getChangeSetContext();
changeSet.register(new ChangeSetListener() {

    @Override
    public void beforeClose() {
        // do something before changeset is closed
    }

    @Override
    public void afterClose(boolean completed) {
        // do something after changeset is closed
    }

});
```

## Cancelling ChangeSets

The ChangeSet Context can  be used to cancel a ChangeSet without throwing an exception.
All events in the changeset are processed in that case, but the transaction is rolled back at the end.
A changeset can still be canceled from within the `beforeClose()` listener method.

```java
ChangeSetContext changeSet = context.getChangeSetContext();
// cancel changeset without throwing an exception
changeSet.markForCancel();
```

## Database Transactions in Spring Boot

Database transactions in CAP are always started and initialized lazily during the first interaction with the Persistence Service.
When running in Spring Boot, CAP Java completely integrates with Spring's transaction management. As a result you can use Spring's `@Transactional` annotations or the `TransactionTemplate` to control transactional boundaries as an alternative to using the ChangeSet Context.

This integration with Spring's transaction management also comes in handy, in case you need to perform plain JDBC connections in your event handlers.
This might be necessary, when calling SAP HANA procedures or selecting from tables not covered by CDS and the Persistence Service.

When annotating an event handler with `@Transactional`, Spring ensures that a transaction is initialized. CAP in that case ensures, that this transaction is managed as part of an existing ChangeSet Context, for which the transaction wasn't yet initialized. If no such ChangeSet Context exists, a new ChangeSet Context is created. In case the transaction propagation is specified as `REQUIRES_NEW`, Spring, and CAP ensure that a new transaction and ChangeSet Context are initialized. This mechanism suspends existing transactions and ChangeSet Context, until the newly created one is closed.

Spring's transaction management can therefore be used to control transactional boundaries and to initialize transactions more eagerly than CAP.
This can be combined with Spring's standard capabilities to get access to a plain JDBC connection:

```java
@Autowired
private JdbcTemplate jdbc;

@Autowired
private DataSource ds;

@Before(event = CqnService.EVENT_CREATE, entity = Books_.CDS_NAME)
@Transactional // ensure transaction is initialized
public void beforeCreateBooks(List<Books> books) {
    // JDBC template
    jdbc.queryForList("SELECT 1 FROM DUMMY");

    // Connection object
    Connection conn = DataSourceUtils.getConnection(ds);
    conn.prepareCall("SELECT 1 FROM DUMMY").executeQuery();
}
```

### Setting Session Context Variables

You can leverage the simplified access to JDBC APIs in Spring Boot to set session context variables on the JDBC connection.
When setting these variables this way, they will also influence statements executed by CAP itself through the Persistence Service APIs.

The following example shows how to set session context variables by means of a custom event handler that is called on all interactions with the Persistence Service.
If setting session context variables is needed only for specific queries, it is also possible to narrow down the invocation of the event handler by providing a more specific `@Before` annotation:

```java
@Component
@ServiceName(value = "*", type = PersistenceService.class)
public class SessionContextHandler implements EventHandler {

    private final static Set<ChangeSetContext> handled = Collections.synchronizedSet(new HashSet<>());

    @Autowired
    private DataSource dataSource;

    @Before
    protected void setSessionContextVariables(EventContext context) {
        ChangeSetContext changeSet = context.getChangeSetContext();
        // handle every transaction only once
        if(handled.add(changeSet)) {
            // set the session variable
            setSessionContextVariable("foo", "bar");

            changeSet.register(new ChangeSetListener(){

                @Override
                public void beforeClose() {
                    // clear the session variable
                    setSessionContextVariable("foo", null);
                    handled.remove(changeSet);
                }

            });
        }
    }

    private void setSessionContextVariable(String name, String value) {
        Connection con = null;
        try {
            // obtains the transaction connection
            con = DataSourceUtils.getConnection(dataSource);
            con.setClientInfo(name, value);
        } catch (SQLClientInfoException e) {
            // handle appropriately
        } finally {
            // only releases the obtained connection
            // the transaction connection is still kept open with the
            // session variables set
            DataSourceUtils.releaseConnection(con, dataSource);
        }
    }

}
```

## Avoiding Transactions for Select { #avoid-transactions }

CAP ensures that every interaction with a service is inside of a ChangeSet Context. However transactions are not started at that point in time yet.
By default, any kind of first interaction with the Persistence Service will begin the transaction. Once a transaction has been started, a connection for that transaction is reserved from the connection pool. This connection is only returned to the connection pool on commit or rollback of the transaction.

However, `READ` events which run simple Select queries don't actually require transactions in most cases. When setting the property `cds.persistence.changeSet.enforceTransactional` to `false` most Select queries do not cause a transaction to be started any longer. A connection for these queries is obtained from the connection pool and returned immediately after executing the queries on the database. This can increase throughput of an application, by making connections available for concurrent requests faster. As soon as a modifying statement is executed on the Persistence Service, a transaction is started. All subsequent Select queries will participate in that transaction. Note, that this behaviour is only transparent when using the default transaction isolation level "Read Committed".

A ChangeSet Context can always be marked as requiring a transaction, by calling the `markTransactional` on the `ChangeSetContext` or `ChangeSetContextRunner`. The next interaction with the Persistence Service will guarantee to start a transaction in that case. Alternatively, Spring Boot annotations `@Transactional` can be used to eagerly start a transaction.

Some Select queries will still require a transaction:

- Select queries with a lock: These are treated like a modifying statement and will start a transaction.
- Select queries reading streamed media data: These are currently not automatically detected. The surrounding ChangeSet Context needs to be marked as transactional explicitly. If not done, `InputStream`s might be corrupted or closed when trying to read them after the connection was returned to the connection pool already.



# Fiori Drafts



This section describes which events occur in combination with SAP Fiori Drafts.

## Overview { #draftevents}

See [Cookbook > Serving UIs > Draft Support](../advanced/fiori#draft-support) for an overview on SAP Fiori Draft support in CAP.

## Reading Drafts

When enabling an entity for draft, an additional set of database tables is created for the entity composition tree. These database tables are used to store the drafts.
When reading draft-enabled entities, data from the active entity and the drafts is merged into a joint result. As part of this, draft-specific elements like `IsActiveEntity`, `HasActiveEntity` or `HasDraftEntity` are calculated.

The standard `READ` event of a `CqnService` orchestrates the delegation of the query to the active entity and the drafts. It might execute multiple queries for this internally.
As part of this orchestration additional events `ACTIVE_READ` and `DRAFT_READ` are triggered. They allow custom handlers to override reading of active entities or reading of drafts:

| HTTP / OData request    | Event constant name                | Default implementation                                                                                                       |
| ----------------------- | ---------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| GET                     | `CqnService.EVENT_READ`            | Reads and merges data from active entities with their drafts. Internally triggers `ACTIVE_READ` and `DRAFT_READ`.            |
| n/a                     | `DraftService.EVENT_ACTIVE_READ`   | Reads data from active entities.                                                                                             |
| n/a                     | `DraftService.EVENT_DRAFT_READ`    | Reads data from drafts.                                                                                                      |

::: tip
`@Before` or `@After` handlers which modify queries or read data are best registered on the `READ` event.
Events `ACTIVE_READ` or `DRAFT_READ` are preferrable for custom `@On` handlers of draft-enabled entities.
:::

By default queries executed internally by the `READ` event are optimized for performance. In certain scenarios queries will rely on the possibility of joining between tables of the active entity and drafts on the database.

Active entity data and draft data is usually stored in tables on the same database schema. However, it is also possible to enable remote entities or entities stored in a different persistence for drafts. In that case set the property `cds.drafts.persistence` to `split` (default: `joint`). This enforces the following behavior:

- Queries strictly separate active entities and drafts.
- Queries to active entities don't contain draft-specific elements like `IsActiveEntity`.

You can then delegate reading of active entities, for example to a remote S/4 system:

```java
@On(entity = MyRemoteDraftEnabledEntity_.CDS_NAME)
public Result delegateToS4(ActiveReadEventContext context) {
    return remoteS4.run(context.getCqn());
}
```

> Note that this is only useful when also delegating `CREATE`, `UPDATE` and `DELETE` events, which only operate on active entities always, to the remote S/4 system as well.

::: warning
When setting `cds.drafts.persistence` to `split` only queries that are specified by the SAP Fiori draft orchestration are supported.
:::

## Editing Drafts

When users edit a draft-enabled entity in the frontend, the following requests are sent to the CAP Java backend. As an effect, draft-specific events are triggered, as described in the following table. The draft-specific events are defined by the [DraftService](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/draft/DraftService.html) interface.

::: tip
Draft-enabled entities have an extra key `IsActiveEntity` by which you can access either the active entity or the draft (inactive entity).
:::

| HTTP / OData request                   | Event constant name                | Default implementation                                                                                                      |
| -------------------------------------- | ---------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| POST                                   | `DraftService.EVENT_DRAFT_NEW`     | Creates a new empty draft. Internally triggers `DRAFT_CREATE`.                                                              |
| PATCH with key `IsActiveEntity=false`  | `DraftService.EVENT_DRAFT_PATCH`   | Updates an existing draft                                                                                                   |
| DELETE with key `IsActiveEntity=false` | `DraftService.EVENT_DRAFT_CANCEL`  | Deletes an existing draft                                                                                                   |
| DELETE with key `IsActiveEntity=true`  | `CqnService.EVENT_DELETE`          | Deletes an active entity *and* the corresponding draft                                                                      |
| POST with action `draftPrepare`        | `DraftService.EVENT_DRAFT_PREPARE` | Empty implementation                                                                                                        |
| POST with action `draftEdit`           | `DraftService.EVENT_DRAFT_EDIT`    | Creates a new draft from an active entity. Internally triggers `DRAFT_CREATE`.                                              |
| POST with action `draftActivate`       | `DraftService.EVENT_DRAFT_SAVE`    | Activates a draft and updates the active entity. Triggers an `CREATE` or `UPDATE` event on the affected entity.             |
| n/a                                    | `DraftService.EVENT_DRAFT_CREATE`  | Stores a new draft in the database.                                                                                         |

You can use these events to add custom logic to the SAP Fiori draft flow, for example to interact with drafts or to validate user data.

The following example registers a `@Before` handler to fill in default-values into a draft before the user starts editing:

```java
@Before
public void prefillOrderItems(DraftNewEventContext context, OrderItems orderItem) {
    // Pre-fill fields with default values
}
```

The `DRAFT_CREATE` is an internal event that is not triggered by OData requests directly. It can be used to set default or calculated values on new drafts, regardless if they were created from scratch (`DRAFT_NEW` flow) or based on an existing active entity (`DRAFT_EDIT` flow).

For more examples, see the [Bookshop sample application](https://github.com/SAP-samples/cloud-cap-samples-java/tree/master/srv/src/main/java/my/bookshop/handlers/AdminServiceHandler.java).

## Validating Drafts <Beta />

CAP Java can provide _state messages_ to the UI5 OData V4 model. This enables validations of drafts and giving feedback about errors to users faster in the UI.

To enable this feature, set the following properties in your `.cdsrc.json`:

::: code-group
```json [.cdsrc.json]
{
  "cdsc": {
    "draftMessages": true
  }
}
```
:::

::: warning Uses _document URLs_ and requires UI5 version >=1.135.0
The _state messages_ feature relies on UI5 to use _document URLs_. That's because, with this feature enabled, CAP sets the annotation `@Common.AddressViaNavigationPath` to instruct UI5 to use _document URLs_. In turn, this requires UI5 version >= 1.135.0.
:::

Setting the `draftMessages` property adds additional elements to your draft-enabled entities and [`DraftAdministrativeData`](/guides/security/data-protection-privacy#dpp-cap), which are required to store and serve state messages. For this to work, CAP Java supports persisting (error) messages for draft-enabled entities.

If you activate this feature, you can observe the following improvements, without any changes to the application code:

- Error messages for annotation-based validations (for example, `@mandatory` or `@assert...`) already appear while editing the draft.
- Custom validations can now be registered to the `DRAFT_PATCH` event and can write (error) messages. It's ensured that the invalid value is still persisted, as expected by the draft choreography.
- Messages no longer unexpectedly vanish from the UI after editing another field.
- Messages are automatically loaded when reopening a previously edited draft.

By default, when activating this state messages, side-effect annotations are generated in the EDMX that instruct UI5 to fetch state messages after every `PATCH` request. If you require more precise control over side-effect annotations, you can disable the side-effect annotation per entity:

```cds
// Setting `null` disables the side-effect annotation for always fetching messages.
annotate MyService.MyEntity with @Common.SideEffects #alwaysFetchMessages: null;
```

::: warning Requires Schema Update
Enabling draft messages requires a database schema update, as it adds an additional element to `DraftAdministrativeData`.
:::

## Activating Drafts

When you finish editing drafts by pressing the *Save* button, a draft gets activated. That means, either a single `CREATE` or `UPDATE` event is triggered to create or update the active entity with all of its compositions through a deeply structured document. You can register to these events to validate the activated data.

The following example shows how to validate user input right before an active entity gets created:

```java
@Before
public void validateOrderItem(CdsCreateEventContext context, OrderItems orderItem) {
    // Add validation logic
}
```

During activation the draft data is deleted from the database. This happens before the active entity is created or updated within the same transaction.
In case the create or update operation raises an error, the transaction is rolled back and the draft data is restored.

## Working with Draft-Enabled Entities

When deleting active entities that have a draft, the draft is deleted as well. In this case, a `DELETE` and `DRAFT_CANCEL` event are triggered.

To read an active entity, send a `GET` request with key `IsActiveEntity=true`, for example:

```http
GET /v4/myservice/myentity(IsActiveEntity=true,ID=<key>);
```

Likewise, to read the corresponding draft, call:

```http
GET /v4/myservice/myentity(IsActiveEntity=false,ID=<key>);
```

To get all active entities, you could use a filter as illustrated by the following example:

```http
GET /v4/myservice/myentity?$filter=IsActiveEntity eq true
```

## Bypassing the SAP Fiori Draft Flow { #bypassing-draft-flow }

It's possible to create and update data directly without creating intermediate drafts. For example, this is useful when prefilling draft-enabled entities with data or in general, when technical components deal with the API exposed by draft-enabled entities. To achieve this, use the following requests. You can register event handlers for the corresponding events to validate incoming data:

| HTTP / OData request                            | Event constant name                                      | Default implementation                               |
| ----------------------------------------------- | -------------------------------------------------------- | ---------------------------------------------------- |
| POST with `IsActiveEntity: true` in payload     | `CqnService.EVENT_CREATE`                                | Creates the active entity                            |
| PUT with key `IsActiveEntity=true` in URI       | `CqnService.EVENT_CREATE` <br> `CqnService.EVENT_UPDATE` | Creates or updates the active entity (full update)   |
| PATCH with key `IsActiveEntity=true` in URI     | `CqnService.EVENT_UPDATE`                                | Creates or updates the active entity (sparse update) |

These events have the same semantics as described in section [Handling CRUD events](./cqn-services/application-services#crudevents).

## Draft Lock { #draft-lock }

An entity with a draft is locked from being edited by other users until either the draft is saved or a timeout is hit (15 minutes by default). You can configure this timeout by the following application configuration property:

```yaml
cds.drafts.cancellationTimeout: 1h
```

You can turn off this feature completely by means of the application configuration property:

```yaml
cds.security.draftProtection.enabled: false
```

## Draft Garbage Collection { #draft-gc }

Stale drafts are automatically deleted after a timeout (30 days default). You can configure the timeout with the following application configuration property:

```yaml
cds.drafts.deletionTimeout: 8w
```

In this example, the draft timeout is set to 8 weeks.

This feature can be also turned off completely by setting the application configuration:

```yaml
cds.drafts.gc.enabled: false
```

::: tip
To get notified when a particular draft-enabled entity is garbage collected, you can register an event handler on the `DRAFT_CANCEL` event.
:::

## Overriding SAP Fiori's Draft Creation Behaviour { #fioridraftnew}

By default SAP Fiori triggers a POST request with an empty body to the entity collection to create a new draft.
This behavior can be overridden [by implementing a custom action](./cqn-services/application-services#actions), which SAP Fiori will trigger instead.

1. Define an action bound to the draft-enabled entity with an explicitly binding parameter typed with `many $self`.

    This way, the action used to create a new draft is bound to the draft-enabled entity collection.

1. Annotate the draft-enabled entity with `@Common.DraftRoot.NewAction: '<action name>'`.

    This indicates to SAP Fiori that this action should be used when creating a new draft.

1. Implement the action in Java.

    The implementation of the action must trigger the `newDraft(CqnInsert)` method of the `DraftService` interface to create the draft. In addition, it must return the created draft entity.

The following code summarizes all of these steps in an example:

```cds
service AdminService {
  @odata.draft.enabled
  @Common.DraftRoot.NewAction: 'AdminService.createDraft'
  entity Orders as projection on my.Orders actions {
    action createDraft(in: many $self, orderNo: String) returns Orders;
  };
}
```

```java
@On(entity = Orders_.CDS_NAME)
public void createDraft(CreateDraftContext context) {
    Orders order = Orders.create();
    order.setOrderNo(context.getOrderNo());
    context.setResult(adminService.newDraft(Insert.into(Orders_.class).entry(order)).single(Orders.class));
}
```

## Consuming Draft Services { #draftservices}

If an [Application Service](cqn-services/application-services#application-services) is created based on a service definition, that contains a draft-enabled entity, it also implements the [DraftService](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/draft/DraftService.html) interface.
This interface provides an API layer around the [draft-specific events](fiori-drafts#draftevents), and allows to create new draft entities, patch, cancel or save them, and put active entities back into edit mode.

The Draft-Service-specific APIs only operate on entities in draft-mode. The CQN Query APIs (`run` methods) provided by any Application Service, operate on active entities only.
However, there's one exception from this behavior, which is the `READ` event: When reading from a Draft Service, active entities and draft entities are both queried and the results are combined.

::: warning
Persistence Services aren't draft-aware. Use the respective Draft Service or Application Service, when running draft-aware queries.
:::

The following example, shows the usage of the Draft-Service-specific APIs:

```java
import static bookshop.Bookshop_.ORDERS;

DraftService adminService = ...;
// create draft
Orders order = adminService.newDraft(Insert.into(ORDERS)).single(Orders.class);
// set values
order.setOrderNo("DE-123456");
// patch draft
adminService.patchDraft(Update.entity(ORDERS).data(order)
    .where(o -> o.ID().eq(order.getId()).and(o.IsActiveEntity().eq(false))));
// save draft
CqnSelect orderDraft = Select.from(ORDERS)
    .where(o -> o.ID().eq(order.getId()).and(o.IsActiveEntity().eq(false)));
adminService.saveDraft(orderDraft);
// read draft
Orders draftOrder = adminService.run(orderDraft).single().as(Order.class);
// put draft back to edit mode
CqnSelect orderActive = Select.from(ORDERS)
    .where(o -> o.ID().eq(order.getId()).and(o.IsActiveEntity().eq(true)));
adminService.editDraft(orderActive, true);
// read entities in draft mode and activated entities
adminService.run(Select.from(ORDERS).where(o -> o.ID().eq(order.getId())));
```






CAP Messaging provides support for publish-subscribe-based messaging, which is an asynchronous communication pattern well suited for scenarios where a sender wants to send out information to one or many receivers that are potentially unknown and/or unavailable at the time of sending.

In contrast, the nature of synchronous communication between services can be disadvantageous depending on the desired information flow, for example, sender and receiver need to be available at the time of the request. The sender needs to know the receiver and how to call it, and that communication per request is usually point-to-point only.

In the following, we provide a basic introduction to publish-subscribe-based messaging and then explain how to use it in CAP. If you're already familiar with publish-subscribe-based messaging, feel free to skip the following introduction section.

## Pub-Sub Messaging

In a publish-subscribe-based messaging scenario (pub-sub messaging), senders send a message tagged with a topic to a message broker. Receivers can create queues at the message broker and subscribe these queues to the topics they're interested in. The message broker will then copy incoming messages matching the subscribed topics to the corresponding queues. Receivers can now consume these messages from their queues. If the receiver is offline, no messages will be lost as the message broker safely stores messages in the queue until a receiver consumes the messages. After the receiver acknowledges the successful processing of a message, the message broker will delete the acknowledged message from the queue.

![The graphic is explained in the accompanying text.](./assets/messaging_foundation.png){}

CAP makes sending and receiving messages easy by providing an API agnostic from specific message brokers, and taking care of broker-specific mechanics like connection handling, protocols to use, creating queues, subscriptions, etc. The API seamlessly blends into the common event API of CAP services, so that event messages can be sent using `emit` and handlers to execute when receiving event messages can be declared with the `@On` annotation.

CAP provides support for different message brokers by providing several messaging services implementing the API for different message brokers. Messaging support as such is built into the core of CAP, as well as a "file-based message broker" for local testing, that mocks a message broker and persists messages to a file on the local file system. Support for other message brokers can be added by including separate Maven dependencies specifically for that broker. See [Supported Message Brokers](#supported-message-brokers) for more details.

In the following, we'll first describe how to send and receive messages in general, before we explain more complex scenarios and configuration options.


## Sending

For a quick start in a local development scenario, use the file-based messaging service (mocking a message broker on the local file system), so you do not need to set up a real message broker first. Later, the configured messaging service can be changed to a real one, without the need of changing the code.

CAP services can be configured in the file _application.yaml_. Here, enable the `file-based-messaging` message service with a specific file to store messages in - like shown in the following example:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging:
    services:
      - name: "messaging-name"
        kind: "file-based-messaging"
        binding: "/any/path/to/file.txt"
```
:::

With the availability of a messaging service, you can now use it to send messages, as illustrated in the following example:

```java
@Autowired
MessagingService messagingService;

// Sending via the technical API of the messaging service
messagingService.emit("My/Topic", Map.of("message", "hello world"));

// Sending by emitting a context via CAP service API
TopicMessageEventContext context = TopicMessageEventContext.create("My/Topic");
context.setDataMap(Map.of("message", "hello world"));
messagingService.emit(context);
```

As shown in the example, there are two flavors of sending messages with the messaging service:

- Directly using the `emit` method of the technical messaging service API. This is a convenient way of sending messages, in case you shouldn't need the context object as such and quickly want to send a message with given topic and payload.

- A CAP messaging service is also a normal CAP service, and as such provides an EventContext-based `emit` method. Using the standard way of creating and dispatching a context via `emit` can also be used to send a message. As shown, create a `TopicMessageEventContext` with the desired topic (in terms of CAP the topic represents an event) for the message, set the payload of the message, and emit the context.

In section [CDS-Declared Events](#cds-declared-events), we show how to declare events in CDS models and by this let CAP generate EventContext interfaces especially tailored for the defined payload, that allows type safe access to the payload.

::: tip Using an outbox
The messages are sent once the transaction is successful. Per default, an in-memory outbox is used, but there's also support for a [persistent outbox](./outbox#persistent).

You can configure a [custom outbox](./outbox#custom-outboxes) for a messaging service by setting the property
`cds.messaging.services.<key>.outbox.name` to the name of the custom outbox. This specifically makes sense when [using multiple channels](../guides/messaging/#using-multiple-channels).
:::


## Receiving

To receive messages matching a desired topic from a message broker, you just need to define a custom handler for the topic on the messaging service.

Example:

```java
@On(service = "messaging-name", event = "My/Topic")
public void receiveMyTopic(TopicMessageEventContext context) {
  // get ID and payload of message
  String msgId = context.getMessageId();
  Map<String, Object> payload = context.getDataMap();
  // ...
}
```

As you can see in the example, the event context not only provides access to the raw message, but also to a unique message ID.

<span id="inreceiving" />
<Fragment target="#inreceiving">


::: tip Internal Information <Internal />
Note: When using SAP Event Mesh in multitenant mode, no unique message ID will be available via `getMessageId`, as SAP Event Mesh does not provide it when delivering messages via WebHook subscriptions that are used in this mode. If the payload itself contains a unique message ID (for example when using [CloudEvents](#cloudevents) format for messages), consider using this ID instead.
 :::


</Fragment>

::: tip
For messaging services, the `@On` handlers don't need to be completed by the `context.setCompleted()` method. The reason for that is because CAP wants to support the parallel handling of the messaging events and completes the context automatically. There could be numerous use cases where different components of the CAP application want to be notified by messaging events. Even more, you should not complete the context in the handler manually. Otherwise, not all registered handlers can be notified.
:::

::: warning _❗ Warning_
If any exceptions occur in the handler, the messaging service will not acknowledge the message as successfully processed to the broker. In consequence, the broker will deliver this message again.
:::

## CDS-Declared Events

In CDS models, services can declare events and the structure of their payload. When compiling, CAP will automatically generate interfaces to access the event message and its payload in a type safe fashion.

Example:

```cds
service ReviewService {
  // ...
  event reviewed : {
    subject: String;
    rating: Decimal(2,1)
  }
  // ...
}
```

**Sending**

The `ReviewService` of the example is now able to construct the payload of the event message and emit the event in a type safe fashion. In the following example, the `ReviewService` does this whenever a review was changed:

```java
@Component
@ServiceName(ReviewService_.CDS_NAME)
public class ReviewServiceHandler implements EventHandler {

  @Autowired
  @Qualifier(ReviewService_.CDS_NAME)
  CqnService reviewService;

  @After(event = { CqnService.EVENT_CREATE, CqnService.EVENT_UPSERT, CqnService.EVENT_UPDATE })
  public void afterReviewChanged(Stream<Reviews> reviews) {
    reviews.forEach(review -> {

      // Calculate the new average rating
      BigDecimal avg = ...;

      // Set event payload
      Reviewed event = Reviewed.create();
      event.setSubject(review.getSubject());
      event.setRating(avg);

      // Set event context to emit
      ReviewedContext evContext = ReviewedContext.create();
      evContext.setData(event);

      // Emit event context
      reviewService.emit(evContext);

    });
  }
}
```

Note that the `ReviewService` itself emits the event context. The `ReviewService` does not explicitly need to use a technical messaging service. If no messaging service has been bound to your application, then the event will be dispatched purely within the runtime of this service. As soon as a messaging service has been bound, the event message will also be sent via the respective message broker, to allow other, external consumers to subscribe to this event message.

When sending the event message, CAP chooses the fully qualified name (FQN) of the event according to the CDS model as the default topic name to use. In the case of the example this would be `ReviewService.reviewed`. If you want to manually override the automatically derived topic name, you can use the `@topic` annotation in the CDS model.

Example:

```cds
service ReviewService {
  // ...
  @topic: 'sap.cap.reviews.v1.ReviewService.changed.v1'
  event reviewed : {
    subject: String;
    rating: Decimal(2,1)
  }
  // ...
}
```

**Receiving**

Other CAP services are able to define handlers on this declared event using the `@On` annotation that references the `ReviewsService` to a method that has the automatically generated `ReviewedContext` as input parameter.

Example:

```java
@On(service = ReviewService_.CDS_NAME)
private void ratingChanged(ReviewedContext context) {
  // Extract payload from message
  Reviewed event = context.getData();
  // Access payload structure in typed fashion
  System.out.println("Rating changed for: '" + event.getSubject() + "'");
}
```

When a CAP service declares such a handler on the `reviewed` event of the `ReviewService` and this service is served within the same runtime, then the event message will be dispatched within this runtime, without being technically transported via a message broker. As soon as the `ReviewService` is declared to be a remote service, and a messaging service is declared, a subscription for this event message will automatically be created at the configured message broker.

Example (excerpt of _application.yaml_):

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  remote.services:
    - name: ReviewService
  messaging.services:
    messaging-em:
      kind: enterprise-messaging
      subscribePrefix: '$namespace/'
```
:::

In this example, the `ReviewService` is declared as a remote service and thus will not be served by the current runtime. SAP Event Mesh is declared as the message broker to use. In addition, the configuration parameter `subscribePrefix` was set to `'$namespace/'` to define, that whenever doing subscriptions to topics at SAP Event Mesh, to always prefix the technical topic used for subscribing with the namespace of the bound SAP Event Mesh instance. SAP Event Mesh instances may define their own rules for valid topic names, and a common pattern is to require all topics to start with the namespace of the used instance, which would be automatically fulfilled in the example by always prefixing its namespace.

[Learn more about **Topic Prefixing**.](#topic-prefixing){.learn-more}


## Supported Message Brokers

### Local Testing

The local messaging service is the simplest way to test messaging in a single process. It is especially useful for automated tests, as the emitting of an event blocks until all receivers have processed the event.

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging.services:
  - name: "messaging-name"
    kind: "local-messaging"
```
:::

Alternatively you can use the file-based messaging service, which mocks a message broker on the local file system. With it emitting of the event is completely decoupled from the receivers of the event, like with real message brokers.
In case you want two services served in different processes to exchange messages, you can achieve this by configuring both services to use the same file for storing and receiving messages.
The file is defined by the parameter `binding`, as can be seen in the following example:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging.services:
  - name: "messaging-name"
    kind: "file-based-messaging"
    binding: "/any/path/to/file.txt"
```
:::

::: tip
In local testing scenarios it might be useful to manually inject messages into the `file-based message broker`, by manually editing its storage file and adding lines to it. New lines will be interpreted as new messages and will be consumed by services subscribed to matching topics. Have a look at the contents of the storage file with a normal text editor after having sent a few messages to get an example of the syntax, which should be self-explanatory.
:::

### Using Real Brokers

Besides the built-in support for `local-messaging` and `file-based-messaging`, all other implementations of technical messaging services are provided as separate CAP features, that can be included as Maven dependencies. This way you can include only the implementations needed for the message brokers you want to address.


#### Configuring SAP Event Mesh Support: { #configuring-sap-event-mesh-support}

::: code-group
```xml [srv/pom.xml]
<dependency>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-feature-enterprise-messaging</artifactId>
  <scope>runtime</scope>
</dependency>
```
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging.services:
  - name: "messaging-name"
    kind: "enterprise-messaging"
```
:::

#### Configuring SAP Cloud Application Event Hub Support: { #configuring-sap-event-hub-support}

::: code-group
```xml [srv/pom.xml]
<dependency>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-feature-event-hub</artifactId>
  <version>${version}</version>
</dependency>
```
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging.services:
  - name: "messaging-name"
    kind: "event-hub"
```
:::

Support for SAP Cloud Application Event Hub is provided via [plugin](../plugins/#event-hub).

#### Configuring SAP Integration Suite, Advanced Event Mesh Support <Beta />: 
{ #configuring-advanced-event-mesh-support}

::: code-group
```xml [srv/pom.xml]
<dependency>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-feature-advanced-event-mesh</artifactId>
  <version>${version}</version>
</dependency>
```
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging.services:
  - name: "messaging-name"
    kind: "aem"
```
:::

[Support for SAP Integration Suite, advanced event mesh is provided via plugin.](../plugins/#advanced-event-mesh){.learn-more}

<span id="beforeredispubsub" />
<Fragment target="#beforeredispubsub">

#### Configuring Message Queuing Support <Internal /> {#configuring-message-queuing-support}

::: code-group
```xml [pom.xml]
<dependency>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-feature-message-queuing</artifactId>
  <scope>runtime</scope>
</dependency>
```

```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging.services:
  - name: "messaging"
    kind: "message-queuing"
```
:::

[Learn more about Message Queuing @ SAP.](https://wiki.one.int.sap/wiki/display/CoCo/Getting+Started+with+Message+Queuing){.learn-more}

</Fragment>

#### Configuring Redis PubSub Support <Beta />: { #configuring-redis-pubsub-support-beta}

::: warning
This is a beta feature. Beta features aren't part of the officially delivered scope that SAP guarantees for future releases.
:::

::: code-group
```xml [srv/pom.xml]
<dependency>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-feature-redis</artifactId>
  <scope>runtime</scope>
</dependency>
```
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging.services:
  - name: "messaging-name"
    kind: "redis-pubsub"
```
:::

::: tip
In contrast to SAP Event Mesh the Redis feature is a PubSub service which means that the Redis events are broadcasted and delivered to all subscribed clients simultaneously. That means, each instance of your application receives the same event send by the Redis service. And it's not guaranteed that really all events are delivered by the infrastructure, for example: If an application instance is not connected to the Redis service, the emitted events are going to be lost.
:::

<span id="beforeinjecting" />
<Fragment target="#beforeinjecting">

#### Configuring Apache Kafka Support <Internal />

This feature provides out-of-the-box messaging with CDS-defined events using [Apache Kafka](https://kafka.apache.org/) as a message broker.
It leverages Apache Kafka's advanced features for high horizontal scalability and reliability. Per default, all CAP events are sent to predefined topic `cds.default`.
[Learn more about messaging with Apache Kafka.](../guides/messaging/apache-kafka){.learn-more}

::: tip Using Apache Kafka in a DwC environment <Internal />
When using deployment vectors in Deploy with Confidence, different versions of a microservice could be running at the same time. This scenario requires special handling regarding messaging. [`util-cap-kafka`](https://github.tools.sap/deploy-with-confidence/spring-utils/tree/master/util-cap-kafka) is provided to ensure correct asynchronous communication between the microservices of a deployment vector. It replaces the default Kafka integration by wrapping the [CALM Iris library](https://pages.github.tools.sap/CALMBuild/adlib/) such that it seamlessly integrates with CAP.
:::

</Fragment>

#### Injecting Messaging Services

The included broker dependencies create technical CAP messaging services at the time of application start, corresponding to the bound platform services. You can access these messaging services at runtime either via the CAP service catalog, or conveniently use autowiring for injecting an instance.

If you're using autowiring and there is only one messaging service bound, then this single instance can be injected without further parameterization. But if several messaging services are bound to your application, you need to define which of these to inject. In the following, different ways of declaring CAP messaging service instances are explained and how they relate to specific message broker service instances. After that we show how to inject a specific CAP messaging service using its name, to avoid ambiguity in case of multiple of such services should exist.

Example:

You have two SAP Event Mesh service instances on Cloud Foundry named `messaging-01` and `messaging-02`. If you bind both of these instances to your application, then CAP will automatically detect these at the time of startup and create two CAP messaging services with the same name as the broker service instance has on the platform. This mechanism works automatically, even without declaring any of these service instances in the _application.yaml_. The result is equivalent to declaring the CAP messaging services in _application.yaml_ using the names of their broker service instances on the platform, like this:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging:
    services:
      - name: "messaging-01"
      - name: "messaging-02"
```
:::

In this case, you do not even need to provide configuration parameters for the kind of the services, as CAP will simply check of which kind these service instances are. After startup, the technical CAP messaging services matching these services will be available under the names `messaging-01` and `messaging-02`.

If you want to abstract from the technical names of the services on the used platform, then you might introduce your own names for the CAP messaging service instances in the configuration and reference the concrete service instances on the platform to use via the configuration parameter `binding`:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging:
    services:
      - name: "messaging1"
        binding: "messaging-01"
      - name: "messaging2"
        binding: "messaging-02"
```
:::

In this case, the technical CAP messaging services will be available under the names `messaging1` and `messaging2`, which will be using the services named `messaging-01` and `messaging-02` on the platform. This way you can easily switch the names of the used platform services, while keeping the names of the technical CAP services stable.

If you want to configure the usage of a single messaging service that is of a special kind, but do not want to specify its service name on the platform, this can be done like this:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging:
    services:
      - name: "messaging-name"
        kind: "enterprise-messaging"
```
:::

In this case, CAP searches for a SAP Event Mesh service instance that is bound to the application, and will provide a CAP messaging service to use it under the name `messaging`, regardless of the name the service instance has on the platform. But if CAP should find multiple SAP Event Mesh service instances bound to your application at runtime, you will get an Exception, as CAP cannot decide which of these to use. In this case you need to be more explicit and define the service instance name to use in one of the ways shown above.

Regardless of the way you have chosen to define the name of the technical CAP messaging service, you can always specify which CAP messaging service you want to inject, by using the `@Qualifier` annotation in your code. When considering the second example above and you want to explicitly inject the CAP messaging service named `messaging2` (that uses the platform service named `messaging-02` - regardless of its kind), then you can do this as follows:

```java
@Autowired
@Qualifier("messaging2")
MessagingService messagingService;
```


### Using Message Brokers in Cloud Foundry

In the Cloud Foundry environment, you can create service instances for message brokers and bind these to your application. CAP will map all bound messaging service instances to technical CAP services that can then be used within your CAP application.

::: tip
If you want to use message broker services you created in the Cloud Foundry environment while testing on your local machine, then you need to manually provide binding information when starting your application. How this works will be explained in the following section.
:::

As a prerequisite of using message brokers from the Cloud Foundry environment, you need to include the Maven dependency for CAP's Cloud Foundry support to your _pom.xml_ file, as well as the dependency for the desired message broker, and a dependency for a messaging adapter if you not only want to send, but also receive messages.


#### Maven Dependency for Cloud Foundry Support:

```xml
<dependency>
	<groupId>com.sap.cds</groupId>
	<artifactId>cds-feature-cloudfoundry</artifactId>
	<scope>runtime</scope>
</dependency>
```

The Cloud Foundry environment provides information about bound services to the application via the `VCAP_SERVICES` environment variable.


#### Running on the Local System

For a local development scenario, it would be annoying to deploy the application to the cloud after each change to test messaging with real brokers. You can let your local application use the message broker services in Cloud Foundry by mocking the `VCAP_SERVICES` and `VCAP_APPLICATION` environment variables locally which Cloud Foundry uses to parametrize your application and bound services.

In `VCAP_APPLICATION` environment variable, you need to set `application_id` and `application_name` as this information will be used when automatically generating queue names in case no names have been configured explicitly. You can set these values to arbitrary values for testing, for example, as shown here:

```sh
VCAP_APPLICATION = {
  "application_id" : "any unique id",
  "application_name" : "any name"
}
```

Cloud Foundry message broker services that should be bound to your application need to be provided in the `VCAP_SERVICES` environment variable. In the following sections, you will find templates for specific message brokers that are supported. You can define multiple service bindings there. The concrete values to set in the templates can be found by creating a service key for the desired service in Cloud Foundry and then viewing the service key and extracting relevant information from there.

Instead of setting the `VCAP_SERVICES` and `VCAP_APPLICATION` environment variables manually, you can provide a file called _default-env.json_ in a service project's root directory to define their values.

Example:

```json
{
  "VCAP_SERVICES": {
    ...
  },
  "VCAP_APPLICATION": {
    ...
  }
}
```

[Learn more about _default-env.json_.](../node.js/cds-env#in-default-env-json){.learn-more}


#### VCAP_SERVICES Template for SAP Event Mesh

```sh
VCAP_SERVICES = {
  "enterprise-messaging": [{
    "label": "enterprise-messaging",
    "credentials": {
      ... Insert content of service key here! ...
    }
  }]
}
```

<span id="beforecomposite" />
<Fragment target="#beforecomposite">

#### VCAP_SERVICES Template for Message Queuing <Internal />

```jsonc
VCAP_SERVICES = {
  "message-queuing": [{
    "label": "message-queuing",
    "credentials": {
      … Insert content of service key here! …
    }
  }]
}
```


</Fragment>

## Composite Messaging Service

In some scenarios you need to deal with multiple message brokers, and thus have multiple messaging services bound to your application. Unfortunately, at the time of development, it is not always known how many and what kind of messaging services will be bound to the application later, and which messages should be sent to or received from which of these brokers.

In such scenarios, the "Composite Messaging Service" can be used, which allows you to change the routing of messages to/from different brokers later on by the means of pure configuration, without the need of changing your code.

Let's start with a configuration example (excerpt from _application.yaml_):

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging:
    routes:
      - service: "em-instance-01"
        events:
          - "My/Topic/A"
      - service: "em-instance-02"
        events:
          - "My/Topic/B"
          - "My/Topic/C*"
```
:::

To use such a configuration, you need to use the composite messaging service for message handling. You can get hold of an instance of such a service in your code, by using the qualifier `MessagingService.COMPOSITE_NAME` when autowiring the messaging service – as shown in the following example:

```java
@Autowired
@Qualifier(MessagingService.COMPOSITE_NAME)
MessagingService messagingService;

messagingService.emit("My/Topic/A", Map.of("hello", "instance 01"));
messagingService.emit("My/Topic/B", Map.of("hello", "instance 02"));
```

As you can see in the configuration, the usage and routing of two messaging services is defined (`em-instance-01`, and `em-instance-02`), each with different topics that should be routed via the service (for example, topic `My/Topic/A` will be sent/received via `em-instance-01`, and topic `My/Topic/B` will be sent/received via `em-instance-02`). The composite service uses the routing configuration in order to dispatch messages as well as subscriptions to the appropriate messaging service. As shown in the sample code, you can simply use the composite message service and submit messages to topics as desired. The messages will be routed to according messaging services as defined in the configuration automatically. To change the routing of messages you can simply change the configuration, without the need of changing your code.

::: tip
If you emit messages with a topic to the composite messaging service that isn't defined in its routing configuration, then the delivery will fail. Consider careful review of your configuration, when you start sending/receiving messages from/to new topics.
:::

Example for receiving messages with a given topic via the composite messaging service:

```java
@On(service = MessagingService.COMPOSITE_NAME, event = "My/Topic/A")
public void receiveA(TopicMessageEventContext context) {
  ...
}

@On(service = MessagingService.COMPOSITE_NAME, event = "My/Topic/B")
public void receiveB(TopicMessageEventContext context) {
  ...
}
```

The configuration of the composite service is used to determine for which messaging service the handlers are registered, and thus in which message broker the subscription for that topic is made.

## Details and Advanced Concepts

### Queue Configuration

By default, each messaging service uses one queue in the broker for all its subscriptions. If no queue exists, a queue with an autogenerated name will be created. If you want a service to use a specific queue name, you can configure it in your _application.yaml_:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging:
    services:
      - name: "messaging-name"
        queue:
          name: "my-custom-queue"
```
:::

If a queue with the given name already exists on the broker, then this queue will be used. If a queue with that name doesn't exist yet, it will be created.

::: tip
Depending on the used message broker, there can be restrictions to what names can be used for queues. Check the documentation of the used broker to ensure you're using a valid name. See [Syntax for Naming Queues, Topics, and Topic Patterns](https://help.sap.com/docs/SAP_EM/bf82e6b26456494cbdd197057c09979f/72ac1fad2dd34c4886d672e66b22b54b.html) in the SAP Event Mesh documentation for more details.
:::

At the time of queue creation, configuration parameters can be passed to the queue. As options and parameters that can be set for a queue depend on the used message broker, custom key value pairs can be defined that will be passed as queue configuration to the broker at time of queue creation. Check the documentation of the used message broker to see which options can be set. Here is an example:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging:
    services:
      - name: "messaging-name"
        queue:
          name: "my-custom-queue"
          config:
            accessType: "EXCLUSIVE"
```
:::

[Learn more about SAP Event Mesh configuration options.](https://hub.sap.com/api/SAPEventMeshDefaultManagementAPIs/path/putQueue){.learn-more}

<div id="queue-config-more" />
<Fragment target="#queue-config-more">

[Learn more about Message Queuing configuration options.](https://github.wdf.sap.corp/PubSubBroker/ssb-management/blob/master/docs/public/management-api-spec-v1.yaml){.learn-more}


</Fragment>

### Queue Configuration Changes

Depending on the configuration, queues can be set up on the broker with autogenerated names or given names. It is possible to manually create queues on the broker and then configure their name, so that already existing queues can be used. When changing the configuration of CAP messaging it is impossible for CAP to do an automated cleanup on the broker, for example, remove previously used, but now unused queues.

::: warning
Queues will not be deleted when removed from the configuration, as you might have configured a manually created queue that should not be deleted and messages in the queue must not be deleted.
:::

At startup of your application CAP messaging will make sure that all configured queues exist, and only if not, that they're created with specified configuration options. Then subscriptions to the queues will be made as defined.

As a queue will never be automatically deleted, renamed, or messages within deleted automatically (as this could cause unintentional, catastrophic loss of messages), unused queues and their subscriptions need to be manually removed. SAP Event Mesh provides a management console to manage queues on the broker as well as a REST API to do so. See [Use REST APIs to Manage Queues and Queue Subscriptions](https://help.sap.com/docs/SAP_EM/bf82e6b26456494cbdd197057c09979f/00160292a8ed445daa0185589d9b43c5.html) in the SAP Event Mesh documentation for more details.


### Using Multiple Queues

Each CAP messaging service instance uses by default one queue for all its topic subscriptions. For some use cases, you might want to separate incoming messages into different queues. This can be achieved by configuring multiple CAP messaging services for one message broker instance – each using its own queue.

Example:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging:
    services:
      - name: "first-messaging"
        binding: "cf-messaging-service-instance-name"
      - name: "second-messaging"
        binding: "cf-messaging-service-instance-name"
```
:::

### Consuming from a Queue

All handlers registered to a messaging service cause a subscription to a specified handler event. But in some scenarios, the broker sends the messages straight to the queue without topic or event origin. In this case, you can register a handler using the queue name as a handler event to receive queue messages.

Example:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging:
    services:
      - name: "messaging-name"
        queue:
          name: "my-custom-queue"
```
:::

```java
@On(service = "messaging-name", event = "my-custom-queue")
public void receiveMyCustomQueueMessage(TopicMessageEventContext context) {
  // access the message as usual
  Map<String, Object> payload = context.getDataMap();
}
```

Furthermore, some messaging brokers support forwarding of messages to another queue. A typical use case is a dead-letter queue that receives messages that could not be delivered from another queue. For those messages you can't register a queue event as the messages have a different topic or event origin. To receive messages from a dead-letter queue, you need to register a `*`-handler in order to receive all topic or event messages. As a `*`-handler is not an explicit subscription it doesn't start queue listening by default. You need to explicitly enable queue listening and set property `forceListening` to `true`.

Example:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging:
    services:
      - name: "messaging-name"
        queue:
          forceListening: true
```
:::

```java
@On(service = "messaging-name")
public void receiveMyCustomQueueAllMessages(TopicMessageEventContext context) {
  // access the message as usual
  Map<String, Object> payload = context.getDataMap();
  // ...
}
```

### Dedicated Connections

To keep the number of simultaneous connections to message brokers as low as possible, only one connection for all CAP messaging services bound to the same message broker service instance is used. All the incoming and outgoing messages are handled via this single connection to the broker.

There can be scenarios in which using multiple queues with dedicated connections for each of them is desired, for example, to balance data throughput. The following example shows how you can use the `dedicated: true` parameter to create a second messaging service bound to the same message broker, but using a different queue with a dedicated connection to it (instead of sharing the same connection with the first messaging service).

Example:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging:
    services:
      - name: "first-messaging"
        binding: "cf-messaging-service-instance-name"
        queue:
          name: "my-first-queue"
      - name: "second-messaging"
        binding: "cf-messaging-service-instance-name"
        connection:
          dedicated: true
        queue:
          name: "my-second-queue"
```
:::
In this example, the `first-messaging` service uses the default connection and the `second-messaging` service uses a new, separate connection.

<span id="indedicatedconnections" />
<Fragment target="#indedicatedconnections">

::: tip Internal Information <Internal />
When using SAP Event Mesh in multitenant mode, no dedicated connections are used to connect to queues. CAP is using WebHook subscriptions in this mode, so that SAP Event Mesh will deliver new incoming messages via HTTP calls to the CAP service. In this mode, the described setting does not apply.
:::

</Fragment>

### Error Handling

To ensure successful delivery of messages, some message brokers require that consumers acknowledge successfully received and processed messages. Otherwise, they redeliver the message. By default, messages are only acknowledged if they have been successfully processed by the CAP handler. Hence, if the message handling fails with an exception, it's redelivered by the messaging broker which can end up in an endless loop. To avoid this, you can register an error handler on the corresponding messaging service. The error handler is called when an exception is thrown during message processing and it allows you to explicitly control whether the message should be acknowledged or not.

The following example demonstrates how the error handler can be used to catch messaging errors. Based on the error code you can differentiate between the CAP infrastructure errors and application errors in order to inspect them and decide whether the message should be acknowledged by the broker or not.

```java
@On(service = "messaging-name")
private void handleError(MessagingErrorEventContext ctx) {

  String errorCode = ctx.getException().getErrorStatus().getCodeString();
  if (errorCode.equals(CdsErrorStatuses.NO_ON_HANDLER.getCodeString()) ||
      errorCode.equals(CdsErrorStatuses.INVALID_DATA_FORMAT.getCodeString())) {
      // error handling for infrastructure error
      ctx.setResult(false); // no acknowledgement
    } else {
      // error handling for application errors

      // how to access the event context of the raised exception:
      // ctx.getException().getEventContexts().stream().findFirst().ifPresent(e -> {
      //    TopicMessageEventContext errorContext = e.as(TopicMessageEventContext.class);
      //    String event = e.getEvent());
      //    Map<String, Object> payload = errorContext.getDataMap();
      // });

      ctx.setResult(true); // acknowledge
    }
}
```

In a multi-tenant setup with several microservices, messages of a tenant not yet subscribed to the own microservice would be already received from the message queue. In this case, the message cannot be processed for the tenant because the tenant context is not yet available. By default, the standard error handler still acknowledges the message to prevent it from getting stuck in the message sequence. To change this behavior, the custom error handler from the example above can be extended by checking the exception type of the unknown tenant.


```java
@On(service = "messaging")
private void handleError(MessagingErrorEventContext ctx) {

  String errorCode = ctx.getException().getErrorStatus().getCodeString();
  if (errorCode.equals(CdsErrorStatuses.NO_ON_HANDLER.getCodeString()) ||
      errorCode.equals(CdsErrorStatuses.INVALID_DATA_FORMAT.getCodeString())) {
      // error handling for infrastructure error
      ctx.setResult(false); // no acknowledgement

    } else if (errorCode.equals(CdsErrorStatuses.TENANT_NOT_EXISTS.getCodeString())) {
      // error handling for unknown tenant context

       // tenant of the received message
      String tenant = ctx.getTenant();

      // received message
      Map<String, Object> headers = ctx.getMessageHeaders();
      Map<String, Object> message = ctx.getMessageData();

      ctx.setResult(true); // acknowledge
    } else {
      // error handling for application errors

      // how to access the event context of the raised exception:
      // ctx.getException().getEventContexts().stream().findFirst().ifPresent(e -> {
      //    TopicMessageEventContext errorContext = e.as(TopicMessageEventContext.class);
      //    String event = e.getEvent());
      //    Map<String, Object> payload = errorContext.getDataMap();
      // });

      ctx.setResult(true); // acknowledge
    }
}
```

::: warning _❗ Warning_
The way how unsuccessfully delivered messages are treated, fully depends on the messaging broker. Please check in section [Acknowledgement Support](#acknowledgement-support)  whether the messaging broker you are using is suitable for your error handler implementation.
:::


#### Acknowledgement Support

Not all messaging brokers provide the acknowledgement support. This means, the result of the error handler has no effect for the messaging broker.

| Messaging Broker                                       | Support |         Cause          |
| ------------------------------------------------------ | :-----: | :--------------------: |
| [File Base Messaging](#local-testing)                  |  <Na/>  |                        |
| [Event Mesh](#configuring-sap-event-mesh-support)      |  <X/>   | removed from the queue |
| [Message Queuing](#configuring-sap-event-mesh-support) |  <X/>   | removed from the queue |
| [Redis PubSub](#configuring-redis-pubsub-support-beta) | <Beta/> |                        |


::: tip
If a broker supports the message acknowledgement and a message is not acknowledged by the application, it will be redelivered.
:::

### Sending and Receiving in the Same Instance

Consider the following scenario: You send messages with a certain topic in your application. Now, you are also registering an `@On` handler for the same event or message topic in the same application. In such a situation the message will be sent to the broker, and once it is received back from the message broker, your registered handler will be called.

If you want to consume the message purely locally, and prevent the message from being sent out to the message broker, you need to register your handler with a higher priority than the default handler that sends out the message, and set the message's context to completed, so it won't be processed further (and thus sent out by the default handler).

You can register your handler with a higher priority than the default handler like this:

```java
@On(service = "messaging-name", event = "My/Topic")
@HandlerOrder(HandlerOrder.EARLY)
public void receiveMyTopic(TopicMessageEventContext context) {
	// Check if message is outgoing to message broker, or incoming from message broker
	if (!context.getIsInbound()) {
		// Process message locally
		…
		// Prevent further processing of message (i.e. prevent sending to broker)
		context.setCompleted();
	}
}
```

In the handler, we now receive the message regardless if it is incoming from a real broker, or if it is outgoing because it was emitted in the local application. We can now check if the message is incoming or outgoing, and set the context to completed, if we want to stop further processing (that means "sending") of the message.


### Topic Prefixing

Before a CAP messaging service finally submits the topic of an event message to the message broker, it provides the configuration option to prefix the topic with an arbitrary string.

Example:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
...
cds:
  messaging.services:
    messaging-em:
      kind: "enterprise-messaging"
      publishPrefix: '$namespace/'
      subscribePrefix: '$namespace/'
...
```
:::
`publishPrefix` will prefix the topic when sending messages, while `subscribePrefix` will prefix the topic when subscriptions to a topic are made. If a service is only sending events, defining `publishPrefix` would be sufficient. If a service is only receiving events, defining `subscribePrefix` would be sufficient.

When using SAP Event Mesh, the placeholder `$namespace` can be used to dynamically use the namespace of the bound SAP Event Mesh instance. In the case of subscribing to messages `+/+/+/` can be used as a prefix to subscribe to all SAP Event Mesh namespaces (needs to be allowed in the defined "topic rules" of the used SAP Event Mesh instance). Regardless of the used messaging service, a fixed string, like `default/my.app/1/` can be used for prefixing.

Besides these kinds of topic manipulations, additional topic manipulations might occur, depending on the used message broker or the chosen format of the event message.


### Messages Representation
{#enhanced-messages-representation}

Messages are provided as two separate `Map` objects, representing data and headers. This enables handling of message headers, like `cloudevents` headers, separately from the message data itself. If using a message broker that supports native headers, for example Kafka, the headers are separated from the business data in the message broker. For message brokers that don't natively support headers, headers and data are merged into a combined structure by following the rule `{...headers, data: data}`.

Message data is always structured and when sent to message brokers serialized to JSON. In case a message data is received, that is not a JSON string and can't be parsed as a `Map`, the plain message data is wrapped into a `Map` structure with key `message`.

::: tip
[Events declared in the CDS model](#cds-declared-events) always result in a structured message data.
:::

### CloudEvents

CAP is able to produce event messages compatible with the [CloudEvents](https://cloudevents.io/) standard. To enable this feature, set the configuration parameter `format` of the messaging service to `cloudevents`, for example, like:

Excerpt from _application.yaml_:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  messaging:
    services:
      - name: "messaging-name"
        kind: [...]
        format: "cloudevents"
```
:::
With this setting, basic header fields (like `type`, `source`, `id`, `datacontenttype`, `specversion`, `time`) will be populated with sensible data (if they have not been set manually before). The event name will be used as-is (without prefixing or any other modifications) as `type` and set in the according CloudEvents header field.

When using CloudEvents format with SAP Event Mesh, the following default prefixing of topics will be applied (if not manually declared differently): Default for `publishPrefix` is set to `$namespace/ce/` and default for `subscribePrefix` is set to `+/+/+/ce/`. Make sure that these prefixes are allowed topic prefixes in your SAP Event Mesh service configuration (especially its topic rules section).

The message data will automatically be embedded in the `data` attribute of the CloudEvents message.

::: tip
Headers of the CloudEvents message can be accessed using the EventContext generated for this event by using its generic `get(String)` API.
:::

The following example shows how to access headers of a CloudEvents message:

```java
@On(service = ReviewService_.CDS_NAME)
private void ratingChanged(ReviewedContext context) {
  // Access the CloudEvents header named "type"
  String eventType = (String) context.get("type");
  // Or access in a type-safe way (only for common CloudEvents headers)
  eventType = context.as(CloudEventMessageEventContext.class).getType();
}
```

[Learn more about **CloudEvents**.](../guides/messaging/#cloudevents){.learn-more}

<span id="aftercloudevents" />
<Fragment target="#aftercloudevents">

## Multitenancy <Internal />

::: warning
SAP Event Mesh deprecated its multitenancy capability for new stakeholders, see [Getting Started with Event Mesh (default plan) in the SaaS context](https://wiki.one.int.sap/wiki/x/kUIAgQ).
:::

[Learn more about **Event Mesh Multitenancy**.](../guides/messaging/event-mesh#multitenancy){.learn-more}


</Fragment>

<div id="secondary-file">java/messaging.fragment.md</div>


# Audit Logging


Find here information about the AuditLog service in CAP Java.




## AuditLog Service

### Overview

As of CAP Java 1.18.0, an AuditLog service is provided for CAP Java applications. The AuditLog service can be used to emit AuditLog related events to registered handlers.

The following events can be emitted with the [AuditLogService](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/auditlog/AuditLogService.html) to the registered handlers:

- [Personal data accesses](#data-access)
- [Personal data modifications](#data-modification)
- [Configuration changes](#config-change)
- [Security events](#security-event)

AuditLog events typically are bound to business transactions. In order to handle the events transactionally and also to decouple the request from outbound calls to a consumer, for example a central audit log service, the AuditLog service leverages the [outbox](./outbox) service internally which allows [deferred](#deferred) sending of events.

### Use AuditLogService

#### Get AuditLogService Instance

The `AuditLogService` can be injected into a custom handler class, if the CAP Java project uses Spring Boot:

```java
import com.sap.cds.services.auditlog.AuditLogService;

@Autowired
private AuditLogService auditLogService;
```

Alternatively the AuditLog service can be retrieved from the `ServiceCatalog`:

```java
ServiceCatalog catalog = context.getServiceCatalog();
auditLogService = (AuditLogService) catalog.getService(AuditLogService.DEFAULT_NAME);
```
[See section **Using Services** for more details about retrieving services.](./services#using-services){.learn-more}


#### Emit Personal Data Access Event { #data-access}

To emit a personal data access event use method [logDataAccess](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/auditlog/AuditLogService.html#logDataAccess-java.util.List-java.util.List-) of the `AuditLogService`.

```java
List<Access> accesses = new ArrayList<>();
Access access = Access.create();
// fill access object with data
accesses.add(access);
auditLogService.logDataAccess(accesses);
```

#### Emit Personal Data Modification Event { #data-modification}

To emit a personal data modification event use method [logDataModification](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/auditlog/AuditLogService.html#logDataModification-java.util.List-) of the `AuditLogService`.

```java
List<DataModification> dataModifications = new ArrayList<>();
DataModification modification = DataModification.create();
// fill data modification object with data
dataModifications.add(modification);
auditLogService.logDataModification(dataModifications);
```

#### Emit Configuration Change Event { #config-change}

To emit a configuration change event use method [logConfigChange](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/auditlog/AuditLogService.html#logConfigChange-java.lang.String-java.util.List-) of the `AuditLogService`.

```java
List<ConfigChange> configChanges = new ArrayList<>();
ConfigChange configChange = ConfigChange.create();
// fill config change object with data
configChanges.add(configChange);
auditLogService.logConfigChange(Action.UPDATE, configChanges);
```

#### Emit Security Event { #security-event}

Use method [logSecurityEvent](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/auditlog/AuditLogService.html#logSecurityEvent-java.lang.String-java.lang.String-) of the `AuditLogService` to emit an security event.

```java
String action = "login";
String data = "user-name";
auditLogService.logSecurityEvent(action, data);
```

### Deferred AuditLog Events { #deferred}

Instead of processing the audit log events synchronously in the [audit log handler](#auditlog-handlers), the `AuditLogService` can store the event in the [outbox](./outbox). This is done in the *same* transaction of the business request. Hence, a cancelled business transaction will not send any audit log events that are bound to it. To gain fine-grained control, for example to isolate a specific event from the current transaction, you may refine the transaction scope. See [ChangeSetContext API](./event-handlers/changeset-contexts#defining-changeset-contexts) for more information.

As the stored events are processed asynchronously, the business request is also decoupled from the audit log handler which typically sends the events synchronously to a central audit log service. This improves resilience and performance.

By default, the outbox comes in an [in-memory](./outbox#in-memory) flavour which has the drawback that it can't guarantee that the all events are processed after the transaction has been successfully closed.

To close this gap, a sophisticated [persistent outbox](./outbox#persistent) service can be configured.

By default, not all events are send asynchronously via (persistent) outbox.
* [Security events](#security-event) are always send synchronously.
* All other events are stored to persistent outbox, if available. The in-memory outbox acts as a fallback otherwise.


::: warning _❗ Compliance & Data Privacy_
* It is up to the application developer to make sure that audit log events stored in the persistent outbox don't violate given **compliance rules**.
  For instance, it might be appropriate not to persist audit log events triggered by users who have operator privileges. Such logs could be modified on DB level by the same user afterward.
* For technical reasons, the AuditLog service temporarily stores audit log events enhanced with personal data such as the request's _user_ and _tenant_.
  In case of persistent outbox, this needs to be handled individually by the application to comply with **data privacy rules**.
:::

## AuditLog Handlers { #auditlog-handlers}

### Default Handler

By default, the CAP Java SDK provides an AuditLog handler that writes the AuditLog messages to the application log.
This default handler is registered on all AuditLog events and writes `DEBUG` log entries.
However, the application log does not log `DEBUG` entries by default.
To enable audit logging to the application log, the log level of the default handler needs to be set to `DEBUG` level:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
logging:
  level:
    com.sap.cds.auditlog: DEBUG
```
:::

### AuditLog v2 Handler { #handler-v2}

Additionally, the CAP Java SDK provides an _AuditLog v2_ handler that writes the audit messages to the SAP Audit Log service via its API version 2. To enable this handler, an additional feature dependency must be added to the `srv/pom.xml` of the CAP Java project:

```xml
<dependency>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-feature-auditlog-v2</artifactId>
  <scope>runtime</scope>
</dependency>
```

Also a service binding to the AuditLog v2 service has to be added to the CAP Java application, then this handler is activated. The Auditlog v2 handler supports the `premium` plan of the AuditLog Service as described [here](https://help.sap.com/docs/btp/sap-business-technology-platform/audit-log-write-api-for-customers?#prerequisites-for-using-the-audit-log-write-api-for-customers).

<div id="handler-service-plans"/>
<Fragment target="#handler-service-plans">

::: info For Internal Users <Internal />
The `premium` plan is only available for customers. For internal usage, the plans `standard` and `oauth2` of the AuditLog Service are supported.

In multitenant scenarios, the `oauth2` plan requires a subscription dependency for subscribed tenants to the SAP Audit Log service. If a service binding with service plan `oauth2` is found, this is automatically added by CAP Java on subscription of a tenant. However, if you migrate from the `standard` to the `oauth2` plan and tenants have already been subscribed using the `standard` plan, you need to be manually upgrade these tenants. This can be accomplished, for example, by using the [Subscription Management Dashboard](https://int.controlcenter.ondemand.com/index.html#/knowledge_center/articles/83aa3c1c02c34586a7e66c07019d0ccb) available in the BTP Cockpit.
:::

</Fragment>

If it's required to disable the AuditLog v2 handler for some reason, this can be achieved by setting the CDS property [`cds.auditLog.v2.enabled`](../java/developing-applications/properties#cds-auditLog-v2-enabled) to `false` in _application.yaml_:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  auditlog.v2.enabled: false
```
:::

The default value of this parameter is `true` and the AuditLog v2 handler is automatically enabled, if all other requirements are fulfilled.

<div id="handler-mt-v2"/>
<Fragment target="#handler-mt-v2">

#### Subscriber or Provider Tenant in Multitenancy scenario <Internal />

The default handler of the `AuditLogService` uses the tenant information of the current user and sends the audit messages to the subscriber tenant of the [SAP Audit Log service](https://discovery-center.cloud.sap/serviceCatalog/audit-log-service?region=all&commercialModel=btpea). In some cases, the tenant information might not be available, for instance in a background job without the context of a request. Then, the audit messages are sent to the provider tenant of the SAP Audit Log service. Using custom code, you can enforce sending logs to the provider tenant by switching the user and tenant of the current `RequestContext` using the `systemUserProvider()` method, as shown in the next code sample:

```java
// create new request context and switch to the technical provider tenant
context.getCdsRuntime().requestContext().systemUserProvider().run(ctx -> {
    // send audit log message into provider tenant
    auditLog.logSecurityEvent("action", "message data");
});
```
[Learn more about modifying the user's tenant in **Defining Request Contexts**.](./event-handlers/request-contexts#defining-requestcontext){.learn-more}

</Fragment>

### Custom AuditLog Handler

CAP Java applications can also provide their own AuditLog handlers to implement custom processing of AuditLog events. The custom handler class has to implement the interface `EventHandler` and needs to be annotated with `@ServiceName(value = "*", type = AuditLogService.class)`.
If the CAP Java project uses Spring Boot, the class can be annotated with `@Component` to register the handler at the CDS runtime.

For each of the four supported AuditLog events, a handler method can be registered. Depending on the event type, the method signature has to support the corresponding argument type:

| Event Type | Argument Type |
| --- | --- |
| [Personal Data Access](#data-access) | [com.sap.cds.services.auditlog.DataAccessLogContext](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/auditlog/DataAccessLogContext.html) |
| [Personal Data Modification](#data-modification) | [com.sap.cds.services.auditlog.DataModificationLogContext](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/auditlog/DataModificationLogContext.html) |
| [Configuration Change](#config-change) | [com.sap.cds.services.auditlog.ConfigChangeLogContext](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/auditlog/ConfigChangeLogContext.html) |
| [Security Event](#security-event) | [com.sap.cds.services.auditlog.SecurityLogContext](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/auditlog/SecurityLogContext.html) |

With one of the annotations `@Before`, `@On`, and `@After` the handler method needs to be annotated to indicate in which phase of the event processing this method gets called.

The following example defines an AuditLog event handler class with methods for all event types:

```java
import com.sap.cds.services.auditlog.*;
import com.sap.cds.services.handler.*;
import com.sap.cds.services.handler.annotations.*;
import org.springframework.stereotype.*;

@Component
@ServiceName(value = "*", type = AuditLogService.class)
class CustomAuditLogHandler implements EventHandler {

	@On
	public void handleDataAccessEvent(DataAccessLogContext context) {
		// custom handler code
	}

	@On
	public void handleDataModificationEvent(DataModificationLogContext context) {
		// custom handler code
	}

	@On
	public void handleConfigChangeEvent(ConfigChangeLogContext context) {
		// custom handler code
	}

	@On
	public void handleSecurityEvent(SecurityLogContext context) {
		// custom handler code
	}
}
```

[Learn more about implementing an event handler in **Event Handler Classes**.](./event-handlers/#handlerclasses){.learn-more}


<div id="secondary-file">java/auditlog.fragment.md</div>


# Change Tracking



The feature tracks the changes of all modifying operations executed via CQN statements, which are indirectly triggered
by the protocol adapters or directly by a custom code.
Changes made through the native SQL, JDBC, or other means that bypass the CAP Java runtime or that are forwarded
to the remote services aren't tracked.

## Enabling Change Tracking

To use the change tracking feature, you need to add a dependency to [cds-feature-change-tracking](https://central.sonatype.com/artifact/com.sap.cds/cds-feature-change-tracking) in the `srv/pom.xml` file of your service:

```xml
<dependency>
  <groupId>com.sap.cds</groupId>
    <artifactId>cds-feature-change-tracking</artifactId>
    <scope>runtime</scope>
</dependency>
```

- Your POM must also include the goal to resolve the CDS model delivered from the feature.
See [Reference the New CDS Model in an Existing CAP Java Project](/java/building-plugins#reference-the-new-cds-model-in-an-existing-cap-java-project).

- If you use SAP Fiori elements as your UI framework and intend to use the built-in UI, update your SAP UI5 version to 1.121.2 or higher.

### Annotating Entities

To capture changes for an entity, you need to extend it with a technical aspect and annotate it
with the annotation `@changelog` that declares the elements whose changes are to be logged.

Given the following entity that represents a book on the domain level:

```cds
namespace model;

entity Books {
    key ID: UUID;
    title: String;
    stock: Integer;
}
```

And the corresponding service definition with the projection of the entity:

```cds
namespace srv;

using {model} from '../db/schema'; // Our domain model

service Bookshop {
    entity Books as projection on model.Books;
}
```

Include the change log model that is provided by this feature:

```cds
using {sap.changelog as changelog} from 'com.sap.cds/change-tracking';
```

Extend **the domain entity** with the aspect `changelog.changeTracked` like this:

```cds
extend model.Books with changelog.changeTracked;
```

This aspect adds the association `changes` that lets you consume the change log both programmatically
via CQN statements and in the UI. This implies that every projection
of the entity `Books` has this association and the changes will be visible in all of them.

Annotate elements of the entity that you want to track with the `@changelog` annotation:

```cds
annotate Bookshop.Books {
  title @changelog;
  stock @changelog;
};
```

Your complete service definition should look like this:

```cds
namespace srv;

using {sap.changelog as changelog} from 'com.sap.cds/change-tracking';
using {model} from '../db/schema';

// The domain entity extended with change tracking aspect.
extend model.Books with changelog.changeTracked;

service Bookshop {
    entity Books as projection on model.Books;
}

// Projection is annotated to indicate which elements are change tracked.
annotate Bookshop.Books {
  title @changelog;
  stock @changelog;
};
```

:::warning Personal data is ignored
Elements with [personal data](../guides/data-privacy/annotations#personaldata), that is, elements that are annotated
with @PersonalData and hence subject to audit logging, are ignored by the change tracking.
:::

The level where you annotate your elements with the annotation `@changelog` is very important. If you annotate
the elements on the _domain_ level, every change made through every projection of the entity is tracked.
If you annotate the elements on the _service_ level, only the changes made through that projection are tracked.

Using the previous books example, the changes made through the service entity `Bookshop.Books` are tracked, but the changes
made on the domain entity are omitted. That can be beneficial if you have a service that is used for data replication
or mass changes where change tracking can be a very expensive operation, and you do not want to generate changes from such operations.

Change tracking also works with the entities that have compositions and tracks the changes made to the items of the compositions.

In the following example you have an entity that represents the order with a composition that represents the items of the order. You can annotate the elements of both and track the changes made through the order and the items in a deep update.

```cds
entity OrderItems : cuid {
  parent    : Association to Orders;
  [...]
  quantity: Integer @changelog;
}

entity Orders : cuid {
  customerName: String @changelog;
  [...]
  items: Composition of many OrderItems on items.parent = $self;
}
```

:::tip Remember: Extend `Orders` entity
You must extend the `Orders` with the aspect `changelog.changeTracked` and not the `OrderItems`. With this, all changes in the `Orders`, even deep ones, are associated with the `Orders`.
:::

### Identifiers for Entities

You can store some elements of the entity together with the changes in the change log to produce a user-friendly identifier that annotates changes.

You define this identifier by annotating the entity with the `@changelog` annotation and including the elements that you want
to store together with the changed value:

```cds
annotate Bookshop.Book with @changelog: [
  title
];
```

This identifier can contain the elements of the entity or values of to-one associations that are reachable via path.
For example, for a book you can store an author name if you have an association from the book to the author. The best candidates for identifier are the elements that are insert-only or that don't change often.

### Identifiers for Compositions

For compositions, no special annotations are required. The identifiers of the target entity are used instead.

For example, given the following model: 

```cds
entity Orders : cuid {
  OrderNo  : String;
  customer: Association to Customer;
  [...]
  items: Composition of many OrderItems on items.parent = $self;
}

entity OrderItems : cuid {
    parent    : Association to Orders;
    supplierName: String;
    [...]
    quantity    : Integer;
}
```

You can annotate your model as follows to define identifiers for both entities.

```cds
annotate Orders with @changelog: [OrderNo];

annotate OrderItems with @changelog: [
  parent.OrderNo,
  supplierName,
];
```

Changes for `Orders` and `OrderItems` will have their own respective target or root identifiers filled. 

### Human-readable values for associations

For associations, the value of the foreign key is stored in the changelog by default. You can change this and store the values of the associated entity instead. 
This kind of identifier changes the values stored in the changelog, while [entity identifiers](#identifiers-for-entities) annotate changed values.

You annotate your entity like this:

```cds
annotate Orders {
  customer @changelog: [ customer.name ]
}
```
Elements from the `@changelog` annotation value must always be prefixed by the association name.

:::warning Validation required
If the target of the association is missing, for example, when an entity is updated with the ID for a customer
that does not exist, the changelog entry is not created. You need to validate
such cases in the custom code or use annotations, for example, [`@assert.target`](/guides/providing-services#assert-target).
:::

### Caveats of Identifiers

Consider the following important points that are relevant for all kinds of identifiers and human-readable values: 

- When you define the identifier for an entity, keep in mind that the projections of the annotated entity
inherit the annotation `@changelog`. If you change the structure of the projection,
for example, exclude or rename the elements that are used in the identifier, you must annotate the projection again
to provide updated element names in the identifier. This is one additional benefit of annotating the top-most projection for change tracking. 

- The values of the identifier are stored together with the change log as-is. They are not translated and some data types might
not be formatted per user locale or some requirements, for example, different units of measurement or currencies.

### Displaying Changes

The changes of the entity are exposed as an association `changes` that you can use to display the change log in the UI.
By default, the entity `Changes` is auto-exposed, but it won't be writable via OData requests.

If you want to display the change log together with the overview of your entity, you need to add the facet
to the object page that displays the changes:

```cds
annotate Bookshop.Books with @(
  UI : { ...
    Facets : [ ...
       {
          $Type               : 'UI.ReferenceFacet',
          ID                  : 'ChangeHistoryFacet',
          Label               : '{i18n>ChangeHistory}',
          Target              : 'changes/@UI.PresentationVariant',
          ![@UI.PartOfPreview]: false
        } ...
   ] ...
  } ...);
```

If you want to have a common UI for all changes, you need to expose the change log as a projection and define
your own presentation for it as the changes are exposed only as part of the change-tracked entity. This projection
must be read-only and shouldn't be writable via OData requests.

The change log is extended with the texts coming from your entities' `@title` annotation and the element. Otherwise, the change log contains only the technical names of the entities and the elements.
Titles are translated, if they're annotated as translatable. See [Externalizing Texts Bundles](../guides/i18n#localization-i18n) for more information.

## How Changes are Stored

The namespace `sap.changelog` defines an entity `Changes` that reflects each change, so the changes are stored in a flat table for all entities together.

Each entry in the `Changes` entity contains the following information:

- A marker that represents the nature of the change: addition, modification, or deletion.
- The qualified name of the entity that was changed and the qualified name of the root entity. They depend on the projection that was used to
  change the entity and reflect the root and a target of the modifying operation. For flat entities, they're the same.
- The attribute of the target projection that was changed.
- The new and old values as strings.
- The user who made the change and the timestamp of the change.
- The data type of the changed attribute.
- The technical path from the root entity to the tracked target entity.

## Detection of Changes

The change tracking intercepts the modifying CQL statements (`Insert`, `Upsert`, `Update`, and `Delete`) and
requires additional READ events to retrieve the old and the new image of the entity.

These two images are compared and differences are stored in the change log. The nature of the change is determined by comparing the old and new
values of the entity: data that weren't present in the old values are considered as added whereas data that aren't present in
the new values are considered as deleted. Elements that are present in both old and new values but have different values
are considered as modified. Each change detected by the change tracking feature is stored in the change log as a separate entry.

As a rule, specify primary keys to modify change tracked entities and avoid using [searched updates](/java/working-with-cql/query-api#searched-update).

### Changes in Deeply Structured Documents

In the case of the deeply structured documents, for example, entities with the compositions, the change tracking feature detects
the changes across the complete document and stores them in the change log with the metadata reflecting the structure of the change.

Take the order and item model used previously in this guide as an example.

For deep updates, use the [delta representation](/java/working-with-cql/query-api#deep-update-delta) for its items or the [full set representation](/java/working-with-cql/query-api#deep-update-full-set) to overwrite complete document.

The following example yields two changelog entries: one for the order and one for the item. The change log entry for the item reflects that the root of the change is an order. Both changes are reachable through the association `changes` of the order entity.

```java
Orders order = Orders.create("...");
order.setOrderNo("N1");
OrderItems item = OrderItems.create("...");
item.setQuantity(3);

order.setItems(CdsList.delta(item));
Update.entity(Orders_.class).entry(order);
```

If a direct update is unavoidable, Specify the order item that needs to be updated with a path expression:

```java
OrderItems item = OrderItems.create("...");
item.setQuantity(3);
Update.entity(Orders_.class, o -> o.filter(f -> f.ID().eq("...")).items()).entry(item);
```

Similarly, a `Delete` statement can be used to remove an item from an order:

```java
Delete.from(Orders_.class, o -> o.filter(f -> f.ID().eq("...")).items().filter(i -> i.ID().eq("...")));
```

The last segment can omit keys to indicate **bulk deletion**:

```java
Delete.from(Orders_.class, o -> o.filter(f -> f.ID().eq("...")).items());
```

The same path expression can be used in the `Insert` statement to directly add an item to a composition.

Changes are correctly referenced to the root if the following conditions are true:
- The path expression starts at the root of the document (`Orders`, in this case).
- The path navigates only through the compositions within the same document tree.
- All segments of the path, except the last one, must include keys.

:::warning Limitation
Avoid Direct modifications of composition items, they aren't supported by change tracking.
:::

In the following example, the item's updated changelog entry _won't_ be associated with an order: 

```java
OrderItems item = OrderItems.create("...");
item.setQuantity(3);
Update.entity(OrderItems_.class).entry(item);
```

You must rewrite such statements using one of the previously illustrated ways.

## Reacting on Changes

You can write an event handler to observe the change log entries. Keep in mind that the change log entries
are created for each statement and this event will not be bound to any kind of transaction or a batch operation.

First, update the dependency's scope to `compile` in the `srv/pom.xml` file of your service:

```xml
<dependency>
  <groupId>com.sap.cds</groupId>
    <artifactId>cds-feature-change-tracking</artifactId>
    <scope>compile</scope>
</dependency>
```

Second, add a handler to access the changes:

```java
import cds.gen.sap.changelog.Changes;

@Component
@ServiceName(ChangeTrackingService.DEFAULT_NAME)
public class ChangeTrackingHandler implements EventHandler {

  @After(event = ChangeTrackingService.CREATE_CHANGES)
  void afterCreate(CreateChangesEventContext context) {
    context.getResult().listOf(Changes.class).forEach(c -> {
      // Do something with the change log entry
    });
  }
}
```

You can query the change log entries via CQN statements, as usual.

## Things to Consider when Using Change Tracking

- Consider the storage costs of the change log. The change log can grow very fast and can consume a lot of space
  in case of frequent changes. You should consider the retention policy of the change log as it won't be deleted when you delete the entities.
- Consider the performance impact. Change tracking needs to execute additional reads during updates to retrieve and compare updated values.
  This can slow down the update operations and can be very expensive in the case of updates that affect a lot of entities.
- Consider the ways your entities are changed. You might want to track the changes only on the service projection level that are used for
  the user interaction and not on the domain level (for instance during data replication).
- If you want to expose the complete change log to the user, you need to consider the security implications of this. If your entities have complex access rules,
  you need to consider how to extend these rules to the change log.



# Flow: Modeling State Transitions <Internal /> <Since version="3.10.0" of="com.sap.cds:cds-feature-flow" />



The flow feature makes it easy to define and manage state transitions in your CDS models. It ensures transitions are explicitly modeled, validated, and executed in a controlled and reliable way.

## Enabling Flows { #enabling-flows }

To get started with the flow feature, simply add the [cds-feature-flow](https://central.sonatype.com/artifact/com.sap.cds/cds-feature-flow) dependency to your `srv/pom.xml` file:

```xml
<dependency>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-feature-flow</artifactId>
  <scope>runtime</scope>
</dependency>
```

## Modeling Flows { #modeling-flows }

Flows are defined in the CDS model using annotations. Flows are made up of a _status element_ and _flow actions_ that trigger state transitions. Annotate the status element with `@flow.status`. Define all transitions as [bound actions](../cds/cdl#bound-actions), list the valid entry states using `@flow.from` and the target state using `@flow.to`.

::: tip Best Practice
We recommend to always use `@flow.status` in combination with `@readonly`. This ensures that the status element is immutable from the client side, giving the service provider full control over all state transitions.
:::

[Learn more about the flow annotations in the Appendix.](#annotations){.learn-more}

## Flows in SFlight

Let's look at the [SFlight](https://github.com/SAP-samples/cap-sflight) sample app and how it looks like using the flow feature.

The following is an extract of the relevant parts of the entity model. The `TravelStatus` element is annotated with the `@flow.status` annotation.

```cds
entity Travel : managed {
  key TravelUUID : UUID;
  TravelID       : Integer default 0 @readonly;
  @flow.status // [!code highlight]
  TravelStatus   : Association to TravelStatus default 'O' @readonly;
};

entity TravelStatus : CodeList {
  key code : TravelStatusCode;
}

type TravelStatusCode : String(1) enum {
  Open     = 'O';
  Accepted = 'A';
  Canceled = 'X';
};
```

Now, let's have a look at the flow annotations in the service model:

```cds
service TravelService @(path:'/processor') {

  entity Travel as projection on my.Travel actions {
    @(flow: { 
        from:[ Open ],                     
        to: Canceled 
    })
    action rejectTravel();
    @(flow: { 
        from:[ Open ],                     
        to: Accepted 
    })
    action acceptTravel();
  };

}
```

No action handler implementation is needed for simple transitions, as the flow feature's default action handler takes care of the logic. It validates that the entry state is `Open` and then transitions the status to `Accepted` or `Canceled` respectively. For more complex logic, custom handlers may still be required, as explained later in the document.

## Using and Extending Flows
When using the flow feature, [generic handlers](#generic-handlers) are registered for your flow actions.

You can extend the default flow handlers with event handlers to implement custom event logic that should run on a transition. 


### Custom Event Handler { #custom-event-handler}

Let's look at some use-cases for custom event handlers:
- If the entry state validation depends on additional conditions, you could implement the logic in a custom `Before` handler. 
- If the action's return type is anything other than `void`, you must implement a custom `On` handler.
- If the transition depends on a condition, you should implement a custom `On` handler.
- If you have multiple target states, you must implement a custom `On` handler, and you must **not** use the `@flow.to` annotation.
- If you want to run logic like contacting an external system on a state transition, consider implementing a custom `On` handler for the respective action.

### Example: Withdrawn

Let's introduce a new requirement to see an action that will require a custom event handler to be implemented. The new requirement is that a customer withdraws from travelling, for example due to sickness. Withdrawing from travelling is only allowed for up to 24 hours before the travel begins.

The status transition diagram below visualizes the new state and transitions.
![Diagram showing SFlight travel status transitions. The diagram title is SFlight Travel Status Transitions. It illustrates the possible state changes for a travel booking: open can transition to accepted or canceled via actions acceptTravel and rejectTravel. Both transitions are labeled with their respective action names. From open or accepted, a withdrawTravel action can be triggered, leading to the withdrawn state. Withdrawn is visually highlighted in green, and the diagram notes that the flow is extended with the withdrawn state. The overall tone is informative and neutral, supporting understanding of state management in the SFlight sample application.](assets/sflight-travel-status.drawio.svg){}

We add the travel status `Withdrawn` and add the action `withdrawTravel`:

```cds
type TravelStatusCode : String(1) enum {
  Open      = 'O';
  Accepted  = 'A';
  Canceled  = 'X';
  Withdrawn = 'W'; // added 
};

service TravelService @(path:'/processor') {

  entity Travel as projection on my.Travel actions {
    @(flow: { 
        from:[ Open ],                     
        to: Canceled 
    })
    action rejectTravel();
    @(flow: { 
        from:[ Open ],                     
        to: Accepted 
    })
    action acceptTravel();
    @(flow: {
      from:[ Open, Accepted ],
    })
    action withdrawTravel(); // added
  };
}
```

Note that the `withdrawTravel` action doesn't have the `@flow.to` annotation, because we will implement the transition in a custom handler:

::: details Custom handler for transition to 'Withdrawn'

```java
@Component
@ServiceName(TravelService_.CDS_NAME)
public class WithdrawTravelHandler implements EventHandler {

  private final PersistenceService persistenceService;

  public WithdrawTravelHandler(PersistenceService persistenceService) {
    this.persistenceService = persistenceService;
  }

  @Before(entity = Travel_.CDS_NAME)
  public void check24HoursBeforeTravel(final TravelWithdrawTravelContext context, CqnStructuredTypeRef travelRef) {
    Travel travel = ((ApplicationService) context.getService()).run(
        Select.from(travelRef).columns(Travel_.BEGIN_DATE)).first(Travel.class)
      .orElseThrow(() -> new ServiceException(ErrorStatuses.BAD_REQUEST, "TRAVEL_NOT_FOUND"));

    if (travel.beginDate().isBefore(LocalDate.now().minusDays(1))) {
      context.getMessages().error("Travel can only be withdrawn up to 24 hours before travel begins.");
    }
  }

  @On(entity = Travel_.CDS_NAME)
  public void onWithdrawTravel(final TravelWithdrawTravelContext context, CqnStructuredTypeRef travelRef) {
    boolean isDraftTarget =DraftUtils.isDraftTarget(
      travelRef,
      context.getModel().findEntity(travelRef.targetSegment().id()).get(),
      context.getModel());
    boolean isDraftEnabled = DraftUtils.isDraftEnabled(context.getTarget());
    var travel = Travel.create();
    travel.travelStatusCode(TravelStatusCode.WITHDRAWN);
    if (isDraftTarget) {
      ((DraftService) context.getService()).patchDraft(Update.entity(travelRef).data(travel));
    } else {
      AnalysisResult analysis = CqnAnalyzer.create(context.getModel()).analyze(travelRef);
      Map<String, Object> keys = analysis.targetKeyValues();
      if (isDraftEnabled) {
        keys.remove(Drafts.IS_ACTIVE_ENTITY);
      }
      persistenceService.run(Update.entity(context.getTarget()).matching(keys).data(travel));
    }
    context.setCompleted();
  }

}
```

:::

The custom `Before` handler retrieves the `BeginDate` of the travel entity from the database and validates whether it is within the allowed time frame, ensuring that the travel can only be withdrawn up to 24 hours before the current date.

The custom `On` handler implements the transition by updating the travel status to `Withdrawn`. It checks whether the entity is a draft or a non-draft entity and applies the appropriate update logic. For draft entities, it uses the `patchDraft` method to update the draft data, while for non-draft entities, it uses the `PersistenceService` to persist the changes. Finally, it marks the action as completed.

Technically, we could have used the `@flow.to` annotation and the default flow handler for the transition instead of implementing it here. However, in this case, omitting the annotation explicitly signals to developers that custom logic is implemented for the transition, ensuring they understand the intent behind the omission.

## Appendix

### Generic Handlers

The default `Before` handler will validate that your entity instance is in a valid entry state, meaning the current state of the entity must match one of the states specified in the `@flow.from` annotation. A validation error will return a `409` HTTP Status Code.

The default `On` handler will complete the action for void return types.

The default `After` handler will process the transition by automatically updating the status element of the entity to the target state defined in the `@flow.to` annotation. For example, if the current state is `Open` and the target state is `Accepted`, the `After` handler will update the status to `Accepted` after the action is executed. This ensures that the state transition is consistently applied without requiring additional custom logic.

### Annotations

Let's dive into the details of the annotations:

`@flow.status`

- This annotation is mandatory.
- The annotated element must be either an enum or an association to a code list.
- Only one status element per entity is supported.
- Draft-enabled entities are supported.
- `null` is **not** a valid state. Model your empty state explicitly.

  ```cds
  type TravelStatusCode : String(1) enum {
    Empty    = ''; // explicitly model the empty state
    Open     = 'O';
    Accepted = 'A';
    Canceled = 'X';
  };
  ```

`@flow.from`

- This annotation is optional. Leave it out and the flow feature won't validate the entry states.
- This annotation's value type is an array. Each array element's type must match the status' enum.

`@flow.to`

- This annotation is optional. Leave it out and the flow feature won't change the target state.
- This annotation's value type must match the status element.

Please note, while both `@flow.from` and `@flow.to` are optional, one of them is mandatory to mark the action as a flow action.



# Transactional Outbox


Find here information about the Outbox service in CAP Java.

## Concepts

Usually the emit of messages should be delayed until the main transaction succeeded, otherwise recipients also receive messages in case of a rollback.
To solve this problem, a transactional outbox can be used to defer the emit of messages until the success of the current transaction.

## In-Memory Outbox (Default) { #in-memory}

The in-memory outbox is used per default and the messages are emitted when the current transaction is successful. Until then, messages are kept in memory.


## Persistent Outbox { #persistent}

The persistent outbox requires a persistence layer to persist the messages before emitting them. Here, the to-be-emitted message is stored in a database table first. The same database transaction is used as for other operations, therefore transactional consistency is guaranteed.

Once the transaction succeeds, the messages are read from the database table and are emitted.

- If an emit was successful, the respective message is deleted from the database table.
- If an emit wasn't successful, there will be a retry after some (exponentially growing) waiting time. After a maximum number of attempts, the message is ignored for processing and remains in the database table. Even if the app crashes the messages can be redelivered after successful application startup.

To enable the persistence for the outbox, you need to add the service `outbox` of kind `persistent-outbox` to the `cds.requires` section in the _package.json_ or _cdsrc.json_, which will automatically enhance your CDS model in order to support the persistent outbox.

```jsonc
{
  // ...
  "cds": {
    "requires": {
      "outbox": {
        "kind": "persistent-outbox"
      }
    }
  }
}
```

::: warning _❗ Warning_
Be aware that you need to migrate the database schemas of all tenants after you've enhanced your model with an outbox version from `@sap/cds`  version 6.0.0 or later.
:::

For a multitenancy scenario, make sure that the required configuration is also done in the MTX sidecar service. Make sure that the base model in all tenants is updated to activate the outbox.

::: info Option: Add outbox to your base model
Alternatively, you can add `using from '@sap/cds/srv/outbox';` to your base model. In this case, you need to update the tenant models after deployment but you don't need to update MTX Sidecar.
:::

If enabled, CAP Java provides two persistent outbox services by default:

-  `DefaultOutboxOrdered` - is used by default by messaging services
-  `DefaultOutboxUnordered` - is used by default by the AuditLog service

The default configuration for both outboxes can be overridden using the `cds.outbox.services` section, for example in the _application.yaml_:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  outbox:
    services:
      DefaultOutboxOrdered:
        maxAttempts: 10
        # ordered: true
      DefaultOutboxUnordered:
        maxAttempts: 10
        # ordered: false
```
:::
You have the following configuration options:
- `maxAttempts` (default `10`): The number of unsuccessful emits until the message is ignored. It still remains in the database table.
- `ordered` (default `true`): If this flag is enabled, the outbox instance processes the entries in the order they have been submitted to it. Otherwise, the outbox may process entries randomly and in parallel, by leveraging outbox processors running in multiple application instances. This option can't be changed for the default persistent outboxes.

The persistent outbox stores the last error that occurred, when trying to emit the message of an entry. The error is stored in the element `lastError` of the entity `cds.outbox.Messages`.

### Configuring Custom Outboxes { #custom-outboxes}

Custom persistent outboxes can be configured using the `cds.outbox.services` section, for example in the _application.yaml_:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
cds:
  outbox:
    services:
      MyCustomOutbox:
        maxAttempts: 5
      MyOtherCustomOutbox:
        maxAttempts: 10
```
:::
Afterward you can access the outbox instances from the service catalog:

```java
OutboxService myCustomOutbox = cdsRuntime.getServiceCatalog().getService(OutboxService.class, "MyCustomOutbox");
OutboxService myOtherCustomOutbox = cdsRuntime.getServiceCatalog().getService(OutboxService.class, "MyOtherCustomOutbox");
```

Alternatively it's possible to inject them into a Spring component:

```java
@Component
public class MySpringComponent {
  private final OutboxService myCustomOutbox;

  public MySpringComponent(@Qualifier("MyCustomOutbox") OutboxService myCustomOutbox) {
    this.myCustomOutbox = myCustomOutbox;
  }
}
```

::: warning When removing a custom outbox ...
... it must be ensured that there are no unprocessed entries left.

Removing a custom outbox from the `cds.outbox.services` section doesn't remove the
entries from the `cds.outbox.Messages` table. The entries remain in the `cds.outbox.Messages` table and aren't
processed anymore.

:::

### Outbox Event Versions

In scenarios with multiple deployment versions (blue/green), situations may arise in which the outbox collectors of the older deployment cannot process the events generated by a newer deployment. In this case, the event can get stuck in the outbox, with all the resulting problems.

To avoid this problem, you can configure the outbox to use an event version that prevents the outbox collectors from using the newer events. For this purpose, you can set the parameter [<Config java keyOnly filesOnly>cds.environment.deployment.version: 2</Config>](../java/developing-applications/properties#cds-environment-deployment-version).

::: warning Ascending Versions
The configured deployment versions must be in ascending order. The messages are only processed by the outbox collector if the event version is less than or equal to the deployment version.
:::

To make things easier, you can automate versioning by using the Maven app version. This requires you to increment the version for each new deployment.

To do this, the Maven `resource.filtering` configuration in the `srv/pom.xml` must be activated as follows, so that the app version placeholder `${project.version}` can be used in [<Config java keyOnly filesOnly>cds.environment.deployment.version: ${project.version}</Config>](../java/developing-applications/properties#cds-environment-deployment-version).

::: code-group
```xml [srv/pom.xml]
<build>
  ...
	<resources>
		<resource>
			<directory>src/main/resources</directory>
			<filtering>true</filtering>
		</resource>
	</resources>
  ...
```
:::

To be sure that the deployment version has been set correctly, you can find a log entry at startup that shows the configured version:

```bash
2024-12-19T11:21:33.253+01:00 INFO 3420 --- [main] cds.services.impl.utils.BuildInfo : application.deployment.version: 1.0.0-SNAPSHOT
```

And finally, if for some reason you don't want to use a version check for a particular outbox collector, you can switch it off via the outbox configuration [<Config java filesOnly>cds.outbox.services.MyCustomOutbox.checkVersion: false</Config>](../java/developing-applications/properties#cds-outbox-services-<key>-checkVersion).

## Outboxing CAP Service Events

Outbox services support outboxing of arbitrary CAP services. A typical use case is to outbox remote OData
service calls, but also calls to other CAP services can be decoupled from the business logic flow.

The API `OutboxService.outboxed(Service)` is used to wrap services with outbox handling. Events triggered
on the returned wrapper are stored in the outbox first, and executed asynchronously. Relevant information from
the `RequestContext` is stored with the event data, however the user context is downgraded to a system user context.

The following example shows you how to outbox a service:

```java
OutboxService myCustomOutbox = ...;
CqnService remoteS4 = ...;
CqnService outboxedS4 = myCustomOutbox.outboxed(remoteS4);
```

If a method on the outboxed service has a return value, it will always return `null` since it's executed asynchronously. A common example for this are the `CqnService.run(...)` methods.
To improve this the API `OutboxService.outboxed(Service, Class)` can be used, which wraps a service with an asynchronous suited API while outboxing it.
This can be used together with the interface `AsyncCqnService` to outbox remote OData services:

```java
OutboxService myCustomOutbox = ...;
CqnService remoteS4 = ...;
AsyncCqnService outboxedS4 = myCustomOutbox.outboxed(remoteS4, AsyncCqnService.class);
```

The method `AsyncCqnService.of()` can be used alternatively to achieve the same for CqnServices:

```java
OutboxService myCustomOutbox = ...;
CqnService remoteS4 = ...;
AsyncCqnService outboxedS4 = AsyncCqnService.of(remoteS4, myCustomOutbox);
```

::: tip Custom asynchronous suited API
When defining your own custom asynchronous suited API, the interface must provide the same method signatures as the interface of the outboxed service, except for the return types which should be `void`.
:::

The outboxed service is thread-safe and can be cached.
Any service that implements the `Service` interface can be outboxed.
Each call to the outboxed service is asynchronously executed, if the API method internally calls the method `Service.emit(EventContext)`.

A service wrapped by an outbox can be unboxed by calling the API `OutboxService.unboxed(Service)`. Method calls to the unboxed
service are executed synchronously without storing the event in an outbox.

::: warning Java Proxy
A service wrapped by an outbox is a [Java Proxy](https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html). Such a proxy only implements the _interfaces_ of the object that it's wrapping. This means an outboxed service proxy can't be casted to the class implementing the underlying service object.
:::

::: tip Custom outbox for scaling
The default outbox services can be used for outboxing arbitrary CAP services. If you detect a scaling issue,
you can define custom outboxes that can be used for outboxing.
:::

## Technical Outbox API { #technical-outbox-api }

Outbox services provide the technical API `OutboxService.submit(String, OutboxMessage)` that can be used to outbox custom messages for an arbitrary event or processing logic.
When submitting a custom message, an `OutboxMessage` that can optionally contain parameters for the event needs to be provided.
As the `OutboxMessage` instance is serialized and stored in the database, all data provided in that message
must be serializable and deserializable to/from JSON. The following example shows the submission of a custom message to an outbox:

```java
OutboxService outboxService = runtime.getServiceCatalog().getService(OutboxService.class, "<OutboxServiceName>");

OutboxMessage message = OutboxMessage.create();
message.setParams(Map.of("name", "John", "lastname", "Doe"));

outboxService.submit("myEvent", message);
```

A handler for the custom message must be registered on the outbox service. This handler performs the processing logic when the message is published by the outbox:

```java
@On(service = "<OutboxServiceName>", event = "myEvent")
void processMyEvent(OutboxMessageEventContext context) {
  OutboxMessage message = context.getMessage();
  Map<String, Object> params = message.getParams();
  String name = (String) param.get("name");
  String lastname = (String) param.get("lastname");

  // Perform processing logic for myEvent

  context.setCompleted();
}
```

You must ensure that the handler is completing the context, after executing the processing logic.

[Learn more about event handlers.](./event-handlers/){.learn-more}

## Handling Outbox Errors { #handling-outbox-errors }

The outbox by default retries publishing a message, if an error occurs during processing, until the message has reached the maximum number of attempts.
This behavior makes applications resilient against unavailability of external systems, which is a typical use case for outbox message processing.

However, there might also be situations in which it is not reasonable to retry publishing a message.
For example, when the processed message causes a semantic error - typically due to a `400 Bad request` - on the external system.
Outbox messages causing such errors should be removed from the outbox message table before reaching the maximum number of retry attempts and instead application-specific
counter-measures should be taken to correct the semantic error or ignore the message altogether.

A simple try-catch block around the message processing can be used to handle errors:
- If an error should cause a retry, the original exception should be (re)thrown (default behavior).
- If an error should not cause a retry, the exception should be suppressed and additional steps can be performed.

```java
@On(service = "<OutboxServiceName>", event = "myEvent")
void processMyEvent(OutboxMessageEventContext context) {
  try {
    // Perform processing logic for myEvent
  } catch (Exception e) {
    if (isUnrecoverableSemanticError(e)) {
      // Perform application-specific counter-measures
      context.setCompleted(); // indicate message deletion to outbox
    } else {
      throw e; // indicate error to outbox
    }
  }
}
```

In some situations, the original outbox processing logic is not implemented by you but the processing needs to be extended with additional error handling.
In that case, wrap the `EventContext.proceed()` method, which executes the underlying processing logic:

```java
@On(service = OutboxService.PERSISTENT_ORDERED_NAME, event = AuditLogService.DEFAULT_NAME)
void handleAuditLogProcessingErrors(OutboxMessageEventContext context) {
  try {
    context.proceed(); // wrap default logic
  } catch (Exception e) {
    if (isUnrecoverableSemanticError(e)) {
      // Perform application-specific counter-measures
      context.setCompleted(); // indicate message deletion to outbox
    } else {
      throw e; // indicate error to outbox
    }
  }
}
```

[Learn more about `EventContext.proceed()`.](./event-handlers/#proceed-on){.learn-more}

## Outbox Dead Letter Queue

The transactional outbox tries to process each entry a specific number of times. The number of attempts is configurable per outbox by setting the configuration `cds.outbox.services.<key>.maxAttempts`.

[Learn more about CDS Properties.](./developing-applications/properties){.learn-more}

Once the maximum number of attempts is exceeded, the corresponding entry is not touched anymore and hence it can be regarded as dead. Dead outbox entries are not deleted automatically. They remain in the database and it's up to the application to take care of the entries. By defining a CDS service, the dead entries can be managed conveniently. Let's have a look, how you can develop a Dead Letter Queue for the transactional outbox.

::: warning Changing configuration between deployments

It's possible to increase the value of the configuration `cds.outbox.services.<key>.maxAttempts` in between of deployments. Older entries which have reached their max attempts in the past would be retried automatically after deployment of the new microservice version. If the dead letter queue has a large size, this leads to unintended load on the system.

:::


### Define the Service

::: code-group

```cds [srv/outbox-dead-letter-queue-service.cds]
using from '@sap/cds/srv/outbox';

@requires: 'internal-user'
service OutboxDeadLetterQueueService {

  @readonly
  entity DeadOutboxMessages as projection on cds.outbox.Messages
    actions {
      action revive();
      action delete();
    };

}
```

:::

The `OutboxDeadLetterQueueService` provides an entity `DeadOutboxMessages` which is a projection on the outbox table `cds.outbox.Messages` that has two bound actions:

- `revive()` sets the number of attempts to `0` such that the outbox entry is going to be processed again.
- `delete()` deletes the outbox entry from the database.

Filters can be applied as for any other CDS defined entity, for example, to filter for a specific outbox where the outbox name is stored in the field `target` of the entity `cds.outbox.Messages`.

::: warning `OutboxDeadLetterQueueService` for internal users only

It is crucial to make the service `OutboxDeadLetterQueueService` accessible for internal users only as it contains sensitive data that could be exploited for malicious purposes if unauthorized changes are performed.

[Learn more about pseudo roles](../guides/security/authorization#pseudo-roles){.learn-more}

:::

### Filter for Dead Entries

This filtering can't be done on the database since the maximum number of attempts is only available from the CDS properties.

To ensure that only dead outbox entries are returned when reading `DeadOutboxMessages`, the following code provides the handler for the `DeadLetterQueueService` and the `@After-READ` handler that filters for the dead outbox entries:

```java
@Component
@ServiceName(OutboxDeadLetterQueueService_.CDS_NAME)
public class DeadOutboxMessagesHandler implements EventHandler {

	@After(entity = DeadOutboxMessages_.CDS_NAME)
	public void filterDeadEntries(CdsReadEventContext context) {
		CdsProperties.Outbox outboxConfigs = context.getCdsRuntime().getEnvironment().getCdsProperties().getOutbox();
		List<DeadOutboxMessages> deadEntries = context
				.getResult()
				.listOf(DeadOutboxMessages.class)
				.stream()
				.filter(entry -> entry.getAttempts() >= outboxConfigs.getService(entry.getTarget()).getMaxAttempts())
				.toList();

		context.setResult(deadEntries);
	}
}
```

[Learn more about event handlers.](./event-handlers/){.learn-more}

### Implement Bound Actions

```java
@Autowired
@Qualifier(PersistenceService.DEFAULT_NAME)
private PersistenceService db;

@On
public void reviveOutboxMessage(DeadOutboxMessagesReviveContext context) {
  CqnAnalyzer analyzer = CqnAnalyzer.create(context.getModel());
  AnalysisResult analysisResult = analyzer.analyze(context.getCqn());
  Map<String, Object> key = analysisResult.rootKeys();
  Messages deadOutboxMessage = Messages.create((String) key.get(Messages.ID));

  deadOutboxMessage.setAttempts(0);

  this.db.run(Update.entity(Messages_.class).entry(key).data(deadOutboxMessage));
  context.setCompleted();
}

@On
public void deleteOutboxEntry(DeadOutboxMessagesDeleteContext context) {
  CqnAnalyzer analyzer = CqnAnalyzer.create(context.getModel());
  AnalysisResult analysisResult = analyzer.analyze(context.getCqn());
  Map<String, Object> key = analysisResult.rootKeys();

  this.db.run(Delete.from(Messages_.class).byId(key.get(Messages.ID)));
  context.setCompleted();
}
```

The injected `PersistenceService` instance is used to perform the operations on the `Messages` entity since the entity `DeadOutboxMessages` is read-only. Both handlers first retrieve the ID of the entry and then they perform the corresponding operation on the database.

[Learn more about CQL statement inspection.](./working-with-cql/query-introspection#cqnanalyzer){.learn-more}

::: tip Use paging logic
Avoid to read all entries of the `cds.outbox.Messages` or `OutboxDeadLetterQueueService.DeadOutboxMessages` table at once, as the size of an entry is unpredictable
and depends on the size of the payload. Prefer paging logic instead.
:::

## Observability using Open Telemetry

The transactional outbox integrates Open Telemetry for logging telemetry data.

[Learn more about observability with Open Telemetry.](./operating-applications/observability#open-telemetry){.learn-more}

The following KPIs are logged in addition to the spans described in the [observability chapter](./operating-applications/observability):

| KPI Name                                   | Description                                                                                            | KPI Type |
| ------------------------------------------ | ------------------------------------------------------------------------------------------------------ | -------- |
| `com.sap.cds.outbox.coldEntries`           | Number of entries that could not be delivered after repeated attempts and will not be retried anymore. | Gauge    |
| `com.sap.cds.outbox.remainingEntries`      | Number of entries which are pending for delivery.                                                      | Gauge    |
| `com.sap.cds.outbox.maxStorageTimeSeconds` | Maximum time in seconds an entry was residing in the outbox.                                           | Gauge    |
| `com.sap.cds.outbox.medStorageTimeSeconds` | Median time in seconds of an entry stored in the outbox."                                              | Gauge    |
| `com.sap.cds.outbox.minStorageTimeSeconds` | Minimal time in seconds an entry was stored in the outbox.                                             | Gauge    |
| `com.sap.cds.outbox.incomingMessages`      | Number of incoming messages of the outbox.                                                             | Counter  |
| `com.sap.cds.outbox.outgoingMessages`      | Number of outgoing messages of the outbox.                                                             | Counter  |

The KPIs are logged per microservice instance (in case of horizontal scaling), outbox, and tenant.



# Multitenancy { #multitenancy}

CAP applications can be run as software as a service (SaaS). That means, multiple customers (subscriber tenants) can use the application at the same time in an isolated manner. Optionally, subscriber tenants may also extend their CDS models being served.

## Setup Overview

This chapter describes how CAP Java applications can deal with multiple business tenants.
To add multitenancy flavour seamlessly, the CAP Java backend can be enriched with CAP multitenancy services as described in detail in general [Multitenancy](../guides/multitenancy/?impl-variant=java) guide.

The overall setup is sketched in the following figure:

![This is a technical architecture modeling diagram, which shows all involved components and how they interact. The involved components are: SaaS Provisioning Service, CAP Java backend, MTX sidecar, SAP BTP Service Manager, and a database.](./assets/architecture-mt.drawio.svg)

The **MTX sidecar** services provide basic functionality such as:

- Deploying or undeploying database containers during subscription or unsubscription of business tenants.
- Managing CDS model [extensions](../guides/extensibility/customization#extending-saas-applications) for tenants.
- Managing CDS models for [feature toggles](../guides/extensibility/feature-toggles#feature-toggles).

There are different web adapters available in the Java backend to integrate with **platform services for tenant lifecycle** such as:

- SAP BTP [SaaS Provisioning service](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/ed08c7dcb35d4082936c045e7d7b3ecd.html) for XSUAA tenants
- SAP BTP Subscription Manager Service for IAS tenants.

This chapter describes the APIs available in the **Java backend**, most notably the technical [DeploymentService](#custom-logic),
which can be used to add custom handlers that influence or react on subscription or unsubscription events

## React on Tenant Events { #custom-logic }

CAP Java can automatically react on tenant lifecycle events sent by platform services such as [SaaS Provisioning service](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/ed08c7dcb35d4082936c045e7d7b3ecd.html).
For these requests, CAP Java internally generates CAP events on the technical service [`DeploymentService`](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/DeploymentService.html).

[For a general introduction to CAP events, see Event Handlers.](../java/event-handlers/){.learn-more}

Register event handlers for the following CAP events to add custom logic for requests sent by the platform service.
Each event passes a special type of `EventContext` object to the event handler method and provides event-specific information:

| Event Name       | Event Context                                                                  | Use Case        |
| -----------------| -------------------------------------------------------------------------------| --------------- |
| `SUBSCRIBE`      | [SubscribeEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/SubscribeEventContext.html)         | Add a tenant    |
| `UNSUBSCRIBE`    | [UnsubscribeEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/UnsubscribeEventContext.html)     | Remove a tenant |
| `DEPENDENCIES`   | [DependenciesEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/DependenciesEventContext.html)   | Dependencies    |

You only need to register event handlers to override the default behavior.

Default behaviors:

- A new tenant-specific database container is created through the [Service Manager](https://help.sap.com/docs/SERVICEMANAGEMENT/09cc82baadc542a688176dce601398de/3a27b85a47fc4dff99184dd5bf181e14.html) during subscription.
- The tenant-specific database container _is deleted_ during unsubscription.

The following sections describe how to register to these events in more detail.

### Subscribe Tenant

Subscription events are generated when a new tenant is added.
By default, subscription creates a new database container for a newly subscribed tenant. This happens during the `@On` phase of the `SUBSCRIBE` event.
You can add additional `@On` handlers to perform additional subscription steps. Note that these `@On` handlers should not call `setCompleted()`, as the event processing is auto-completed.

The following examples show how to register custom handlers for the `SUBSCRIBE` event:

```java
@Before
public void beforeSubscription(SubscribeEventContext context) {
    // Activities before tenant database container is created
}

@After
public void afterSubscribe(SubscribeEventContext context) {
    // For example, send notification, ...
}
```

#### Defining a Database ID

When you've registered exactly one SAP HANA instance in your SAP BTP space, a new tenant-specific database container is created automatically.
However, if you've registered more than one SAP HANA instance in your SAP BTP space, you have to pass the target database ID for the new database container in a customer handler, as illustrated in the following example:

```java
@Before
public void beforeSubscription(SubscribeEventContext context) {
    context.getOptions().put("provisioningParameters",
        Collections.singletonMap("database_id", "<database ID>"));
}
```

### Unsubscribe Tenant

By default, the tenant-specific database container _is deleted_ during offboarding. This happens during the `@On` phase of the `UNSUBSCRIBE` event.
You can add additional `@On` handlers to perform additional unsubscription steps. Note that these `@On` handlers should not call `setCompleted()`, as the event processing is auto-completed.

The following example shows how to add custom logic for the `UNSUBSCRIBE` event:

```java
@Before
public void beforeUnsubscribe(UnsubscribeEventContext context) {
    // Activities before offboarding
}

@After
public void afterUnsubscribe(UnsubscribeEventContext context) {
    // Notify offboarding finished
}
```

::: warning
If you are accessing the tenant database container during unsubscription, you need to wrap the access into a dedicated ChangeSetContext or transaction. This ensures that the transaction to the tenant database container is committed, before the container is deleted.
:::

#### Skipping Deletion of Tenant Data

By default, tenant-specific resources (for example, database containers) are deleted during removal. However, you can register a customer handler to change this behavior.
This is required, for example, in case a tenant is subscribed to your application multiple times and only the last unsubscription should remove its resources.

```java
@Before
public void beforeUnsubscribe(UnsubscribeEventContext context) {
    if (keepResources(context.getTenant())) {
      context.setCompleted(); // avoid @On handler phase
    }
}
```

### Define Dependent Services

The event `DEPENDENCIES` fires when the platform service calls the [`getDependencies` callback](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/ff540477f5404e3da2a8ce23dcee602a.html).
Hence, if your application consumes any reuse services provided by SAP, you must implement the `DEPENDENCIES` event to return the service dependencies of the application.
The event must return a list of all of the dependent services' `xsappname` values.

CAP automatically adds dependencies of services to the list, for which it provides dedicated integrations.

[Learn more about automatically added SaaS dependencies.](/guides/multitenancy/?impl-variant=java#saas-dependencies){.learn-more}

::: tip
The `xsappname` of an SAP reuse service that is bound to your application is part of the service binding. The structure of the service binding, and hence the exact location of the `xsappname` field, may vary between services.
:::

The following example shows this in more detail:

```java
@Component
@Profile("cloud")
@ServiceName(DeploymentService.DEFAULT_NAME)
public class SubscriptionHandler implements EventHandler {
	private static final String SERVICE_NAME = "my-service";

	@Autowired
	private CdsRuntime cdsRuntime;

	@On
	public void onDependencies(DependenciesEventContext context) {
		List<Map<String, Object>> dependencies = new ArrayList<>();
		Optional<ServiceBinding> service = cdsRuntime.getEnvironment().
                getServiceBindings().filter(binding -> binding.getServiceName().
                        get().equals(SERVICE_NAME)).findFirst();
		
		if (service.isPresent()) {
			String xsappname = extractXsappname(service.get().getCredentials());
			dependencies.add(SaasRegistryDependency.create(xsappname));
		}
		context.setResult(dependencies);
	}

	private String extractXsappname(Map<String, Object> credentials) {
		// location of the `xsappname` in the credentials is service specific
	}
}
```

### Database Schema Update { #database-update }

When shipping a new application version with an updated CDS model, the database schema for each subscribed tenant needs an update. The database schema update needs to be triggered explicitly.

When the database schema update is triggered, the following CAP event is sent:

| Event Name       | Event Context                                                              |
| ---------------- | ---------------------------------------------------------------------------|
| `UPGRADE`        | [UpgradeEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/UpgradeEventContext.html)         |

By registering custom handlers for these events, you can add custom logic to influence the deployment and upgrade process of a tenant.
By default, the CAP Java SDK notifies the _MTX Sidecar_ to perform any schema upgrade if necessary.



> It's often desired to update the whole service in a zero downtime manner. This section doesn't deal with the details about updating a service productively, but describes tool support the CAP Java SDK offers to update tenants.

The following sections describe how to trigger the update for tenants, including the database schema upgrade.

#### Deploy Main Method { #deploy-main-method }

The CAP Java SDK offers a `main` method in the class `com.sap.cds.framework.spring.utils.Deploy` that can be called from the command line while the CAP Java application is still stopped. This way, you can run the update for all tenants before you start a new version of the Java application. This prevents new application code to access database artifacts that aren't yet deployed.

In order to register all handlers of the application properly during the execution of a tenant operation `main` method, the component scan package must be configured. To set the component scan, the property `cds.multitenancy.component-scan` must be set to the package name of your application.

The handler registration provides additional information that is used for the tenant upgrade, for example, messaging subscriptions that are created.

::: warning
While the CAP Java backend might be stopped when you call this method, the _MTX Sidecar_ application must be running!
:::

<div id="afterdeploymainmethod" />

This synchronization can also be automated, for example using [Cloud Foundry Tasks](https://docs.cloudfoundry.org/devguide/using-tasks.html) on SAP BTP and [Module Hooks](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/b9245ba90aa14681a416065df8e8c593.html) in your MTA.

The `main` method takes an optional list of tenant IDs as input arguments. If tenant IDs are specified, only these tenants are updated. If no input parameters are specified, all tenants are updated. The method waits until all deployments are finished and then prints the result.

The method returns the following exit codes

| Exit Code | Result                                                                                                |
| --------- | ----------------------------------------------------------------------------------------------------- |
| 0         | All tenants updated successfully.                                                                     |
| 1         | Failed to update at least one tenant. Re-run the procedure to make sure that all tenants are updated. |

To run this method locally, use the following command where `<jar-file>` is the one of your application:

::: code-group

```sh [&gt;= Spring Boot 3.2.0]
java -cp <jar-file> -Dloader.main=com.sap.cds.framework.spring.utils.Deploy org.springframework.boot.loader.launch.PropertiesLauncher [<tenant 1>] ... [<tenant n>]
```

```sh [&lt; Spring Boot 3.2.0]
java -cp <jar-file> -Dloader.main=com.sap.cds.framework.spring.utils.Deploy org.springframework.boot.loader.PropertiesLauncher [<tenant 1>] ... [<tenant n>]
```

:::

For local development you can create a launch configuration in your IDE. For example in case of VS Code it looks like this:

```json
{
   "type": "java",
   "name": "MTX Update tenants",
   "request": "launch",
   "mainClass": "com.sap.cds.framework.spring.utils.Deploy",
   "args": "", // optional: specify the tenants to upgrade, defaults to all
   "projectName": "<your project>",
   "vmArgs": "-Dspring.profiles.active=local-mtxs" // or any other profile required for MTX
}
```

In the SAP BTP, Cloud Foundry environment it can be tricky to construct such a command. The reason is, that the JAR file is extracted by the Java Buildpack and the place of the Java executable isn't easy to determine. Also, the place differs for different Java versions. Therefore, we recommend to adapt the start command that is generated by the buildpack and run the adapted command:

::: code-group

```sh [&gt;= Spring Boot 3.2.0]
sed -i 's/org.springframework.boot.loader.launch.JarLauncher/org.springframework.boot.loader.launch.PropertiesLauncher/g' /home/vcap/staging_info.yml && \
  sed -i 's/-Dsun.net.inetaddr.negative.ttl=0/-Dsun.net.inetaddr.negative.ttl=0 -Dloader.main=com.sap.cds.framework.spring.utils.Deploy/g' /home/vcap/staging_info.yml && \
  jq -r .start_command /home/vcap/staging_info.yml | bash
```

```sh [&lt; Spring Boot 3.2.0]
sed -i 's/org.springframework.boot.loader.JarLauncher/org.springframework.boot.loader.PropertiesLauncher/g' /home/vcap/staging_info.yml && \
  sed -i 's/-Dsun.net.inetaddr.negative.ttl=0/-Dsun.net.inetaddr.negative.ttl=0 -Dloader.main=com.sap.cds.framework.spring.utils.Deploy/g' /home/vcap/staging_info.yml && \
  jq -r .start_command /home/vcap/staging_info.yml | bash
```

```sh [Java 8]
sed -i 's/org.springframework.boot.loader.JarLauncher/-Dloader.main=com.sap.cds.framework.spring.utils.Deploy org.springframework.boot.loader.PropertiesLauncher/g' /home/vcap/staging_info.yml && \
  jq -r .start_command /home/vcap/staging_info.yml | bash
```

:::

To run the command manually or automated, you can for example use [Cloud Foundry Tasks](https://docs.cloudfoundry.org/devguide/using-tasks.html) on SAP BTP and [Module Hooks](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/b9245ba90aa14681a416065df8e8c593.html) in your MTA.
To trigger it as part of a Cloud Foundry Task, login to the Cloud Foundry landscape using the Cloud Foundry command line client and execute:

```sh
cf run-task <application_name> "<command>"
```

`<application_name>` needs to be replaced with the name of a Cloud Foundry application, typically the <i>srv</i> module of your CAP project. You can find the name for example in the section `modules` in your `mta.yaml`. `<command>` represents the adapted start command. The output of the command will be logged to the application logs of the application you have specified in `<application_name>`.

## Development Aspects

### Working with Tenants

You can override the tenant ID that is set in the current `RequestContext`. This enables accessing data of arbitrary tenants programmatically. This might be useful for example:

- To access configuration data stored by means of the [provider tenant](#switching-provider-tenant) while processing the request of a business tenant.
- To access [subscriber tenant](#switching-subscriber-tenant) data in asynchronously scheduled jobs, where no tenant information is present in the `RequestContext`.

#### Switching to Provider Tenant { #switching-provider-tenant }

`RequestContextRunner` API provides convenient methods to switch to the underlying provider tenant:

```java
runtime.requestContext().systemUserProvider().run(context -> {
   // call technical service
   ...
});
```

[Learn more about how to switch to a technical tenant.](../java/event-handlers/request-contexts#switching-to-provider-tenant){.learn-more}

#### Switching to Subscriber Tenants { #switching-subscriber-tenant }

You can set a particular tenant and access it by running your code in a nested `RequestContext` as explained [here](../java/event-handlers/request-contexts#switching-to-a-specific-technical-tenant) and demonstrated by the following example:

```java
runtime.requestContext().systemUser(tenant).run(context -> {
   // call technical service
   ...
});
```

Note that switching the tenant in the context is a quite expensive operation as CDS model data might need to be fetched from MTX sidecar in case of tenant extensions.
Hence, avoid setting the context for all subscribed tenants iteratively as this might overload the sidecar and also could flood the local CDS model cache.

::: warning _❗ Warning_
If an application deviates from default behaviour and switches the tenant context internally, it needs to ensure data privacy and proper isolation!
:::

#### Enumerating Subscriber Tenants

Dealing with multiple business tenants is usually on behalf of the provider tenant.

You can use the [`TenantProviderService`](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/TenantProviderService.html) to get a list of available tenants:

```java
@Autowired
TenantProviderService tenantProvider;
...
List<TenantInfo> tenantInfo = tenantProvider.readTenants();
```

::: warning _❗ Warning_
Retrieving the tenants is an expensive operation. It might be a good idea to cache the results if appropriate.
:::

### DB Connection Pooling

::: tip
Pretty much everything in this section depends on your modeling, the load, and also on the sizing (JVM, HTTP server, DB etc.).
As there's no one-size-fits-all recommendation, the mentioned configuration parameters are a good starting point.
:::

Data source pool configuration is a tradeoff between resources and latency:

#### Pool per tenant - less latency, more resources

The dedicated pools per tenant approach creates a dedicated connection pool for each tenant. In it's default
configuration this strategy uses a static sizing approach: the number of configured connections (defaults to 10) is
opened on startup of the application and kept open. This has the lowest possible latency and the highest resource
consumption. The application will need a static number of connections per subscribed client. In case you need
low latency but a bit less resource consumption you can [configure dynamic pool sizing](#configure-data-pools) for your tenants'
connection pools. Then the application will need at least the minimum number of connections per subscribed clients. Depending
on the concurrent load the number can increase per client until the configured maximum number of connections is reached.

#### Pool per database - less resources, more latency { #combine-data-pools}

The combined pool approach uses only one pool for all tenants holding a fixed number of connections. This approach, however, needs to switch
connections to the correct schema and user of the tenant, before handing out the connection. This causes some additional latency compared to
the pools per tenant, where a connection, once opened for a given schema and user, can be reused until it's retired. For the combined pool
you can, as for the dedicated pools, decide between static sizing (the default) and [dynamic sizing](#configure-data-pools). For the latter the
resource consumption can be even more reduced while adding a bit more latency because new database connections might be opened
upon incoming requests.

In order to activate the combined pool approach set the property `cds.multiTenancy.datasource.combinePools.enabled = true`.

::: warning _❗ Warning_
Since the pool is shared among all tenants, one tenant could eat up all available connections, either intentionally or by accident. Applications using combined pools need to take adequate measures to mitigate this risk, for example by introducing rate-limiting.
:::

#### Dynamic Data Source Pooling { #configure-data-pools}

If not configured differently both, the dedicated pool and the combined pool approaches use static sizing strategies by default.

The connections are kept open regardless of whether the application is currently serving requests for the given tenant. If you expect a low
number of tenants, this shouldn't be an issue. With a large number of active tenants, this might lead to resource problems, for example, too
many database connections or out-of-memory situations.

Once you have an increased number of tenants, or run short of connections on the database side, you need to adjust the
[configuration of the CDS datasource](./cqn-services/persistence-services#datasource-configuration) for HikariCP as described in the following section. We're using three parameters for the configuration:

- `cds.dataSource.<service-instance>.hikari.minimum-idle`
- `cds.dataSource.<service-instance>.hikari.maximum-pool-size`
- `cds.dataSource.<service-instance>.hikari.idle-timeout`

Keep in mind that `<service-instance>` is the placeholder for the service manager instance bound to your CAP Java application.

|Parameter           |Description  |
|--------------------|-------------|
|`minimum-idle`      | The minimum number of connections kept in the pool after being considered as idle. This helps to adjust the usage of resources to the actual load of a given tenant at runtime. In order to save resources (Java heap and DB connections), this value should be kept rather small (for example `1`). |
|`maximum-pool-size` | The maximum number of connections in the pool. Here, the value needs to be balanced. Counter-intuitively a bigger value doesn't necessarily lead to higher response/time or throughput. Closely monitor your application under load in order to find a good value. As a starting point you can just leave the default value `10`. |
|`idle-timeout`      | The time span after which a connection is considered as _idle_. It controls how fast the size of the pool is adjusted to the load of the application, until `minimum-idle` is reached. Keep in mind that opening a connection comes at a latency cost, too. Don't retire connections too soon.  |

See section [Multitenancy Configuration Properties](#mtx-properties) for more details.

### Logging Support { #app-log-support}

Logging service support gives you the capability to observe properly correlated requests between the different components of your CAP application in Kibana.
This is especially useful for multi-tenant aware applications that use the `MTX sidecar`.
Just enable either [`application-logs`](../java/operating-applications/observability#logging-service) service or [`cloud-logging`](../java/operating-applications/observability#open-telemetry) service for both, the Java service as well as for the `MTX sidecar`, to get correlated log messages from these components.

The logs can be inspected in the corresponding front ends such as `Kibana`, `Cloud Logging Service` or `Dynatrace`.

### Configuration Properties { #mtx-properties }

A number of multitenancy settings can be configured through application configuration properties.
See section [Application Configuration](./developing-applications/configuring#profiles-and-properties) for more details.
All properties can be found in the [properties overview](./developing-applications/properties#cds-multiTenancy).
The prefix for multitenancy-related settings is `cds.multitenancy`.

<span id="aftermtxpropertis" />



# Multitenancy (Classic) { #multitenancy-classic}

CAP applications can be run as software as a service (SaaS). That means, multiple customers (subscriber tenants) can use the application at the same time in an isolated manner. This section explains how to configure multitenancy for the CAP Java.

::: warning
The multitenancy services (`@sap/cds-mtx`) described in this chapter are in maintenance mode and only supported until CAP Java 2.x.
If you start a new multitenancy project, it's highly recommended to make use of [Multitenancy](multitenancy) based on CAP Java 3.x and streamlined MTX (`@sap/cds-mtxs`).
:::

## Overview

For a general overview on this topic, see the [Multitenancy guide](../guides/multitenancy/?impl-variant=java).

In CAP Java, the Node.js based [*cds-mtx* module](../guides/multitenancy/?impl-variant=java) is reused to handle tenant provisioning. This reuse has the following implications:

- Java applications need to run and maintain the *cds-mtx* module as a sidecar application (called *MTX sidecar* in this documentation). The following sections describe the setup as a [Multitarget Application](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/d04fc0e2ad894545aebfd7126384307c.html) using a [Multitarget Application Development Descriptor](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/c2d31e70a86440a19e47ead0cb349fdb.html) (*mta.yaml*) file. It can be packaged by means of the [MTA Build Tool](https://sap.github.io/cloud-mta-build-tool) and deployed to the SAP BTP by means of the Deploy Service.
- Multitenant CAP Java applications automatically expose the tenant provisioning API called by the SaaS Provisioning service so that [custom logic during tenant provisioning](#custom-logic) can be written in Java.

The following figure describes the basic setup:

![This is a technical architecture modeling diagram, which shows all involved components and how they interact. The involved components are: SaaS Provisioning Service, CAP Java backend, MTX sidecar, SAP BTP Service Manager, and a database.](./assets/architecture-mt.drawio.svg)



## Maven Dependencies

Multitenancy support is available as a so called optional [application feature](developing-applications/building#starter-bundles#application-features) of the CAP Java SDK. It's already included when you use the `cds-starter-cloudfoundry` dependency. Otherwise, you can add the following Maven dependency to apply the feature:

```xml
<dependency>
    <groupId>com.sap.cds</groupId>
    <artifactId>cds-feature-mt</artifactId>
</dependency>
```

::: tip
When you add this dependency to your project, it becomes active when certain conditions are fulfilled, for example, [when your application is deployed to SAP BTP](#required-services-mt). This condition check lets you test your application locally without multitenancy turned on.
:::

## Tenant Subscription Events { #custom-logic }

The [SaaS Provisioning service](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/ed08c7dcb35d4082936c045e7d7b3ecd.html) (`saas-registry`) in SAP BTP sends [specific requests](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/ff540477f5404e3da2a8ce23dcee602a.html) to applications when tenants are subscribed or unsubscribed. For these requests, the CAP Java SDK internally generates CAP events on the technical service [`MtSubscriptionService`](https://www.javadoc.io/doc/com.sap.cds/cds-feature-mt/latest/com/sap/cds/services/mt/MtSubscriptionService.html).

[For a general introduction to CAP events, see Service Provisioning API.](event-handlers/){.learn-more}

Register event handlers for the following CAP events to add custom logic for requests sent by the SaaS Provisioning service. Each event passes a special type of `EventContext` object to the event handler method and provides event-specific information:

| Event Name               | Event Context                                                                         | Use Case        |
| ------------------------ | ------------------------------------------------------------------------------------- | --------------- |
| `EVENT_SUBSCRIBE`        | [MtSubscribeEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-feature-mt/latest/com/sap/cds/services/mt/MtSubscribeEventContext.html)             | Add a tenant    |
| `EVENT_UNSUBSCRIBE`      | [MtUnsubscribeEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-feature-mt/latest/com/sap/cds/services/mt/MtUnsubscribeEventContext.html)         | Remove a tenant |
| `EVENT_GET_DEPENDENCIES` | [MtGetDependenciesEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-feature-mt/latest/com/sap/cds/services/mt/MtGetDependenciesEventContext.html) | Dependencies    |

<div id="incustomlogic" />
<Fragment target="#incustomlogic">

In addition, the SaaS Provisioning Service supports asynchronous subscription <Internal />

| Event Name                         | Event Context                                                                                           | Use Case        |
| ---------------------------------- | ------------------------------------------------------------------------------------------------------- | --------------- |
| `EVENT_ASYNC_SUBSCRIBE`            | [MtAsyncSubscribeEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-feature-mt/latest/com/sap/cds/services/mt/MtAsyncSubscribeEventContext.html)                     | Add a tenant    |
| `EVENT_ASYNC_SUBSCRIBE_FINISHED`   | [MtAsyncSubscribeFinishedEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-feature-mt/latest/com/sap/cds/services/mt/MtAsyncSubscribeFinishedEventContext.html)     | Add a tenant    |
| `EVENT_ASYNC_UNSUBSCRIBE`          | [MtAsyncUnsubscribeEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-feature-mt/latest/com/sap/cds/services/mt/MtAsyncUnsubscribeEventContext.html)                 | Remove a tenant |
| `EVENT_ASYNC_UNSUBSCRIBE_FINISHED` | [MtAsyncUnsubscribeFinishedEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-feature-mt/latest/com/sap/cds/services/mt/MtAsyncUnsubscribeFinishedEventContext.html) | Remove a tenant |
</Fragment>

You only need to register event handlers to override the default behavior.

Default behaviors:

- A new tenant-specific database container is created through the [Service Manager](https://help.sap.com/docs/SERVICEMANAGEMENT/09cc82baadc542a688176dce601398de/3a27b85a47fc4dff99184dd5bf181e14.html) during subscription.
- A tenant-specific database container *isn't* deleted during unsubscription.

The following sections describe how to register to these events in more detail.

## Subscribe Tenant

Subscription events are generated when a new tenant is added.
By default, subscription creates a new database container for a newly subscribed tenant.

### Synchronous Tenant Subscription

By default an `EVENT_SUBSCRIBE` event is sent when a tenant is added.

The following example shows how to register to this event:

```java
package com.sap.cds.demo.spring.handler;

import org.springframework.stereotype.Component;

import com.sap.cds.services.handler.EventHandler;
import com.sap.cds.services.handler.annotations.Before;
import com.sap.cds.services.handler.annotations.ServiceName;
import com.sap.cds.services.mt.MtSubscriptionService;
import com.sap.cds.services.mt.MtUnsubscribeEventContext;

@Component
@ServiceName(MtSubscriptionService.DEFAULT_NAME)
public class SubscriptionHandler implements EventHandler {

  @Before(event = MtSubscriptionService.EVENT_SUBSCRIBE)
  public void beforeSubscription(MtSubscribeEventContext context) {
      // Activities before tenant database container is created
  }

}
```


To send notifications when a subscription was successful, you could register an `@After` handler:

```java
@After(event = MtSubscriptionService.EVENT_SUBSCRIBE)
public void afterSubscription(MtSubscribeEventContext context) {
    // For example, send notification, …
}
```

<span id="beforereturningdbid" />
<Fragment target="#beforereturningdbid">

### Asynchronous Tenant Subscription <Internal />

If you have configured asynchronous subscription in your [`saas-registry` service instance](#saas-registry), `EVENT_ASYNC_SUBSCRIBE` and `EVENT_ASYNC_SUBSCRIBE_FINISHED` events are sent when a tenant subscribes. See section [SaaS Provisioning Service documentation](https://int.controlcenter.ondemand.com/index.html#/knowledge_center/articles/f239e5501a534b64ab5f8dde9bd83c53) for more details.

Make sure to configure the URL of your CAP Java backend by means of the application configuration property `cds.multitenancy.callbackUrl` in this case. This could be configured in the _mta.yaml_ file as illustrated by the following example:

```yaml
modules:
  […]
  - name: srv
    […]
    properties:
      CDS_MULTITENANCY_CALLBACKURL: '${default-url}'
```

The onboarding events are fired in the following order:

1. The event `EVENT_ASYNC_SUBSCRIBE` is emitted when the SaaS Provisioning Service calls the CAP application. The default implementation of this event calls MTX Sidecar asynchronously to deploy the database artifacts. When this event finishes, the database schema isn't yet fully deployed!

2. When the database deployment is finished, the MTX Sidecar calls the CAP application and the event `EVENT_ASYNC_SUBSCRIBE_FINISHED` is emitted. The default implementation of this event calls the SaaS Provisioning Service to report that the onboarding is finished.

The following examples show how to register to these events:

```java
@Before(event = MtSubscriptionService.EVENT_ASYNC_SUBSCRIBE)
public void beforeSubscription(MtAsyncSubscribeEventContext context) {
    // Activities before tenant database container is created
}
```

To send notifications when a subscription request is finished, you can register an `@After` handler:

```java
@After(event = MtSubscriptionService.EVENT_ASYNC_SUBSCRIBE_FINISHED)
public void afterSubscribe(MtAsyncSubscribeFinishedEventContext context) {
    // For example, send notification, …
}
```


</Fragment>

### Returning a Database ID

When you've registered exactly one SAP HANA instance in your SAP BTP space, a new tenant-specific database container is created automatically. However, if you've registered more than one SAP HANA instance in your SAP BTP space, you have to pass the target database ID for the new database container in a customer handler, as illustrated in the following example:

```java
@Before(event = MtSubscriptionService.EVENT_SUBSCRIBE)
public void beforeSubscription(MtSubscribeEventContext context) {
    context.setInstanceCreationOptions(
      new InstanceCreationOptions().withProvisioningParameters(
        Collections.singletonMap("database_id", "<database ID>")));
}
```

### Returning a Custom Application URL

The following example shows how to return a custom application URL that is shown in SAP BTP Cockpit:

```java
@After(event = MtSubscriptionService.EVENT_SUBSCRIBE)
public void afterSubscribe(MtSubscribeEventContext context) {
    if (context.getResult() == null) {
        context.setResult(
          "https://" +
          context.getSubscriptionPayload().subscribedSubdomain +
          ".myapp.com");
    }
}
```

By default, the application URL is constructed by configuration as described in [Wiring It Up](#binding-it-together).

### Returning Dependencies

The event `EVENT_GET_DEPENDENCIES` fires when the SaaS Provisioning calls the [`getDependencies` callback](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/ff540477f5404e3da2a8ce23dcee602a.html). Hence, if your application consumes any reuse services provided by SAP, you must implement the `EVENT_GET_DEPENDENCIES` to return the service dependencies of the application. The callback must return a `200` response code and a JSON file with the dependent services' `appName` and `appId`, or just the `xsappname`.

::: tip
The `xsappname` of an SAP reuse service that is bound to your application can be found as part of the `VCAP_SERVICES` JSON structure under the path `VCAP_SERVICES.<service>.credentials.xsappname`.
:::

The following example shows this in more detail:

```java
import com.sap.cloud.mt.subscription.json.ApplicationDependency;

@Value("${vcap.services.<my-service-instance>.credentials.xsappname}")
private String xsappname;

@On(event = MtSubscriptionService.EVENT_GET_DEPENDENCIES)
public void onGetDependencies(MtGetDependenciesEventContext context) {
    ApplicationDependency dependency = new ApplicationDependency();
    dependency.xsappname = xsappname;
    List<ApplicationDependency> dependencies = new ArrayList<>();
    dependencies.add(dependency);
    context.setResult(dependencies);
}
```

## Unsubscribe Tenant

Unsubscription events are generated, when a tenant is offboarded. By default, the tenant-specific database container is *not* deleted during offboarding. You can change this behavior by registering a custom event handler as illustrated in the following examples.

### Synchronous Tenant Unsubscription

By default an `EVENT_UNSUBSCRIBE` is sent when a tenant is removed. The following example shows how to add custom logic for this event:

```java
@Before(event = MtSubscriptionService.EVENT_UNSUBSCRIBE)
public void beforeUnsubscribe(MtUnsubscribeEventContext context) {
    // Activities before offboarding
}
```

You can also register an `@After` handler, for example to notify when removal is finished:

```java
@After(event = MtSubscriptionService.EVENT_UNSUBSCRIBE)
public void afterUnsubscribe(MtUnsubscribeEventContext context) {
    // Notify offboarding finished
}
```

<span id="beforedeletingcontainer" />
<Fragment target="#beforedeletingcontainer">

### Asynchronous Tenant Unsubscription <Internal />

If you have configured asynchronous unsubscription in your [`saas registry` service instance](#saas-registry), `EVENT_ASYNC_UNSUBSCRIBE` and `EVENT_UNSUBSCRIBE_FINISHED` events are sent. The following example shows how to add custom logic for these events:

```java
@Before(event = MtSubscriptionService.EVENT_ASYNC_UNSUBSCRIBE)
public void beforeUnsubscribe(MtAsyncUnsubscribeEventContext context) {
    // Activities before offboarding
}
```

You can also register an `@After` handler, for example to notify if removal was finished:

```java
@After(event = MtSubscriptionService.EVENT_ASYNC_UNSUBSCRIBE_FINISHED)
public void beforeUnsubscribe(MtAsyncUnsubscribeFinishedEventContext context) {
    // Notify offboarding finished
}
```


</Fragment>

### Deleting Tenant Containers During Tenant Unsubscription

By default, tenant-specific database containers aren't deleted during removal. However, you can register a customer handler change this behavior. For example:

```java
@Before(event = MtSubscriptionService.EVENT_UNSUBSCRIBE)
public void beforeUnsubscribe(MtUnsubscribeEventContext context) {
    // Trigger deletion of database container of offboarded tenant
    context.setDelete(true);
}
```

## Configuring the Required Services { #required-services-mt}

To enable multitenancy on SAP BTP, three services are involved:

- XSUAA
- Service Manager
- SaaS Provisioning service (`saas-registry`)

Only when these services are bound to your application, the multitenancy feature is turned on. You can either create and configure these services manually. See section [Developing Multitenant Applications in SAP BTP, Cloud Foundry Environment](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/5e8a2b74e4f2442b8257c850ed912f48.html) for more details. The following sections describe how to configure and bind these services by means of an *mta.yaml* file.

### XSUAA { #xsuaa-mt-configuration }

A special configuration of an XSUAA service instance is required to enable authorization between the SaaS Provisioning service, CAP Java application, and MTX sidecar.

The service can be configured in the *mta.yaml* by adding an `xsuaa` resource as follows:

```yaml
resources:
  […]
  - name: xsuaa
    type: com.sap.xs.uaa
    parameters:
      service-plan: application
      path: ./xs-security.json
      config:
        xsappname: <appname>
```

Choose a value for property `xsappname` that is unique globally.

Also, you have to create an [Application Security Descriptor (*xs-security.json*)](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/517895a9612241259d6941dbf9ad81cb.html) file, which must include two scopes:

- `mtcallback`
- `mtdeployment`

> You can also use custom scope names by configuring them. Use the following application configuration properties:
>
> - mtcallback: `cds.multitenancy.security.subscription-scope`
> - mtdeployment: `cds.multitenancy.security.deployment-scope`

The `mtcallback` scope is required by the onboarding process. The `mtdeployment` scope is required to redeploy database artifacts at runtime.

An example *xs-security.json* file looks like this:

```json
{
    "xsappname": "<appname>",
    "tenant-mode": "shared",
    "scopes": [
        {
            "name": "$XSAPPNAME.mtcallback",
            "description": "Multi Tenancy Callback Access",
            "grant-as-authority-to-apps": [
                "$XSAPPNAME(application, sap-provisioning, tenant-onboarding)"
            ]
        },
        {
            "name": "$XSAPPNAME.mtdeployment",
            "description": "Scope to trigger a re-deployment of the database artifacts"
        }
    ],
    "authorities": [
        "$XSAPPNAME.mtdeployment"
    ]
}
```

In this example, the `grant-as-authority-to-apps` section is used to grant the `mtcallback` scope to the applications *sap-provisioning* and *tenant-onboarding*. These are services provided by SAP BTP involved in the onboarding process.

It isn't necessary to have the security configuration in a separate file. It can also be added to the *mta.yaml* file directly.

::: warning *❗ Warning*
The `mtcallback` and `mtdeployment` scopes **must not be exposed** to any business user, for example, using a role template. Else a malicious user could update or even delete the artifacts of arbitrary tenants. In addition, if you implement a service broker in order to expose your service API for (technical) users of SaaS tenants, you must ensure that both scopes **cannot be consumed as authorities** in cloned service instances created by clients. To achieve that, set  `authorities-inheritance: false`. It is **strongly recommended** to explicitly enumerate all authorities that should be exposed in the the broker configuration (allow-list).
:::

### Service Manager

A service instance of the [Service Manager](https://help.sap.com/docs/SERVICEMANAGEMENT/09cc82baadc542a688176dce601398de/3a27b85a47fc4dff99184dd5bf181e14.html) (`service-manager`) is required that the CAP Java SDK can create database containers per tenant at application runtime. It doesn't require special parameters and can be added as a resource in *mta.yaml* as follows:

```yaml
resources:
  […]
  - name: service-manager
    type: org.cloudfoundry.managed-service
    parameters:
      service: service-manager
      service-plan: container
```

### SaaS Provisioning Service (saas-registry) { #saas-registry }

A `saas-registry` service instance is required to make your application known to the SAP BTP Provisioning Service and to register the endpoints that should be called when tenants are added or removed. The service can be configured as a resource in *mta.yaml* as follows. See section [Register the Multitenant Application to the SaaS Provisioning Service](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/3971151ba22e4faa9b245943feecea54.html) for more details.

```yaml
resources:
  […]
  - name: saas-registry
    type: org.cloudfoundry.managed-service
    parameters:
      service: saas-registry
      service-plan: application
      config:
        appName: <app display name>
        xsappname: <appname>
        appUrls:
          getDependencies: ~{srv/url}/mt/v1.0/subscriptions/dependencies
          onSubscription: ~{srv/url}/mt/v1.0/subscriptions/tenants/{tenantId}
    requires:
      - name: srv
```

It's required to configure the parameters:

- `appName`: Choose an appropriate application display name.
- `xsappname`: Use the value for `xsappname` you configured at your [UAA service instance](#xsuaa-mt-configuration).
- `appUrls`: Configure the callback URLs used by the SaaS Provisioning service to get the dependencies of the application and to trigger a subscription. In the above example, the property `~{srv/url}` that is provided by the `srv` module is used. See section [Wiring It Up](#binding-it-together) for more details. If you use different module and property names for your CAP Java backend module, you have to adapt these properties here accordingly.

## Adding the MTX Sidecar Application { #mtx-sidecar-server }

This section describes how to use the `cds-mtx` Node.js module and add the MTX sidecar microservice to the *mta.yaml* file.

In a dedicated project subfolder named *mtx-sidecar*, create a Node.js start script in a file named *server.js* to bootstrap the `cds-mtx` library:

```js
const app = require('express')();
const cds = require('@sap/cds');

const main = async () => {
 await cds.connect.to('db');
 const PORT = process.env.PORT || 4004;
 await cds.mtx.in(app);
 app.listen(PORT);
}

main();
```

::: tip
By default, this script implements authorization and checks for the scope `mtcallback`. If you use a custom scope name for requests issued by the SaaS Provisioning Service in your application security descriptor (*xs-security.json*), you have to configure the custom scope name at the MTX sidecar as well. Use the environment variable `CDS_MULTITENANCY_SECURITY_SUBSCRIPTIONSCOPE`, for example, by specifying it in the *mta.yaml* file.
:::

To define the dependencies and start command, also create a file *package.json* like this:

```json
{
    "name": "deploy",
    "engines": {
        "node": ">=12"
    },
    "scripts": {
        "start": "node server.js"
    }
}
```

Next, add the required dependencies:

```sh
npm add @sap/cds @sap/cds-mtx @sap/xssec hdb express
```

Because the MTX sidecar will build the CDS model, you need to configure the build by means of two *.cdsrc.json* files.

The first *.cdsrc.json* file goes into the root folder of your project and specifies from which location the CDS files should be collected. The following example demonstrates this:

```json
{
    "build": {
        "target": ".",
        "tasks": [
            {
                "for": "java-cf"
            },
            {
                "for": "mtx",
                "src": ".",
                "dest": "mtx-sidecar"
            },
            {
                "for": "hana"
            }
        ]
    },
    "requires": {
        "db": {
            "kind": "hana-mt"
        }
    },
    "odata": {
        "version": "v4"
    }
}
```

::: tip
You only need to change this configuration if you named your project folders, `app`, `db`, `srv`, and `mtx-sidecar` differently.
:::

A detailed description of this configuration file can be found in section [Build Configuration](../guides/deployment/custom-builds#build-config). In the following, you find a short summary of this example:

The `build` section defines the build `tasks` that should be executed. Three build tasks are defined in this example:

| Task      | Description                                                                     |
| --------- | ------------------------------------------------------------------------------- |
| `java-cf` | Generates *csn.json* and EDMX files                                             |
| `mtx`     | Collects *.cds* files to copy to *mtx-sidecar* directory, generates *i18n.json* |
| `hana`    | Generates SAP HANA artifacts                                                    |

In the previous example, the `options` section specifies the source directories for each build task. 

::: tip
The `hana` build task is optional because the SAP HANA artifacts are also generated by the *mtx-sidecar* directly. However, the generated SAP HANA artifacts enable you to test your application in a single tenant scenario.
:::

The second *.cdsrc.json* file goes into the *mtx-sidecar* directory. The following example demonstrates this:

```json
{
    "hana": {
        "deploy-format": "hdbtable"
    },
    "build": {
        "tasks": [
            {
                "for": "hana"
            },
            {
                "for": "java-cf"
            }
        ]
    },
    "odata": {
        "version": "v4"
    },
    "requires": {
        "db": {
            "kind": "hana-mt",
        },
        "auth": {
            "kind": "xsuaa"
        },
        "multitenancy": true
    }
}
```

::: tip
You only need to change this configuration if you named your project folders, `app`, `db`, `srv`, and `mtx-sidecar` differently.
:::

::: warning
If you have configured a location for your i18n files as described in the [Localization Section](../guides/i18n#where-to-place-text-bundles), please make sure to add the same CDS configuration in both, the *.cdsrc.json* of the SaaS application and in the *.cdsrc.json* of the `mtx-sidecar`.
:::

In this file, the `requires` section configures the service instances that should be used by the *mtx-sidecar*. In this case, it's an instance of the UAA Service, to enable authentication and authorization, as well as the Service Manager, that enables multitenancy.

Now, add the `mtx-sidecar` module to your *mta.yaml* file:

```yaml
modules:
  […]
  - name: mtx-sidecar
    type: nodejs
    path: mtx-sidecar
    parameters:
      memory: 256M
      disk-quota: 512M
    requires:
      - name: xsuaa
      - name: service-manager
    provides:
      - name: mtx-sidecar
        properties:
          url: ${default-url}
```

The `mtx-sidecar` module requires the XSUAA and Service Manager services. Also you need to provide its URL to be able to configure the URL in the service module as shown in the previous *mta.yaml*. The authentication works through token validation.

<span id="beforebindingittogehter" />
<Fragment target="#beforebindingittogehter">

### Customize HTTP Requests to MTX Sidecar <Internal />

You can customize how the CAP Java SDK authenticates at the MTX Sidecar. By default, it uses OAuth client credential authentication in combination with an XSUAA service instance. To change this behavior, use SAP Cloud SDK's `DefaultHttpDestination` class to define a custom [destination](https://sap.github.io/cloud-sdk/docs/java/features/connectivity/sdk-connectivity-destination-service) with the name `com.sap.cds.mtxSidecar` as illustrated in the following. In turn, this destination is used by the CAP JAva SDK to call the MTX Sidecar.

[Learn more about destinations in the **SAP Cloud SDK documentation**.](https://sap.github.io/cloud-sdk/docs/java/features/connectivity/sdk-connectivity-destination-service){.learn-more}

The following example uses a custom destination with a security configuration strategy `FROM_PLATFORM` to configure mutual TLS authentication. This way, it enables running the MTX Sidecar within the [*Deploy with Confidence* (*DwC*) environment](https://pages.github.tools.sap/deploy-with-confidence/solar-system/documentation/):

Add the following dependency to your *pom.xml*:

```xml
<dependency>
  <groupId>com.sap.cloud.sdk.cloudplatform</groupId>
  <artifactId>dwc-cf</artifactId>
</dependency>
```

Add a custom destination at application startup:

```java
import com.sap.cloud.sdk.cloudplatform.connectivity.DefaultDestinationLoader;
import com.sap.dwc.util.headers.DwcHeaderConstants;

@Component
@ServiceName(ApplicationLifecycleService.DEFAULT_NAME)
public class DestinationConfiguration implements EventHandler {

  @Before(event = ApplicationLifecycleService.EVENT_APPLICATION_PREPARED)
  public void initializeDestinations() {
    String url = Properties.getCds().getMultiTenancy().getSidecar().getUrl();
    DefaultHttpDestination httpDestination =
        DefaultHttpDestination.builder(url)
            .name("com.sap.cds.mtxSidecar")
            .securityConfiguration(SecurityConfigurationStrategy.FROM_PLATFORM)
            .headerProviders(new DwcHeaderProvider())
            .build();
    DestinationAccessor.prependDestinationLoader(
        new DefaultDestinationLoader().registerDestination(httpDestination));
  }
}
```

In addition, to enable authorization at the MTX sidecar and set information about the current tenant, configure a `DestinationHeaderProvider` to specify which HTTP headers are forwarded by the CAP Java SDK to the MTX sidecar. You need to distinguish two cases:

- The request to the MTX Sidecar is triggered by an inbound request (for example, SaaS tenant onboarding)
- The request to the MTX Sidecar is triggered by a background job (for example, internal cache refreshes)

In this example, the tenant and subdomain headers are preserved for inbound requests and the tenant header is set for requests triggered by background jobs when calling the MTX Sidecar:

```java
import com.sap.cloud.sdk.cloudplatform.servlet.RequestAccessor;

private static class DwcHeaderProvider implements DestinationHeaderProvider {

  @Override
  public List<Header> getHeaders(DestinationRequestContext outboundRequestContext) {
    final Try<HttpServletRequest> inboundRequest = RequestAccessor.tryGetCurrentRequest();
    final List<Header> dwcHeaders = new ArrayList<>();
    if (inboundRequest.isSuccess()) {
      // Triggered by an inbound request (for example, SaaS tenant onboarding)
      final Enumeration<String> headerNames = inboundRequest.get().getHeaderNames();

      while (headerNames.hasMoreElements()) {
        final String name = headerNames.nextElement();
        if (DwcHeaderConstants.DWC_TENANT.equals(name) || DwcHeaderConstants.DWC_SUBDOMAIN.equals(name)) {
          final String value = inboundRequest.get().getHeader(name);
          final Header header = new Header(name, value);
          dwcHeaders.add(header);
        }
      }
    } else {
      // Triggered by a background job
      String[] urlSplit = outboundRequestContext.getRequestUri().toString().split("/");
      final Header header = new Header(DwcHeaderConstants.DWC_TENANT, urlSplit[urlSplit.length - 1]);
      dwcHeaders.add(header);
      // <-- Add additional authorization headers or security scopes respectively here
    }

    return dwcHeaders;
  }
}
```
::: tip
It is in the responsibility of the application to process these forwarded headers in the custom server part of the [MTX Sidecar](../guides/multitenancy/#enable-multitenancy).
:::


</Fragment>

## Wiring It Up { #binding-it-together }

To bind the previously mentioned services and the MTX sidecar to your CAP Java application, you could use the following example of the `srv` module in the *mta.yaml* file:

```yaml
modules:
  […]
  - name: srv
    type: java
    path: srv
    parameters:
      […]
    requires:
      - name: service-manager
      - name: xsuaa
      - name: mtx-sidecar
        properties:
          CDS_MULTITENANCY_SIDECAR_URL: ~{url}
      - name: app
        properties:
          CDS_MULTITENANCY_APPUI_URL: ~{url}
          CDS_MULTITENANCY_APPUI_TENANTSEPARATOR: "."
    provides:
      - name: srv
        properties:
          url: '${default-url}'
```

The environment variable `CDS_MULTITENANCY_SIDECAR_URL` of the `srv` module is internally mapped to property `cds.multitenancy.sidecar.url`. This URL is required by the runtime to connect to the [MTX Sidecar application](#mtx-sidecar-server) and it's derived from property `url` of the mtx-sidecar [module](#mtx-sidecar-server) (Note that `${default-url}` is a placeholder for the own URL).
Similarly, `CDS_MULTITENANCY_APPUI_URL` configures the URL that is shown in the SAP BTP Cockpit. Usually it's pointing to the app providing the UI, which is the module `app` in this example.

As value for `CDS_MULTITENANCY_APPUI_TENANTSEPARATOR` only `"."` is supported at the moment. The actual URL shown in the SAP BTP Cockpit is then composed of:

```txt
https://<subaccount subdomain>.<CDS_MULTITENANCY_APPUI_URL>
```

<div id="beforeapplogsupport" />
<Fragment target="#beforeapplogsupport">

::: info <Internal />
You can also define the environment variable `CDS_MULTITENANCY_APPUI_TENANTSEPARATOR` in the extension descriptor. It's either `"."` or `"-"` depending on whether you run the app on a live landscape or on Canary. The extension descriptor file could look like this:

```yaml
_schema-version: "3.1"
extends: my-app
ID: my-app.di

modules:
  - name: srv
    properties:
      CDS_MULTITENANCY_APPUI_TENANTSEPARATOR: "-"
  - name: app
    properties:
      TENANT_HOST_PATTERN: ^(.*)-${default-uri}
```

The URL shown in the SAP BTP Cockpit is then composed of:

```txt
https://<subaccount subdomain><CDS_MULTITENANCY_APPUI_TENANTSEPARATOR><CDS_MULTITENANCY_APPUI_URL>
```
:::
</Fragment>

## Adding Logging Service Support { #app-log-support }

Logging service support gives you the capability to observe properly correlated requests between the different components of your CAP application in Kibana. This is especially useful for `multi-tenant aware applications` that use the `MTX sidecar`.

As described in the section [Observability > Logging](./operating-applications/observability#logging-service), in order to enable the Cloud Foundry `application-logs` service support with CAP Java SDK, it's recommended to use the [cf-java-logging-support](https://github.com/SAP/cf-java-logging-support). Information about configuration options is provided there, as well.

### Adding the Service Bindings

Aside from that, a service binding to the `application-logs` service in the Cloud Foundry environment is required. This can be set up manually with the SAP BTP cockpit for both, the CAP application and the MTX sidecar, or more easily with an `mta` deployment.

The *mta.yaml* file needs a new resource definition for the `application-logs` service which is required by both the `srv` module of the CAP Java application and the `mtx-sidecar` module. Building and deploying from this manifest then creates the necessary `application-logs` service instance if not existing yet and the `service bindings`:

```yaml
modules:
  […]
  - name: srv
    type: java
    path: srv
    parameters:
      […]
    requires:
      […]
      - name: cf-logging
      […]
    provides:
      - name: srv
        properties:
          url: '${default-url}'
  […]
  - name: sidecar
    type: nodejs
    path: mtx-sidecar
    parameters:
      […]
    requires:
      […]
      - name: cf-logging
      […]
    provides:
      - name: sidecar
        properties:
          url: ${default-url}
  […]
resources:
  […]
  - name: cf-logging
    type: org.cloudfoundry.managed-service
    parameters:
      service: application-logs
      service-plan: lite
  […]
```

::: tip
In our example, we use the service-plan `lite` of the `application-logs` service, but you might require one with larger quota limits.
:::

::: tip
Complete examples for *mta.yaml* files can be found in the [CAP Java bookshop samples](https://github.com/SAP-samples/cloud-cap-samples-java/).
:::

### Configuring the MTX Sidecar Application

To properly correlate requests in the `mtx-sidecar`, a `correlate()` function needs to be added to the `Express` app that acts as a middleware that either reads the `correlation id` from the request headers if provided or generates a new one if not.

One way to do so, is to modify the Node.js start script `server.js`, that was introduced in [Adding the MTX Sidecar Application](#mtx-sidecar-server), as follows:

```js
const app = require('express')();
const cds = require('@sap/cds');

const main = async () => {
  app.use(defaults.correlate);

  await cds.connect.to('db');
  const PORT = process.env.PORT || 4004;

  await cds.mtx.in(app);
  app.listen(PORT);
}

const defaults = {
  get correlate() {
    return (req, res, next) => {
      const id = req.headers['x-correlation-id'] || req.headers['x-correlationid']
        || req.headers['x-request-id'] || req.headers['x-vcap-request-id']
        || cds.utils.uuid()
      // new intermediate cds.context, if necessary
      cds.context = { id }
      // guarantee x-correlation-id going forward and set on res
      req.headers['x-correlation-id'] = id
      res.set('x-correlation-id', id)
      // guaranteed access to cds.context._.req -> REVISIT
      if (!cds.context._) cds.context._ = {}
      if (!cds.context._.req) cds.context._.req = req
      next()
    }
  }
}

main();
```

The final piece of configuration required for the MTX sidecar is to enable the Kibana formatter feature.

The following object literal needs be added to the json object within the *package.json* file in the *mtx-sidecar* subfolder of your CAP Java application:

```json
"cds": {
    "features": {
        "kibana_formatter": true
    }
}
```

::: tip
For the Kibana formatter feature it is recommended to use *@sap/cds* in version *5.4.3 or higher*, *@sap/cds-mtx* in version *2.2.0 or higher* and *node* in version *16.2.0 or higher*.
:::

### Correlated Application Logs

With a successful deployment of the CAP application with all the previously mentioned configuration in place, application logs from both, the `srv` and `mtx sidecar` modules, will be properly correlated by their `correlation id`.

This can easily be seen in `Kibana`, which is part of the ELK (*Elasticsearch/Logstash/Kibana*) stack on Cloud Foundry and available by default with the `application-logs` service:

![Kibana screenshot](./assets/kibana.png)

<span id="beforedatabaseupdate" />
<Fragment target="#beforedatabaseupdate">

## HDI Dynamic Deployer (Deprecated) <Internal />

This section describes the _mta.yaml_ and _package.json_ configuration if you use the *HDI Dynamic Deployer* instead of the [MTX Sidecar](../guides/multitenancy/#enable-multitenancy) application to deploy SAP HANA artifacts at runtime. Note that this method is deprecated and you will get plain multitenancy without extensibility in this case.

The *HDI Dynamic Deployer* is implemented in Node.js and comes with a start script, which starts an HTTP server listening for deploy requests. At runtime, the CAP Java SDK calls it when processing subscription events or to update SAP HANA artifacts for tenants.

An example for the _package.json_ is:

```json
{
  "name": "db",
  "dependencies": {
    "@sap/hdi-dynamic-deploy": "1.5.9"
  },
  "scripts": {
    "start": "node node_modules/@sap/hdi-dynamic-deploy/"
  }
}
```

The HDI Dynamic Deployer authenticates requests using basic authentication. Therefore, it's required to configure the credentials that should be used for authentication. In the _mta.yaml_ you can generate them in the `resources` section like this:

```yaml
resources:
  […]
  - name: hdi_credentials
    properties:
      user: ${generated-user}
      password: ${generated-password}
```

Now, you need to pass them to the `db` module. The configuration could look like the following:

```yaml
modules:
  […]
  - name: db
    type: nodejs
    path: db
    parameters:
      memory: 256M
      disk-quota: 256M
    requires:
      - name: hdi_credentials
        properties:
          hdi_dynamic_deploy_user: ~{user}
          hdi_dynamic_deploy_password: ~{password}
    provides:
      - name: db
        properties:
          url: ${default-url}

```

This configuration also exposes the URL of the module so you can reference it in the `srv` module as shown previously. The `srv` module configuration can be extended to pass the credentials:

```yaml
modules:
  […]
  - name: srv
    […]
    requires:
      […]
      - name: db
        properties:
          CDS_MULTITENANCY_DEPLOYER_URL: ~{url}
      - name: hdi_credentials
        properties:
          CDS_MULTITENANCY_DEPLOYER_USER: ~{user}
          CDS_MULTITENANCY_DEPLOYER_PASSWORD: ~{password}
```

### Deprecated Events

When using the dynamic HDI Deployer, the following events are generated:

- `EVENT_DEPLOY`

### Switching from HDI Dynamic Deployer to MTX sidecar

Both, HDI Dynamic Deployer and MTX sidecar, create containers for each tenant that gets the tenant ID as label.
The credentials of a tenant's container can be requested by using the Service Manager client library (Java resp. Node.js).
In contrast to the HDI Dynamic Deployer, the MTX sidecar stores some metadata in an additional container for each tenant and requires a common container for shared access.

When moving projects based on the HDI Dynamic Deployer to MTX sidecar, the existing containers can be reused and the additional containers needed by the MTX sidecar have to be created.

This can be achieved by the following steps:

- Setup the [MTX sidecar based project](#mtx-sidecar-server).
- Bind the existing `service-manager` instance to the MTX sidecar application.
- Deploy / start the MTX sidecar application.
- Call the [Database Schema Update API](#database-update) for all tenants:
```json
{
  "tenants": ["all"]
}
```

As a result, the common container and the metadata containers for all tenants are created and the application is fully functional again.



</Fragment>

## Database Schema Update { #database-update }

When shipping a new application version with an updated CDS model, the database schema for each subscribed tenant needs an update. The database schema update needs to be triggered explicitly, as described in the following sections.

When the database schema update is triggered, the following CAP events are sent. By registering custom handlers for these events, you can add custom logic to influence the deployment process. By default, the CAP Java SDK notifies the *MTX Sidecar* to perform any schema upgrade if necessary.

| Event Name                  | Event Context                                                                             |
| --------------------------- | ----------------------------------------------------------------------------------------- |
| `EVENT_ASYNC_DEPLOY`        | [MtAsyncDeployEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-feature-mt/latest/com/sap/cds/services/mt/MtAsyncDeployEventContext.html)             |
| `EVENT_ASYNC_DEPLOY_STATUS` | [MtAsyncDeployStatusEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-feature-mt/latest/com/sap/cds/services/mt/MtAsyncDeployStatusEventContext.html) |


It's often desired to update the whole service in a zero downtime manner. This section doesn't deal with the details about updating a service productively, but describes tool support the CAP Java SDK offers to update database schemas.

The following sections describe how to trigger the database schema upgrade for tenants.

### Deploy Endpoint { #deploy-endpoint }

When multitenancy is configured, the CAP Java SDK exposes a REST endpoint to update database schemata.

::: warning *❗ Warning*
You must use the scope `mtdeployment` for the following requests!
:::

#### Deployment Request

Send this request when a new version of your application with an updated database schema was deployed. This call triggers updating the persistence of each tenant.

##### Route

```http
POST /mt/v1.0/subscriptions/deploy/async
```

::: tip
This is the default endpoint. One or more endpoints might differ if you configure different endpoints through properties.
:::

##### Body

The `POST` request must contain the following body:

```json
{
  "tenants": [ "all" ]
}
```

Alternatively, you can also update single tenants:

```json
{
  "tenants": ["<tenant-id-1>", "<tenant-id-2>", …]
}
```

##### Response

The deploy endpoint is asynchronous, so it returns immediately with status code `202` and JSON structure containing a `jobID` value:

```json
{
  "jobID": "<jobID>"
}
```

#### Job Status Request

You can use this `jobID` to check the progress of the operation by means of the following REST endpoint:

##### Route

```http
GET /mt/v1.0/subscriptions/deploy/async/status/<jobID> HTTP/1.1
```

##### Response

The server responds with status code `200`. During processing, the response looks like:

```json
{
  "error": null,
  "status": "RUNNING",
  "result": null
}
```

Once a job is finished, the collective status is reported like this:

```json
{
  "error": null,
  "status": "FINISHED",
  "result": {
      "tenants": {
          "<tenantId1>": {
              "status": "SUCCESS",
              "message": "",
              "buildLogs": "<build logs>"
          },
          "<tenantId2>": {
              "status": "FAILURE",
              "message": "<error log output>",
              "buildLogs": "<build logs>"
          }
      }
  }
}
```

::: tip
Logs are persisted for a period of 30 minutes before they get deleted automatically. If you're requesting the job status after the 30-minute period expired, you get a *404 Not Found* response.
:::



### Deploy Main Method

As an alternative to calling the [deploy REST endpoints](#deploy-endpoint), the CAP Java SDK also offers a `main` method in the class `com.sap.cds.framework.spring.utils.Deploy` that can be called from the command line while the CAP Java application is still stopped. This way, you can run the database deployment for all tenants before you start a new version of the Java application. This prevents new application code to access database artifacts that aren't yet deployed.

::: warning
While the CAP Java backend might be stopped when you call this method, the *MTX Sidecar* application must be running!
:::

<div id="afterdeploymainmethod" />
<Fragment target="#afterdeploymainmethod">

::: warning <Internal />
While the CAP Java backend might be stopped when you call this method, either the *MTX Sidecar* or the dynamic HDI deployer application must be running!
:::
</Fragment>

This synchronization can also be automated, for example using [Cloud Foundry Tasks](https://docs.cloudfoundry.org/devguide/using-tasks.html) on SAP BTP and [Module Hooks](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/b9245ba90aa14681a416065df8e8c593.html) in your MTA.

The `main` method takes an optional list of tenant IDs as input arguments. If tenant IDs are specified, only these tenants are updated. If no input parameters are specified, all tenants are updated. The method waits until all deployments are finished and then prints the result.

The method returns the following exit codes

| Exit Code | Result                                                                                           |
| --------- | ------------------------------------------------------------------------------------------------ |
| 0         | All tenants updated successfully.                                                                |
| 1         | Failed to update at least one tenant. Re-run the procedure to make sure that all tenants are updated. |

To run this method locally, use the following command where `<jar-file>` is the one of your application:

::: code-group

```sh [&gt;= Spring Boot 3.2.0]
java -cp <jar-file> -Dloader.main=com.sap.cds.framework.spring.utils.Deploy org.springframework.boot.loader.launch.PropertiesLauncher [<tenant 1>] … [<tenant n>]
```

```sh [&lt; Spring Boot 3.2.0]
java -cp <jar-file> -Dloader.main=com.sap.cds.framework.spring.utils.Deploy org.springframework.boot.loader.PropertiesLauncher [<tenant 1>] … [<tenant n>]
```

:::

In the SAP BTP, Cloud Foundry environment it can be tricky to construct such a command. The reason is, that the JAR file is extracted by the Java Buildpack and the place of the Java executable isn't easy to determine. Also the place differs for different Java versions. Therefore, we recommend to adapt the start command that is generated by the buildpack and run the adapted command:

::: code-group

```sh [&gt;= Spring Boot 3.2.0]
sed -i 's/org.springframework.boot.loader.launch.JarLauncher/org.springframework.boot.loader.launch.PropertiesLauncher/g' /home/vcap/staging_info.yml && sed -i 's/-Dsun.net.inetaddr.negative.ttl=0/-Dsun.net.inetaddr.negative.ttl=0 -Dloader.main=com.sap.cds.framework.spring.utils.Deploy/g' /home/vcap/staging_info.yml && jq -r .start_command /home/vcap/staging_info.yml | bash
```

```sh [&lt; Spring Boot 3.2.0]
sed -i 's/org.springframework.boot.loader.JarLauncher/org.springframework.boot.loader.PropertiesLauncher/g' /home/vcap/staging_info.yml && sed -i 's/-Dsun.net.inetaddr.negative.ttl=0/-Dsun.net.inetaddr.negative.ttl=0 -Dloader.main=com.sap.cds.framework.spring.utils.Deploy/g' /home/vcap/staging_info.yml && jq -r .start_command /home/vcap/staging_info.yml | bash
```

```sh [Java 8]
sed -i 's/org.springframework.boot.loader.JarLauncher/-Dloader.main=com.sap.cds.framework.spring.utils.Deploy org.springframework.boot.loader.PropertiesLauncher/g' /home/vcap/staging_info.yml && jq -r .start_command /home/vcap/staging_info.yml | bash
```

:::

## Developing Multitenant CAP Applications

### Local Development

A multitenant CAP application can still be started and tested locally, for example with SQLite. In this case,
the CAP Java SDK simply disables the multitenancy feature (as there is no Service Manager service binding present) to enable local testing of the general business logic.

Another option is to access cloud services from the local development machine (hybrid scenario). You can decide whether you want to access just one fixed SAP HANA service binding or access all available SAP HANA service bindings that were created through the Service Manager binding, which is described by the following sections.

#### Static SAP HANA Binding

For the static case, just copy the credentials of the SAP HANA service binding you want to use into the *default-env.json*. You can, for example, see all application-managed service instances in the SAP BTP Cockpit. The app behaves like in the single tenant case.

#### Service Manager Binding

If you want to test multitenancy locally, just copy the complete Service Manager binding into the *default-env.json*. If you have extensibility enabled, you also need to set the property `cds.multitenancy.sidecar.url` to the URL of the deployed MTX sidecar app. Now you can access the data of different tenants locally, if user information is set for the requests to your locally running server.

You can locally authenticate at your app either through mock users or the UAA.

The configuration of mock users is described in section [Security](./security). For a mock user, you can also set the `tenant` property. The value needs to be the subaccount ID, which can be found in SAP BTP Cockpit in the *Subaccount* details. You can then authenticate at your app using basic authentication. If you already secured your services, the browser asks you automatically for credentials. Otherwise, you can also set username and password explicitly, for example, in Postman.

If you want to authenticate using the XSUAA, just copy the XSUAA service binding into the *default-env.json*. You then need to have a valid token for the tenant to authenticate. This can be obtained through client-credential-flow, for example, using Postman.

::: warning *❗ Warning*
Requests without user information fail!
:::

::: tip
Currently you need to push the changes to Cloud Foundry, to update the database artifacts. If you're working on the data model, it's recommended to use a static SAP HANA binding.
:::

### Accessing Arbitrary Tenants

You can override the tenant ID that is set in the current `RequestContext`. This enables accessing data of arbitrary tenants programmatically. This might be useful for example:

- To access configuration data stored by means of a "technical" tenant while processing the request of a business tenant.
- To access tenant data in asynchronously scheduled jobs, where no tenant information is present in the `RequestContext`, yet (for example, a startup task prefilling tables of tenants with certain data).

You can use the [`TenantProviderService`](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/TenantProviderService.html) to get a list of available tenants. You can set a particular tenant and access it by running your code in [nested `RequestContext`](event-handlers/request-contexts#defining-requestcontext) as demonstrated by the following example:

```java
TenantProviderService tenantProvider = runtime.getServiceCatalog()
  .getService(TenantProviderService.class, TenantProviderService.DEFAULT_NAME);
List<String> tenants = tenantProvider.readTenants();
tenants.forEach(tenant -> {
  runtime.requestContext().privilegedUser().modifyUser(user -> user.setTenant(tenant)).run(context -> {
    // ... your code
  });
});
```

::: warning *❗ Warning*
If an application overrides the default behavior of the CAP Java SDK this way, it's responsible of ensuring data privacy and isolation!
:::

### Data Source Pooling Configuration

> Pretty much everything in this section depends on your modeling, the load, and also on the sizing (JVM/DB). As there's no one-size-fits-all recommendation, the mentioned configuration parameters are a good starting point.

Data source pool configuration is a tradeoff between resources and latency:

##### Pool per tenant - less latency, more resources

The dedicated pools per tenant approach creates a dedicated connection pool for each tenant. In it's default
configuration this strategy uses a static sizing approach: the number of configured connections (defaults to 10) is
opened on startup of the application and kept open. This has the lowest possible latency and the highest resource
consumption. The application will need a static number of connections per subscribed client. In case you need
low latency but a bit less resource consumption you can [configure dynamic pool sizing](#configure-data-pools) for your tenants'
connection pools. Then the application will need at least the minimum number of connections per subscribed clients. Depending
on the concurrent load the number can increase per client until the configured maximum number of connections is reached.

##### Pool per database - less resources, more latency { #combine-data-pools}

The combined pool approach uses only one pool for all tenants holding a fixed number of connections. This approach, however, needs to switch
connections to the correct schema and user of the tenant, before handing out the connection. This causes some additional latency compared to
the pools per tenant, where a connection, once opened for a given schema and user, can be reused until it's retired. For the combined pool
you can, as for the dedicated pools, decide between static sizing (the default) and [dynamic sizing](#configure-data-pools). For the latter the
resource consumption can be even more reduced while adding a bit more latency because new database connections might be opened
upon incoming requests.

In order to activate the combined pool approach set the property `cds.multiTenancy.datasource.combinePools.enabled = true`.

::: warning *❗ Warning*
Since the pool is shared among all tenants, one tenant could eat up all available connections, either intentionally or by accident. Applications using combined pools need to take adequate measures to mitigate this risk, for example by introducing rate-limiting.
:::

#### Dynamic Data Source Pooling { #configure-data-pools}

If not configured differently both, the dedicated pool and the combined pool approaches use static sizing strategies by default.

The connections are kept open regardless of whether the application is currently serving requests for the given tenant. If you expect a low
number of tenants, this shouldn't be an issue. With a large number of active tenants, this might lead to resource problems, for example, too
many database connections or out-of-memory situations.

Once you have an increased number of tenants, or run short of connections on the database side, you need to adjust the
[configuration of the CDS datasource](./cqn-services/persistence-services#datasource-configuration) for HikariCP as described in the following section. We're using three parameters for the configuration:

- `cds.dataSource.<service-instance>.hikari.minimum-idle`
- `cds.dataSource.<service-instance>.hikari.maximum-pool-size`
- `cds.dataSource.<service-instance>.hikari.idle-timeout`

Keep in mind that `<service-instance>` is the placeholder for the service manager instance bound to your CAP Java application.

|Parameter           |Description  |
|--------------------|-------------|
|`minimum-idle`      | The minimum number of connections kept in the pool after being considered as idle. This helps to adjust the usage of resources to the actual load of a given tenant at runtime. In order to save resources (Java heap and DB connections), this value should be kept rather small (for example `1`). |
|`maximum-pool-size` | The maximum number of connections in the pool. Here, the value needs to be balanced. Counter-intuitively a bigger value doesn't necessarily lead to higher response/time or throughput. Closely monitor your application under load in order to find a good value. As a starting point you can just leave the default value `10`. |
|`idle-timeout`      | The time span after which a connection is considered as *idle*. It controls how fast the size of the pool is adjusted to the load of the application, until `minimum-idle` is reached. Keep in mind that opening a connection comes at a latency cost, too. Don't retire connections too soon.  |

See section [Multitenancy Configuration Properties](#mtx-properties) for more details.

## Multitenancy Configuration Properties { #mtx-properties }

A number of multitenancy settings can be configured through application configuration properties. See section [Application Configuration](./developing-applications/configuring#profiles-and-properties) for more details. All properties can be found in the [properties overview](./developing-applications/properties#cds-multiTenancy). The prefix for multitenancy-related settings is `cds.multitenancy`.

<span id="aftermtxpropertis" />
<Fragment target="#aftermtxpropertis">

### Deprecated Properties <Internal />

| Name                | Description                       | Default            |
| ------------------- | --------------------------------- | ------------------ |
| `deployer.url`      | URL of HDI dynamic deployer       | Not set by default |
| `deployer.user`     | User for HDI dynamic deployer     | Not set by default |
| `deployer.password` | Password for HDI dynamic deployer | Not set by default |


</Fragment>

<div id="secondary-file">java/multitenancy-classic.fragment.md</div>





Describes authentication and authorization in CAP Java.

{ #security}

## Overview

With respect to web services, authentication is the act of proving the validity of user claims passed with the request. This typically comprises verifying the user's identity, tenant, and additional claims like granted roles. Briefly, authentication controls _who_ is using the service. In contrast, authorization makes sure that the user has the required privileges to access the requested resources. Hence, authorization is about controlling _which_ resources the user is allowed to handle.

Hence both, authentication and authorization, are essential for application security:
* [Authentication](#authentication) describes how to configure authentication.
* [Authorization](#auth) describes how to configure access control.

::: warning
Without security configured, CDS services are exposed to public. Proper configuration of authentication __and__ authorization is required to secure your CAP application.
:::

## Authentication { #authentication}

User requests with invalid authentication need to be rejected as soon as possible, to limit the resource impact to a minimum. Ideally, authentication is one of the first steps when processing a request. This is one reason why it's not an integral part of the CAP runtime and needs to be configured on application framework level. In addition, CAP Java is based on a [modular architecture](./developing-applications/building#modular_architecture) and allows flexible configuration of the authentication method. For productive scenarios, [XSUAA and IAS](#xsuaa-ias) authentication is supported out of the box, but a [custom authentication](#custom-authentication) can be configured as well. For the local development and test scenario, there's a built-in [mock user](#mock-users) support.

### Configure XSUAA and IAS Authentication { #xsuaa-ias}
To enable your application for XSUAA or IAS-authentication we recommend to use the `cds-starter-cloudfoundry` or the `cds-starter-k8s` starter bundle, which covers all required dependencies.

:::details Individual Dependencies
These are the individual dependencies that can be explicitly added in the `pom.xml` file of your service:
   * `com.sap.cloud.security:resourceserver-security-spring-boot-starter` that brings [spring-security library](https://github.com/SAP/cloud-security-services-integration-library/tree/main/spring-security)
   * `org.springframework.boot:spring-boot-starter-security`
   * `cds-feature-identity`

:::

In addition, your application needs to be bound to corresponding service instances depending on your scenario.  The following list describes which service needs to be bound depending on the tokens your applications should accept:
   * only accept tokens issued by XSUAA --> bind your application to an [XSUAA service instance](../guides/security/authorization#xsuaa-configuration)
   * only accept tokens issued by IAS --> bind your application to an [IAS service instance](https://help.sap.com/docs/IDENTITY_AUTHENTICATION)
   * accept tokens issued by XSUAA and IAS --> bind your application to service instances of both types.

::: tip Specify Binding
CAP Java picks only a single binding of each type. If you have multiple XSUAA or IAS bindings, choose a specific binding with property `cds.security.xsuaa.binding` respectively `cds.security.identity.binding`.
Choose an appropriate XSUAA service plan to fit the requirements. For instance, if your service should be exposed as technical reuse service, make use of plan `broker`.
:::

#### Proof-Of-Possession for IAS { #proof-of-possession}

Proof-Of-Possession is a technique for additional security where a JWT token is **bound** to a particular OAuth client for which the token was issued. On BTP, Proof-Of-Possession is supported by IAS and can be used by a CAP Java application.

Typically, a caller of a CAP application provides a JWT token issued by IAS to authenticate a request. With Proof-Of-Possession in place, a mutual TLS (mTLS) tunnel is established between the caller and your CAP application in addition to the JWT token. Clients calling your CAP application need to send the certificate provided by their `identity` service instance in addition to the IAS token.

On Cloud Foundry, the CAP application needs to be exposed under an additional route which accepts client certificates and forwards them to the application as `X-Forwarded-Client-Cert` header (for example, the `.cert.cfapps.<landscape>` domain).

<div id="meshdomain" />
<Fragment target="#meshdomain">

::: info For Internal Users <Internal />
For SAP internal usage, it is recommended to use the `mesh.cf.` domain over the `cert.cfapps` domain.

[Learn more about the `mesh.cf.` domain.](https://github.tools.sap/cloudfoundry/custom-domain-selfservice/tree/master/docs/mesh){.learn-more}
:::
</Fragment>

On Kyma, it is required to configure an additional component (i.e. a gateway in Istio) which accepts client certificates and forwards them to the application as `X-Forwarded-Client-Cert` header. An example can be found in the Bookshop sample application [here](https://github.com/SAP-samples/cloud-cap-samples-java/tree/ias-ams-kyma/k8s). Besides defining the actual `Gateway` resource, it is required to expose the application under the new domain (see the `values.yaml` [here](https://github.com/SAP-samples/cloud-cap-samples-java/blob/e9c779cb64c0937815910988387b0775d8842765/helm/values.yaml#L47).

The Proof-Of-Possession also affects approuter calls to a CAP Java application. The approuter needs to be configured to forward the certificate to the CAP application. First, set `forwardAuthCertificates: true` on the destination pointing to your CAP backend (for more details see [the `environment destinations` section on npmjs.org](https://www.npmjs.com/package/@sap/approuter#environment-destinations)). Second, configure the destination to use the route of the CAP backend that has been configured to accept client certificates as described previously.

When authenticating incoming requests with IAS, the Proof-Of-Possession is activated by default. This requires using at least version `3.5.1` of the [SAP BTP Spring Security Client](https://github.com/SAP/cloud-security-services-integration-library/tree/main/spring-security) library.

You can disable the Proof-Of-Possession enforcement in your CAP Java application by setting the property `sap.spring.security.identity.prooftoken` to `false` in the `application.yaml` file.

### Automatic Spring Boot Security Configuration { #spring-boot}

Only if **both, the library dependencies and an XSUAA/IAS service binding are in place**, the CAP Java SDK activates a Spring security configuration, which enforces authentication for all endpoints **automatically**:
* Protocol adapter endpoints (managed by CAP such as OData V4/V2 or custom protocol adapters)
* Remaining custom endpoints (not managed by CAP such as custom REST controllers or Spring Actuators)

The security auto configuration authenticates all endpoints by default, unless corresponding CDS model is not explicitly opened to public with [pseudo-role](../guides/security/authorization#pseudo-roles) `any` (configurable behaviour).
Here's an example of a CDS model and the corresponding authentication configuration:

```cds
service BooksService @(requires: 'any') {
  @readonly
  entity Books @(requires: 'any') {...}

  entity Reviews {...}

  entity Orders @(requires: 'Customer') {...}
}
```

| Path                      | Authenticated ?  |
|:--------------------------|:----------------:|
| `/BooksService`           |      <Na/>       |
| `/BooksService/$metadata` |      <Na/>       |
| `/BooksService/Books`     |      <Na/>       |
| `/BooksService/Reviews`   |       <X/>       |
| `/BooksService/Orders`    |       <X/>       |


::: tip
For multitenant applications, it's required to authenticate all endpoints as the tenant information is essential for processing the request.
:::

There are several application parameters in section `cds.security.authentication` that influence the behaviour of the auto-configuration:

| Configuration Property                               | Description                                             | Default
| :---------------------------------------------------- | :----------------------------------------------------- | ------------
| `mode`  | Determines the [authentication mode](#auth-mode): `never`, `model-relaxed`, `model-strict` or `always` | `model-strict`
| `authenticateUnknownEndpoints`  | Determines, if security configurations enforce authentication for endpoints not managed by protocol-adapters. | `true`
| `authenticateMetadataEndpoints`  | Determines, if OData $metadata endpoints enforce authentication. | `true`

The following properties can be used to switch off automatic security configuration at all:

| Configuration Property                               | Description                                             | Default
| :---------------------------------------------------- | :----------------------------------------------------- | ------------
| `cds.security.xsuaa.enabled`  | Whether automatic XSUAA security configuration is enabled. | `true`
| `cds.security.identity.enabled`  | Whether automatic IAS security configuration is enabled. | `true`

#### Setting the Authentication Mode { #auth-mode}

The property `cds.security.authentication.mode` controls the strategy used for authentication of protocol-adapter endpoints. There are four possible values:

- `never`: No endpoint requires authentication. All protocol-adapter endpoints are considered public.
- `model-relaxed`: Authentication is derived from the authorization annotations `@requires` and `@restrict`. If no such annotation is available, the endpoint is considered public.
- `model-strict`: Authentication is derived from the authorization annotations `@requires` and `@restrict`. If no such annotation is available, the endpoint is authenticated. An explicit `@requires: 'any'` makes the endpoint public.
- `always`: All endpoints require authentication.

By default the authentication mode is set to `model-strict` to comply with secure-by-default.
In that case you can use the annotation `@requires: 'any'` on service-level to make the service and its entities public again.
Please note that it's only possible to make an endpoint public, if the full endpoint path is considered public as well.
For example you can only make an entity public, if the service that contains it is also considered public.
::: tip
Please note that the authentication mode has no impact on the *authorization* behaviour.
:::

#### Customizing Spring Boot Security Configuration { #custom-spring-security-config}

If you want to explicitly change the automatic security configuration, you can add an _additional_ Spring security configuration on top that overrides the default configuration by CAP. This can be useful, for instance, if an alternative authentication method is required for *specific endpoints* of your application.

```java
@Configuration
@EnableWebSecurity
@Order(1) // needs to have higher priority than CAP security config
public class AppSecurityConfig {

  @Bean
  public SecurityFilterChain appFilterChain(HttpSecurity http) throws Exception {
    return http
      .securityMatcher(AntPathRequestMatcher.antMatcher("/public/**"))
      .csrf(c -> c.disable()) // don't insist on csrf tokens in put, post etc.
      .authorizeHttpRequests(r -> r.anyRequest().permitAll())
      .build();
  }

}
```
Due to the custom configuration, all URLs matching `/public/**` are opened for public access.
::: tip
The Spring `SecurityFilterChain` requires CAP Java SDK [1.27.x](../releases/archive/2022/aug22#minimum-spring-boot-version-2-7-x) or later. Older versions need to use the deprecated `WebSecurityConfigurerAdapter`.
:::

::: warning _❗ Warning_ 
Be cautious with the configuration of the `HttpSecurity` instance in your custom configuration. Make sure that only the intended endpoints are affected.
:::

Another typical example is the configuration of [Spring Actuators](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html#actuator.enabling). For example a custom configuration can apply basic authentication to actuator endpoints `/actuator/**`:

```java
@Configuration
@EnableWebSecurity
@Order(1)
public class ActuatorSecurityConfig {

  @Bean
  public SecurityFilterChain actuatorFilterChain(HttpSecurity http) throws Exception {
    return http
      .securityMatcher(AntPathRequestMatcher.antMatcher("/actuator/**"))
      .httpBasic(Customizer.withDefaults())
      .authenticationProvider(/* configure basic authentication users here with PasswordEncoder etc. */)
      .authorizeHttpRequests(r -> r.anyRequest().authenticated())
      .build();
  }

}
```

### Custom Authentication { #custom-authentication}

You're free to configure any authentication method according to your needs. CAP isn't bound to any specific authentication method or user representation such as introduced with XSUAA, it rather runs the requests based on a [user abstraction](../guides/security/authorization#user-claims). The CAP user of a request is represented by a [UserInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/UserInfo.html) object that can be retrieved from the [RequestContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/RequestContext.html) as explained in [Enforcement API & Custom Handlers](#enforcement-api).

Hence, if you bring your own authentication, you have to transform the authenticated user and inject as `UserInfo` to the current request. This is done by means of [UserInfoProvider](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/runtime/UserInfoProvider.html) interface that can be implemented as Spring bean as demonstrated in [Registering Global Parameter Providers](../java/event-handlers/request-contexts#global-providers).
More frequently you might have the requirement to just adapt the request's `UserInfo` which is possible with the same interface:


```java
@Component
public class CustomUserInfoProvider implements UserInfoProvider {

    private UserInfoProvider defaultProvider;

    @Override
    public UserInfo get() {
        ModifiableUserInfo userInfo = UserInfo.create();
        if (defaultProvider != null) {
            UserInfo prevUserInfo = defaultProvider.get();
            if (prevUserInfo != null) {
                userInfo = prevUserInfo.copy();
            }
        }
        if (userInfo != null) {
           XsuaaUserInfo xsuaaUserInfo = userInfo.as(XsuaaUserInfo.class);
           userInfo.setName(xsuaaUserInfo.getEmail() + "/" +
                            xsuaaUserInfo.getOrigin()); // adapt name
        }

        return userInfo;
    }

    @Override
    public void setPrevious(UserInfoProvider prev) {
        this.defaultProvider = prev;
    }
}
```

In the example, the `CustomUserInfoProvider` defines an overlay on the default XSUAA-based provider (`defaultProvider`). The overlay redefines the user's name by a combination of email and origin.

### Mock User Authentication with Spring Boot { #mock-users}

By default, CAP Java creates a security configuration, which accepts _mock users_ for test purposes.

::: details Requirement

Mock users are only initialized if the `org.springframework.boot:spring-boot-starter-security` dependency is present in the `pom.xml` file of your service.

:::

#### Preconfigured Mock Users

For convenience, the runtime creates default mock users reflecting the [pseudo roles](../guides/security/authorization#pseudo-roles). They are named `authenticated`, `system` and `privileged` and can be used with an empty password. For instance, requests sent during a Spring MVC unit test with annotation `@WithMockUser("authenticated")` will pass authorization checks that require `authenticated-user`. The privileged user will pass any authorization checks. `cds.security.mock.defaultUsers = false` prevents the creation of default mock users at startup.

#### Explicitly Defined Mock Users

You can also define mock users explicitly. This mock user configuration only applies if:
* The service runs without an XSUAA service binding (non-productive mode)
* Mock users are defined in the active application configuration

Define the mock users in a Spring profile, which may be only active during testing, as in the following example:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
---
spring:
  config.activate.on-profile: test
cds:
  security:
    mock:
      users:
        - name: Viewer-User
          password: viewer-pass
          tenant: CrazyCars
          roles:
            - Viewer
          attributes:
            Country: [GER, FR]
          additional:
            email: myviewer@crazycars.com
          features:
            - cruise
            - park

        - name: Privileged-User
          password: privileged-pass
          privileged: true
          features:
            - "*"
```
:::
- Mock user with name `Viewer-User` is a typical business user with SaaS-tenant `CrazyCars` who has assigned role `Viewer` and user attribute `Country` (`$user.Country` evaluates to value list `[GER, FR]`). This user also has the additional attribute `email`, which can be retrieved with `UserInfo.getAdditionalAttribute("email")`. The [features](../java/reflection-api#feature-toggles) `cruise` and `park` are enabled for this mock user.
- `Privileged-User` is a user running in privileged mode. Such a user is helpful in tests that bypasses all authorization handlers.

Property `cds.security.mock.enabled = false` disables any mock user configuration.

A setup for Spring MVC-based tests based on the given mock users and the CDS model from [above](#spring-boot) could look like this:

```java
@RunWith(SpringRunner.class)
@SpringBootTest
@AutoConfigureMockMvc
public class BookServiceOrdersTest {
	String ORDERS_URL = "/odata/v4/BooksService/Orders";

	@Autowired
	private MockMvc mockMvc;

	@Test
	@WithMockUser(username = "Viewer-User")
	public void testViewer() throws Exception {
		mockMvc.perform(get(ORDERS_URL)).andExpect(status().isOk());
	}
	@Test
	public void testUnauthorized() throws Exception {
		mockMvc.perform(get(ORDERS_URL)).andExpect(status().isUnauthorized());
	}
}
```

#### Mock Tenants

A `tenants` section allows to specify additional configuration for the _mock tenants_. In particular it is possible to assign features to tenants:
::: code-group
```yaml [srv/src/main/resources/application.yaml]
---
spring:
  config.activate.on-profile: test
cds:
  security:
    mock:
      users:
        - name: Alice
          tenant: CrazyCars
      tenants:
        - name: CrazyCars
          features:
            - cruise
            - park
```
:::
The mock user `Alice` is assigned to the mock tenant `CrazyCars` for which the features `cruise` and `park` are enabled.

## Authorization { #auth}

CAP Java SDK provides a comprehensive authorization service. By defining authorization rules declaratively via annotations in your CDS model, the runtime enforces authorization of the requests in a generic manner. Two different levels of authorization can be distinguished:

- [Role-based authorization](../guides/security/authorization#requires) allows to restrict resource access depending on user roles.
- [Instance-based authorization](../guides/security/authorization#instance-based-auth) allows to define user privileges even on entity instance level, that is, a user can be restricted to instances that fulfill a certain condition.

It's recommended to configure authorization declaratively in the CDS model. If necessary, custom implementations can be built on the [Authorization API](#enforcement-api).

A precise description of the general authorization capabilities in CAP can be found in the [Authorization](../guides/security/authorization) guide.

In addition to standard authorization, CAP Java provides additional out of the box capabilities to reduce custom code:

#### Deep Authorization { #deep-auth}

Queries to Application Services are not only authorized by the target entity which has a `@restrict` or `@requires` annotation, but also for all __associated entities__ that are used in the statement. 
__Compositions__ are neither checked nor extended with additional filters.
For instance, consider the following model:

```cds
@(restrict: [{ grant: 'READ', to: 'Manager' }])
entity Books {...}

@(restrict: [{ grant: 'READ', to: 'Manager' }])
entity Orders {
  key ID: String;
  items: Composition of many {
    key book: Association to Books;
    quantity: Integer;
  }
}
```

For the following OData request `GET Orders(ID='1')/items?$expand=book`, authorizations for `Orders` and for `Books` are checked. 
If the entity `Books` has a `where` clause for [instance-based authorization](/java/security#instance-based-auth), 
it will be added as a filter to the sub-request with the expand.

Custom CQL statements submitted to the [Application Service](/java/cqn-services/application-services) instances 
are also authorized by the same rules including the path expressions and subqueries used in them.

For example, the following statement checks role-based authorizations for both `Orders` and `Books`, 
because the association to `Books` is used in the select list. 

```java
Select.from(Orders_.class,
    f -> f.filter(o -> o.ID().eq("1")).items())
  .columns(c -> c.book().title());
```

For modification statements with associated entities used in infix filters or where clauses,
role-based authorizations are checked as well. Associated entities require `READ` authorization, in contrast to the target of the statement itself.

The following statement requires `UPDATE` authorization on `Orders` and `READ` authorization on `Books`
because an association from `Orders.items` to the book is used in the where condition.

```java
Update.entity(Orders_.class, f -> f.filter(o -> o.ID().eq("1")).items())
  .data("quantity", 2)
  .where(t -> t.book().ID().eq(1));
```
:::tip Modification of Statements
Be careful when you modify or extend the statements in custom handlers.
Make sure you keep the filters for authorization.
:::

Starting with CAP Java `4.0`, deep authorization is on by default. 
It can be disabled by setting <Config java>cds.security.authorization.deep.enabled: false</Config>.

[Learn more about `@restrict.where` in the instance-based authorization guide.](/guides/security/authorization#instance-based-auth){.learn-more}

#### Forbidden on Rejected Entity Selection { #reject-403 }

Entities that have an instance-based authorization condition, that is [`@restrict.where`](/guides/security/authorization#restrict-annotation), 
are guarded by the CAP Java runtime by adding a filter condition to the DB query **excluding not matching instances from the result**. 
Hence, if the user isn't authorized to query an entity, requests targeting a *single* entity return *404 - Not Found* response and not *403 - Forbidden*.

To allow the UI to distinguish between *not found* and *forbidden*, CAP Java can detect this situation and rejects`PATCH` and `DELETE` requests to single entities with forbidden accordingly.
The additional authorization check may affect performance.

::: warning
To avoid to disclosure the existence of such entities to unauthorized users, make sure that the key is not efficiently enumerable or add custom code to overrule the default behaviour otherwise.
:::

Starting with CAP Java `4.0`, the reject behaviour is on by default.
It can be disabled by setting <Config java>cds.security.authorization.instance-based.reject-selected-unauthorized-entity.enabled: false</Config>.

[Learn more about `@restrict.where` in the instance-based authorization guide.](/guides/security/authorization#instance-based-auth){.learn-more}

#### Authorization Checks On Input Data { #input-data-auth }

Input data of `CREATE` and `UPDATE` events is also validated with regards to instance-based authorization conditions.
Invalid input that does not meet the condition is rejected with response code `400`.

Let's assume an entity `Orders` which restricts access to users classified by assigned accounting areas:

```cds
annotate Orders with @(restrict: [
  { grant: '*', where: 'accountingArea = $user.accountingAreas' } ]);
```

A user with accounting areas `[Development, Research]` is not able to send an `UPDATE` request, that changes `accountingArea` from `Research` or `Development` to `CarFleet`, for example.
Note that the `UPDATE` on instances _not matching the request user's accounting areas_ (for example, `CarFleet`) are rejected by standard instance-based authorization checks.

Starting with CAP Java `4.0`, deep authorization is on by default.
It can be disabled by setting <Config java>cds.security.authorization.instanceBased.checkInputData: false</Config>.

[Learn more about `@restrict.where` in the instance-based authorization guide.](/guides/security/authorization#instance-based-auth){.learn-more}


### Enforcement API & Custom Handlers { #enforcement-api}

The generic authorization handler performs authorization checks driven by the annotations in an early Before handler registered to all application services by default. You may override or add to the generic authorization logic by providing custom handlers. The most important piece of information is the [UserInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/UserInfo.html) that reflects the authenticated user of the current request. You can retrieve it:

a) from the [EventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/EventContext.html):
  ```java
  EventContext context;
  UserInfo user = context.getUserInfo();
  ```

b) through dependency injection within a handler bean:

  ```java
  @Autowired
  UserInfo user;
  ```

The most helpful getters in `UserInfo` are listed in the following table:

| UserInfo method                               | Description
| :---------------------------------------------------- | :----------------------------------------------------- |
| `getName()`  | Returns the unique (logon) name of the user as configured in the IdP. Referred by `$user` and `$user.name`. |
| `getTenant()` | Returns the tenant of the user. |
| `isSystemUser()` | Indicates whether the request has been initiated by a technical service. Refers to [pseudo-role](../guides/security/authorization#pseudo-roles) `system-user`. |
| `isAuthenticated()` | True if the current user has been authenticated. Refers to [pseudo-role](../guides/security/authorization#pseudo-roles) `authenticated-user`. |
| `isPrivileged()` |  Returns `true` if the current user runs in privileged (that is, unrestricted) mode |
| `hasRole(String role)` | Checks if the current user has the given role. |
| `getRoles()` | Returns the roles of the current user |
| `getAttributeValues(String attribute)` | Returns the value list of the given user attribute. Referred by `$user.<attribute>`. |

It's also possible to modify the `UserInfo` object for internal calls. See section [Request Contexts](./event-handlers/request-contexts) for more details.
For instance, you might want to run internal service calls in privileged mode that bypasses authorization checks:

```java
cdsRuntime.requestContext().privilegedUser().run(privilegedContext -> {
	assert privilegedContext.getUserInfo().isPrivileged();
	// ... Service calls in this scope pass generic authorization handler
});
```

<div id="secondary-file">java/security.fragment.md</div>



# IAS Authorization via AMS  <Badge type="warning" text="beta" /> { #ams-configuration-java }

CAP applications using *Identity Authentication Service (IAS)* for authentication have to manage authorization via *Authorization Management Service (AMS)* which is also part of *SAP Cloud Identity Services (SCI)*.

## Streamlined AMS Integration

CAP is tightly integrated with Authorization Management Service (AMS).
Applications that run with IAS-based authentication can benefit from AMS which allows central access policy management at the business level.
The integration with AMS comes as an easy-to-consume plugin for CAP applications

![The graphic is explained in the following text.](./assets/ams.png){ }

The interaction between the CAP application and AMS (via plugin) is as follows:

1. IAS-Authentication is performed independently as a pre-step.
2. The plugin injects **user roles and filters** according to AMS policies assigned to the current request user.
3. CAP performs the authorization on basis of the CDS authorization model and the injected user claims.

**AMS is transparent to CAP application code** and can be easily consumed via plugin dependency.

In oder to enhance your project with IAS and AMS you may make use of new CDS CLI tooling:

```sh
cds add ias
cds add ams
```

This automatically adds required configuration for IAS/AMS taking into account the concrete application context (tenant mode and runtime environment etc.).

The CDS model and technical authorization rules in the application domain are fully decoupled from AMS business policies which are defined on top:

::: details Define your CDS model along with technical authorization rules

```cds
aspect fromSystem {
  systemType : String enum { DEV; QS; PROD; };
}

entity Issues : fromSystem {
  key ID: UUID;
      description: String;
      resolved: Boolean;
}

annotate Issues with @(restrict: [
    { grant: ['READ'], to: 'ReviewIssues' },
    { grant: ['READ', 'WRITE'], to: 'ManageIssues' }
]);
```

:::

::: details Optionally, link your CDS model to AMS attributes by `@ams` annotation


```cds
annotate fromSystem with @ams.attributes: {
  SystemType: (systemType)
};
```

:::

::: details Define AMS policies that combine roles and attribute filters at business level

```yaml
SCHEMA {
 SystemType : String
}

POLICY QualityAuditor {
 ASSIGN ROLE ReviewIssues WHERE SystemType IS NOT RESTRICTED;
}

POLICY SupportEngineer {
 USE QualityAuditor RESTRICT SystemType = 'PROD';
}
```

:::

::: details Assign users to AMS policies

![Screenshot showing the AMS Policy Assignment](assets/ams-assignment.png)

:::


::: warning
Make sure to use at least version `3` of `@sap/ams` resp. at least version `2` of `com.sap.cloud.security.ams.client:cap-ams-support`.
:::

<span id="internallinks"/>
<Fragment target="#internallinks">

:::info SAP-internal links for further reading

- [Authorization Management Service (AMS)](https://github.wdf.sap.corp/pages/CPSecurity/ams-docu/)
- [AMS schema](https://github.wdf.sap.corp/pages/CPSecurity/ams-docu/docs/DCLLanguage/SchemaAndAttributes)
- [*Data Control Language* (DCL)](https://github.wdf.sap.corp/pages/CPSecurity/ams-docu/docs/DCLLanguage/Declare)
- [AMS plugin for CAP Java](https://github.wdf.sap.corp/CPSecurity/cloud-authorization-client-library-java/tree/master/cap-ams-support)
- [Find an example CAP Java project with AMS](https://github.com/SAP-samples/cloud-cap-samples-java/tree/identity-ams)
- [AMS plugin for CAP Node.js](https://github.wdf.sap.corp/CPSecurity/cloud-authorization-client-library-nodejs)
- [Find an example CAP Node.js project with AMS](https://github.com/SAP-samples/ams-samples-node/tree/main/ams-cap-nodejs-bookshop)

Find more details in the [documentation for Java](https://github.wdf.sap.corp/CPSecurity/cloud-authorization-client-library-java/tree/master/cap-ams-support) resp. [documentation für Node.js](https://github.wdf.sap.corp/CPSecurity/cloud-authorization-client-library-nodejs#sapams).

:::

</Fragment>


## Setup

Since `@sap/cds-dk` 8.6.0, the `cds add ams` command has been available to configure the project for authorization via AMS. Implicitly, it also runs the new `cds add ias` command to configure the project for authentication via SAP Identity Service.

```sh
cds add ams
```

::: details This adds the following...

##### Runtime plugins

See the dependencies to the AMS client library and the AMS CAP integration library:

::: code-group
```xml [srv/pom.xml]
<properties>
  <sap.cloud.security.ams.version>3.3.0</sap.cloud.security.ams.version> 
</properties>
<dependencies>
  <dependency>  
    <groupId>com.sap.cloud.security.ams.client</groupId>
    <artifactId>jakarta-ams</artifactId>
    <version>${sap.cloud.security.ams.version}</version>
  </dependency>
  <dependency>
    <groupId>com.sap.cloud.security.ams.client</groupId>
    <artifactId>cap-ams-support</artifactId>
    <version>${sap.cloud.security.ams.version}</version>
  </dependency>
</dependencies>
```
:::

These libraries integrate into the CAP framework to handle incoming requests. Based on the user's assigned [policies](#generate-policies), the user's roles are determined and written to the [UserInfo](./security#enforcement-api) object. Afterwards, the framework authorizes the request as usual based on the user's roles.

<br>

##### Development plugins

It also adds a build step using a CDS plugin as a Node.js *devDependency*:

::: code-group
```json [package.json]
{
  "devDependencies": {
    "@sap/ams": "^3"
  }
}
```
:::

This plugin provides three features:

- Validate `ams.attributes` annotations for type coherence against the AMS schema.
- Generate policies from the CDS model during the build using a [custom build task](../guides/deployment/custom-builds#custom-build-plugins).
- Generate a deployer application during the build to upload the Data Control Language (DCL) base policies.


## Generate Policies

In AMS, [authorization policies](https://help.sap.com/docs/cloud-identity-services/cloud-identity-services/configuring-authorization-policies?locale=en-US) are used to define concepts such as *roles* in a language called *Data Control Language* (DCL).

Using the official AMS plugins (`cds add ams`), you can generate policies from the CDS model and get out-of-the-box enforcement of CAP role restrictions based on AMS policies during runtime.

### Role-based authorization

You define the role *Reader* as required to access the `Books` entity in your CDS model:

```cds
entity Books @(requires: 'Reader') {...}
```

The following policy is generated from the CDS source and defines the *Reader* role:

```sql
POLICY Reader {
    ASSIGN ROLE Reader;
}
```

### Instance-based authorization

Given the expressiveness of DCL, the Authorization Management Service (AMS) is the natural choice when your application requires instance-based authorization that exceeds the capabilities of the standard [instance-based CDS conditions](../guides/security/authorization#instance-based-auth). AMS supports exclusively role-based authorization, as well as a mix of instance-based and role-based authorization equally well.

The AMS integration for defining advanced instance-based authorization rules has recently received a redesign in close collaboration with CAP.
There will be detailed documentation soon.

## Build

```sh
mvn clean install
```

After the application is built, check the *srv/src/main/resources/ams* folder to see the generated AMS *schema* and a *basePolicies* DCL file in a DCL package called *cap*:

::: code-group

``` [srv/src/main/resources]
└─ ams
   ├─ cap
   │  └─ basePolicies.dcl
   └─ schema.dcl
```

:::

## Prepare for Deployment

Policies are typically deployed to the AMS server whenever the application is deployed. Afterwards, those policies can be assigned to users in the Administration Console of the IAS tenant, for example, to grant a role to a user. Using the AMS plugins (`cds add ams`), the configuration of the deployment artifacts is done automatically.

::: details Prerequisites on SAP BTP

- [Get your SAP Cloud Identity Service tenant.](https://help.sap.com/docs/cloud-identity-services/cloud-identity-services/get-your-tenant)
- [Establish Trust](https://help.sap.com/docs/btp/sap-business-technology-platform/establish-trust-and-federation-between-uaa-and-identity-authentication) towards your SAP Cloud Identity Service tenant to use it as identity provider for applications in your subaccount.

:::

Follow the [Deploy to Cloud Foundry guide](../guides/deployment/to-cf), to prepare your project for deployment. Here's a shortcut:

```sh
cds add hana,approuter,mta,ams

```

After successful deployment, you need to [Assign Authorization Policies](https://help.sap.com/docs/cloud-identity-services/cloud-identity-services/assign-authorization-policies).

::: details Kyma configuration

Using `cds add helm` to deploy to Kyma is fully supported and automatically configured, too. Follow the [Deploy to Kyma guide](../guides/deployment/to-kyma) to prepare your project.

:::

::: warning XSUAA-specific configuration

If not required, make sure to manually remove the XSUAA-specific configuration.

:::

<div id="secondary-file">java/ams.fragment.md</div>


# Spring Boot Integration


This section shows how CAP Java is smoothly integrated with Spring Boot.





This section describes the [Spring Boot](https://spring.io/projects/spring-boot) integration of the CAP Java SDK. Classic Spring isn't supported.
Running your application with Spring Boot framework offers a number of helpful benefits that simplify the development and maintenance of the application to a high extend.
Spring not only provides a rich set of libraries and tools for most common challenges in development, you also profit from a huge community, which constantly contributes optimizations, bug fixes and new features.

As Spring Boot is not only widely accepted but also the most popular application framework, CAP Java SDK comes with seamless integration of Spring Boot as described in the following sections.

## Integration Configuration

To make your web application ready for Spring Boot, you need to make sure that the following Spring dependencies are referenced in your `pom.xml` (group ID `org.springframework.boot`):
* `spring-boot-starter-web`
* `spring-boot-starter-jdbc`
* `spring-boot-starter-security` (optional)

In addition, for activating the Spring integration of CAP Java, the following runtime dependency is required:

```xml
<dependency>
	<groupId>com.sap.cds</groupId>
	<artifactId>cds-framework-spring-boot</artifactId>
	<version>${cds.services.version}</version>
	<scope>runtime</scope>
</dependency>
```

It might be easier to use the CDS starter bundle `cds-starter-spring-boot-odata`, which not only comprises the necessary Spring dependencies, but also configures the OData V4 protocol adapter:

```xml
<dependency>
	<groupId>com.sap.cds</groupId>
	<artifactId>cds-starter-spring-boot-odata</artifactId>
	<version>${cds.services.version}</version>
</dependency>
```

::: tip
If you refrain from adding explicit Spring or Spring Boot dependencies in your service configuration,
the CDS integration libraries transitively retrieve the recommended Spring Boot version for the current CAP Java version.
:::

## Integration Features

Besides common Spring features such as dependency injection and a sophisticated [test framework](./developing-applications/testing), the following features are available in Spring CAP applications:

* CDS event handlers within custom Spring beans are automatically registered at startup.
* Full integration into Spring transaction management (`@Transactional` is supported).
* A number of CAP Java SDK interfaces are exposed as [Spring beans](#exposed-beans) and are available in the Spring application context such as technical services, the `CdsModel`, or the `UserInfo` in current request scope.
* *Automatic* configuration of XSUAA, IAS, and [mock user authentication](./security#mock-users) by means of Spring security configuration.
* Integration of `cds`-property section into Spring properties. See section [Externalized Configuration](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config) in the Spring Boot documentation for more details.
* [The cds actuator](./operating-applications/observability#spring-boot-actuators) exposing monitoring information about CDS runtime and security.
* [The DB health check indicator](./operating-applications/observability#spring-health-checks) which also applies to tenant-aware DB connections.

::: tip
None of the listed features will be available out of the box in case you choose to pack and deploy your web application as plain Java Servlet in a *war* file.
:::


## CDS Spring Beans { #exposed-beans}

| Bean              | Description                      | Example
| :---------------------------------------------------- | :----------------------------------------------------- | :----------------------------------------------------- |
| [CdsRuntime](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/runtime/CdsRuntime.html)  | Runtime instance (singleton)  | `@Autowired`<br>`CdsRuntime runtime;`
| [CdsRuntimeConfigurer](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/runtime/CdsRuntimeConfigurer.html)  | Runtime configuration instance (singleton)  | `@Autowired`<br>`CdsRuntimeConfigurer configurer;`
| [Service](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/Service.html)  | All kinds of CDS services, application services, and technical services   | `@Autowired`<br>`@Qualifier(CatalogService_.CDS_NAME)`<br>`private ApplicationService cs;`<br><br>`@Autowired`<br>`private PersistenceService ps;`
| [ServiceCatalog](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/ServiceCatalog.html)  | The catalog of all available services   | `@Autowired`<br>`ServiceCatalog catalog;`
| [CdsModel](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/reflect/CdsModel.html)  | The current model   | `@Autowired`<br>`CdsModel model;`
| [UserInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/UserInfo.html)  | Information about the authenticated user   | `@Autowired`<br>`UserInfo userInfo;`
| [AuthenticationInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/authentication/AuthenticationInfo.html)  | Authentication claims   | `@Autowired`<br>`AuthenticationInfo authInfo;`
| [ParameterInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/ParameterInfo.html)  | Information about request parameters   | `@Autowired`<br>`ParameterInfo paramInfo;`
| [Messages](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/messages/Messages.html)  | Interface to write messages | `@Autowired`<br>`Messages messages;`
| [FeatureTogglesInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/FeatureTogglesInfo.html)  | Information about feature toggles | `@Autowired`<br>`FeatureTogglesInfo ftsInfo;`
| [CdsDataStore](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/CdsDataStore.html) | Direct access to the default data store | `@Autowired`<br>`CdsDataStore ds;` |







# Developing CAP Java Applications

Learn here about developing a CAP Java application.



<IndexList :pages='pages' />



# Building Applications


One of the key [CAP design principles](../../about/#open-and-opinionated) is to be an opinionated but yet open framework.
Giving a clear guidance for cutting-edge technologies on the one hand and still keeping the door wide open for custom choice on the other hand, demands a highly flexible CAP Java runtime stack.
The [modular architecture](#modular_architecture) reflects this requirement, allowing a fine-grained and flexible [configuration](#stack_configuration) based on standard or custom modules.

## Modular Stack Architecture
{ #modular_architecture}

### Overview

One of the basic design principle of the CAP Java is to keep orthogonal functionality separated in independent components.
The obvious advantage of this decoupling is that it makes concrete components exchangeable independently.
Hence, it reduces the risk of expensive adaptions in custom code, which can be necessary due to new requirements with regards to the platform environment or used version of platform services.
Hence, the application is [platform **and** service agnostic](../../about/best-practices#agnostic-by-design).

For instance, custom code doesn't need to be written against the chosen type of persistence service, but can use the generic persistence service based on [CQL](../working-with-cqn/../working-with-cql/query-api).
Likewise, the application isn't aware of the concrete (cloud) platform environment in which it gets embedded.
Consequently, preparing an application to be deployable in different platform contexts is rather a matter of configuration than of code adaption.

Consequently, CAP Java doesn't determine the technology the application is built on.
But it comes with a chosen set of industry-proven frameworks that can be consumed easily.
Nevertheless, you can override the defaults separately depending on the demands in your scenario.

Moreover, the fine-grained modularization allows you to assemble a minimum set of components, which is necessary to fulfill the application-specific requirements.
This reduces resource consumption at runtime as well as maintenance costs significantly.

Another helpful result of the described architecture is that it simplifies local testing massively.
Firstly, as components are coupled weakly, you can define the actual test scope precisely and concentrate on the parts that need a high test coverage.
Components outside of the test scope are replaceable with mocks, which ideally simulate all the possible corner cases.
Alternatively, you can even configure test on integration level to be executed locally if you replace all dependencies to remote services by local service providers.
A common example for this is to run the application locally on H2 instead of SAP HANA.

The following diagram illustrates the modular stack architecture and highlights the generic components:

![This screenshot is explained in the accompanying text.](./assets/modularized-architecture.png){}

You can recognize five different areas of the stack, which comprise components according to different tasks:

* The mandatory [application framework](#application-framework) defines the runtime basis of your application typically comprising a web server.
* [Protocol adapters](#protocol-adapters) map protocol-specific web events into [CQN](../../cds/cqn) events for further processing.
* The resulting CQN-events are passed to [service providers](#service-providers) or the mandatory core runtime, which drives the processing of the event.
* The [CQN execution engine](#cqn-execution-engine) is capable of translating [CQN](../../cds/cqn) statements into native statements of a data sink such as a persistence service or remote service.
* [Application features](#application-features) are optional application extensions, for instance to add multitenancy capabilities or a platform service integration.


### Application Framework

Before starting the development of a new CAP-based application, an appropriate application framework to build on needs to be chosen.
The architecture of the chosen framework not only has a strong impact on the structure of your project, but it also affects efforts for maintenance as well as support capabilities.
The framework provides the basis of your web application in terms of a runtime container in which your business code can be embedded and executed.
This helps to separate your business logic from common tasks like processing HTTP/REST endpoints including basic web request handling.
Typically, a framework also provides you with a rich set of generic tools for recurring tasks like configuration, localization, or logging.
In addition, some frameworks come with higher-level concepts like dependency injection or sophisticated testing infrastructure.

CAP Java positions [Spring](https://spring.io) or more precisely [Spring Boot](https://spring.io/projects/spring-boot) as the first choice application framework, which is seamlessly integrated.
Spring comes as a rich set of industry-proven frameworks, libraries, and tools that greatly simplify custom development.
Spring Boot also allows the creation of self-contained applications that are easy to configure and run.

As all other components in the different layers of the CAP Java stack are decoupled from the concrete application framework, you aren't obligated to build on Spring.
In some scenarios, it might be even preferable to run the (web) service with minimal resource consumption or with smallest possible usage of open source dependencies.
In this case, a solution based on plain Java Servlets could be favorable.
Lastly, in case you want to run your application on a 3rd party application framework, you're free to bundle it with CAP modules and provide the glue code, which is necessary for integration.


### Protocol Adapters


The CAP runtime is based on an [event](../../about/best-practices#events) driven approach.
Generally, [Service](../../about/best-practices#services) providers are the consumers of events, that means, they do the actual processing of events in [handlers](../../guides/providing-services#event-handlers).
During execution, services can send events to other service providers and consume the results.
The native query language in CAP is [CQN](../../cds/cqn), which is accepted by all services that deal with data query and manipulation.
Inbound requests therefore need to be mapped to corresponding CQN events, which are sent to an accepting Application Service (see concept [details](../../about/best-practices#querying)) afterwards.
Mapping the ingress protocol to CQN essentially summarizes the task of protocol adapters depicted in the diagram.
Most prominent example is the [OData V4](https://www.odata.org/documentation/) protocol adapter, which is fully supported by the CAP Java.
Further HTTP-based protocols can be added in future, but often applications require specific protocols, most notably [RESTful](https://en.wikipedia.org/wiki/Representational_state_transfer) ones.
Such application-specific protocols can easily be implemented by means of Spring RestControllers.

The modular architecture allows to add custom protocol adapters in a convenient manner, which can be plugged into the stack at runtime.
Note that different endpoints can be served by different protocol adapters at the same time.


### Service Providers { #service-providers}

Services have different purposes. For instance, CDS model services provide an interface to work with persisted data of your [domain model](../../guides/domain-modeling).
Other services are rather technical, for example, hiding the consumption API of external services behind a generic interface.
As described in CAPs [core concepts](../../about/best-practices#services), services share the same generic provider interface and are implemented by event handlers.
The service provider layer contains all generic services, which are auto-exposed by CAP Java according to the appropriate CDS model.
In addition, technical services are offered such as the [Persistence Service](../cqn-services/#persistenceservice) or [Auditlog Service](../auditlog#auditlog-service), which can be consumed in custom service handlers.

In case the generic handler implementation of a specific service doesn't match the requirements, you can extend or replace it with custom handler logic that fits your business needs.
See section [Event Handlers](../event-handlers/) for more details.


### CQN Execution Engine { #cqn-execution-engine}

The CQN execution engine is responsible for processing the passed CQN events and translating them to native statements that get executed in a target persistence service like SAP HANA, PostgreSQL or H2.
CQN statements can be built conveniently in a [fluent API](../working-with-cqn/../working-with-cql/query-api). In the future, additional targets can be added to the list of supported outbound sources.


### Application Features { #application-features}

The CAP Java architecture allows **additional modules to be plugged in at runtime**.
This plugin mechanism makes the architecture open for future extensions and allows context-based configuration.
It also enables you to override standard behavior with custom-defined logic in all different layers.
Custom [plugins](../building-plugins) are automatically loaded by the runtime and can bring CDS models, CDS services, adapters or just handlers for existing services.

::: info
Plugins are optional modules that adapt runtime behaviour.
:::

CAP Java makes use of the plugin technique itself to offer optional functionality.
Examples are [SAP Event Mesh](../messaging) and [Audit logging](../auditlog) integration.
Find a full list of standard plugins in [Standard Modules](#standard-modules).

## Stack Configuration { #stack_configuration}

 As outlined in section [Modular Stack Architecture](#modular_architecture), the CAP Java runtime is highly flexible.
 You can choose among modules prepared for different environments and in addition also include plugins which are optional extensions.
 Which set of modules and plugins is active at runtime is a matter of compile time and runtime configuration.

 At compile time, you can assemble modules from the different layers:
 * The [application framework](#application-framework)
 * One or more [protocol adapters](#protocol-adapters)
 * The core [service providers](#service-providers)
 * [Application features](#application-features) to optionally extend the application or adapt to a specific environment

### Module Dependencies

All CAP Java modules are built as [Maven](https://maven.apache.org/) artifacts and are available on [Apache Maven Central Repository](https://search.maven.org/search?q=com.sap.cds).
They have `groupId` `com.sap.cds`.
Beside the Java libraries (Jars) reflecting the modularized functionality, the group also contains a "bill of materials" (BOM) pom named `cds-services-bom`, which is recommended especially for multi-project builds.
It basically helps to control the dependency versions of the artifacts and should be declared in dependency management of the parent `pom`:

```xml
<properties>
	<cds.services.version>2.6.0</cds.services.version>
</properties>

<dependencyManagement>
	<dependencies>
		<dependency>
			<groupId>com.sap.cds</groupId>
			<artifactId>cds-services-bom</artifactId>
			<version>${cds.services.version}</version>
			<type>pom</type>
			<scope>import</scope>
		</dependency>
	</dependencies>
</dependencyManagement>
```

::: tip Keep Versions in Sync
Importing `cds-services-bom` into the `dependencyManagement` of your project ensures that versions of all CAP modules are in sync.
:::

The actual Maven dependencies specified in your `pom` need to cover all modules that are required to run the web application:
- The application framework.
- At least one protocol adapter (in case of inbound requests).
- The CAP Java runtime.

The dependencies of a Spring Boot application with OData V4 endpoints could look like in the following example:

```xml
<dependencies>
	
	<dependency>
		<groupId>com.sap.cds</groupId>
		<artifactId>cds-framework-spring-boot</artifactId>
		<scope>runtime</scope>
	</dependency>

	
	<dependency>
		<groupId>com.sap.cds</groupId>
		<artifactId>cds-adapter-odata-v4</artifactId>
		<scope>runtime</scope>
	</dependency>

	
	<dependency>
		<groupId>com.sap.cds</groupId>
		<artifactId>cds-services-api</artifactId>
	</dependency>
	<dependency>
		<groupId>com.sap.cds</groupId>
		<artifactId>cds-services-impl</artifactId>
		<scope>runtime</scope>
	</dependency>
</dependencies>
```

::: tip API Modules w/o scope `dependency`
Only API modules without dependency scope should be added (they gain `compile` scope by default) such as `cds-services-api` or `cds4j-api`.
All other dependencies should have a dedicated scope, like `runtime` or `test` to prevent misuse.
:::

You are not obliged to choose one of the prepared application frameworks (identifiable by `artifactId` prefix `cds-framework`),
instead you can define your own application context if required.
Similarly, you're free to configure multiple adapters including custom implementations that map any specific web service protocol.

::: tip Recommended Application Framework
We highly recommended to configure `cds-framework-spring-boot` as application framework.
It provides you with a lot of [integration with CAP](../spring-boot-integration#spring-boot-integration) out of the box, as well as enhanced features, such as dependency injection and auto configuration.
:::

Additional application features (plugins) you want to use can be added as additional dependencies.
The following is required to make your application multitenancy aware:

```xml
<dependencies>
	
	<dependency>
		<groupId>com.sap.cds</groupId>
		<artifactId>cds-feature-mt</artifactId>
		<scope>runtime</scope>
	</dependency>
</dependencies>
```

Choosing a feature by adding the Maven dependency *at compile time* enables the application to make use of the feature *at runtime*.
If a chosen feature misses the required environment at runtime, the feature won't be activated.
Together with the fact that all features have a built-in default implementation ready for local usage, you can run the application locally with the same set of dependencies as for productive mode.
For instance, the authentication feature `cds-feature-hana` requires a valid `hana` binding in the environment.
Hence, during local development without this binding, this feature gets deactivated and the stack falls back to default feature adapted for H2.

#### Standard Modules { #standard-modules }

CAP Java comes with a rich set of prepared modules for all different layers of the stack:

**Application Frameworks**:
* `cds-framework-spring-boot`:  Makes your application a Spring Boot application.
* `cds-framework-plain`:  Adds support to run as plain Java Servlet-based application.

**Protocol adapters**:
* `cds-adapter-odata-v4`:  Auto-exposes Application Services as OData V4 endpoints.
* `cds-adapter-odata-v2`:  Auto-exposes Application Services as OData V2 endpoints.

**Core runtime**:
* `cds-adapter-api`:  Generic protocol adapter interface to be implemented by customer adapters.
* `cds-services-api`:  Interface of the CAP Java SDK. Custom handler or adapter code needs to compile against.
* `cds-services-impl`:  Implementation of the core CAP Java runtime (**mandatory**).

**Application plugins**:
* `cds-feature-cloudfoundry`:  Makes your application aware of SAP BTP, Cloud Foundry environment.
* `cds-feature-k8s`: Service binding support for SAP BTP, Kyma Runtime.
* `cds-feature-jdbc`: Consuming JDBC persistences using the CDS4j JDBC runtime.
* `cds-feature-hana`:  Makes your application aware of SAP HANA data sources.
* `cds-feature-postgresql`: Makes your application aware of PostgreSQL data sources.
* `cds-feature-xsuaa`:  Adds [XSUAA](https://github.com/SAP/cloud-security-xsuaa-integration)-based authentication to your application.
* `cds-feature-identity`: Adds [Identity Services](https://github.com/SAP/cloud-security-xsuaa-integration) integration covering IAS to your application.
* `cds-feature-mt`:  Makes your application multitenant aware.
* `cds-feature-enterprise-messaging`:  Connects your application to SAP Event Mesh.
* `cds-feature-kafka`: Benefit from intra-application messaging with Apache Kafka.
* `cds-feature-remote-odata`: Adds [Remote Service](../cqn-services/remote-services#remote-services) support.
* `cds-feature-auditlog-v2`: Provides out of the box integration with SAP BTP Auditlog Service V2.
* `cds-integration-cloud-sdk`: Allows smooth integration with Cloud SDK to connect with remote REST-based services.

::: tip
`cds-feature-cloudfoundry` and `cds-feature-k8s` can be combined to create binaries that support both environments.
:::

### Starter Bundles

To simplify the configuration on basis of Maven dependencies, the CAP Java comes with several starter bundles that help to set up your configuration for most common use cases quickly:

* `cds-starter-cloudfoundry`: Bundles features to make your application production-ready for SAP BTP, Cloud Foundry environment. It comprises XSUAA authentication, SAP HANA persistence, Cloud Foundry environment for SAP BTP, and multitenancy support.
* `cds-starter-k8s`: Bundles features to make your application production-ready for SAP BTP, Kyma/K8s environment. It comprises XSUAA authentication, SAP HANA persistence, Kyma/K8s environment for SAP BTP, and multitenancy support.
* `cds-starter-spring-boot`: Bundles all dependencies necessary to set up a web-application based on Spring Boot. No protocol adapter is chosen.

Starter bundle `cds-starter-spring-boot` can be combined with any of the other bundles.

An example of a CAP application with OData V4 on Cloud Foundry environment:
```xml
<dependencies>
		<dependency>
			<groupId>com.sap.cds</groupId>
			<artifactId>cds-starter-spring-boot</artifactId>
		</dependency>

		<dependency>
			<groupId>com.sap.cds</groupId>
			<artifactId>cds-adapter-odata-v4</artifactId>
			<scope>runtime</scope>
		</dependency>

		<dependency>
			<groupId>com.sap.cds</groupId>
			<artifactId>cds-starter-cloudfoundry</artifactId>
			<scope>runtime</scope>
		</dependency>
</dependencies>
```


## Generating Projects with Maven { #the-maven-archetype }

Use the following command line to create a project from scratch with the CDS Maven archetype:

::: code-group
```sh [Mac/Linux]
mvn archetype:generate -DarchetypeArtifactId=cds-services-archetype -DarchetypeGroupId=com.sap.cds -DarchetypeVersion=RELEASE
```

```cmd [Windows]
mvn archetype:generate -DarchetypeArtifactId=cds-services-archetype -DarchetypeGroupId=com.sap.cds -DarchetypeVersion=RELEASE
```

```powershell [Powershell]
mvn archetype:generate `-DarchetypeArtifactId=cds-services-archetype `-DarchetypeGroupId=com.sap.cds `-DarchetypeVersion=RELEASE
```
:::

<div id="release-sap" />

It supports the following command-line options:

| Option | Description |
| -- | -- |
| `-DgroupId=<a valid Maven groupId>` | The `groupId` of the Maven artifact for the new project. If not specified, Maven prompts for user input. |
| `-DartifactId=<a valid Maven artifactId>` | The `artifactId` of the Maven artifact for the new project. If not specified, Maven prompts for user input. |
| `-Dversion=<a valid Maven version>` | The `version` of the Maven artifact for the new project. Defaults to `1.0.0-SNAPSHOT` |
| `-Dpackage=<a valid Java package>` | The Java package for your project's classes. Defaults to `${groupId}.${artifactId}`. |
| `-DincludeModel=true` | Adds a minimalistic sample CDS model to the project. |
| `-DincludeIntegrationTest=true` | Adds an integration test module to the project. |
| `-DodataVersion=[v2\|v4]` | Specify which protocol adapter is activated by default. |
| `-DtargetPlatform=cloudfoundry` | Adds CloudFoundry target platform support to the project. |
| `-DinMemoryDatabase=[h2\|sqlite]` | Specify which in-memory database is used for local testing. If not specified, the default value is `h2`. |
| `-DjdkVersion=[17\|21]` | Specifies the target JDK version. If not specified, the default value is `21`. |
| `-Dpersistence=[true\|false]` | Specify whether persistence is enabled (`true`) or disabled (`false`). Defaults to `true`. |
| `-DcdsdkVersion=<a valid cds-dk version>` | Sets the provided cds-dk version in the project. If not specified, the default of CAP Java is used. |

## Building Projects with Maven
{ #maven-build-options }

You can build and run your application by means of the following Maven command:

```sh
mvn spring-boot:run
```


### CDS Maven Plugin

CDS Maven plugin provides several goals to perform CDS-related build steps.
For instance, the CDS model needs to be compiled to a CSN file which requires a Node.js runtime with module `@sap/cds-dk`.

It can be used in CAP Java projects to perform the following build tasks:

- Install Node.js in the specified version
- Install the CDS Development Kit `@sap/cds-dk` with a specified version
- Perform arbitrary CDS commands on a CAP Java project
- Generate Java classes for type-safe access
- Clean a CAP Java project from artifacts of the previous build

Since CAP Java 1.7.0, the CDS Maven Archetype sets up projects to leverage the CDS Maven plugin to perform the previous mentioned build tasks.
To have an example on how you can modify a project generated with a previous version of the CDS Maven Archetype, see [this commit](https://github.com/SAP-samples/cloud-cap-samples-java/commit/ceb47b52b1e30c9a3f6e0ea29e207a3dad3c0190).

See [CDS Maven Plugin documentation](../assets/cds-maven-plugin-site/plugin-info.html){target="_blank"} for more details.

::: tip
Use the _.cdsrc.json_ file to add project specific configuration of `@sap/cds-dk` in case defaults are not appropriate.
:::

[Learn more about configuration and `cds.env`](../../node.js/cds-env){.learn-more}


### Using a Local cds-dk

Starting with version 3.6.0 of the `cds-services-archetype`, the default setup of a newly created CAP Java project has changed. The `@sap/cds-dk` is maintained as a `devDependency` in `package.json` and installed with an `npm ci` during the Maven build.
The `install-cdsdk` goal is no longer used to install the `@sap/cds-dk` locally and it's also marked as deprecated. The version of the `@sap/cds-dk` is no longer maintained in _pom.xml_, it's configured in the _package.json_:
```json
{
  "devDependencies" : {
    "@sap/cds-dk" : "^8.5.1",
  }
}
```
A `package-lock.json` is also created during project creation with the `cds-services-archetype`. The lock file is needed for `npm ci` to run successfully and pins the transitive dependencies of `@sap/cds-dk` to fixed versions. Fixing the versions ensures that the CDS build is fully reproducible.

::: warning
For multitenant applications, ensure that the `@sap/cds-dk` version in the sidecar is in sync.
:::

#### Migrate From Goal `install-cdsdk` to `npm ci` 
{ #migration-install-cdsdk }

To migrate from the deprecated goal `install-cdsdk` to the new `npm ci` approach, the following steps are required:

1. Remove execution of goal `install-cdsdk` from the `cds-maven-plugin` in _srv/pom.xml_:
	```xml
	<plugin>
		<groupId>com.sap.cds</groupId>
		<artifactId>cds-maven-plugin</artifactId>
		<version>${cds.services.version}</version>
		<executions>
			
			<execution>
				<id>cds.install-cdsdk</id>
				<goals>
					<goal>install-cdsdk</goal>
				</goals>
			</execution>
			
	```

2. Then add execution of goal `npm` with arguments `ci` instead to the `cds-maven-plugin` in _srv/pom.xml_:
	```xml
			<execution>
				<id>cds.npm-ci</id>
				<goals>
					<goal>npm</goal>
				</goals>
				<configuration>
					<arguments>ci</arguments>
				</configuration>
			</execution>
	```

3. Remove cds-dk version property `cds.install-cdsdk.version` from _pom.xml_:
	```xml
		<properties>
			
			<cds.install-cdsdk.version>8.4.2</cds.install-cdsdk.version>
			
		</properties>
	```

4. Add `@sap/cds-dk` as devDependency to _package.json_:
	```json
	{
	"devDependencies" : {
		"@sap/cds-dk" : "^8.5.0"
	}
	}
	```

5. Perform `npm install` on the command line to get the _package-lock.json_ created or updated.

6. Finally, do a `mvn clean install` and verify that the installation of `@sap/cds-dk` is done with the new approach.

#### Maintaining cds-dk

1. _package.json_ and `npm ci` <br>
Newly created CAP Java projects maintain the `@sap/cds-dk` with a specific version as a devDependency in `package.json`. So, when you update the version, run npm install from the command line to update the `package-lock.json`. `npm ci` will then install the updated version of `@sap/cds-dk`.

2. Goal `install-cdsdk` <br>
 Older CAP Java projects that use the `install-cdsdk` goal of the `cds-maven-plugin` don't update `@sap/cds-dk`. By default, the goal skips the installation if it's already installed.
To update the `@sap/cds-dk` version:

3. Specify a newer version of `@sap/cds-dk` in your *pom.xml* file.
4. Execute `mvn spring-boot:run` with an additional property `-Dcds.install-cdsdk.force=true`, to force the installation of a **`@sap/cds-dk`** in the configured version.

    ```sh
    mvn spring-boot:run -Dcds.install-cdsdk.force=true
    ```

::: tip _Recommendation_ 
This should be done regularly to get the latest bugfixes, but at least with every **major update** of `@sap/cds-dk`.
:::

<div id="xmake-troubleshooting" />

### Using a Global cds-dk

By default, the build is configured to download a Node.js runtime and the `@sap/cds-dk` tools and install them locally within the project.
This step makes the build self-contained, but the build also takes more time. You can omit these steps and speed up the Maven build, using the Maven profile `cdsdk-global`.

Prerequisites:
* `@sap/cds-dk` is [globally installed](../../get-started/#setup).
* Node.js installation is available in current *PATH* environment.

If these prerequisites are met, you can use the profile `cdsdk-global` by executing:

```sh
mvn spring-boot:run -P cdsdk-global
```



# Running Applications


## Spring Boot Devtools
You can speed up your development turnaround by adding the [Spring Boot Devtools](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools) dependency to your CAP Java application. Just add this dependency to the `pom.xml` of your `srv` module:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-devtools</artifactId>
</dependency>
```

Once this is added, you can use the restart capabilities of the Spring Boot Devtools while developing your application in your favorite Java IDE. Any change triggers an automatic application context reload without the need to manually restart the complete application. Besides being a lot faster than a complete restart this also eliminates manual steps. The application context reload is triggered by any file change on the application's classpath:

* Java classes (for example, custom handlers)
* Anything inside src/main/resources
  * Configuration files (for example, _application.yaml_)
  * Artifacts generated from CDS (schema.sql, CSN, EDMX)
  * Any other static resource

::: warning Restart for changed Java classes
Spring Boot Devtools only detects changes to .class files. You need to enable the *automatic build* feature in your IDE which detects source file changes and rebuilds the .class file. If not, you have to manually rebuild your project to restart your CAP Java application.
:::

### CDS Build

The Spring Boot Devtools have no knowledge of any CDS tooling or the CAP Java runtime. Thus, they can't trigger a CDS build if there are changes in the CDS source files. For more information, please check the [Local Development Support](#local-development-support) section.

::: tip
CDS builds in particular change numerous resources in your project. To have a smooth experience, define a [trigger file](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.restart.triggerfile) and [use `auto-build` goal](#cds-auto-build) of the CDS Maven plugin started from the command line.
:::


## Local Development Support

### Use `cds` Prefix Everywhere

To use the `cds` prefix of the `cds-maven-plugin` from everywhere, add the plugin group `com.sap.cds` to your local `~/.m2/settings.xml`:

```xml
<pluginGroups>
    <pluginGroup>com.sap.cds</pluginGroup>
</pluginGroups>
```

This uses the [Maven plugin prefix resolution](https://maven.apache.org/guides/introduction/introduction-to-plugin-prefix-mapping.html) feature. This Maven feature allows you to use only the `cds` prefix of the `cds-maven-plugin` to execute goals of this plugin. For example, instead of `mvn com.sap.cds:cds-maven-plugin:watch` you can use the shorter variant `mvn cds:watch` to run the `watch` goal of the `cds-maven-plugin`.

### CDS Watch
In addition to the previously mentioned build tasks, the CDS Maven plugin can also support the local development of your CAP Java application. During development, you often have to perform the same steps to test the changes in the CDS model:

1. Modify your CDS model.
1. Build and run your application.
1. Test your changes.

To automate and accelerate these steps, the `cds-maven-plugin` offers the goal `watch`, which can be executed from the command line by using Maven:

```sh
mvn cds:watch
```
:::details Other options if you've not configured the plugin group
```sh
# from your root directory
mvn com.sap.cds:cds-maven-plugin:watch
# or your srv/ folder
cd srv
mvn cds:watch
```
:::

It builds and starts the application and looks for changes in the CDS model. If you change the CDS model, these are recognized and a restart of the application is initiated to make the changes effective.

The `watch` goal uses the `spring-boot-maven-plugin` internally to start the application with the goal `run` (this also includes a CDS build). Therefore, it's required that the application is a Spring Boot application and that you execute the `watch` goal within your service module folder.
When you add the [Spring Boot Devtools](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools) to your project, the `watch` goal can take advantage of the reload mechanism. In case your application doesn't use the Spring Boot Devtools the `watch` goal performs a complete restart of the Spring Boot application after CDS model changes. As the application context reload is always faster than a complete restart the approach using the Spring Boot Devtools is the preferred approach.

::: warning
On Windows, the `watch` goal only works if the Spring Boot Devtools are enabled.
:::

### CDS Auto-Build

If you want to have the comfort of an automated CDS build like with the `watch` goal but want to control your CAP Java application from within the IDE, you can use the `auto-build` goal. This goal reacts on any CDS file change and performs a rebuild of your applications's CDS model. However, no CAP Java application is started by the goal. This doesn't depend on Spring Boot Devtools support.

::: tip
If the Spring Boot Devtools configuration of your CAP Java application defines a [trigger file](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.devtools.restart.triggerfile), the `auto-build` can detect this and touch the trigger file in case of any file change. The same applies to the `watch` goal.
:::

### Multitenant Applications

With the streamlined MTX, you can run your multitenant application locally along with the MTX sidecar and use SQLite as the database.
See [the _Multitenancy_ guide](../../guides/multitenancy/#test-locally) for more information.


## Debugging

You can debug both local and remote Java applications.

- For local applications, it's best to start the application using the integrated debugger of your [preferred IDE](../../tools/cds-editors).
- Especially for remote applications, we recommend [`cds debug`](../../tools/cds-cli#java-applications) to turn on debugging.



# Testing Applications { #testing-cap-java-applications }



This section describes some best practices and recommendations for testing CAP Java applications.

As described in [Modular Architecture](building#starter-bundles#modular_architecture), a CAP Java application consists of weakly coupled components, which enables you to define your test scope precisely and focus on parts that need a high test coverage.

Typical areas that require testing are the [services](../cqn-services/#cdsservices) that dispatch events to [event handlers](../event-handlers/), the event handlers themselves that implement the behaviour of the services, and finally the APIs that the application services define and that are exposed to clients through [OData](../cqn-services/application-services#odata-requests).

::: tip
Aside from [JUnit](https://junit.org/junit5/), the [Spring framework](https://docs.spring.io/spring-framework/docs/current/reference/html/index.html) provides much convenience for both unit and integration testing, like dependency injection via [*autowiring*](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire) or the usage of [MockMvc](https://docs.spring.io/spring-framework/reference/testing/mockmvc.html) and [*mocked users*](https://docs.spring.io/spring-security/reference/servlet/test/method.html#test-method-withmockuser). So whenever possible, it's recommended to use it for writing tests.
:::

## Sample Tests

To illustrate this, the following examples demonstrate some of the recommended ways of testing. All the examples are taken from the [CAP Java bookshop sample project](https://github.com/SAP-samples/cloud-cap-samples-java/) in a simplified form, so definitely have a look at this as well.

Let's assume you want to test the following custom event handler:

```java
@Component
@ServiceName(CatalogService_.CDS_NAME)
public class CatalogServiceHandler implements EventHandler {

    private final PersistenceService db;

    public CatalogServiceHandler(PersistenceService db) {
        this.db = db;
    }

    @On
    public void onSubmitOrder(SubmitOrderContext context) {
        Integer quantity = context.getQuantity();
        String bookId = context.getBook();

        Optional<Books> book = db.run(Select.from(BOOKS).columns(Books_::stock).byId(bookId)).first(Books.class);

        book.orElseThrow(() -> new ServiceException(ErrorStatuses.NOT_FOUND, MessageKeys.BOOK_MISSING)
            .messageTarget(Books_.class, b -> b.ID()));

        int stock = book.map(Books::getStock).get();

        if (stock >= quantity) {
            db.run(Update.entity(BOOKS).byId(bookId).data(Books.STOCK, stock -= quantity));
            SubmitOrderContext.ReturnType result = SubmitOrderContext.ReturnType.create();
            result.setStock(stock);
            context.setResult(result);
        } else {
            throw new ServiceException(ErrorStatuses.CONFLICT, MessageKeys.ORDER_EXCEEDS_STOCK, quantity);
        }
    }

    @After(event = CqnService.EVENT_READ)
    public void discountBooks(Stream<Books> books) {
        books.filter(b -> b.getTitle() != null).forEach(b -> {
            loadStockIfNotSet(b);
            discountBooksWithMoreThan111Stock(b);
        });
    }

    private void discountBooksWithMoreThan111Stock(Books b) {
        if (b.getStock() != null && b.getStock() > 111) {
            b.setTitle(String.format("%s -- 11%% discount", b.getTitle()));
        }
    }

    private void loadStockIfNotSet(Books b) {
        if (b.getId() != null && b.getStock() == null) {
            b.setStock(db.run(Select.from(BOOKS).byId(b.getId()).columns(Books_::stock)).single(Books.class).getStock());
        }
    }
}
```

::: tip
You can find a more complete sample of the previous snippet in our [CAP Java bookshop sample project](https://github.com/SAP-samples/cloud-cap-samples-java/blob/main/srv/src/main/java/my/bookshop/handlers/CatalogServiceHandler.java).
:::

The `CatalogServiceHandler` here implements two handler methods -- `onSubmitOrder` and `discountBooks` -- that should be covered by tests.

The method `onSubmitOrder` is registered to the `On` phase of a `SubmitOrder` event and basically makes sure to reduce the stock quantity of the ordered book by the order quantity, or, in case the order quantity exceeds the stock, throws a `ServiceException`.

Whereas `discountBooks` is registered to the `After` phase of a `read` event on the `Books` entity and applies a discount information to a book's title if the stock quantity is larger than 111.

## Event Handler Layer Testing

Out of these two handler methods `discountBooks` doesn't actually depend on the `PersistenceService`.

That allows us to verify its behavior in a unit test by creating a `CatalogServiceHandler` instance with the help of a `PersistenceService` mock to invoke the handler method on, as demonstrated below:

::: tip
For mocking, you can use [Mockito](https://site.mockito.org/), which is already included with the `spring-boot-starter-test` starter bundle.
:::

```java
@ExtendWith(MockitoExtension.class)
public class CatalogServiceHandlerTest {

    @Mock
    private PersistenceService db;

    @Test
    public void discountBooks() {
        Books book1 = Books.create();
        book1.setTitle("Book 1");
        book1.setStock(10);

        Books book2 = Books.create();
        book2.setTitle("Book 2");
        book2.setStock(200);

        CatalogServiceHandler handler = new CatalogServiceHandler(db);
        handler.discountBooks(Stream.of(book1, book2));

        assertEquals("Book 1", book1.getTitle(), "Book 1 was discounted");
        assertEquals("Book 2 -- 11% discount", book2.getTitle(), "Book 2 was not discounted");
    }
}
```

::: tip
You can find a variant of this sample code also in our [CAP Java bookshop sample project](https://github.com/SAP-samples/cloud-cap-samples-java/blob/main/srv/src/test/java/my/bookshop/handlers/CatalogServiceHandlerTest.java).
:::

Whenever possible, mocking dependencies and just testing the pure processing logic of an implementation allows you to ignore the integration bits and parts of an event handler, which is a solid first layer of your testing efforts.

## Service Layer Testing

[Application Services](../cqn-services/application-services) that are backed by an actual service definition within the `CdsModel` implement an interface, which extends the `Service` interface and offers a common `CQN execution API` for `CRUD` events. This API can be used to run `CQN` statements directly against the service layer, which can be used for testing, too.

To verify the proper discount application in our example, we can run a `Select` statement against the `CatalogService` and assert the result as follows, using a well-known dataset:

```java
@ExtendWith(SpringExtension.class)
@SpringBootTest
public class CatalogServiceTest {

    @Autowired
    @Qualifier(CatalogService_.CDS_NAME)
    private CqnService catalogService;

    @Test
    public void discountApplied() {
        Result result = catalogService.run(Select.from(Books_.class).byId("51061ce3-ddde-4d70-a2dc-6314afbcc73e"));

        // book with title "The Raven" and a stock quantity of > 111
        Books book = result.single(Books.class);

        assertEquals("The Raven -- 11% discount", book.getTitle(), "Book was not discounted");
    }
}
```

As every service in CAP implements the [Service](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/Service.html) interface with its [emit(EventContext)](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/Service.html#emit-com.sap.cds.services.EventContext-) method, another way of testing an event handler is to dispatch an event context via the `emit()` method to trigger the execution of a specific handler method.

Looking at the `onSubmitOrder` method from our example above we see that it uses an event context called `SubmitOrderContext`. Therefore, using an instance of that event context, in order to test the proper stock reduction, we can trigger the method execution and assert the result, as demonstrated:

```java
@SpringBootTest
public class CatalogServiceTest {

    @Autowired
    @Qualifier(CatalogService_.CDS_NAME)
    private CqnService catalogService;

    @Test
    public void submitOrder() {
        SubmitOrderContext context = SubmitOrderContext.create();

        // ID of a book known to have a stock quantity of 22
        context.setBook("4a519e61-3c3a-4bd9-ab12-d7e0c5329933");
        context.setQuantity(2);
        catalogService.emit(context);

        assertEquals(22 - context.getQuantity(), context.getResult().getStock());
    }
}
```

In the same way you can verify that the `ServiceException` is being thrown when the order quantity exceeds the stock value:

```java
@SpringBootTest
public class CatalogServiceTest {

    @Autowired
    @Qualifier(CatalogService_.CDS_NAME)
    private CqnService catalogService;

    @Test
    public void submitOrderExceedingStock() {
        SubmitOrderContext context = SubmitOrderContext.create();

        // ID of a book known to have a stock quantity of 22
        context.setBook("4a519e61-3c3a-4bd9-ab12-d7e0c5329933");
        context.setQuantity(30);
        catalogService.emit(context);

        assertThrows(ServiceException.class, () -> catalogService.emit(context), context.getQuantity() + " exceeds stock for book");
    }
}
```

::: tip
For a more extensive version of the previous `CatalogServiceTest` snippets, have a look at our [CAP Java bookshop sample project](https://github.com/SAP-samples/cloud-cap-samples-java/blob/main/srv/src/test/java/my/bookshop/CatalogServiceTest.java).
:::

## Integration Testing

Integration tests enable us to verify the behavior of a custom event handler execution doing a roundtrip starting at the protocol adapter layer and going through the whole CAP architecture until it reaches the service and event handler layer and then back again through the protocol adapter.

As the services defined in our `CDS model` are exposed as `OData` endpoints, by using [MockMvc](https://docs.spring.io/spring-framework/reference/testing/mockmvc.html) we can simply invoke a specific `OData` request and assert the response from the addressed service.

The following demonstrates this by invoking a `GET` request to the `OData` endpoint of our `Books` entity, which triggers the execution of the `discountBooks` method of the `CatalogServiceHandler` in our example:

```java
@SpringBootTest
@AutoConfigureMockMvc
public class CatalogServiceITest {

    private static final String booksURI = "/api/browse/Books";

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void discountApplied() throws Exception {
        mockMvc.perform(get(booksURI + "?$filter=stock gt 200&top=1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.value[0].title").value(containsString("11% discount")));
    }

    @Test
    public void discountNotApplied() throws Exception {
        mockMvc.perform(get(booksURI + "?$filter=stock lt 100&top=1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.value[0].title").value(not(containsString("11% discount"))));
    }
}
```

::: tip
Check out the version in our [CAP Java bookshop sample project](https://github.com/SAP-samples/cloud-cap-samples-java/blob/main/srv/src/test/java/my/bookshop/CatalogServiceITest.java) for additional examples of integration testing.
:::



# Configuring Applications



## Profiles and Properties

This section describes how to configure applications.
CAP Java applications can fully leverage [Spring Boot's](../spring-boot-integration) capabilities for [Externalized Configuration](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config).
This enables you to define multiple **configuration profiles** for different scenarios, like local development and cloud deployment.

For a first introduction, have a look at our [sample application](https://github.com/sap-samples/cloud-cap-samples-java) and the [configuration profiles](https://github.com/SAP-samples/cloud-cap-samples-java/blob/master/srv/src/main/resources/application.yaml) we added there.

Now, that you're familiar with how to configure your application, start to create your own application configuration. See the full list of [CDS properties](properties) as a reference.

### Production Profile { #production-profile }

When running your application in production, it makes sense to strictly disable some development-oriented features.
The production profile configures a set of selected property defaults, recommended for production deployments, at once.
By default the production profile is set to `cloud`. To specify a custom production profile, set `cds.environment.production.profile` to a Spring profile used in your production deployments.

::: tip Production profile = `cloud`
The Java Buildpacks set the `cloud` profile for applications by default.
Other active profiles for production deployments are typically set using the environment variable `SPRING_PROFILES_ACTIVE` on your application in your deployment descriptors (`mta.yaml`, Helm charts, etc.).
:::

Property defaults adjusted with the production profile are the following:

- Index Page is disabled: `cds.index-page.enabled` is set to `false`
- Mock Users are strictly disabled: `cds.security.mock.enabled` is set to `false`

Note, that explicit configuration in the application takes precedence over property defaults from the production profile.

## Using SAP Java Buildpack { #buildpack }

In SAP BTP Cloud Foundry environment, the Java runtime that is used to run your application is defined by the so-called [buildpack](https://docs.cloudfoundry.org/buildpacks/).
For CAP applications, we advise you to use the [SAP Java Buildpack 2](https://help.sap.com/docs/btp/sap-business-technology-platform/sap-jakarta-buildpack).
CAP applications built with Spring Boot don't require any specific configuration for the buildpack and run using [Java Main](https://help.sap.com/docs/btp/sap-business-technology-platform/java-main) runtime by default.

To configure the buildpack for Java 21 with SapMachine JRE, add the following lines to your `mta.yaml` right under your Java service definition:

::: code-group
```yaml [mta.yaml]
parameters:
  buildpack: sap_java_buildpack_jakarta
properties:
  JBP_CONFIG_COMPONENTS: "jres: ['com.sap.xs.java.buildpack.jre.SAPMachineJRE']"
  JBP_CONFIG_SAP_MACHINE_JRE: '{ version: 21.+ }'
```
:::

:::warning SAP Business Application Studio
If you develop your application in SAP Business Application Studio and Java 21 is not available there, use the Java 17, instead.
:::





# CDS Properties

The following table lists all configuration properties that can be used to configure
<span class="nowrap">CAP Java {{ version }}</span>.
You can set them in your project's `application.yml`.

::: tip
In property files `<index>` should be replaced with a number and `<key>` with an arbitrary String. In YAML files, you can use standard YAML list and map structures.
:::

[Learn more about Spring Properties.](https://docs.spring.io/spring-boot/how-to/properties-and-configuration.html){.learn-more}

<table>
  <thead>
    <tr>
      <th class="anchor"></th>
      <th class="prop">Property</th>
      <th class="java-type">Type</th>
      <th class="default">Default Value</th>
      <th class="descr">Description</th>
    </tr>
  </thead>
  <tr v-for="p in properties" :key="p.name" :id="p.anchor">
    <td class="anchor"><a :href="'#'+p.anchor" class="header-anchor"></a></td>
    <td class="prop"      v-html="p.name" :class="{ group: p.header }"></td>
    <td class="java-type" v-html="p.type"></td>
    <td class="default" v-html="p.defaultValue"></td>
    <td class="descr"   v-html="p.description"></td>
  </tr>
</table>





# Operating CAP Java Applications

Learn here about operating a CAP Java application.



<IndexList :pages='pages' />



# Optimizing Applications


## Profiling { #profiling}

To minimize overhead at runtime, [monitoring](observability#monitoring) information is gathered rather on a global application level and hence might not be sufficient to troubleshoot specific issues.
In such a situation, the use of more focused profiling tools can be an option.
Typically, such tools can focus on a specific aspect of an application (for instance CPU or Memory management), but they come with an additional overhead and should only be enabled when needed. Hence, they need to meet the following requirements:

* Switchable at runtime
* Use a communication channel not exposed to unauthorized users
* Not interfering or even blocking business requests

How can dedicated Java tools access the running services in a secure manner? The depicted diagram shows recommended options that **do not require exposed HTTP endpoints**:

![This screenshot is explained in the accompanying text.](./assets/remote-tracing.png){}

As an authorized operator, you can access the container and start tools [locally](#profiling-local) in a CLI session running with the same user as the target process. Depending on the protocol, the JVM supports on-demand connections, for example, JVM diagnostic tools such as `jcmd`. Alternatively, additional JVM configuration is required as a prerequisite (JMX).

### Local Tools { #profiling-local}

Various CLI-based tools for JVMs are delivered with the SDK. Popular examples are [diagnostic tools](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/toc.html) such as `jcmd`, `jinfo`, `jstack`, and `jmap`, which help to fetch basic information about the JVM process regarding all relevant aspects. You can take stack traces, heap dumps, fetch garbage collection events and read Java properties and so on.
The SAP JVM comes with additional handy profiling tools: `jvmmon` and `jvmprof`. The latter, for instance,  provides a helpful set of traces that allow a deep insight into JVM resource consumption. The collected data is stored within a `prf`-file and can be analyzed offline in the [SAP JVM Profiler frontend](https://wiki.scn.sap.com/wiki/display/ASJAVA/Features+and+Benefits).

<span id="cfclijava" />
<Fragment target="#cfclijava" type="">

### Cloud Foundry Command Line Java Plugin

The [Java Plugin](https://github.com/SAP/cf-cli-java-plugin) for the [Cloud Foundry cli](https://github.com/cloudfoundry/cli) tool provides convenience utilities to work with Java applications deployed on Cloud Foundry. It helps to create heap dumps, thread dumps and profiling records of deployed and running Java application instances.

Find the installation information in the plugin's [ReadMe](https://github.com/SAP/cf-cli-java-plugin?tab=readme-ov-file#installation).

#### Creating Heap Dumps

```sh
cf java heap-dump sample-app-srv
```

Produces a `.hprof` file which can be viewed in a Java heap analyzer, such as [Memory Analyzer (MAT)](https://eclipse.dev/mat/).

#### Creating Thread Dumps

```sh
cf java thread-dump sample-app-srv > thread-dump.txt
```

Produces a thread dump on `stdout` which is here piped into a file for persistence.

#### Async Profiler

Using `cf java` to profile Java applications on Cloud Foundry with the [Async Profiler](https://github.com/async-profiler/async-profiler?tab=readme-ov-file#async-profiler) requires the [SAP Java Buildpack](https://help.sap.com/docs/btp/sap-business-technology-platform/sap-jakarta-buildpack?version=Cloud) and SapMachine 17 or 21.

Make sure [SSH Access](https://github.com/SAP/cf-cli-java-plugin?tab=readme-ov-file#ssh-access) is enabled for the deployed application. Once enabled, you can start profiling easily using `cf java`.

`cf java` provides the following **async-profiler** related commands:

- `asprof-start-cpu`
  
  Start an async-profiler CPU-time profile recording on a running Java application
  
- `asprof-start-wall`

  Start an async-profiler wall-clock profile recording on a running Java application
  
- `asprof-start-alloc`
  
  Start an async-profiler allocation profile recording on a running Java application
  
- `asprof-start-lock`
  
  Start an async-profiler lock profile recording on a running Java application
  
- `asprof-stop`
  
  Stop an async-profiler profile recording on a running Java application
  
- `asprof-status`
  
  Get the status of async-profiler on a running Java application
  
- `asprof` (*Expert Mode*)
  
  Run async-profiler commands passed to asprof via --args
  
##### Usage
  
The typical usage would be

1. Start profiling with one of `asprof-start-cpu` , `asprof-start-wall` , `asprof-start-alloc` , `asprof-start-lock`:

   ```sh
   cf java asprof-start-cpu sample-app-srv
   ```

2. Produce some load in your Java application.

3. Optional: Check current async-profiler status:

   ```sh
   cf java asprof-status sample-app-srv
   ```

4. Stop profiling:

   ```sh
   cf java asprof-stop sample-app-srv
   ```

    `asprof-stop` produces a `.jfr` file in your current local working directory. `.jfr` files are *JFR recordings* and can be viewed, for instance,  using [multiple options](https://github.com/async-profiler/async-profiler/blob/master/docs/JfrVisualization.md).

:::tip
Profiling accuracy improves if the following JVM arguments are set:

- **-XX:+UnlockDiagnosticVMOptions**
- **-XX:+DebugNonSafepoints**

These can be set in a running application as follows:

```sh
cf set-env sample-app-srv JBP_CONFIG_JAVA_OPTS "[java_opts: '-XX:+UnlockDiagnosticVMOptions -XX:+DebugNonSafepoints']"
```

Then restage your application:

```sh
cf restage sample-app-srv
```

:::

</Fragment>

### Remote JMX-Based Tools { #profiling-jmx}

Java's standardized framework [Java Management Extensions](https://www.oracle.com/java/technologies/javase/javamanagement.html) (JMX) allows introspection and monitoring of the JVM's internal state via exposed Management Beans (MBeans). MBeans also allow to trigger operations at runtime, for instance setting a logger level. Spring Boot automatically creates a bunch of MBeans reflecting the current [Spring configuration and metrics](observability#spring-boot-actuators) and offers convenient ways for customization. To activate JMX in Spring, add the following property to your application configuration.:

```sh
spring.jmx.enabled: true
```

In addition, to enable remote access, add the following JVM parameters to open JMX on a specific port (for example, 5000) in the local container:

```sh
-Djava.rmi.server.hostname=localhost
-Dcom.sun.management.jmxremote
-Dcom.sun.management.jmxremote.port=<port>
-Dcom.sun.management.jmxremote.rmi.port=<port>
-Dcom.sun.management.jmxremote.authenticate=false
-Dcom.sun.management.jmxremote.ssl=false
```

::: warning Don't use public endpoints with JMX/MBeans
Exposing JMX/MBeans via a public endpoint can pose a serious security risk.
:::

To establish a connection with a remote JMX client, first open an ssh tunnel to the application via `cf` CLI as operator user:

```sh
cf ssh -N -T -L <local-port>:localhost:<port> <app-name>
```

Afterwards, connect to `localhost:<local-port>` in the JMX client. Common JMX clients are:

- [JConsole](https://openjdk.java.net/tools/svc/jconsole/), which is part of the JDK delivery.
- [OpenJDK Mission Control](https://github.com/openjdk/jmc), which can be installed separately.



## GraalVM Native Image Support <Beta /> { #graalvm-native-image-support-beta }

Since Spring Boot 3 it's possible to compile Spring Boot applications to stand-alone native executables leveraging GraalVM Native Images.
Native Image applications have faster startup times and require less memory. CAP Java provides compatibility with the Native Image technology.

[Learn more about Native Image support in Spring Boot.](https://docs.spring.io/spring-boot/how-to/native-image/index.html){.learn-more}

If you want to compile your application as a native executable the following boundary conditions need to be considered:

1. The GraalVM Native Image build analyzes your application from the `main` entry point. Only the code that is reachable through static analysis is included into the native image. This means that the full classpath needs to be known and available already at build time.

2. Dynamic elements of your code, such as usage of reflection, JDK proxies, or resources need to be registered with the GraalVM Native Image build. You can learn more about this in the [GraalVM Native Image documentation](https://www.graalvm.org/latest/reference-manual/native-image/metadata/).

    ::: tip
    Many runtime hints for reflection, JDK proxy usage, and resources are contributed automatically to the Native Image build.
    This includes
    - Required reflection for event handler classes defined in application code.
    - JDK proxies for interfaces generated from the application's CDS model by the CDS Maven Plugin.
    :::

3. Spring Boot automatically defines and fixes all bean definitions of your application at build time. If you have bean definitions that are created based on conditions on externalized configuration or profiles, you need to supply these triggers to the Native Image build.

    CAP Java also creates various bean definitions based on service bindings. Therefore, you need to provide the metadata of expected service bindings at runtime already during build time. This is similar to the information you define in deployment descriptors (for example `mta.yaml` or Helm charts). This information is also required to be supplied to the Native Image build.

    The Spring Boot Maven Plugin allows you to [configure the Spring profiles](https://docs.spring.io/spring-boot/docs/current/reference/html/howto.html#howto.aot.conditions) that are used during the Native Image build. You can supply information to the Native Image Build in a `native-build-env.json`, which you can configure together with the Spring profile. For example you can provide information to the Native image build in the `native-build-env.json` which you can configure together with the spring profile in the `srv/pom.xml`:

    ::: code-group
    ```json [native-build-env.json]
    {
        "hana": [ { "name": "<hana-binding-name>" } ],
        "xsuaa": [ { "name": "<xsuaa-binding-name>" } ]
    }
    ```
    ```xml [srv/pom.xml]
    <profile>
        <id>native</id>
        <build>
            <pluginManagement>
                <plugins>
                    <plugin>
                        <groupId>org.springframework.boot</groupId>
                        <artifactId>spring-boot-maven-plugin</artifactId>
                        <executions>
                            <execution>
                                <id>process-aot</id>
                                <configuration>
                                    <profiles>cloud</profiles>
                                    <jvmArguments>-Dcds.environment.local.defaultEnvPath=../native-build-env.json</jvmArguments>
                                </configuration>
                            </execution>
                        </executions>
                    </plugin>
                </plugins>
            </pluginManagement>
        </build>
    </profile>
    ```
    :::

When using Spring Boot's parent POM, you can easily trigger the Native Image build by executing `mvn spring-boot:build-image -Pnative`.
This builds a Docker image using Cloud Native Buildpacks including a minimized OS and your application.
You can launch the Docker image by running `docker run --rm -p 8080:8080 <srv-project-name>:<version>`.

::: tip
If you want to try out CAP's Native Image support you can use the [SFlight sample application](https://github.com/SAP-samples/cap-sflight) which is prepared for GraalVM Native Images.
Note, that SFlight's native executable is built and configured to use SAP HANA and XSUAA by default. You therefore need to run it with the `cloud` profile and supply an SAP HANA and XSUAA service binding.
Alternatively you can make corresponding adaptations in `native-build-env.json` and `srv/pom.xml` to build the native executable for a different set of service bindings and profile.
:::


<div id="secondary-file">java/operating-applications/optimizing.fragment.md</div>


# Observability


Presents a set of recommended tools that help to understand the current status of running CAP services.

## Logging { #logging}

When tracking down erroneous behavior, *application logs* often provide useful hints to reconstruct the executed program flow and isolate functional flaws. In addition, they help operators and supporters to keep an overview about the status of a deployed application. In contrast, messages created using the [Messages API](../event-handlers/indicating-errors#messages) in custom handlers are reflected to the business user who has triggered the request.


### Logging Façade { #logging-facade}

Various logging frameworks for Java have evolved and are widely used in Open Source software. Most prominent are `logback`, `log4j`, and `JDK logging` (`java.util.logging` or briefly `jul`). These well-established frameworks more or less deal with the same problem domain, that is:

- Logging API for (parameterized) messages with different log levels.
- Hierarchical logger components that can be configured independently.
- Separation of log input (messages, parameters, context) and log output (format, destination).

CAP Java SDK seamlessly integrates with Simple Logging Façade for Java ([SLF4J](https://www.slf4j.org)), which provides an abstraction layer for logging APIs. Applications compiled against SLF4J are free to choose a logging framework implementation at deployment time. Most famous libraries have a native integration to SLF4J, but it also can bridge legacy logging API calls:

![](./assets/slf4j.png){}

### Logger API { #logging-api}

The SLF4J API is simple to use. Retrieve a logger object, choose the log method of the corresponding log level and compose a message with optional parameters via the Java API:

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

Logger logger = LoggerFactory.getLogger("my.loggers.order.consolidation");

@After(event = CqnService.EVENT_READ)
public void readAuthors(List<Orders> orders) {
	orders.forEach(order -> {
		logger.debug("Consolidating order {}", order);
		consolidate(order);
	});
	logger.info("Consolidated {} orders", orders.size());
}
```

Some remarks:

* [Spring Boot Logging](#logging-configuration) shows how to configure loggers individually to control the emitted log messages.
* The API is robust with regards to the passed parameters, which means no exception is thrown on parameters mismatch or invalid parameters.

::: tip
Prefer *passing parameters* over *concatenating* the message. `logger.info("Consolidating order " + order)` creates the message `String` regardless the configured log level. This can have a negative impact on performance.
:::

::: tip
A `ServiceException` thrown in handler code and indicating a server error (that is, HTTP response code `5xx`) is *automatically* logged as error along with a stacktrace.
:::


### Spring Boot Logging { #logging-configuration}

To set up a logging system, a concrete logging framework has to be chosen and, if necessary, corresponding SLF4j adapters.
In case your application runs on Spring Boot and you use the Spring starter packages, **you most likely don't have to add any explicit dependency**, as the bundle `spring-boot-starter-logging` is part of all Spring Boot starters. It provides `logback` as default logging framework and in addition adapters for the most common logging frameworks (`log4j` and `jul`).

Similarly, no specific log output configuration is required for local development, as per default, log messages are written to the console in human-readable form, which contains timestamp, thread, and logger component information. To customize the log output, for instance to add some application-specific information, you can create corresponding configuration files (such as `logback-spring.xml` for logback). Add them to the classpath and Spring picks them automatically. Consult the documentation of the dedicated logging framework to learn about the configuration file format.

All logs are written, that have a log level greater or equal to the configured log level of the corresponding logger object.
The following log levels are available:

| Level   | Use case                                                 |
| :------ | :------------------------------------------------------- |
| `OFF`   | Turns off the logger                                     |
| `TRACE` | Tracks the application flow only                         |
| `DEBUG` | Shows diagnostic messages                                |
| `INFO`  | Shows important flows of the application (default level) |
| `WARN`  | Indicates potential error scenarios                      |
| `ERROR` | Shows errors and exceptions                              |

With Spring Boot, there are different convenient ways to configure log levels in a development scenario, which is explained in the following section.

#### At Compile Time { #logging-configuration-compiletime}

The following log levels can be configured:

::: code-group
```sh [srv/src/main/resources/application.yaml]
# Set new default level
logging.level.root: WARN

# Adjust custom logger
logging.level.my.loggers.order.Consolidation: INFO

# Turn off all loggers matching org.springframework.*:
logging.level.org.springframework: OFF
```
:::

Note that loggers are organized in packages, for instance `org.springframework` controls all loggers that match the name pattern `org.springframework.*`.

#### At Runtime with Restart { #logging-configuration-restart}

You can overrule the given logging configuration with a corresponding environment variable. For instance, to set loggers in package `my.loggers.order` to `DEBUG` level set the following environment variable:

```sh
LOGGING_LEVEL_MY_LOGGERS_ORDER=DEBUG
```

and restart the application.
::: tip
Note that Spring normalizes the variable's suffix to lower case, for example, `MY_LOGGERS_ORDER` to `my.loggers.order`, which actually matches the package name. However, configuring a dedicated logger (such as `my.loggers.order.Consolidation`) can't work in general as class names are in camel case typically.
:::

::: tip
On SAP BTP, Cloud Foundry environment, you can add the environment variable with `cf set-env <app name> LOGGING_LEVEL_MY_LOGGERS_ORDER DEBUG`. Don't forget to restart the application with `cf restart <app name>` afterwards. The additional configuration endures an application restart but might be lost on redeployment.
:::

#### At Runtime Without Restart { #logging-configuration-runtime}

If configured, you can use [Spring actuators](https://docs.spring.io/spring-boot/docs/current/reference/html/actuator.html) to view and adjust logging configuration. Disregarding security aspects and provided that the `loggers` actuator is configured as HTTP endpoint on path `/actuator/loggers`, following example HTTP requests show how to accomplish this:

```sh
# retrieve state of all loggers:
curl https://<app-url>/actuator/loggers

# retrieve state of single logger:
curl https://<app-url>/actuator/loggers/my.loggers.oder.consolidation
#> {"configuredLevel":null,"effectiveLevel":"INFO"}

# Change logging level:
curl -X POST -H 'Content-Type: application/json' -d '{"configuredLevel": "DEBUG"}' \
  https://<app-url>/actuator/loggers/my.loggers.oder.consolidation
```

[Learn more about Spring actuators and security aspects in the section **Metrics**.](#spring-boot-actuators){ .learn-more}

#### Predefined Loggers { #predefined-loggers}

CAP Java SDK has useful built-in loggers that help to track runtime behavior:

| Logger                                | Use case                                                                                             |
| :------------------------------------ | :--------------------------------------------------------------------------------------------------- |
| `com.sap.cds.security.authentication` | Logs authentication and user information                                                             |
| `com.sap.cds.security.authorization`  | Logs authorization decisions                                                                         |
| `com.sap.cds.odata.v2`                | Logs OData V2 request handling in the adapter                                                        |
| `com.sap.cds.odata.v4`                | Logs OData V4 request handling in the adapter                                                        |
| `com.sap.cds.handlers`                | Logs sequence of executed handlers as well as the lifecycle of RequestContexts and ChangeSetContexts |
| `com.sap.cds.persistence.sql`         | Logs executed queries such as CQN and SQL statements (w/o parameters)                                |
| `com.sap.cds.persistence.sql-tx`      | Logs transactions, ChangeSetContexts, and connection pool                                            |
| `com.sap.cds.multitenancy`            | Logs tenant-related events and sidecar communication                                                 |
| `com.sap.cds.messaging`               | Logs messaging configuration and messaging events                                                    |
| `com.sap.cds.remote.odata`            | Logs request handling for remote OData calls                                                         |
| `com.sap.cds.remote.wire`             | Logs communication of remote OData calls                                                             |
| `com.sap.cds.auditlog`                | Logs audit log events                                                                                |
| `com.sap.cds.properties`              | Logs CDS properties with a non-default value on application startup                                  |

Most of the loggers are used on DEBUG level by default as they produce quite some log output. It's convenient to control loggers on package level, for example, `com.sap.cds.security` covers all loggers that belong to this package (namely `com.sap.cds.security.authentication` and `com.sap.cds.security.authorization`).

::: tip
Spring comes with its own [standard logger groups](https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/reference/html/boot-features-logging.html#boot-features-custom-log-groups). For instance, `web` is useful to track HTTP requests. However, HTTP access logs gathered by the Cloud Foundry platform router are also available in the application log.
:::

#### Log CDS Configuration

Upon start-up, you can get an overview of the configured CDS properties. Use this feature to:
- list all accepted CDS properties and double-check the running configuration
- check for warnings of usage of deprecated properties
- check for warnings of usage of undocumented properties

Please note that secrets are masked.

Turn it on by setting the log level <Config Java>com.sap.cds.properties = DEBUG</Config>.


::: details Sample output:

```sh
... DEBUG ... com.sap.cds.properties : 'cds.dataSource.autoConfig.enabled': 'false' (default: 'true')
... DEBUG ... com.sap.cds.properties : 'cds.dataSource.embedded': 'true' (default: 'false')
...  WARN ... com.sap.cds.properties : 'cds.security.authorization.emptyAttributeValuesAreRestricted': 'false' (default: 'true', deprecated, not documented)
... DEBUG ... com.sap.cds.properties : 'cds.security.mock.users.admin.name': 'admin'
... DEBUG ... com.sap.cds.properties : 'cds.security.mock.users.admin.password': '***' (sensitive)
... DEBUG ... com.sap.cds.properties : 'cds.security.mock.users.admin.roles[0]': 'admin'
... DEBUG ... com.sap.cds.properties : 'cds.security.mock.users.admin.roles[1]': 'cds.Developer'
... DEBUG ... com.sap.cds.properties : 'cds.security.mock.users.admin.attributes.businessPartner[0]': '10401010'
... DEBUG ... com.sap.cds.properties : 'cds.odataV4.endpoint.path': '/api' (default: '/odata/v4')
... DEBUG ... com.sap.cds.properties : 'cds.errors.defaultTranslations.enabled': 'true' (default: 'false')
```
:::

### Logging Service { #logging-service}

The SAP BTP platform offers the [SAP Application Logging service for SAP BTP](https://help.sap.com/docs/r/product/APPLICATION_LOGGING)
and its recommended successor [SAP Cloud Logging](https://help.sap.com/docs/cloud-logging) service to which bound Cloud Foundry applications can stream logs.

Establishing a connection is the same for both services: The application needs to be [bound to the service](https://help.sap.com/docs/application-logging-service/sap-application-logging-service/produce-logs-container-metrics-and-custom-metrics). To match the log output format and structure expected by the logging service, it's recommended to use a prepared encoder from [cf-java-logging-support](https://github.com/SAP/cf-java-logging-support) that matches the configured logger framework. `logback` is used by default as outlined in [Logging Frameworks](#logging-configuration):

```xml [srv/pom.xml]
<dependency>
	<groupId>com.sap.hcp.cf.logging</groupId>
	<artifactId>cf-java-logging-support-logback</artifactId>
	<version>${logging.support.version}</version>
</dependency>
```

By default, the library appends additional fields to the log output such as correlation id or Cloud Foundry space. To instrument incoming HTTP requests, a servlet filter needs to be created. See [Instrumenting Servlets](https://github.com/SAP/cf-java-logging-support/wiki/Instrumenting-Servlets) for more details.

During local development, you might want to stick to the (human-readable) standard log line format. This boils down to having different logger configurations for different Spring profiles. The following sample configuration outlines how you can achieve this. `cf-java-logging-support` is only active for profile `cloud`, since all other profiles are configured with the standard logback output format:
::: code-group
```xml [srv/src/main/resources/logback-spring.xml]
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE xml>
<configuration debug="false" scan="false">
	<springProfile name="cloud">
		
		...
	</springProfile>
	<springProfile name="!cloud">
		<include resource="org/springframework/boot/logging/logback/base.xml"/>
	</springProfile>
</configuration>
```
:::

::: tip
For an example of how to set up a multitenant aware CAP Java application with enabled logging service support, have a look at section [Multitenancy > Adding Logging Service Support](../multitenancy#app-log-support).
:::

### Correlation IDs

In general, a request can be handled by unrelated execution units such as internal threads or remote services. This fact makes it hard to correlate the emitted log lines of the different contributors in an aggregated view. The problem can be solved by enhancing the log lines with unique correlation IDs, which are assigned to the initial request and propagated throughout the call tree.

In case you've configured `cf-java-logging-support` as described in [Logging Service](#logging-service) before, *correlation IDs are handled out of the box by the CAP Java SDK*. In particular, this includes:

- Generation of IDs in non-HTTP contexts
- Thread propagation through [Request Contexts](../event-handlers/request-contexts#threading-requestcontext)
- Propagation to remote services when called via CloudSDK (for instance [Remote Services](../cqn-services/remote-services) or [MTX sidecar](../multitenancy#setup-overview))

By default, the ID is accepted and forwarded via HTTP header `X-CorrelationID`. If you want to accept `X-Correlation-Id` header in incoming requests alternatively,
follow the instructions given in the guide [Instrumenting Servlets](https://github.com/SAP/cf-java-logging-support/wiki/Instrumenting-Servlets#correlation-id).

### JDBC Tracing in SAP Hana

To activate JDBC tracing in the SAP Hana JDBC driver, you have to use the driver [Trace Options](https://help.sap.com/docs/SAP_HANA_CLIENT/f1b440ded6144a54ada97ff95dac7adf/4033f8e603504c0faf305ab77627af03.html). You can activate it either by setting datasource properties in the `application.yaml` and restarting the application, or, while the application is running by using the [command line](https://help.sap.com/docs/SAP_HANA_CLIENT/f1b440ded6144a54ada97ff95dac7adf/e411647b03f1425fab1e33bb495c9c42.html).

#### Using datasource properties

In the `application.yaml` under `cds.dataSource.<service-binding-name>:` specify `hikari.data-source-properties.traceFile` and `hikari.data-source-properties.traceOptions`:

```yaml [srv/src/main/resources/application.yaml]
cds:
  dataSource:
    service-manager: # name of service binding
      hikari:
        data-source-properties:
          traceFile: "/home/user/jdbctraces/trace_.log" # use a path that is write accessible
          traceOptions: "CONNECTIONS,API,PACKET"
```

::: tip
 Add an underscore at the end of the trace file's name. It helps redability by separating the string of numbers that the JDBC tracing process appends for the epoch timestamp.

```sh
~/jdbctraces/ $ ls

trace_10324282997834295561.log
trace_107295864860396783.log
trace_10832681394984179734.log
...
```
:::

[Trace Options](https://help.sap.com/docs/SAP_HANA_CLIENT/f1b440ded6144a54ada97ff95dac7adf/4033f8e603504c0faf305ab77627af03.html) lists the available command line options. For the datasource property, you only need the option's name, such as `CONNECTIONS`, `API`, or `PACKET`. You can specify more than one option, separated by commas.

This method of activating JDBC tracing requires restarting the application. For cloud deployments on Cloud Foundry this typically means redeploying via MTA, on Kyma this means rebuilding the application, re-creating, and publishing the container image to the container image registry and redeploying the application via Helm.

Once the `application.yaml` of the deployed application contains both `hikari.data-source-properties.traceFile` and `hikari.data-source-properties.traceOptions`, their values can also be overwritten by setting the corresponding environment variables in the container.

For example, to overwrite the tracefile path for the `application.yaml` you have to set the environment variable such as this with `SERVICE_MANAGER` being the name of the service binding:
```yaml
CDS_DATASOURCE_SERVICE_MANAGER_HIKARI_DATA_SOURCE_PROPERTIES_TRACEFILE: "/home/cnb/jdbctraces/sm/trace_.log"
```
To overwrite the tracing options respectively:
```yaml
CDS_DATASOURCE_SERVICE_MANAGER_HIKARI_DATA_SOURCE_PROPERTIES_TRACEOPTIONS: "DISTRIBUTIONS"
```

#### Using the command line

Using the command line to activate JDBC tracing doesn't require an application restart.

However, when running in the cloud it depends on the buildpacks used for the CAP Java application where the exact location of the Hana JDBC driver and the `java` executable are. The following assumes the usage of the [Cloud Native Buildpacks](https://pages.github.tools.sap/unified-runtime/docs/building-blocks/unified-build-and-deploy/buildpacks) as recommended by the [Unified Runtime](https://pages.github.tools.sap/unified-runtime/).


##### On Kyma

Step-by-step description on how to access a bash session in the application's container to use trace options in the Hana JDBC driver:

1. Run bash in the pod that runs the CAP Java application:

   First, identify the pod name:
   ```sh
   kubectl get pods
   ```
   in the right namespace run:
   ```sh
   kubectl exec -it pod/<POD_NAME> -- bash
   ```
   to acquire a bash session in the container.

1. Locate java executable and JDBC driver:

   By default `JAVA_HOME` isn't set in the buildpack and contains minimal tooling, as it tries to minimize the container size. However, the default location of the `java` executable is `/layers/paketo-buildpacks_sap-machine/jre/bin`.

   For convenience, store the path into a variable, for example, `JAVA_HOME`:
   ```sh
   export JAVA_HOME=/layers/paketo-buildpacks_sap-machine/jre/bin/
   ```

   The JDBC driver is usually located in `/workspace/BOOT-INF/lib`. Store it into another variable, for example, `JDBC_DRIVER_PATH`:
   ```sh
   export JDBC_DRIVER_PATH=/workspace/BOOT-INF/lib
   ```

1. Use JDBC trace options in the driver, using the correct (versioned) name of the `ngdbc.jar`:
   ```sh
   $JAVA_HOME/java -jar $JDBC_DRIVER_PATH/ngdbc-<VERSION>.jar <option>
   ```

   [Trace Options](https://help.sap.com/docs/SAP_HANA_CLIENT/f1b440ded6144a54ada97ff95dac7adf/4033f8e603504c0faf305ab77627af03.html) lists the available options.

   Before turning on tracing with `TRACE ON`, it's recommended to set `TRACE FILENAME` to a path that the current shell user has write access to, for example:
   ```sh
   $JAVA_HOME/java -jar $JDBC_DRIVER_PATH/ngdbc-<VERSION>.jar TRACE FILENAME ~/tmp/traces/jdbctrace
   ```

1. Read the trace file while the pod is still running, or use [`kubectl cp`](https://kubernetes.io/docs/reference/kubectl/generated/kubectl_cp/) to copy the file to your local machine.



## Monitoring { #monitoring }

Connect your productive application to a [monitoring](#monitoring) tool to identify resource bottlenecks at an early stage and to take appropriate countermeasurements.

When connected to a monitoring tool, applications can report information about memory, CPU, and network usage, which forms the basis for resource consumption overview and reporting capabilities.
In addition, call-graphs can be reconstructed and visualized that represent the flow of web requests within the components and services.

CAP Java integrates with the following monitoring tools:

- [Open Telemetry](#open-telemetry) for reporting signals like distributed traces, logs, and metrics into Open Telemetry-compliant solutions.
SAP Cloud Logging is supported with [minimal configuration](#open-telemetry-configuration-cls).

- [Dynatrace](#dynatrace) provides sophisticated features to monitor a solution on SAP BTP.

- [Spring Boot Actuators](#spring-boot-actuators) can help operators to quickly get an overview about the general status of the application on a technical level.

- [Availability](#availability) checks are offered by [SAP Cloud ALM for Operations](https://help.sap.com/docs/cloud-alm).

### Open Telemetry { #open-telemetry }

[Open Telemetry](https://opentelemetry.io/) is an Open Source framework for observability in cloud applications. Applications can collect signals (distributed traces and metrics) and send them to observability front ends that offer a wide set of capabilities to analyze the current state or failures of an application. On SAP BTP, for example, the [SAP Cloud Logging](https://help.sap.com/docs/cloud-logging) is offered as a front end for these purposes.

CAP Java applications can easily be configured to connect to SAP Cloud Logging or Dynatrace. In your CAP Java application, you configure one of these services inside the Open Telemetry configuration. Then the application automatically benefits from the following features:

- Out-of-the-box traces and metrics by auto-instrumented [libraries and frameworks](https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#libraries--frameworks)
- Additional traces for CAP-specific capabilities
- Automatic forwarding of telemetry signals (logs, traces, or metrics) to SAP BTP Cloud Logging or Dynatrace
- Full setup of Open Telemetry relevant configuration, including span hierarchy and Open Telemetry collectors

Spans and traces that are produced out of the box, include HTTP requests as well as CAP-specific execution of CQN statements or individual requests inside an OData $batch request. Metrics that are automatically provided, include standard JVM metrics like CPU and memory utilization.

In addition, it's possible to add manual instrumentations using the [Open Telemetry Java API](https://opentelemetry.io/docs/instrumentation/java/manual/), for example, in a custom event handler.

![This graphic shows several spans, which conclude a trace of a single HTTP request, including the time they're opened and closed.](./assets/screenshot_otel_trace.png){ class="mute-dark"}

#### Configure Java Agent and Extension Library { #agent-extension }

:::warning Dependency
The configuration steps below assume that your application uses the [SAP Java Buildpack](https://help.sap.com/docs/btp/sap-business-technology-platform/sap-jakarta-buildpack).
:::

:::tip
You can conveniently enhance your application with Open Telemetry observability by running the command `cds add cloud-logging --with-telemetry` in your project directory.
:::

Configure your application to enable the Open Telemetry Java Agent by adding or adapting the `JBP_CONFIG_JAVA_OPTS` parameter in your deployment descriptor:

::: code-group
```yaml [mta.yaml]
- name: <srv-module>
  # ...
  properties:
    # ...
    JBP_CONFIG_JAVA_OPTS:
      from_environment: false
      java_opts: >
        -javaagent:META-INF/.sap_java_buildpack/otel_agent/opentelemetry-javaagent.jar
        -Dotel.javaagent.extensions=META-INF/.sap_java_buildpack/otel_agent_extension/otel-agent-ext-java.jar
```
:::

The buildpack delivers the Open Telemetry Agent Extension library with the common configuration for Open Telemetry that applies to Cloud Logging Service and Dynatrace. This library provides out-of-the box configuration of the required credentials taken from the service bindings and more sophisticated configuration possibilities.

[Learn more in the Open Telemetry Agent Extension library documentation](https://github.com/SAP/cf-java-logging-support/tree/main/cf-java-logging-support-opentelemetry-agent-extension){.learn-more}

For troubleshooting purposes, you can increase the log level of the Open Telemetry Java Agent by adding the parameter `-Dotel.javaagent.debug=true` to the `JBP_CONFIG_JAVA_OPTS` argument.

::: tip Suppress auto-instrumentation for specific libraries
It's possible to suppress auto-instrumentation for specific libraries as described [here](https://opentelemetry.io/docs/instrumentation/java/automatic/agent-config/#suppressing-specific-agent-instrumentation). The corresponding `-Dotel.instrumentation.[name].enabled=false` parameter(s) can be added to the `JBP_JAVA_OPTS` argument.
:::

#### Configuration of Cloud Logging Service { #open-telemetry-configuration-cls }

Open Telemetry support using SAP BTP Cloud Logging Service leverages the [Open Telemetry Java Agent](https://opentelemetry.io/docs/instrumentation/java/automatic/) which needs to be attached to the CAP Java application. The following steps describe how this can be done:

1) Bind your CAP Java application to a service instance of `cloud-logging`. It's important to enable the Open Telemetry capabilities by passing `ingest_otlp` as additional configuration parameter. The following snippet shows an example how to add this to an _mta.yaml_ descriptor:
    ::: code-group
    ```yaml [mta.yaml]
    modules:
      - name: <srv-module>
        # ...
        requires:
          - name: cloud-logging-instance
    # ...
    resources:
      - name: cloud-logging-instance
        type: org.cloudfoundry.managed-service
        parameters:
          service: cloud-logging
          service-plan: standard
          config:
            ingest_otlp:
              enabled: true
    # ...
    ```
    :::

2) Define additional environment variables to tell the [agent extension](#agent-extension) to use Cloud Logging Service.

   ::: code-group
   ```yaml [mta.yaml]
   - name: <srv-module>
     # ...
     properties:
       # ...
       OTEL_METRICS_EXPORTER: cloud-logging
       OTEL_TRACES_EXPORTER: cloud-logging
       OTEL_LOGS_EXPORTER: none
   ```
   :::


#### Configuration of Dynatrace { #open-telemetry-configuration-dynatrace }

Open Telemetry support using Dynatrace leverages the _Dynatrace OneAgent_ for distributed traces and _Open Telemetry Java Agent_ for metrics. OpenTelemetry also can trace your application, but if you're using Dynatrace, it is better to leave the traces to the Dynatrace OneAgent to avoid trace duplication and inconsistencies in the trace data.

The following steps describe the required configuration:

1) Follow the description to [connect your CAP Java application to Dynatrace](#dynatrace). Make sure that the service binding or user-provided service provides an API token for dynatrace with scope `metrics.ingest`. The property name will be required in one of the following steps.

<div id="dynatrace-metrics-ingest"/>
<Fragment target="#dynatrace-metrics-ingest">

::: info <Internal />
If you are using the Dynatrace Service Broker which is available for SAP-internal usage, you can request the required API token with correct scopes as part of a service binding or service key. For details, refer to the [how to generate API tokens](https://pages.github.tools.sap/apm/docs/installation/cf/service-broker#api-tokens-via-service-bindings) documentation.
:::
</Fragment>

2) Open Telemetry support in OneAgent needs to be enabled once in your Dynatrace environment using the Dynatrace UI. Navigate to **Settings > Preferences > OneAgent features** and turn on the switch for **OpenTelemetry (Java)** as well as for **OpenTelemetry Java Instrumentation agent support**.
3) In addition, enable W3C Trace Context for proper context propagation between remote services. Navigate to **Settings > Server-side service monitoring > Deep monitoring > Distributed tracing** and turn on **Send W3C Trace Context HTTP headers**.
4) Define an additional environment variable to tell the [agent extension](#agent-extension) to export metrics to Dynatrace via OpenTelemetry.

   ::: code-group
    ```yaml [mta.yaml]
   - name: <srv-module>
     # ...
     properties:
       # ...
       OTEL_METRICS_EXPORTER: dynatrace
       OTEL_TRACES_EXPORTER: none
       OTEL_LOGS_EXPORTER: none
   ```
   :::

5) Check your Dynatrace binding. You are looking for two tokens generated for you: the default one is called `apitoken` and the second one should correspond to the token you have requested in your `mta.yaml` or generated from Dynatrace instance manually.
6) Add to the environment variable `JBP_CONFIG_JAVA_OPTS` the following option `-Dotel.javaagent.extension.sap.cf.binding.dynatrace.metrics.token-name=<ingest_apitoken>`. Replace the name `<ingest_apitoken>` with the name of the token you have found previously.

   Traces will be handled by the Dynatrace OneAgent and OpenTelemetry export for them is disabled to prevent the OpenTelemetry agent from interfering with that.


#### CAP Instrumentation

By default, instrumentation for CAP-specific components is disabled, so that no traces and spans are created even if the Open Telemetry Java Agent has been configured. It's possible to selectively activate specific spans by changing the log level for a component.

| Logger                                         | Required Level | Description                                                |
| ---------------------------------------------- | -------------- | ---------------------------------------------------------- |
| `com.sap.cds.otel.span.ODataBatch`             | `INFO`         | Spans for individual requests of a OData $batch request.   |
| `com.sap.cds.otel.span.CQN`                    | `INFO`         | Spans for executed CQN statement.                          |
| `com.sap.cds.otel.span.OutboxCollector`        | `INFO`         | Spans for execution of the transactional outbox collector. |
| `com.sap.cds.otel.span.DraftGarbageCollection` | `INFO`         | Spans for execution of the draft garbage collection.       |
| `com.sap.cds.otel.span.RequestContext`         | `DEBUG`        | Spans for each Request Context.                            |
| `com.sap.cds.otel.span.ChangeSetContext`       | `DEBUG`        | Spans for each ChangeSet Context.                          |
| `com.sap.cds.otel.span.Emit`                   | `DEBUG`        | Spans for dispatching events in the CAP runtime.           |

For specific steps to change the log level, please refer to the respective section for [configuring logging](#logging-configuration).

#### Custom Instrumentation

Using the Open Telemetry Java API, it's possible to provide additional observability signals from within a CAP Java application. This can include additional spans as well as metrics.

You may use annotation-based instrumentation using the OpenTelemetry annotations for instrumenting your code or you can define your custom spans for places where you need a lot of context or require the advanced features of the OpenTelemetry API.

To enable annotation-based tracing, include the following dependency in your `pom.xml`:

::: code-group
```xml [srv/pom.xml]
<dependency>
   <groupId>io.opentelemetry.instrumentation</groupId>
   <artifactId>opentelemetry-instrumentation-annotations</artifactId>
   <version>2.3.0</version>
</dependency>
```
:::

Then, you can create additional spans around your event handlers just by annotating their methods with the annotation `@WithSpan`. Such spans will react on exceptions and by default they will have class and method name as the description.

```java
@Component
@ServiceName(CatalogService_.CDS_NAME)
class CatalogServiceHandler implements EventHandler {

   @Before(entity = Books_.CDS_NAME)
   @WithSpan
   public void beforeAddReview(AddReviewContext context) {
      // ...
   }
}
```

[Learn more about the features of annotation-based spans.](https://opentelemetry.io/docs/languages/java/automatic/annotations/) {.learn-more}

To use OpenTelemetry API for more complex spans, add a dependency to the Open Telemetry Java API in the `pom.xml` of the CAP Java application:
::: code-group
```xml [srv/pom.xml]
<dependency>
   <groupId>io.opentelemetry</groupId>
   <artifactId>opentelemetry-api</artifactId>
</dependency>
```
:::

The instance of OpenTelemetry API is preconfigured for you by the agent that was injected in your application. You don't need to configure it again.

The following example produces an additional span when the `@After` handler is executed. The Open Telemetry API automatically ensures that the span is correctly added to the current span hierarchy. Span attributes allow an application to associate additional data to the span, which helps to identify and to analyze the span. Exceptions that were thrown within the span should be associated with the span using the `recordException` method. This marks the span as erroneous and helps to analyze failures. It's important to close the span in any case. Otherwise, the span isn't recorded and is lost.

```java
@Component
@ServiceName(CatalogService_.CDS_NAME)
class CatalogServiceHandler implements EventHandler {
  Tracer tracer = GlobalOpenTelemetry.getTracerProvider()
    .tracerBuilder("RatingCalculator").build();

  @After(entity = Books_.CDS_NAME)
  public void afterAddReview(AddReviewContext context) {
      Span childSpan = tracer.spanBuilder("setBookRating").startSpan();
      childSpan.setAttribute("book.title", context.getResult().getTitle());
      childSpan.setAttribute("book.id", context.getResult().getBookId());
      childSpan.setAttribute("book.rating", context.getResult().getRating());

      try(Scope scope = childSpan.makeCurrent()) {
          ratingCalculator.setBookRating(context.getResult().getBookId());
      } catch (Throwable t) {
          childSpan.recordException(t);
          throw t;
      } finally {
          childSpan.end();
      }
  }
}
```

[Learn more about the features of the instrumentation API](https://opentelemetry.io/docs/languages/java/instrumentation/) {.learn-more}

You can record metrics during execution of, for example, a custom event handler. The following example manages a metric `reviewCounter`, which counts the number of book reviews posted by users. Adding the `bookId` as additional attribute improves the value of the data as this can be handled by the Open Telemetry front end as dimension for aggregating values of this metric.

```java
@Component
@ServiceName(CatalogService_.CDS_NAME)
class CatalogServiceHandler implements EventHandler {
   Meter meter = GlobalOpenTelemetry.getMeterProvider().meterBuilder("RatingCalculator").build();

   @After(entity = Books_.CDS_NAME)
   public void afterAddReview(AddReviewContext context) {
      ratingCalculator.setBookRating(context.getResult().getBookId());

      LongCounter counter = meter.counterBuilder("reviewCounter")
        .setDescription("Counts the number of reviews created per book")
        .build();
      counter.add(1, Attributes.of(AttributeKey.stringKey("bookId"),
        context.getResult().getBookId()));
   }
}
```


### Dynatrace { #dynatrace }

[Dynatrace](https://www.dynatrace.com/support/help) is a comprehensive platform that delivers analytics and automation based on monitoring events sent by the backend services.
It requires OneAgent that runs in the backend capturing monitoring data and sending to the Dynatrace service.

How to configure a Dynatrace connection to your CAP Java application is described in [Dynatrace Integration](https://help.sap.com/docs/BTP/65de2977205c403bbc107264b8eccf4b/1610eac123c04d07babaf89c47d82c91.html).

<div id="dynatrace-setup"/>
<Fragment target="#dynatrace-setup">

::: info <Internal />
For SAP-internal usage, a [managed Dynatrace service](https://pages.github.tools.sap/apm/docs/) is available. Among others, it offers a Service Broker for simpler management of Dynatrace environments.
:::

</Fragment>


### Spring Boot Actuators { #spring-boot-actuators }

Metrics are mainly referring to operational information about various resources of the running application, such as HTTP sessions and worker threads, JDBC connections, JVM memory including garbage collector statistics and so on.
Similar to [health checks](#spring-health-checks), Spring Boot comes with a bunch of built-in metrics based on the [Spring Actuator](#spring-boot-actuators) framework.
Actuators form an open framework, which can be enhanced by libraries (see [CDS Actuator](#cds-actuator)) as well as the application (see [Custom Actuators](#custom-actuators)) with additional information.

[Spring Boot Actuators](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html) are designed to provide a set of out-of-the-box supportability features, that help to make your application observable in production.

To add actuator support in your application, add the following dependency:

::: code-group
```xml [srv/pom.xml]
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```
:::

The following table lists some of the available actuators that might be helpful to understand the internal status of the application:

| Actuator  | Description                                                                      |
| :-------- | :------------------------------------------------------------------------------- |
| `metrics` | Thread pools, connection pools, CPU, and memory usage of JVM and HTTP web server |
| `beans`   | Information about Spring beans created in the application                        |
| `env`     | Exposes the full Spring environment including application configuration          |
| `loggers` | List and modify application loggers                                              |

By default, nearly all actuators are active. You can switch off actuators individually in the configuration. The following configuration turns off `flyway` actuator:

```yaml
management.endpoint.flyway.enabled: false
```

Depending on the configuration, exposed actuators can have HTTP or [JMX](https://en.wikipedia.org/wiki/Java_Management_Extensions) endpoints. For security reasons, it's recommended to expose only the `health` actuator as web endpoint as described in [Health Indicators](#spring-health-checks). All other actuators are recommended for local JMX-based access as described in [JMX-based Tools](optimizing#profiling-jmx).


#### CDS Actuator { #cds-actuator }

CAP Java SDK plugs a CDS-specific actuator `cds`. This actuator provides information about:

- The version and commit ID of the currently used `cds-services` library
- All services registered in the service catalog
- Security configuration (authentication type and so on)
- Loaded features such as `cds-feature-xsuaa`
- Database pool statistics (requires `registerMbeans: true` in [Hikari pool configuration](../cqn-services/persistence-services#datasource-configuration))


#### Custom Actuators { #custom-actuators }

Similar to [Custom Health Indicators](#custom-health-indicators), you can add application-specific actuators as done in the following example:

```java
@Component
@ConditionalOnClass(Endpoint.class)
@Endpoint(id = "app", enableByDefault = true)
public class AppActuator {
	@ReadOperation
	public Map<String, Object> info() {
		Map<String, Object> info = new LinkedHashMap<>();
		info.put("Version", "1.0.0");
		return info;
	}
}
```
The `AppActuator` bean registers an actuator with name `app` that exposes a simple version string.



### Availability { #availability}

This section describes how to set up an endpoint for availability or health check. At a first glance, providing such a health check endpoint sounds like a simple task. But some aspects need to be considered:

- Authentication (for example, Basic or OAuth2) increases security but introduces higher configuration and maintenance effort.
- Only low resource consumption can be introduced. If you provide a public endpoint, only low overhead is accepted to avoid denial-of-service attacks.
- Ideally, the health check response shows not only the aggregate status, but also the status of crucial services the application depends on such as the underlying persistence.

#### Spring Boot Health Checks { #spring-health-checks}

Conveniently, Spring Boot offers out-of-the-box capabilities to report the health of the running application and its components. Spring provides a bunch of health indicators, especially `PingHealthIndicator` (`/ping`) and `DataSourceHealthIndicator` (`/db`). This set can be extended by [custom health indicators](#custom-health-indicators) if necessary, but most probably, **setting up an appropriate health check for your application is just a matter of configuration**.

To do so, first add a dependency to Spring Actuators, which forms the basis for health indicators:

::: code-group
```xml [srv/pom.xml]
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
```
:::

By default, Spring exposes the *aggregated* health status on web endpoint `/actuator/health`, including the result of all registered health indicators. But also the `info` actuator is exposed automatically, which might be not desired for security reasons. It's recommended to **explicitly** control web exposition of actuator components in the application configuration. The following configuration snippet is an example suitable for public visible health check information:

```yaml [srv/src/main/resources/application.yaml]
management:
  endpoint:
    health:
      show-components: always # shows individual indicators
  endpoints:
    web:
      exposure:
        include: health # only expose /health as web endpoint
  health:
     defaults.enabled: false # turn off all indicators by default
     ping.enabled: true
     db.enabled: true
```

The example configuration makes Spring exposing only the health endpoint with health indicators `db` and `ping`. Other indicators ready for auto-configuration such as `diskSpace` are omitted. All components contributing to the aggregated status are shown individually, which helps to understand the reason for overall status `DOWN`.

::: tip
For multitenancy scenarios, CAP Java replaces the default `db` indicator with an implementation that includes the status of all tenant databases.
:::

In addition CAP Java offers a health indicator `modelProvider`. This health indicator allows to include the status of the MTX sidecar serving the [Model Provider Service](/java/reflection-api#the-model-provider-service).

```yaml
management:
  health:
    modelProvider.enabled: true
```

::: warning
The `modelProvider` health indicator requires `@sap/cds` version `7.8.0` or higher in MTX sidecar.
:::

Endpoint `/actuator/health` delivers a response (HTTP response code `200` for up, `503` for down) in JSON format with the overall `status` property (for example, `UP` or `DOWN`) and the contributing components:

```json
{
  "status": "UP",
  "components": {
    "db": {
      "status": "UP"
    },
    "ping": {
      "status": "UP"
    }
  }
}
```

It might be advantageous to expose information on a detailed level. This configuration is only an option for a [protected](#protected-health-checks) health endpoint:

```yaml
management.endpoint.health.show-details: always
```

::: warning Be mindful about data exposure and resource consumption
A public health check endpoint may neither disclose system internal data (for example, health indicator details) nor introduce significant resource consumption (for example, doing synchronous database request).
:::

Find all details about configuration opportunities in [Spring Boot Actuator](https://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-features.html) documentation.

#### Custom Health Indicators { #custom-health-indicators}

In case your application relies on additional, mandatory services not covered by default health indicators, you can add a custom health indicator as sketched in this example:

```java
@Component("crypto")
@ConditionalOnEnabledHealthIndicator("crypto")
public class CryptoHealthIndicator implements HealthIndicator {

    @Autowired
    CryptoService cryptoService;

    @Override
    public Health health() {
        Health.Builder status = cryptoService.isAvailalbe() ?
              Health.up() : Health.down();
        return status.build();
    }
}
```

The custom `HealthIndicator` for the mandatory `CryptoService` is registered by Spring automatically and can be controlled with property `management.health.crypto.enabled: true`.

#### Protected Health Checks { #protected-health-checks}

Optionally, you can configure a protected health check endpoint. On the one hand this gives you higher flexibility with regards to the detail level of the response but on the other hand introduces additional configuration and management efforts (for instance key management).
As this highly depends on the configuration capabilities of the client services, CAP doesn't come with an auto-configuration. Instead, the application has to provide an explicit security configuration on top as outlined with `ActuatorSecurityConfig` in [Customizing Spring Boot Security Configuration](../security#custom-spring-security-config).

<div id="secondary-file">java/operating-applications/observability.fragment.md</div>


# Developer Dashboard


::: warning Only to be used in development
The dashboard is only intended for use in the development environment. It is strictly forbidden to use the dashboard in a production environment, as it allows access to sensitive data and presents a security risk.
:::
<br>

![Screenshot of the CAP developer dashboard UI.](assets/dashboard.jpg)




The CAP Developer Dashboard simplifies development by providing a centralized point where developers can efficiently manage and monitor their CAP applications. It offers tools and functions to support the development process and helps developers to quickly identify and resolve problems. Additionally, the dashboard facilitates better integration of CAP components, such as messaging, resilience and multitenancy, ensuring seamless functionality throughout CAP applications.

You can get a brief overview of the dashboard's features in the [Developer Dashboard Presentation](https://broadcast.sap.com/replay/240604_recap?playhead=2188) at our RECAP 2024 conference.

Add the `cds-feature-dev-dashboard` feature to your maven dependencies:

```xml [pom.xml]
<dependency>
    <groupId>com.sap.cds</groupId>
    <artifactId>cds-feature-dev-dashboard</artifactId>
</dependency>
```

## Local Setup

By default, the dashboard requires authorized access, which requires the `cds.Developer` role. The default mock user configuration provides the user `developer` already configured with this role. If you use your own mocked users, you must assign them the `cds.Developer` role if you want to give them access to the dashboard. 

::: code-group
```yaml [application.yaml]
cds:
  security:
    mock:
      users:
        - name: myUser
          password: myPass
          roles:
            - cds.Developer
```
:::

## Cloud Setup

If you also want to use the CAP Developer Dashboard in your cloud development scenario, you need to take a few more steps to achieve this. Let's take an example of a BTP Cloud Foundry app example with Approuter and XSUAA.

1. Deactivate the [production profile](../developing-applications/configuring#production-profile) in the _mta.yaml_.

2. Add the `cds.Developer` role to your security configuration in the *xs-security.json*.

3. Customize the approuter configuration (*xs-app.json*) by enabling support for websocket connections and defining the dashboard routes.

::: code-group
```yaml [mta.yaml]
modules:
  - name: my-cap-app-srv
    [...]
    properties:
      CDS_ENVIRONMENT_PRODUCTION_ENABLED: false
```

```json [xs-security.json]
{
	"xsappname": "dashboard-test",
	[...]
	"scopes": [
		{
			"name": "$XSAPPNAME.cds.Developer",
			"description": "CAP Developer"
		},
    [...]
	],
 "attributes": [
		{
			[...]
		}
	],
	"role-templates": [
		{
			"name": "capDeveloper",
			"description": "generated",
			"scope-references": [
				"$XSAPPNAME.cds.Developer"
			]
		},
    [...]
	]
}
```

```json [xs-app.json]
{
	...
	"authenticationMethod": "route",
	"websockets": {
		"enabled": true
	},
	"routes": [
		{
			"source": "^/dashboard",
			"authenticationType": "xsuaa",
			"destination": "backend"
		},
		{
			"source": "^/dashboard/(.*)",
			"authenticationType": "xsuaa",
			"destination": "backend"
		},
		{
			"source": "^/dashboard_api/(.*)",
			"authenticationType": "xsuaa",
			"destination": "backend"
		}, 
    [...]
	]
}
```
:::

Now you can deploy the application in BTP and assign the `cds.Developer` role to the users you want to grant access to the CAP Developer Dashboard.

::: warning
For security reasons, the **cds.Developer** role should only be used in conjunction with test users. It is strongly recommended not to use this role with users who could potentially be used in production systems.
:::

## Disable Authorization

In some cases, your application may run in a complex environment and you simply want to access the CAP Developer Dashboard running in your CAP Service Module directly without using a router in between. For this reason, you can switch off the authorization to grant direct unauthorized access.

1. Switch off authorization using one of the following options:

	::: code-group
	```yaml [application.yaml]
	cds:
	dashboard:
		authorization:
		enabled: false
	```

	```yaml [mta.yaml]
	modules:
	- name: my-cap-app-srv
		[...]
		properties:
		CDS_DASHBOARD_AUTHORIZATION_ENABLED: false
	```

	:::

2. Disable authentication. 

	::: code-group
	```java [WebSecurity]
	import static org.springframework.security.web.util.matcher.AntPathRequestMatcher.antMatcher;

	import org.springframework.context.annotation.Bean;
	import org.springframework.context.annotation.Configuration;
	import org.springframework.core.annotation.Order;
	import org.springframework.security.config.annotation.web.builders.HttpSecurity;
	import org.springframework.security.web.SecurityFilterChain;

	@Configuration
	@Order(1)
	public class WebSecurity {

		@Bean
		public SecurityFilterChain appFilterChain(HttpSecurity http) throws Exception {

			return http
					.securityMatchers(m -> m.requestMatchers(antMatcher("/dashboard/**"), antMatcher("/dashboard_api/**")))
					.authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
					.csrf(c-> c.disable())
					.build();

		}
	}
	```
	:::


<div id="inOpenEndpoint" />
<Fragment target="#inOpenEndpoint">

### DwC: Open the Endpoint

When using _Deploy with Confidence_, the following web security configuration disables mTLS for the CAP Developer Dashboard endpoint.

::: code-group

```java [DwC WebSecurity]
import static org.springframework.security.web.util.matcher.AntPathRequestMatcher.antMatcher;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.annotation.Order;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
@Order(1)
public class DwcWebSecurityConfiguration {

 @Bean
 SecurityFilterChain configure(HttpSecurity http) throws Exception {

  return http
    .authorizeHttpRequests(auth -> auth.requestMatchers(antMatcher("/dashboard/**"), antMatcher("/dashboard_api/**")).permitAll())
    .authorizeHttpRequests(auth -> auth.anyRequest().authenticated())
    .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
    .httpBasic(b -> b.disable())
    .formLogin(f -> f.disable())
    .csrf(c -> c.disable())
    .build();
 }
}
```

:::

</Fragment>
<div id="secondary-file">java/operating-applications/dashboard.fragment.md</div>


# Integrating CAP Java Applications

Learn here about integrating a CAP Java application.



<IndexList :pages='pages' />



# Unified Customer Landscape (UCL) <Internal /> <Since version="4.0.0" of="com.sap.cds:cds-feature-ucl" />



The CAP integration with the Unified Customer Landscape (UCL) makes it easy to plug into UCL´s Tenant Mapping API (aka Service Provider Integration Interface (SPII)). This is required if your application shall participate in UCL formations and exchange configuration data with other participants of the formation.

CAP does not provide an automatic registration of the CAP application in UCL. Onboarding of a CAP Java application to UCL is subject to the application owner. The exact steps and onboarding method depends on the overall requirements of the application.

[Learn more about UCL](https://pages.github.tools.sap/ucl/stakeholders-documentation/docs/overview/){.learn-more}
[Learn more about Service Provider Integration Interface (SPII)](https://pages.github.tools.sap/atom-cfs/atom-docs/docs/product-concepts/customer-landscape/spii/){.learn-more}

## Enabling the SPII endpoint

As a pre-requisite to use CAP´s SPII capabilities, you have to onboard your multi-tenant CAP application to UCL as a system type (e.g. using Unified Services or UCL´s GraphQL API).

[Learn more about Onboarding to UCL](https://pages.github.tools.sap/ucl/stakeholders-documentation/docs/onboarding/){.learn-more} 

To enable the SPII endpoint, you have to perform the following steps:
1. Add the module `cds-feature-ucl` to your `srv/pom.xml`.

   ```xml
    <dependency>
      <groupId>com.sap.cds</groupId>
      <artifactId>cds-feature-ucl</artifactId>
    </dependency>
   ```

   After adding the dependency, the CAP application will automatically expose an additional endpoint `/ucl/spii/v1/tenantMappings` which fulfills the SPII protocol. The endpoint enforces mTLS authentication which maps to UCL´s `sap:cmp-mtls:v1` access strategy. Other access strategies are not supported. 

1. Make your application available under a route that terminates TLS and forwards the provided client certificate to the application as http header. This is supported both on Cloud Foundry as well as on Kyma. In Cloud Foundry, you have to expose your application under the `.cert` or `.mesh` domain.
 
   [Learn more about `.cert` and `.mesh` domains](https://github.tools.sap/cloudfoundry/custom-domain-selfservice/tree/master/docs/mesh){.learn-more}

1. Though, the chain of the incoming certificate  is validated in the component that terminates TLS, there is an additional validation of the certificate subject and issuer performed by the SPII endpoint. This check requires you to provide the expected subject issuer in `application.yaml` using the properties `cds.ucl.x509.certSubject` and `cds.ucl.x509.certIssuer`.
 
   Alternatively, you can also configure the values as environment variables (e.g. in the mta.yaml): `CDS_UCL_X509_CERTSUBJECT` and `CDS_UCL_X509_CERTISSUER`
   ::: tip
   Unless you have configured your own certificates in UCL, the default certificate subject and issuer depend on the UCL environment you have onboarded your application. Check the list of available UCL environments [here](https://pages.github.tools.sap/CentralEngineering/open-resource-discovery-specification/spec-extensions/access-strategies/sap-cmp-mtls-v1#ucl-environments).
   :::

## Register the SPII endpoint in UCL
The SPII endpoint of your CAP Java application needs to be made known to UCL. The exact steps for registration depends on the way you have chosen to onboard your application to UCL. Consult the [UCL documentation](https://pages.github.tools.sap/ucl/stakeholders-documentation/docs/onboarding/) for more information.

However, regardless of the way you've chosen to onboard, there are three things you need to know from the CAP Java perspective.

1. The SPII URL that needs to be registered is: `https://<mtls_enabled_application_route>/ucl/spii`. The remaining path (that is, `/tenantMapping...`) is added by UCL automatically when calling the endpoint.

2. CAP Java only supports the `SYNC` mode of the Tenant Mapping API.

3. The only supported authentication strategy is `sap:cmp-mtls:v1`.

Once the endpoint is properly registered, you can add your system type to an existing formation type or request a new formation.


[Learn more about UCL Formations](https://pages.github.tools.sap/atom-cfs/atom-docs/docs/product-concepts/customer-landscape/formations/){.learn-more}

## Provide a SPII Event Handler


CAP Java provides a dedicated `UclService` which is connected to the SPII endpoint. The service exposes the events `ASSIGN` and `UNASSIGN` to allow event handlers to react on formation notifications. The events are triggered whenever UCL calls the SPII endpoint to assign a tenant to a formation respectively unassign it from a formation. The event payload is very close to the SPII payload. Thus, it is recommended to get familiar with the SPII protocol before implementing the event handler. 

The logic of the event handler highly depends on the requirements of your application and the formation you are participating in. This can be as simple as returning static configuration to the other formation participant. But it might also be required to create credentials and share them with the other participant. 

### Sample Handler

Create a new custom Event Handler to hook into formation assignment and/or unassignment notifications. Code example:

```java
@Component
@ServiceName(UclService.DEFAULT_NAME)
public class TestHandler implements EventHandler {

	@On
	public void onAssign(AssignEventContext context) {
		SpiiResult result = SpiiResult.create();
		//opt-in feature of UCL to create a destination
		result.setConfiguration(Map.of("destinations", List.of(createDestination())));
		result.setReady(true);
		context.setResult(result);
	}
	
	private Map<String, Object> createDestination() {
		Map<String, Object> destination = new HashMap<>();

		destination.put("authenticationType", "NoAuthentication");
		destination.put("url", "http://localhost:8080");
		destination.put("name", "OrderApi");
		destination.put("proxyType", "Internet");
		destination.put("type", "HTTP");

		Map<String, Object> properties = new HashMap<>();
		properties.put("cloudsdk.ias-dependency-name", "order-api");
		destination.put("additionalProperties", properties);
		return destination;
	}
}
```
The given example is showing how it is possible to leverage the UCL opt-in features to create destinations in the BTP Destination Service.

### Implementation Considerations

In a productive solution, you probably should first evaluate certain conditions in the event context via `context.getUclContext()` (e.g. for which formation the notification is sent). If your handler requires certain configuration to be provided by the assigned tenant, you can read this via `context.getUclAssignedTenant().getConfiguration()`. There might be situations in which the assigned tenant has not yet provided required configuration. In this case, your handler can signal this by setting `result.setReady(false)`. This translates to the status `CONFIG_PENDING` in the result to UCL. If there is nothing pending from the assigned tenant anymore, you have to signal this as well via `result.setReady(true)`.

### Multiple Formations

If you want to participate in more than one formation and you want to separate the logic into separate Event Handlers, you can do so. However, it is important that `context.setResult()` is only called by the handler which is responsible for the formation specified in the event context. According to CAP´s standard behavior multiple `@On` handlers have to work cooperatively. The first handler calling `context.setResult()` will finish the event processing and no additional `@On` handlers will be called.

## Local Testing
In case you want to test your SPII handler via the provided SPII endpoint locally or within a test, you can bypass the mTLS-based authentication by calling the endpoint with a privileged or internal user.

::: info
If you run your application with the `production` profile (e.g. by deploying to the cloud), the internal user access will be automatically disabled. You have to explicitly enable it by setting the property `cds.security.authentication.internalUserAccess.enabled: true`.
:::



# Building Plugins



A collection of different mechanisms that can be used to build plugins for CAP Java.

Especially, when working with larger projects that may consist of many individual CAP Java applications or when building platform services that need to be integrated with CAP applications there's the requirement to extend CAP Java with custom, yet reusable code.

In the following sections, the different extension points and mechanisms are explained.

## General Considerations

### Java Version

When building CAP Java plugin modules, you need to keep in mind that the generated Java byte code of the plugin has to be compatible with the Java byte code version of the potential consumers of the plugin. To be on the safe side, we recommend using *Java 17* as this is anyways the minimum Java version for CAP Java (for 2.x release) applications. In case you deviate from this you need to check and align with the potential consumers of the plugin.

### Maven GroupId and Java Packages

Of course, it's up to your project / plugin how you call the corresponding Maven GroupId and Java packages. To avoid confusion and also to make responsibilities clear `com.sap.cds` for GroupId and Java package names are reserved for components maintained by the CAP Java team and must not be used for external plugins. This rule also includes substructures to `com.sap.cds` like `com.sap.cds.foo.plugin`.


## Share CDS Models via Maven Artifacts

Before the CAP Java 2.2 release CDS definitions had to be shared as Node.js modules, also for Java projects.

Starting with the 2.2 release CDS models, CSV import data and i18n files can now be shared through Maven dependencies in addition to npm packages. This means you can now provide CDS models, CSV files, i18n files, and Java code (for example, event handlers) in a single Maven dependency.

### Create the CDS Model in a New Maven Artifact

Simply create a plain Maven Java project and place your CDS models in the `main/resources/cds` folder of the reuse package under a unique module directory (for example, leveraging group ID and artifact ID): `src/main/resources/cds/com.sap.capire/bookshop/`. With `com.sap.capire` being the group ID and `bookshop` being the artifact ID.

You can simplify the creation of such a **plain Maven Java** project by calling the following Maven archetype command:

```shell
mvn archetype:generate -DgroupId=com.sap.capire -DartifactId=bookshop -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false
```

After the creation you'll need to maintain the plugin versions as well as the desired Java language version (we recommend version 17).

::: warning Only plain Maven Java projects
Please make sure that your plugin / reuse model project is neither created as a CAP Java project nor as a plain Spring Boot project.
:::

### Reference the New CDS Model in an Existing CAP Java Project

Projects wanting to import the content simply add a Maven dependency to the reuse package to their _srv/pom.xml_ in the `<dependencies>` section.

::: code-group
```xml [srv/pom.xml]
<dependency>
  <groupId>com.sap.capire</groupId>
  <artifactId>bookshop</artifactId>
  <version>1.0.0</version>
</dependency>
```
:::

Additionally, the new `resolve` goal from the CDS Maven Plugin needs to be added, to extract the models into the `target/cds/` folder of the Maven project, in order to make them available to the CDS Compiler.

::: code-group
```xml [srv/pom.xml]
<plugin>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-maven-plugin</artifactId>
  <version>${cds.services.version}</version>
  <executions>
    ...
    <execution>
      <id>cds.resolve</id>
      <goals>
        <goal>resolve</goal> 
      </goals>
    </execution>
    ...
  </executions>
</plugin>
```
:::

::: details Reuse module as Maven module
Please be aware that the module that uses the reuse module needs to be a Maven module itself or a submodule to a Maven module that declares the dependency to the Maven module. Usually you would declare the dependency in the `srv` module of your CAP Java project and use the reuse model in the service's CDS files then. In case you want to use the reuse model in your `db` module you need to make sure that your `db` module is a Maven module and include it to the project's parent `pom.xml` file.
:::

When your Maven build is set up correctly, you can use the reuse models in your CDS files using the standard `using` directive:

```cds
using { CatalogService } from 'com.sap.capire/bookshop';
```
::: details Different resolution rules
The location in the `using` directive differs from the default [CDS model resolution rules](../cds/cdl#model-resolution). The *name* does not refer to a local file/package, nor to an NPM package. Instead, it follows to the groupId/artifactId scheme. The name doesn't directly refer to an actual file system location but is looked up in a _cds_ folder in Maven's _target_ folder.
:::

[Learn more about providing and using reuse packages.](../guides/extensibility/composition){.learn-more}

This technique can be used independently or together with one or more of the techniques described on this page.

## Event Handlers for Custom Types and Annotations

In CAP Java, event handlers aren't tightly coupled to the request handling or any other runtime components. Thus, it's easily possible to package event handlers in external libraries (like plugins) in order to provide common but custom functionality to CAP Java applications. You can achieve this by defining custom handlers that react on model characteristics (common types or annotations) or also on entity values, for example, validations.

In most of the cases an event handler plugin for a CAP Java application can be a plain Maven project without further dependencies or special project layout. Since you need to use or implement CAP Java extension points, it's required to define the following dependencies:

```xml
<properties>
    <cds.services.version>2.4.0</cds.services.version>
</properties>

<dependencyManagement>
    <dependencies>
      <dependency>
        <groupId>com.sap.cds</groupId>
        <artifactId>cds-services-bom</artifactId>
        <version>${cds.services.version}</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
</dependencyManagement>

<dependencies>
    <dependency>
        <groupId>com.sap.cds</groupId>
        <artifactId>cds-services-api</artifactId>
    </dependency>
</dependencies>
```

Inside your plugin module, you can define a custom event handler and a registration hook as plain Java code. Once this module is deployed to a Maven repository it can be added to any CAP Java application as a dependency. The contained event handler code is active automatically once your CAP Java application is started along with the new reuse module.

The heart of the plugin module, the event handler, basically looks like any other CAP Java event handler. Take this one as an example:

```java
@ServiceName(value = "*", type = ApplicationService.class)
public class SampleHandler implements EventHandler {

    @After
    public void handleSample(CdsReadEventContext context) {
      // any custom Java code using the event context and CQL APIs
    }
}
```

The shown handler code is registered for any entity type on any [ApplicationService](../guides/providing-services). Depending on the use case the target scope could be narrowed to specific entities and/or services. The handler registration applies to the same rules as custom handlers that are directly packaged with a CAP Java application.

[Learn more about event handling in our EventHandler documentation](event-handlers/){.learn-more}

Of course, this handler code looks just the same as any other custom or builtin CAP Java handler. The only difference here is that you need to think a bit more about the provisioning of the handler. When you write a custom handler as part of (in the package of) a CAP Java application, you can annotate the handler's class with `@Component`. Then Spring Boot's component scan picks up the class during startup of the Application Context.

When you provide your custom handler as part of a reuse library, external to your application, things change a bit. At first, you need to decide whether you want to use Spring Boot's component model and rely on dependency injection or if you want to use one of the CAP Java ServiceLoader based extension points.

The decision between the two is straightforward: In case your handler depends on other Spring components, for example relies on dependency injection, you should use the [Spring approach](#spring-autoconfiguration). This applies as soon as you need to access another CAP Service like [`CqnService`](./cqn-services/application-services), [`PersistenceService`](./cqn-services/persistence-services) or to a service using it's [typed service interface](../releases/archive/2023/nov23#typed-service-interfaces).

If your custom handler is isolated and, for example, only performs a validation based on provided data or a calculation, you can stick with the [CAP Java ServiceLoader approach](#service-loader), which is described in the following section.

### Load Plugin Code via ServiceLoaders {#service-loader}
At runtime, CAP Java uses the [`ServiceLoader`](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/ServiceLoader.html) mechanism to load all implementations of the `CdsRuntimeConfiguration` interface from the application's ClassPath. In order to qualify as a contributor for a given ServiceLoader-enabled interface, we need to place a plain text file, named like the fully qualified name of the interface, in the directory `src/main/resources/META-INF/services` of our reuse model. This file contains the name of one or more implementing classes. For the earlier implemented `CdsRuntimeConfiguration` we need to create a file `src/main/resources/META-INF/services/com.sap.cds.services.runtime.CdsRuntimeConfiguration` with the following content:

```txt
com.sap.example.cds.SampleHandlerRuntimeConfiguration
```

With this code you instrument the CAP Java's ServiceLoader for `CdsRuntimeConfiguration` to load our new, generic EventHandler for all read events on all entities of all services. For realistic use cases, the handler configuration can be more concise, of course.

So, in order to have a framework independent handler registration the `CdsRuntimeConfiguration` interface needs to be implemented like this:

```java
package com.sap.example.cds;

import com.sap.cds.services.runtime.CdsRuntimeConfiguration;
import com.sap.cds.services.runtime.CdsRuntimeConfigurer;

public class SampleHandlerRuntimeConfiguration implements CdsRuntimeConfiguration {

  @Override
  public void eventHandlers(CdsRuntimeConfigurer configurer) {
    configurer.eventHandler(new SampleHandler());
  }

}
```

### Load Plugin Code with the Spring Component Model {#spring-autoconfiguration}

In case your reuse module depends on other components managed as part of the Spring ApplicationContext (having an `@Autowired` annotation in your class is a good hint for that) you need to register your plugin as a Spring component itself. The most straight forward (but not recommended) way is to annotate the plugin class itself with `@Component`.

This is, however, error-prone: [Spring Boot's component scan](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ComponentScan.html) is by default scanning downward from the package in which the main `Application` class is declared. Meaning that you need to place the plugin either in a subpackage or the same package as the `Application` class. This would hamper the reuse aspect of the plugin as it would only work applications in a specific package. You could customize the component scan of the application using your plugin but this is also error-prone as you explicitly have to remember to change the `@ComponentScan` annotation each time you include a plugin.

Because of those complications it's best practice to use the `AutoConfiguration` mechanism provided by Spring Boot in reuse modules that ship Spring components. For further details, please refer to the [Spring Boot reference documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.auto-configuration).


A complete end-to-end example for reusable event handlers can be found in this [blog post](https://blogs.sap.com/2023/05/16/how-to-build-reusable-plugin-components-for-cap-java-applications/).

## Custom Protocol Adapters {#protocol-adapter}

In CAP, the protocol adapter is the mechanism to implement inbound communication (from another service or the UI) to the CAP service in development. You can read more about protocol adapters in our [architecture documentation](developing-applications/building#protocol-adapters).

Usually, a protocol adapter comes in two parts:

- the adapter
- a factory class that creates an instance of the adapter

The adapter itself is in most cases an extension of the HttpServlet abstract class. The factory class also provides information about the paths to which the protocol adapter (the servlet) needs to be registered. The factory interface is called `ServletAdapterFactory` and implementations of that factory will be loaded with the same [`ServiceLoader` approach as described above](#service-loader) in the event handler section.

This is an example implementation of the `ServletAdapterFactory`:

```java
public class SampleAdapterFactory implements ServletAdapterFactory, CdsRuntimeAware {
  /*
   * a short key identifying the protocol that's being served
   * by the new protocol adapter, for example, odata-v4, hcql, ..
   */
  static final String PROTOCOL_KEY = "protocol-key";

  private CdsRuntime runtime;

  @Override
  public void setCdsRuntime(CdsRuntime runtime) {
    /*
     * In case the protocol adapter needs the CdsRuntime
     * the factory can implement CdsRuntimeAware and will
     * be provided with a CdsRuntime via this method.
     * The create() method below can then use the provided
     * runtime for the protocol adapter.
     */
    this.runtime = runtime;
  }

  @Override
  public Object create() {
    // Create and return the protocol adapter
    return new SampleAdapter(runtime);
  }

  @Override
  public boolean isEnabled() {
    // Determines if the protocol adapter is enabled
  }

  @Override
  public String getBasePath() {
    // Return the base path
  }

  @Override
  public String[] getMappings() {
    /*
     * Return all paths to which the protocol adapter is
     * going to be mapped. Usually, this will be each CDS
     * service with either it's canonical or annotated
     * path prefixed with the base path of the protocol
     * adapter (see above).
     */
  }

  @Override
  public UrlResourcePath getServletPath() {
    /*
     * Use the UrlResourcePathBuilder to build and return
     * a UrlResourcePath containing the basePath (see above)
     * and all paths being registered for the protocol key
     * of the new protocol adapter.
     */
  }
}
```

With the factory in place, you can start to build the actual protocol adapter. As mentioned before, most adapters implement HTTP connectivity and are an extension of the Jakarta `HttpServlet` class. Based on the incoming request path the protocol adapter needs to determine the corresponding CDS `ApplicationService`. Parts of the request path together with potential request parameters (this depends on the protocol to be implemented) then need to be mapped to a CQL statement, which is then executed on the previously selected CDS `ApplicationService`.

```java
public class SampleAdapter extends HttpServlet {
  private final CdsRuntime runtime;

  public SampleAdapter(CdsRuntime runtime) {
    this.runtime = runtime;
    // see below for further details
  }

  @Override
  public void service(HttpServletRequest request,
      HttpServletResponse response) throws IOException {
    // see below for further details
  }
}
```

As mentioned previously, a protocol adapter maps incoming requests to CQL statements and executes them on the right [`ApplicationService`](./cqn-services/application-services) according to the `HttpServletRequest`'s request-path. In order to have all relevant `ApplicationServices` ready at runtime, you can call `runtime.getServiceCatalog().getServices(ApplicationService.class)` in the adapter's constructor to load all `ApplicationServices`. Then select the ones relevant for this protocol adapter to have them ready, for example in a Map, for serving requests in `service()`.

When handling incoming requests at runtime, you need to extract the request path and parameters from the incoming HttpServletRequest. Then, you can use CQL API from the `cds4j-api` module to [create CQL](./working-with-cql/query-api) corresponding to the extracted information. This statement then needs to be executed with [`ApplicationService.run()`](./working-with-cql/query-execution). The returned result then needs to be mapped to the result format that is suitable for the protocol handled by the adapter. For REST, it would be some canonical JSON serialization of the returned objects.

REST request:

```http
GET /CatalogService/Books?id=100
```

Resulting CQL statement:

```java
CqnSelect select = Select.from("Books").byId(100);
```

The `CqnSelect` statement can then be executed with the right (previously selected) `ApplicationService` and then written to `HttpServletResponse` as a serialized string.

```java
String resposePayload = applicationService.run(select).toJson();
response.getWriter().write(responsePayload);
```

With that, a first iteration of a working CAP Java protocol adapter would be complete. As a wrap-up, this would be the tasks that need to be implemented in the adapter:

1. Extract the request path and select the corresponding CDS `ApplicationService`.
2. Build a CQL statement based on the request path and parameters.
3. Execute the CQL statement on the selected service and write the result to the response.

One final comment on protocol adapters: even a simple protocol adapter like sketched in this section enables full support of other CAP features like declarative security, i18n and of course custom as well as generic event handlers.

## Putting It All Together

As you've learned in this guide, there are various ways to extend the CAP Java framework. You can use one or more of the mentioned techniques and combine them in one or more Maven modules. This totally depends on your needs and requirements.

Most probably you combine the *Event Handler with custom types and annotations* mechanism together with *Sharing reusable CDS models via Maven artifacts* because the event handler mechanism might rely on shared CDS artifacts. The protocol adapters on the other hand are generic and model-independent modules that should be packaged and distributed independently.






# Migration Guides



This chapter contains comprehensive guides that help you to work through migrations such as from CAP Java 1.x to CAP Java 2.x.

## CAP Java 3.10 to CAP Java 4.0 { #three-to-four }

### New License

The license of CAP Java 4.0 has changed and it's released under the new [SAP Developer License Agreement for CAP](https://cap.cloud.sap/resources/license/developer-license-3_2_CAP.txt).

### Minimum Versions

CAP Java 4.0 increased some minimum required versions:

| Dependency | Minimum Version |
| --- | --- |
| @sap/cds-dk | ^8 |

CAP Java 4.0 no longer supports @sap/cds-dk ^7.

### Removed feature `cds-feature-event-hub`

The feature `cds-feature-event-hub` has been removed from CAP Java. The successor of this feature is the [CDS Plugin for SAP Cloud Application Event Hub](https://github.com/cap-java/cds-feature-event-hub). This new CAP Java Plugin is published independently of CAP Java and is open source. It however has the same Maven group ID and artifact ID as the previous CAP Java feature and starts versioning with `4.0.0`.

### Changes in goal `generate` of the `cds-maven-plugin`

1. Removed already deprecated properties:
- sharedInterfaces
- uniqueEventContexts

2. Deprecated properties and marked for removal:
- eventContext
- cqnService

3. Changed default value of properties:
- excludes: "localized.**" -> null

### Removed unstructured messages from MessagingService { #removed-unstructured }

The deprecated `cds.messaging.services.<key>.structured` property, which allowed to handle messages as (unstructured) plain strings has now been completely removed.
Messaging services always represent data in a structured way by using a `Map`. Headers are represented in a separate `Map`.

With this change the following deprecated methods have been removed:
- `void MessagingService.emit(String, String)`
- `String TopicMessageEventContext.getData()`

When publishing a unstructured String-based message, wrap the message into a Map:

```java
// instead of
messagingService.emit("myTopic", "unstructured message");
// use
messagingService.emit("myTopic", Map.of("message", "unstructured message")); // [!code focus]
```

In case you receive a unstructured String-based message from a message broker, it is also wrapped into a structured message with a `message` property:

```java
@On(event = "myTopic")
void handleMyTopic(TopicMessageEventContext context) {
  // instead of
  String message = context.getData();
  // use
  String message = (String) context.getDataMap().get("message"); // [!code focus]
}
```

This change has no effect on CDS modelled events, as these have always been structured.

### Adjusted Property Defaults

Some property defaults have been adjusted:

| Property | Old Value | New Value | Explanation |
| --- | --- | --- | --- |
| `cds.security.authorization.deep.enabled` | false | true | [Deep Authorization](./security#deep-auth) is now enabled by default. |
| `cds.security.authorization.instanceBased.rejectSelectedUnauthorizedEntity.enabled` | false | true | Requests that violate instance-based authorization conditions now fail with 403, instead of 404. |
| `cds.security.authorization.instanceBased.checkInputData.enabled` | false | true | [Authorization Checks On Input Data](./security#input-data-auth) are now enabled by default. |
| `cds.errors.defaultTranslations.enabled` | false | true | [Translations for Validation Error Messages](./event-handlers/indicating-errors#ootb-translated-messages) are now enabled by default. |
| `cds.sql.runtimeView.mode` | resolve | cte | [Runtime views](./working-with-cql/query-execution#runtimeviews) are now by default translated into Common Table Expressions |

### Deprecated Properties

The following properties have been deprecated and might be removed in a future major version:

- `cds.errors.combined`
- `cds.sql.hana.optimizationMode`
- `cds.outbox.services.<key>.storeLastError.enabled`

The functionality provided by these properties is enabled by default and there is no reason to switch these off.

### Removed Properties

The following table gives an overview about the removed properties:

| Removed Property | Replacement / Explanation |
| --- | --- |
| `cds.messaging.services.`<br>`<key>.structured` | [Use structured messages.](#removed-unstructured) |
| `cds.security.authorization.`<br>`emptyAttributeValuesAreRestricted` | [Use conditions with explicit checks for empty attributes.](../guides/security/authorization#user-attrs) |
| `cds.odataV4.serializer.buffered` | OData V4 responses are now always streamed while serialized. |
| `cds.environment.k8s` | Use service bindings from SAP BTP Operator on Kyma. |
| `cds.multiTenancy.subscriptionManager.`<br>`clientCertificateHeader` | `cds.security.authentication.`<br>`clientCertificateHeader` |
| `cds.multiTenancy.security.`<br>`internalUserAccess.enabled` | `cds.security.authentication.`<br>`internalUserAccess.enabled` |

### Removed Java APIs

- Removed deprecated classes:
  - `com.sap.cds.ql.cqn.CqnSearchPredicate`, use `CqnSearchTermPredicate` instead

- Removed deprecated methods:
  - `com.sap.cds.ql.cqn.Modifier.search(String term)`, use `searchTerm(CqnSearchTermPredicate)` instead
  - `com.sap.cds.ql.cqn.Modifier.selectListValue(Value<?> value, String alias)`, use `selectListValue(SelectableValue value, String alias)` instead
  - `com.sap.cds.ql.SelectableValue.withoutAlias()`, use `as(String alias)` instead

## CAP Java 2.10 to CAP Java 3.0 { #two-to-three }

### Minimum Versions

CAP Java 3.0 increased some minimum required versions:

| Dependency | Minimum Version |
| --- | --- |
| Cloud SDK | 5.9.0 |
| @sap/cds-dk | ^7 |
| Maven | 3.6.3 |

CAP Java 3.0 no longer supports @sap/cds-dk ^6.

### Production Profile `cloud`

The Production Profile now defaults to `cloud`. This ensures that various property defaults suited for local development are changed to recommended secure values for production.

One of the effects of the production profile is that the index page is disabled by default.
If you are using the root path `/` for a readiness or liveness probe in Kyma you will need to adjustment them. in this case the recommended approach would be to use the Spring Boot actuator's `/actuator/health` endpoint instead.

[Learn more about the Production Profile.](developing-applications/configuring#production-profile){.learn-more}

### Removed MTX Classic Support

Support for classic MTX (@sap/cds-mtx) has been removed. Using streamlined MTX (@sap/cds-mtxs) is mandatory for multitenancy.
If you're still using MTX Classic refer to the [multitenancy migration guide](../guides/multitenancy/old-mtx-migration).

In addition, the deprecated `MtSubscriptionService` API, has been removed. It has now been superseeded by the `DeploymentService` API.
As part of this change the compatibility mode for the `MtSubscriptionService` API has been removed. Besides the removal of the Java APIs this includes the following behavioural changes:

- During unsubscribe, the tenant's content (like HDI container) is now deleted by default when using the new `DeploymentService` API.
- The HTTP-based tenant upgrade APIs provided by the CAP Java app have been removed, use the [`Deploy` main method](/java/multitenancy#deploy-main-method) instead. This includes the following endpoints:
  - `/mt/v1.0/subscriptions/deploy/**` (GET & POST)
  - `/messaging/v1.0/em/<tenant>` (PUT)

### Removed feature `cds-feature-xsuaa`

The feature `cds-feature-xsuaa` has been removed. Support for XSUAA and IAS has been unified under the umbrella of `cds-feature-identity`.

It utilizes [SAP´s `spring-security` library](https://github.com/SAP/cloud-security-services-integration-library/tree/main/spring-security) instead of the deprecated [`spring-xsuaa` library](https://github.com/SAP/cloud-security-services-integration-library/tree/main/spring-xsuaa).

If your application relies on the standard security configuration by CAP Java and depend on one of the CAP starter bundles, it is expected that you won't need to adapt code.

If you have customized the security configuration, you need to adapt it to the new library. If your application had a direct dependency to `cds-feature-xsuaa`, we recommend using one of our starter bundles `cds-starter-cloudfoundry` or `cds-starter-k8s`.

Though CAP does not support multiple XSUAA bindings, it was possible in previous versions to extend the standard security configuration to work with multiple bindings. If you require this, you need to set `cds.security.xsuaa.allowMultipleBinding` to `true` so that all XSUAA bindings are available in custom spring auto-configurations. Note: CAP Java still does not process multiple bindings and requires a dedicated spring configuration. In general, applications should refrain from configuring several XSUAA bindings.

[Learn more about the security configuration.](./security#xsuaa-ias){.learn-more}
[Learn more about migration to SAP´s `spring-security` library.](https://github.com/SAP/cloud-security-services-integration-library/blob/main/spring-security/Migration_SpringXsuaaProjects.md)

### Proof-Of-Possession enforced for IAS-based authentication

In IAS scenarios, the [Proof-Of-Possession](https://github.com/SAP/cloud-security-services-integration-library/tree/main/java-security#proofofpossession-validation) is now enforced by default for incoming requests for versions starting from `3.5.1` of the [SAP BTP Spring Security Client](https://github.com/SAP/cloud-security-services-integration-library/tree/main/spring-security).

Because of this, applications calling a CAP Java application will need to send a valid client certificate in addition to the JWT token. In particular, applications using an Approuter have to set `forwardAuthCertificates: true` on the Approuter destination pointing to your CAP backend.

[Learn more about Proof-Of-Possession.](./security.md#proof-of-possession){.learn-more}

### Lazy Localization by default

EDMX resources served by the OData V4 `/$metadata` endpoints are now localized lazily by default.
This significantly reduces EDMX cache memory consumption when many languages are used.
Note, that this requires at least `@sap/cds-mtxs` in version `1.12.0`.

The cds build no longer generates localized EDMX files by default anymore, but instead generates templated EDMX files and a `i18n.json` containing text bundles.
If you need localized EDMX files to be generated, set `--opts contentLocalizedEdmx=true` when calling `cds build`.

### Star-expand and inline-all are no longer permitted

Previously, you could not use expand or inline without explicit paths on draft-enabled entities. Now they are rejected for all entities on application service level.

For example, following statement will not be executed when submitted to an instance of [`ApplicationService`](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/ApplicationService.html).

```java
Select.from(BOOKS).columns(b -> b.expand());
```

This does not impact OData where `expand=*` is transformed into expands for all associations.

### Adjusted POJO class generation

Some parameter defaults of the goal `generate` have been adjusted:

| Parameter | Old Value | New Value | Explanation |
| --- | --- | --- | --- |
| `sharedInterfaces` | `false` | `true` | Interfaces for global arrayed types with inline anonymous type are now generated exactly once. `sharedInterfaces` ensures such types are not generated as inline interfaces again, if used in events, actions or functions. |
| `uniqueEventContexts` | `false` | `true` | Determines whether the event context interfaces should be unique for bound actions and functions, by prefixing the interfaces with the entity name. |

Both these changes result in the generation of incompatible POJOs. To get the former POJOs, the new defaults can be overwritten by setting the parameters to the old values.

Consider the following example:

```cds
service MyService {
  entity MyEntity {
	key ID: UUID
  } actions {
	// bound action
	action doSomething(values: MyArray);
  }
}

// global arrayed type
type MyArray: many {
	value: String;
}
```

With the new defaults the generated interface for the `doSomething` action looks like this:

```java
// uniqueEventContexts: true =>
// interface is prefixed with entity name "MyEntity"
public interface MyEntityDoSomethingContext extends EventContext {

  // sharedInterfaces: true => global MyArray type is used
  Collection<MyArray.Item> getValues();
  void setValues(Collection<MyArray.Item> values);

}
```

Formerly the generated interface looked like this:

```java
// uniqueEventContexts: false =>
// interface is not prefixed with entity name
public interface DoSomethingContext extends EventContext {

  // sharedInterfaces: false => global MyArray type is not used,
  // instead an additional interface Values is generated inline
  Collection<Values> getValues();
  void setValues(Collection<Values> values);

  interface Values extends CdsData {
    // ...
  }
}
```

### Adjusted Property Defaults

Some property defaults have been adjusted:

| Property | Old Value | New Value | Explanation |
| --- | --- | --- | --- |
| `cds.remote.services.<key>.http.csrf.enabled` | `true` | `false` | Most APIs don't require CSRF tokens. |
| `cds.sql.hana.optimizationMode` | `legacy` | `hex` | SQL for SAP HANA is optimized for the HEX engine. |
| `cds.odataV4.lazyI18n.enabled` | `null` | `true` | Lazy localization is now enabled by default in multitenant scenarios. |
| `cds.auditLog.personalData.`<br>`throwOnMissingDataSubject` | `false` | `true` | Raise errors for incomplete personal data annotations by default. |
| `cds.messaging.services.<key>.structured` | `false` | `true` | [Structured message representation](./messaging.md#messages-representation) is now enabled by default. |

### Adjusted Property Behavior

| Property | New Behavior |
| --- | --- |
| `cds.outbox.persistent.enabled` | When set to `false`, all persistent outboxes are disabled regardless of their specific configuration. |

### Removed Properties

The following table gives an overview about the removed properties:

| Removed Property | Replacement / Explanation |
| --- | --- |
| `cds.auditlog.outbox.persistent.enabled` | `cds.auditlog.outbox.name` |
| `cds.dataSource.csvFileSuffix` | `cds.dataSource.csv.fileSuffix` |
| `cds.dataSource.csvInitializationMode` | `cds.dataSource.csv.initializationMode` |
| `cds.dataSource.csvPaths` | `cds.dataSource.csv.paths` |
| `cds.dataSource.csvSingleChangeset` | `cds.dataSource.csv.singleChangeset` |
| `cds.security.identity.authConfig.enabled` | `cds.security.authentication.`<br>`authConfig.enabled` |
| `cds.security.xsuaa.authConfig.enabled` | `cds.security.authentication.`<br>`authConfig.enabled` |
| `cds.security.mock.users.<key>.unrestricted` | Special handling of unrestricted attributes has been removed, in favor of [explicit modelling](../guides/security/authorization#unrestricted-xsuaa-attributes). |
| `cds.messaging.services.<key>.outbox.persistent.enabled` | `cds.messaging.services.<key>.outbox.name` |
| `cds.multiTenancy.compatibility.enabled` | MtSubscriptionService API [has been removed](#removed-mtx-classic-support) and compatibility mode is no longer available. |
| `cds.multiTenancy.healthCheck.intervalMillis` | `cds.multiTenancy.healthCheck.interval` |
| `cds.multiTenancy.mtxs.enabled` | MTXS is enabled [by default](#removed-mtx-classic-support). |
| `cds.multiTenancy.security.deploymentScope` | HTTP-based tenant upgrade endpoints [have been removed](#removed-mtx-classic-support). |
| `cds.odataV4.apply.inCqn.enabled` | `cds.odataV4.apply.transformations.enabled` |
| `cds.odataV4.serializer.enabled` | The legacy serializer has been removed. |
| `cds.outbox.persistent.maxAttempts` | `cds.outbox.services.<key>.maxAttempts` |
| `cds.outbox.persistent.storeLastError` | `cds.outbox.services.<key>.storeLastError` |
| `cds.outbox.persistent.ordered` | `cds.outbox.services.<key>.ordered` |
| `cds.remote.services.<key>.destination.headers` | `cds.remote.services.<key>.http.headers` |
| `cds.remote.services.<key>.destination.queries` | `cds.remote.services.<key>.http.queries` |
| `cds.remote.services.<key>.destination.service` | `cds.remote.services.<key>.http.service` |
| `cds.remote.services.<key>.destination.suffix` | `cds.remote.services.<key>.http.suffix` |
| `cds.remote.services.<key>.destination.type` | `cds.remote.services.<key>.type` |
| `cds.sql.search.useLocalizedView` | `cds.sql.search.model` |
| `cds.sql.supportedLocales` | All locales are supported by default for localized entities, as session variables can now be leveraged on all databases. |

### Deprecated Session Context Variables

| Old Variable | Replacement |
| --- | --- |
| `$user.tenant` | `$tenant` |
| `$at.from` | `$valid.from` |
| `$at.to` | `$valid.to` |

### Removed Java APIs

- Removed deprecated classes:
  - `com.sap.cds.services.environment.ServiceBinding`
  - `com.sap.cds.services.environment.ServiceBindingAdapter`
  - `com.sap.cds.services.mt.MtAsyncDeployEventContext`
  - `com.sap.cds.services.mt.MtAsyncDeployStatusEventContext`
  - `com.sap.cds.services.mt.MtAsyncSubscribeEventContext`
  - `com.sap.cds.services.mt.MtAsyncSubscribeFinishedEventContext`
  - `com.sap.cds.services.mt.MtAsyncUnsubscribeEventContext`
  - `com.sap.cds.services.mt.MtAsyncUnsubscribeFinishedEventContext`
  - `com.sap.cds.services.mt.MtDeployEventContext`
  - `com.sap.cds.services.mt.MtGetDependenciesEventContext`
  - `com.sap.cds.services.mt.MtSubscribeEventContext`
  - `com.sap.cds.services.mt.MtSubscriptionService`
  - `com.sap.cds.services.mt.MtUnsubscribeEventContext`

- Removed deprecated methods:
  - `com.sap.cds.services.request.ModifiableUserInfo.addUnrestrictedAttribute`
  - `com.sap.cds.services.request.ModifiableUserInfo.setUnrestrictedAttributes`
  - `com.sap.cds.services.request.ModifiableUserInfo.removeUnrestrictedAttribute`
  - `com.sap.cds.services.request.UserInfo.getUnrestrictedAttributes`
  - `com.sap.cds.services.request.UserInfo.isUnrestrictedAttribute`
  - `com.sap.cds.ql.Insert.cqn(String)`
  - `com.sap.cds.ql.Update.cqn(String)`
  - `com.sap.cds.ql.Upsert.cqn(String)`

- Deprecations:
  - `com.sap.cds.ql.cqn.CqnSearchPredicate`, instead use `CqnSearchTermPredicate`
  - `com.sap.cds.ql.cqn.Modifier.search(String)`, instead use `searchTerm(CqnSearchTermPredicate)`
  - `com.sap.cds.services.messaging.MessageService.emit(String, String)` instead use `emit(String, Map)` or `emit(String, Map, Map)`

### Removed goals in `cds-maven-plugin`

The goal `addSample` from the `cds-maven-plugin` has been removed. Use the new goal `add` with the property `-Dfeature=TINY_SAMPLE` instead.

## Cloud SDK 4 to 5 { #cloudsdk5 }

CAP Java `2.6.0` and higher is compatible with Cloud SDK in version 4 and 5. For reasons of backward compatibility, CAP Java assumes Cloud SDK 4 as the default. However, we highly recommend that you use at least version `5.9.0` of Cloud SDK. If you relied on the Cloud SDK integration package (`cds-integration-cloud-sdk`), you won't need to adapt any code to upgrade your CAP Java application to Cloud SDK 5. In these cases, it's sufficient to add the following maven dependency to your CAP Java application:

```xml
<dependency>
	<groupId>com.sap.cloud.sdk.cloudplatform</groupId>
	<artifactId>connectivity-apache-httpclient4</artifactId>
</dependency>
```

If you are using Cloud SDK APIs explicitly in your code consider the migration guide for Cloud SDK 5 itself: https://sap.github.io/cloud-sdk/docs/java/guides/5.0-upgrade-steps

## CAP Java 1.34 to CAP Java 2.0 { #one-to-two }

This section describes the changes in CAP Java between the major versions 1.34 and 2.0. It provides also helpful information how to migrate a CAP Java application to the new major version 2.0.

As preparation, we strongly recommend to firstly upgrade to 1.34.x and then follow this guide to upgrade to 2.0.x.

### Spring Boot 3

CAP Java 2 uses Spring Boot 3 as underlying framework. Consult the [Spring Boot 3.0 Migration Guide](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.0-Migration-Guide) for changes between Spring Boot 2.7 and Spring Boot 3.0. A CAP Java application is typically only affected by Spring Boot 3 incompatibilities if it uses native Spring APIs.

#### Java 17

Spring Boot 3 requires Java 17 as minimum version.
Maven dependencies, which are not managed by CAP Java, need to be updated to Java 17 compatible versions.

#### Jakarta EE 10

Spring Boot 3 requires Jakarta EE 10. This includes a switch in package names from `javax` to `jakarta`. For example all Servlet-related classes are moved from package `javax.servlet` to `jakarta.servlet`.

For instance, replace
```java
import javax.servlet.http.HttpServletResponse;
```
with
```java
import jakarta.servlet.http.HttpServletResponse;
```

Maven dependencies, which are not managed by CAP Java or Spring Boot, need to be updated to Jakarta EE 10 compatible versions.

#### Spring Security

Since version 1.27 CAP Java is running with Spring Boot 2.7, which uses Spring Security 5.7. Spring Boot 3 uses Spring Security 6. In case you defined custom security configurations you need to follow the guides, which describe the [migration from 5.7 to 5.8](https://docs.spring.io/spring-security/reference/5.8/migration/index.html) and the [migration from 5.8 to 6.0](https://docs.spring.io/spring-security/reference/6.0/migration/index.html).

### Minimum Dependency Versions

Make sure that all libraries used in your project are either compatible with Spring Boot 3 / Jakarta EE 10 or alternatively offer a new version which you can adopt.

CAP Java 2.0 itself requires updated minimum dependency versions:

| Dependency | Minimum Version | Recommended Version |
| --- | --- | --- |
| JDK | 17 | 21 |
| Maven | 3.5.0 | 3.9.8 |
| @sap/cds-dk | 6 | 7 |
| @sap/cds-compiler | 3 | 4 |
| Spring Boot | 3.0 | latest |
| XSUAA | 3.0 | latest |
| SAP Cloud SDK | 4.24 | latest |
| Java Logging | 3.7 | latest |

Java Logging (replace `cf-java-logging-support-servlet` with `cf-java-logging-support-servlet-jakarta`)

::: warning
The Cloud SDK BOM `sdk-bom` manages XSUAA until version 2.x, which isn't compatible with CAP Java 2.x.
You have two options:
* Replace `sdk-bom` with `sdk-modules-bom`, which [manages all Cloud SDK dependencies but not the transitive dependencies.](https://sap.github.io/cloud-sdk/docs/java/guides/manage-dependencies#the-sap-cloud-sdk-bill-of-material)
* Or, add [dependency management for XSUAA](https://github.com/SAP/cloud-security-services-integration-library#installation) before Cloud SDK's `sdk-bom`.
:::

### API Cleanup

Some interfaces, methods, configuration properties and annotations, which had already been deprecated in 1.x, are now removed in version 2.0. Please strictly fix all usage of [deprecated APIs](#overview-of-removed-interfaces-and-methods) by using the recommended replacement.

::: tip
In your IDE, enable the compiler warning "Signal overwriting or implementing deprecated method".
:::

#### Legacy Upsert

Up to cds-services 1.27, upsert always completely _replaced_ pre-existing data with the given data: it was implemented as
cascading delete followed by a deep _insert_. In the insert phase, for all elements that were absent in the data,
the initializations were performed: UUID generation, `@cds.on.insert` handlers, and initialization with default values.
Consequently, in the old implementation, an upsert with partial data would have reset absent elements to their initial values!
To avoid a reset with the old upsert, data always had to be complete.

Since version 1.28 the upsert is implemented as a deep _update_ that creates data if not existing.  An upsert with partial data now leaves the absent elements untouched. In particular, UUID values are _not generated_ with the new upsert implementation.

Application developers upgrading from cds-services <= 1.27 need to be aware of these changes.
Check, if the usage of upsert in your code is compatible with the new implementation, especially:

* Ensure that all key values are contained in the data and you don't rely on UUID key generation.
* Check if insert is more appropriate.

::: warning
The global configuration parameter `cds.sql.upsert.strategy`, as well as the upsert hint to switch back to the legacy upsert behavior are not supported anymore with 2.0. If you rely on the replace behavior of the legacy upsert, use a cascading delete followed by a deep insert.
:::

#### Representation of Pagination {#limit}
The interfaces <Cds4j link="ql/cqn/CqnLimit.html">CqnLimit</Cds4j> and <Cds4j link="ql/Limit.html">Limit</Cds4j> are removed. Use the methods `limit(top)` and `limit(top, skip)` of the `Select` and `Expand` to specify the pagination settings. Use the methods <Cds4j link="ql/cqn/CqnEntitySelector.html#skip--">top()</Cds4j> and <Cds4j link="ql/cqn/CqnEntitySelector.html#skip--">skip()</Cds4j> of the `CqnEntitySelector` to introspect the pagination settings of a `CqnExpand` and `CqnSelect`.

#### Statement Modification {#modification}

##### Removal of Deprecated CqnModifier
The deprecated <Cds4j link="ql/cqn/CqnModifier.html">CqnModifier</Cds4j>, whose default methods make expensive copies of literal values, is removed. Instead, use the <Cds4j latest link="ql/cqn/Modifier.html">Modifier</Cds4j> as documented in [Modifying CQL Statements](working-with-cql/query-api#copying-modifying-cql-statements).

If your modifier overrides one or more of the `CqnModifier:literal` methods that take `value` and `cdsType` as arguments, override `Modifier:literal(CqnLiteral<?> literal)` instead. You can create new values using `CQL.val(value).type(cdsType);`.

##### Removal of Deprecated Methods in Modifier {#modifier}
The deprecated methods `ref(StructuredTypeRef)` and `ref(ElementRef<?>)` are removed, instead implement the new methods `ref(CqnStructuredTypeRef)` and `ref(CqnElementRef)`. Use `CQL.copy(ref)` if you require a modifiable copy of the ref.

```java
Modifier modifier = new Modifier() {
	@Override
	public CqnStructuredTypeRef ref(CqnStructuredTypeRef ref) {
		RefBuilder<StructuredTypeRef> copy = CQL.copy(ref); // try to avoid copy
		copy.targetSegment().filter(newFilter);
		return copy.build();
	}

	@Override
	public CqnValue ref(CqnElementRef ref) {
		List<Segment> segments = new ArrayList<>(ref.segments());
		segments.add(0, CQL.refSegment(segments.get(0).id(), filter));
		return CQL.get(segments).as(alias);
	}
};
CqnStatement copy = CQL.copy(statement, modifier);
```

### Removed Interfaces and Methods Overview {#overview-of-removed-interfaces-and-methods}


#### com.sap.cds

| Class / Interface | Method / Field | Replacement |
| --- | --- | --- |
| <Cds4j link="ConstraintViolationException.html">ConstraintViolationException</Cds4j> | | <Cds4j latest link="UniqueConstraintException.html">UniqueConstraintException</Cds4j> |
| <Cds4j link="ResultBuilder.html">ResultBuilder</Cds4j> | <Cds4j link="ResultBuilder.html#updatedRows-int:A-java.util.List-">updatedRows</Cds4j> | see <Cds4j link="ResultBuilder.html#updatedRows-int:A-java.util.List-">javadoc</Cds4j> |

#### com.sap.cds.ql

| Class / Interface | Method / Field | Replacement |
| --- | --- | --- |
| <Cds4j link="ql/CQL.html">CQL</Cds4j> | <Cds4j link="ql/CQL.html#literal-T-">literal</Cds4j> | <Cds4j latest link="ql/CQL.html#val-T-">val</Cds4j> or <Cds4j latest link="ql/CQL.html#constant-T-">constant</Cds4j> |
| <Cds4j link="ql/Select.html">Select</Cds4j> | <Cds4j link="ql/Select.html#groupBy-java.util.Collection-">groupBy</Cds4j> | <Cds4j latest link="ql/Select.html#groupBy-java.util.List-">groupBy</Cds4j> |

#### com.sap.cds.ql.cqn

| Class / Interface | Method / Field | Replacement |
| --- | --- | --- |
| <Cds4j link="ql/cqn/CqnParameter.html">CqnParameter</Cds4j> | <Cds4j link="ql/cqn/CqnParameter.html#getName--">getName</Cds4j> | <Cds4j link="ql/cqn/CqnParameter.html#name--">name</Cds4j> |
| <Cds4j link="ql/cqn/CqnReference.Segment.html">CqnReference.Segment</Cds4j> | <Cds4j link="ql/cqn/CqnReference.Segment.html#accept-com.sap.cds.ql.cqn.CqnVisitor-">accept(visitor)</Cds4j> | <Cds4j latest link="ql/cqn/CqnReference.html#accept-com.sap.cds.ql.cqn.CqnVisitor-">CqnReference.accept(visitor)</Cds4j> |
| <Cds4j link="ql/cqn/CqnSelectList.html">CqnSelectList</Cds4j> | <Cds4j link="ql/cqn/CqnSelectList.html#prefix--">prefix</Cds4j> | <Cds4j latest link="ql/cqn/CqnSelectList.html#ref--">ref</Cds4j> |
| <Cds4j link="ql/cqn/CqnSelectListItem.html">CqnSelectListItem</Cds4j> | <Cds4j link="ql/cqn/CqnSelectListItem.html#displayName--">displayName</Cds4j> | <Cds4j latest link="ql/cqn/CqnSelectListItem.html#asValue--">asValue</Cds4j> + <Cds4j latest link="ql/cqn/CqnSelectListValue.html#displayName--">displayName</Cds4j> |
| | <Cds4j link="ql/cqn/CqnSelectListItem.html#alias--">alias</Cds4j> | <Cds4j latest link="ql/cqn/CqnSelectListItem.html#asValue--">asValue</Cds4j> + <Cds4j latest link="ql/cqn/CqnSelectListValue.html#alias--">alias</Cds4j> |
| <Cds4j link="ql/cqn/CqnSortSpecification.html">CqnSortSpecification</Cds4j> | <Cds4j link="ql/cqn/CqnSortSpecification.html#item--">item</Cds4j> | <Cds4j latest link="ql/cqn/CqnSortSpecification.html#value--">value</Cds4j> |
| <Cds4j link="ql/cqn/CqnSource.html">CqnSource</Cds4j> | <Cds4j link="ql/cqn/CqnSource.html#isQuery--">isQuery</Cds4j> | <Cds4j latest link="ql/cqn/CqnSource.html#isSelect--">isSelect</Cds4j> |
| | <Cds4j link="ql/cqn/CqnSource.html#asQuery--">asQuery</Cds4j> | <Cds4j latest link="ql/cqn/CqnSource.html#asSelect--">asSelect</Cds4j> |
| <Cds4j link="ql/cqn/CqnVisitor.html">CqnVisitor</Cds4j> | <Cds4j link="ql/cqn/CqnVisitor.html#visit-com.sap.cds.ql.cqn.CqnReference.Segment-">visit(CqnReference.Segment seg)</Cds4j> | <Cds4j latest link="ql/cqn/CqnVisitor.html#visit-com.sap.cds.ql.cqn.CqnElementRef-">visit(CqnElementRef)</Cds4j>, <Cds4j latest link="ql/cqn/CqnVisitor.html#visit-com.sap.cds.ql.cqn.CqnStructuredTypeRef-">visit(CqnStructuredTypeRef)</Cds4j>|
| <Cds4j link="ql/cqn/CqnXsert.html">CqnXsert</Cds4j> | <Cds4j link="ql/cqn/CqnXsert.html#getKind--">getKind</Cds4j> | <Cds4j latest link="ql/cqn/CqnStatement.html#isInsert--">isInsert</Cds4j>, <Cds4j latest link="ql/cqn/CqnStatement.html#isUpsert--">isUpsert</Cds4j> |
| <Cds4j link="ql/cqn/Modifier.html">Modifier</Cds4j> | <Cds4j link="ql/cqn/CompatibilityDefaults.html#ref-com.sap.cds.ql.StructuredTypeRef-">ref(StructuredTypeRef ref)</Cds4j> | <Cds4j link="ql/cqn/Modifier.html#ref-com.sap.cds.ql.cqn.CqnStructuredTypeRef-">ref(CqnStructuredTypeRef ref)</Cds4j> |
| | <Cds4j link="ql/cqn/CompatibilityDefaults.html#ref-com.sap.cds.ql.ElementRef-">ref(ElementRef<?> ref)</Cds4j> | <Cds4j link="ql/cqn/Modifier.html#ref-com.sap.cds.ql.cqn.CqnElementRef-">ref(CqnElementRef ref)</Cds4j> |
| | <Cds4j link="ql/cqn/CompatibilityDefaults.html#in-com.sap.cds.ql.Value-java.util.Collection-">in(Value, Collection)</Cds4j> | <Cds4j link="ql/cqn/Modifier.html#in-com.sap.cds.ql.Value-com.sap.cds.ql.cqn.CqnValue-">in(Value, CqnValue)</Cds4j> |
| | <Cds4j link="ql/cqn/CompatibilityDefaults.html#match-com.sap.cds.ql.StructuredTypeRef-com.sap.cds.ql.Predicate-com.sap.cds.ql.cqn.CqnMatchPredicate.Quantifier-">match(ref, pred, quantifier)</Cds4j> | <Cds4j link="ql/cqn/Modifier.html#match-com.sap.cds.ql.cqn.CqnMatchPredicate-">match(CqnMatchPredicate match)</Cds4j> |
| | <Cds4j link="ql/cqn/CompatibilityDefaults.html#selectListItem-com.sap.cds.ql.Value-java.lang.String-">selectListItem(value, alias)</Cds4j> | <Cds4j link="ql/cqn/Modifier.html#selectListValue-com.sap.cds.ql.Value-java.lang.String-">selectListValue(value, alias)</Cds4j> |
| | <Cds4j link="ql/cqn/CompatibilityDefaults.html#inline-com.sap.cds.ql.StructuredTypeRef-java.util.List-">inline(ref, items)</Cds4j> | <Cds4j link="ql/cqn/Modifier.html#inline-com.sap.cds.ql.cqn.CqnInline-">inline(CqnInline inline)</Cds4j> |
| | <Cds4j link="ql/cqn/CompatibilityDefaults.html#expand-com.sap.cds.ql.StructuredTypeRef-java.util.List-java.util.List-com.sap.cds.ql.cqn.CqnLimit-">expand(ref, items, orderBy, limit)</Cds4j> | <Cds4j link="ql/cqn/Modifier.html#expand-com.sap.cds.ql.cqn.CqnExpand-">expand(CqnExpand expand)</Cds4j> |
| | <Cds4j link="ql/cqn/CompatibilityDefaults.html#expand-com.sap.cds.ql.Expand-">expand(Expand<?> expand)</Cds4j> | <Cds4j link="ql/cqn/Modifier.html#expand-com.sap.cds.ql.cqn.CqnExpand-">expand(CqnExpand expand)</Cds4j> |
| | <Cds4j link="ql/cqn/CompatibilityDefaults.html#limit-com.sap.cds.ql.Limit-">limit(Limit limit)</Cds4j> | <Cds4j link="ql/cqn/Modifier.html#top-long-">top(long top)</Cds4j> and <Cds4j link="ql/cqn/Modifier.html#skip-long-">skip(long skip)</Cds4j> |

#### com.sap.cds.reflect

| Class / Interface | Method / Field | Replacement |
| --- | --- | --- |
| <Cds4j link="reflect/CdsAssociationType.html">CdsAssociationType</Cds4j> | <Cds4j link="reflect/CdsAssociationType.html#keys--">keys</Cds4j> | <Cds4j latest link="reflect/CdsAssociationType.html#refs--">refs</Cds4j> |
| <Cds4j link="reflect/CdsStructuredType.html">CdsStructuredType</Cds4j> | <Cds4j link="reflect/CdsStructuredType.html#isInlineDefined--">isInlineDefined</Cds4j> | <Cds4j latest link="reflect/CdsStructuredType.html#isAnonymous--">isAnonymous</Cds4j> |


#### com.sap.cds.services

| Class / Interface | Method / Field | Replacement |
| --- | --- | --- |
|<CdsSrv link="services/ErrorStatus.html">ErrorStatus</CdsSrv> | <CdsSrv link="services/ErrorStatus.html#getCode--">getCode()</CdsSrv> | <CdsSrv latest link="services/ErrorStatus.html#getCodeString--">getCodeString()</CdsSrv>|
| <CdsSrv link="services/ServiceException.html">ServiceException</CdsSrv> | <CdsSrv link="services/ServiceException.html#messageTarget-java.lang.String-java.lang.String-java.util.function.Function-">messageTarget(prefix, entity, path)</CdsSrv> |<CdsSrv latest link="services/ServiceException.html#messageTarget-java.lang.String-java.util.function.Function-">messageTarget(parameter, path)</CdsSrv> |

#### com.sap.cds.services.cds

|Class/Interface  | Method  | Replacement  |
|---------|---------| -----|
|<CdsSrv link="services/cds/CdsService.html">CdsService</CdsSrv>   |  | <CdsSrv latest link="services/cds/CqnService.html">CqnService</CdsSrv>        |

#### com.sap.cds.services.environment

| Class / Interface | Method / Field | Replacement |
| --- | --- | --- |
|<CdsSrv latest link="services/environment/ServiceBinding.html">ServiceBinding</CdsSrv>  |   |   [com.sap.cloud.environment.<br>`servicebinding.api.ServiceBinding`](https://github.com/SAP/btp-environment-variable-access/blob/main/api-parent/core-api/src/main/java/com/sap/cloud/environment/servicebinding/api/ServiceBinding.java)      |

::: details

##### Interface `ServiceBinding`
The interface <CdsSrv latest link="services/environment/ServiceBinding.html">`com.sap.cds.services.environment.ServiceBinding`</CdsSrv> is deprecated and replaced with interface [`com.sap.cloud.environment.servicebinding.api.ServiceBinding`](https://github.com/SAP/btp-environment-variable-access/blob/main/api-parent/core-api/src/main/java/com/sap/cloud/environment/servicebinding/api/ServiceBinding.java). For convenience the adapter class `com.sap.cds.services.utils.environment.ServiceBindingAdapter` is provided, which maps the deprecated interface to the new one.

:::

#### com.sap.cds.services.handler

|Class/Interface  | Method  | Replacement  |
|---------|---------| -----|
|<CdsSrv link="services/handler/EventPredicate.html">EventPredicate</CdsSrv>   |  | n/a |

::: details

#### Interface `EventPredicate`
The interface `com.sap.cds.services.handler.EventPredicate` is removed. Consequently, all methods at interface <CdsSrv latest link="services/Service.html">`com.sap.cds.services.Service`</CdsSrv> containing this interface as argument are removed. All removed method were marked as deprecated in prior releases.

:::

#### com.sap.cds.services.messages

| Class / Interface | Method / Field | Replacement |
| --- | --- | --- |
| <CdsSrv link="services/messages/Message.html">Message</CdsSrv> | <CdsSrv link="services/messages/Message.html#target-java.lang.String-java.lang.String-java.util.function.Function-">target(prefix, entity, path)</CdsSrv> | <CdsSrv link="services/messages/Message.html#target-java.lang.String-java.util.function.Function-">target(start, path)</CdsSrv>|
| <CdsSrv link="services/messages/MessageTarget.html">MessageTarget</CdsSrv> | <CdsSrv link="services/messages/MessageTarget.html#getPrefix--">getPrefix()</CdsSrv> | <CdsSrv latest link="services/messages/MessageTarget.html#getParameter--">getParameter()</CdsSrv> |
| | <CdsSrv link="services/messages/MessageTarget.html#getEntity--">getEntity()</CdsSrv>, <CdsSrv link="services/messages/MessageTarget.html#getPath--">getPath()</CdsSrv>| <CdsSrv latest link="services/messages/MessageTarget.html#getRef--">getRef()</CdsSrv>  |

#### com.sap.cds.services.persistence

| Class / Interface | Method / Field | Replacement |
| --- | --- | --- |
| <CdsSrv link="services/persistence/PersistenceService.html">PersistenceService</CdsSrv> | <CdsSrv link="services/persistence/PersistenceService.html#getCdsDataStore--">getCdsDataStore()</CdsSrv> | Use <CdsSrv link="services/persistence/PersistenceService.html#getCdsDataStore--">PersistenceService</CdsSrv> |

#### com.sap.cds.services.request

| Class / Interface | Method / Field | Replacement |
| --- | --- | --- |
|<CdsSrv link="services/request/ParameterInfo.html">ParameterInfo</CdsSrv> | <CdsSrv link="services/request/ParameterInfo.html#getQueryParameters--">getQueryParameters()</CdsSrv> | <CdsSrv latest link="services/request/ParameterInfo.html#getQueryParams--">getQueryParams()</CdsSrv> |
| <CdsSrv link="services/request/UserInfo.html">UserInfo</CdsSrv> | <CdsSrv link="services/request/UserInfo.html#getAttribute-java.lang.String-">getAttribute(String)</CdsSrv> | <CdsSrv link="services/request/UserInfo.html#getAttributeValues-java.lang.String-">getAttributeValues(String)</CdsSrv> |



#### com.sap.cds.services.runtime

| Class / Interface | Method / Field | Replacement |
| --- | --- | --- |
| <CdsSrv link="services/runtime/CdsModelProvider.html">CdsModelProvider</CdsSrv> | <CdsSrv link="services/runtime/CdsModelProvider.html#get-java.lang.String-">get(tenantId)</CdsSrv>  | <CdsSrv latest link="services/runtime/CdsModelProvider.html#get-com.sap.cds.services.request.UserInfo-com.sap.cds.services.request.FeatureTogglesInfo-">get(userInfo, features)</CdsSrv>|
| <CdsSrv link="services/runtime/CdsRuntime.html">CdsRuntime</CdsSrv> |<CdsSrv link="services/runtime/CdsRuntime.html#runInChangeSetContext-java.util.function.Consumer-">runInChangeSetContext(Consumer)</CdsSrv> | <CdsSrv latest link="services/runtime/CdsRuntime.html#changeSetContext--">changeSetContext()</CdsSrv>.<CdsSrv latest link="services/runtime/ChangeSetContextRunner.html#run-java.util.function.Consumer-">run(Consumer)</CdsSrv> |
| |<CdsSrv link="services/runtime/CdsRuntime.html#runInChangeSetContext-java.util.function.Function-">runInChangeSetContext(Function)</CdsSrv> | <CdsSrv latest link="services/runtime/CdsRuntime.html#changeSetContext--">changeSetContext()</CdsSrv>.<CdsSrv latest link="services/runtime/ChangeSetContextRunner.html#run-java.util.function.Function-">run(Function)</CdsSrv> |
| |<CdsSrv link="services/runtime/CdsRuntime.html#runInRequestContext-com.sap.cds.services.runtime.Request-java.util.function.Consumer-">runInRequestContext(Consumer)</CdsSrv> | <CdsSrv latest link="services/runtime/CdsRuntime.html#requestContext--">requestContext()</CdsSrv>.<CdsSrv latest link="services/runtime/RequestContextRunner.html#run-java.util.function.Consumer-">run(Consumer)</CdsSrv> |
| |<CdsSrv link="services/runtime/CdsRuntime.html#runInRequestContext-com.sap.cds.services.runtime.Request-java.util.function.Function-">runInRequestContext(Function)</CdsSrv> | <CdsSrv latest link="services/runtime/CdsRuntime.html#requestContext--">requestContext()</CdsSrv>.<CdsSrv latest link="services/runtime/RequestContextRunner.html#run-java.util.function.Function-">run(Function)</CdsSrv> |
| <CdsSrv link="services/runtime/Request.html">Request</CdsSrv> | CdsRuntime.runInRequestContext(Request, Function\|Consumer) | <CdsSrv latest link="services/runtime/CdsRuntime.html#requestContext--">CdsRuntime.requestContext()</CdsSrv><CdsSrv latest link="services/runtime/RequestContextRunner.html#run-java.util.function.Consumer-">.run(Function)</CdsSrv> |
| <CdsSrv link="services/runtime/RequestParameters.html">RequestParameters</CdsSrv> | CdsRuntime.runInRequestContext(Request, Function\|Consumer) | <CdsSrv latest link="services/runtime/CdsRuntime.html#requestContext--">CdsRuntime.requestContext()</CdsSrv><CdsSrv latest link="services/runtime/RequestContextRunner.html#run-java.util.function.Consumer-">.run(Function)</CdsSrv> |
| <CdsSrv link="services/runtime/RequestUser.html">RequestUser</CdsSrv> | CdsRuntime.runInRequestContext(Request, Function\|Consumer) | <CdsSrv latest link="services/runtime/CdsRuntime.html#requestContext--">CdsRuntime.requestContext()</CdsSrv><CdsSrv latest link="services/runtime/RequestContextRunner.html#run-java.util.function.Consumer-">.run(Function)</CdsSrv> |

::: details

#### Method `CdsRuntime.runInRequestContext(Request, Function|Consumer)`
The interface <CdsSrv link="services/runtime/Request.html">`Request`</CdsSrv> and its used interfaces <CdsSrv link="services/runtime/RequestParameters.html">`RequestParameters`</CdsSrv> and <CdsSrv link="services/runtime/RequestUser.html">`RequestUser`</CdsSrv> are removed. They were still used in the method <CdsSrv link="services/runtime/CdsRuntime.html#runInRequestContext-com.sap.cds.services.runtime.Request-java.util.function.Consumer-">`CdsRuntime.runInRequestContext(Request, Function|Consumer)`</CdsSrv>, which was also deprecated and should be replaced by <CdsSrv latest link="services/runtime/CdsRuntime.html#requestContext--">`CdsRuntime.requestContext()`</CdsSrv><CdsSrv latest link="services/runtime/RequestContextRunner.html#run-java.util.function.Consumer-">`.run(Function)`</CdsSrv>

:::

#### Overview of Removed CDS Properties

Some CdsProperties were already marked as deprected in CAP Java 1.x and are now removed in 2.x.

| removed | replacement |
| --- | --- |
| <CdsSrv link="services/environment/CdsProperties.DataSource.html">cds.dataSource.serviceName</CdsSrv> | `cds.dataSource.binding` |
| cds.drafts.associationsToInactiveEntities | see [Lean Draft](#lean-draft) |
| <CdsSrv link="services/environment/CdsProperties.Locales.Normalization.html">cds.locales.normalization.whiteList</CdsSrv> | `cds.locales.normalization.includeList` |
| <CdsSrv link="services/environment/CdsProperties.Messaging.MessagingServiceConfig.Queue.html">cds.messaging.services.\<key\>.queue.maxFailedAttempts</CdsSrv> | Use custom error handling |
| <CdsSrv link="services/environment/CdsProperties.Messaging.MessagingServiceConfig.html">cds.messaging.services.\<key\>.topicNamespace</CdsSrv> | `cds.messaging.services.<key>.subscribePrefix` |
| <CdsSrv link="services/environment/CdsProperties.MultiTenancy.html">cds.multiTenancy.instanceManager</CdsSrv> | `cds.multiTenancy.serviceManager` |
| <CdsSrv link="services/environment/CdsProperties.MultiTenancy.Sidecar.DataSource.html">cds.multiTenancy.dataSource.hanaDatabaseIds</CdsSrv> | obsolete, information is automatically retrieved from bindings |
| <CdsSrv link="services/environment/CdsProperties.ODataV4.html">cds.odataV4.indexPage</CdsSrv> | `cds.indexPage` |
| <CdsSrv link="services/environment/CdsProperties.Security.html#isAuthenticateUnknownEndpoints--">cds.security.authenticateUnknownEndpoints</CdsSrv> | `cds.security.authentication.authenticateUnknownEndpoints` |
| <CdsSrv link="services/environment/CdsProperties.Security.html#getAuthorizeAutoExposedEntities--">cds.security.authorizeAutoExposedEntities</CdsSrv> | if disabled, add auto-exposed entities explicitly into your service definition |
| <CdsSrv link="services/environment/CdsProperties.Security.Authorization.html#getAutoExposedEntities--">cds.security.authorization.autoExposedEntities</CdsSrv> | if disabled, add auto-exposed entities explicitly into your service definition |
| <CdsSrv link="services/environment/CdsProperties.Security.html#getDefaultRestrictionLevel--">cds.security.defaultRestrictionLevel</CdsSrv> | `cds.security.authentication.mode` |
| <CdsSrv link="services/environment/CdsProperties.Security.html#getDraftProtection--">cds.security.draftProtection</CdsSrv> | `cds.security.authorization.draftProtection` |
| <CdsSrv link="services/environment/CdsProperties.Security.html#getInstanceBasedAuthorization--">cds.security.instanceBasedAuthorization</CdsSrv> | if disabled, remove `@requires` / `@restrict` annotations |
| <CdsSrv link="services/environment/CdsProperties.Security.Authorization.html#getInstanceBasedAuthorization--">cds.security.authorization.instanceBasedAuthorization</CdsSrv> | remove `@requires` / `@restrict` annotations |
| <CdsSrv link="services/environment/CdsProperties.Security.html#isOpenMetadataEndpoints--">cds.security.openMetadataEndpoints</CdsSrv> | `cds.security.authentication.authenticateMetadataEndpoints` |
| <CdsSrv link="services/environment/CdsProperties.Security.html#getOpenUnrestrictedEndpoints--">cds.security.openUnrestrictedEndpoints</CdsSrv> | `cds.security.authentication.mode` |
| <CdsSrv link="services/environment/CdsProperties.Security.Xsuaa.html">cds.security.xsuaa.serviceName</CdsSrv> | `cds.security.xsuaa.binding` |
| <CdsSrv link="services/environment/CdsProperties.Security.Xsuaa.html">cds.security.xsuaa.normalizeUserNames</CdsSrv> | obsolete, effectively hard-coded to `false` |
| <CdsSrv link="services/environment/CdsProperties.html">cds.services</CdsSrv> | cds.application.services |
| <CdsSrv link="services/environment/CdsProperties.Sql.Upsert.html">cds.sql.upsert</CdsSrv> | See [Legacy Upsert](#legacy-upsert) |

### Removed Annotations Overview

- `@search.cascade` is no longer supported. It's replaced by [@cds.search](../guides/providing-services#cds-search).

### Changed Behavior

#### Immutable Values

The implementations of `Value` are now immutable. This change makes [copying & modifying CQL statements](./working-with-cql/query-api#copying-modifying-cql-statements) cheaper, which significantly improves the performance.

Changing the type of a value via `Value::type` now returns a new (immutable) value or throws an exception if the type change is not supported:

```Java
Literal<Number> number = CQL.val(100);
Value<String>   string = number.type(CdsBaseType.STRING); // number is unchanged
```

#### Immutable References

In CDS QL, a [reference](../cds/cxn#references) (_ref_) identifies an entity set or element of a structured type. References can have multiple segments and ref segments can have filter conditions.

The default implementations of references (`ElementRef` and `StructuredTypeRef`), as well as ref segments (`RefSegment`) are now immutable. This change makes [copying & modifying CQL statements](./working-with-cql/query-api#copying-modifying-cql-statements) much cheaper, which significantly improves the performance.

##### - Set alias or type

`CQL:entity:asRef`, `CQL:to:asRef` and `CQL:get` create immutable refs. Modifying the ref is not supported. Methods `as(alias)` and `type(cdsType)` now return a *new* (immutable) ref:

```java
ElementRef<?> authorName = CQL.get("name").as("Author");
ElementRef<?> nombre = authorName.as("nombre");         // authorName is unchanged
ElementRef<?> string = authorName.type("cds.String");   // authorName is unchanged
```

##### - Modify ref segments

Also the segments of an immutable ref can't be modified in-place any longer. Create an immutable ref segment with filter as follows:

```java
Segment seg = CQL.refSegment("title", predicate);
```

The deprecated `RefSegment:id` and `RefSegment:filter` methods now throw an `UnsupportedOperationException`. For in-place modification of ref segments use `CQL.copy(ref)` to create a `RefBuilder`, which is a modifiable copy of the original ref. The `RefBuilder` allows to modify the segments in-place to change the segment ID or set a filter. Finally call the `build` method to create an immutable ref.

To manipulate a ref in a [Modifier](#modifier), implementations need to override the new `ref(CqnStructuredTypeRef ref)` and `ref(CqnElementRef ref)` methods.

#### Null Values in CDS QL Query Results

With CAP Java 2.0, `null` values are not removed from the result of CDS QL queries anymore, this needs to be considered when using methods that operate on the key set of `Row`, such as `Row:containsKey`, `Row:keySet` and `Row:entrySet`.

#### Result of Updates Without Matching Entity

The `Result` rows of CDS QL Updates are not cleared anymore if no entity was updated. To find out if the entity has been updated, check the [update count](./working-with-cql/query-api#update):

```Java
CqnUpdate update = Update.entity(BOOKS).entry(book); // w/ book: {ID: 0, stock: 3}
Result result = service.run(update);

long updateCount = result.rowCount(); // 0 matches with ID 0
```

For batch updates use `Result::rowCount` with the [batch index](./working-with-cql/query-execution#batch-execution):

```Java
// books: [{ID: 251, stock: 11}, {ID: 252, stock: 7}, {ID: 0, stock: 3}]
CqnUpdate update = Update.entity(BOOKS).entries(books);
Result result = service.run(update);

result.batchCount(); // number of batches (3)
result.rowCount(2);  // 0 matches with ID 0
```

#### Provider Tenant Normalization

The default value of CDS Property `cds.security.authentication.normalizeProviderTenant` is changed to `true`. With this change, the provider tenant is normalized and set to `null` in the UserInfo by default. If you have subscribed the provider tenant to your application you need to disable this feature.

### Lean Draft

The property `cds.drafts.associationsToInactiveEntities` has been removed. It enabled a feature, which caused associations to other draft documents to combine active and inactive versions of the association target. This mixing of inactive and active data is no longer supported.
In cases where it is still required to connect two independent draft documents through an association, you can annotate this association with `@odata.draft.enclosed`. Note: This ensures that the active version points to an active target, while the inactive version points to an inactive target. It will not mix active and inactive data into the same association.

The following table summarizes the behaviour of associations between different draft-enabled entities:

| Source Entity | Association Type | Target Entity | Draft Document Boundaries |
| --- | --- | --- | --- |
| active<sup>1</sup> | composition | active | same document |
| inactive<sup>2</sup> | composition | inactive | same document |
| active | [backlink](../cds/cdl#to-many-associations) association | active | same document |
| inactive | backlink association | inactive | same document |
| active | association | active | independent documents |
| inactive | association | active | independent documents |
| active | association with `@odata.draft.enclosed` | active | independent documents |
| inactive | association with `@odata.draft.enclosed` | inactive | independent documents |

<sup>1</sup> `IsActiveEntity = true`
<br>
<sup>2</sup> `IsActiveEntity = false`

### Changes to Maven Plugins

#### cds-maven-plugin

The deprecated parameters `generateMode` and `parserMode` are removed from the [goal generate](./assets/cds-maven-plugin-site/generate-mojo.html){target="_blank"}.

#### cds4j-maven-plugin

The deprecated Maven plugin `cds4j-maven-plugin` is removed and no longer available. It's replaced by the [`cds-maven-plugin`](./assets/cds-maven-plugin-site/plugin-info.html){target="_blank"} which provides the same functionality and more.


## Classic MTX to Streamlined MTX

How to migrate from [classic MTX](./multitenancy) to [streamlined MTX](../guides/multitenancy/) is described [here](../guides/multitenancy/old-mtx-migration).


## CAP Java Classic to CAP Java 1.x

To make the CAP Java SDK and therefore the applications built on it future-proof, we revamped the CAP Java SDK. Compared the classic CAP Java Runtime (also known as the "Java Gateway stack"), the new CAP Java SDK has numerous benefits:

- Starts up much faster
- Supports local development with SQLite
- Has clean APIs to register event handlers
- Integrates nicely with Spring and Spring Boot
- Supports custom protocol adapters (OData V4 support included)
- Has a modular design: Add features as your application grows
- Enables connecting to advanced SAP BTP services like SAP Event Mesh

We strongly recommend adopting the new CAP Java SDK when starting a new project. Existing projects that currently use the classic CAP Java Runtime can adopt the new CAP Java SDK midterm to take advantage of new features and the superior architecture. In the following sections, we describe the steps to migrate a Java project from the classic CAP Java Runtime to the new CAP Java SDK.



### OData Protocol Version

The classic CAP Java Runtime came in several different flavors supporting either the OData V2 or V4 protocols. The new CAP Java SDK streamlines this by providing a common [protocol adapter layer](./developing-applications/building#protocol-adapters), which enables to handle any OData protocol version or even different protocols with *one* application backend. Hence, if you decide to change the protocol that exposes your domain model, you no longer have to change your business logic.

::: tip
By default, the CAP Java Runtime comes with protocol adapters for OData V4 and [OData V2 (Beta)](#v2adapter). Therefore, you can migrate your frontend code to new CAP Java SDK without change. In addition, you have the option to move from SAP Fiori Elements V2 to SAP Fiori Elements V4 at any time.
:::

### Migrate the Project Structure

Create a new CAP Java project beside your existing one, which you want to migrate. You can use the CAP Java Maven archetype to create a new CAP Java project:

```sh
mvn archetype:generate -DarchetypeArtifactId=cds-services-archetype -DarchetypeGroupId=com.sap.cds -DarchetypeVersion=RELEASE
```

<div id="release-sap" />
<Fragment target="#release-sap">

::: tip Artifactory <Internal />
At SAP, if you're using the internal [Artifactory repository](https://int.repositories.cloud.sap/) you need to explicitly exchange `RELEASE` in `-DarchetypeVersion` with the [latest released version of `com.sap.cds:cds-services-bom`](https://javadoc.io/doc/com.sap.cds). Using `RELEASE`, the above command will install the internally available milestones of the next major release.
:::

</Fragment>

Further details about creating a new CAP Java project and the project structure itself can be found in section [Starting a New Project](./getting-started#new-project).

By default, the Java service module goes to the folder `srv`. If you want to use a different service module folder, you have to adapt it manually.
Rename the service module folder to your preferred name and adjust also the `<modules>` section in the file `pom.xml` in your projects root folder:

```xml
...
<modules>
	<module>srv</module> 
</modules>
...
```

::: tip
If you've changed the service module folder name, you have to consider this in the next steps.
:::

### Copy the CDS Model

Now, you can start migrating your CDS model from the classic project to the newly created CAP Java project.

Therefore, copy your CDS model and data files (_*.cds_ & _*.csv_) manually from the classic project to the corresponding locations in the new project, presumably the `db` folder. If you organize your CDS files within subfolders, also re-create these subfolders in the new project to ensure the same relative path between copied CDS files. Otherwise, compiling your CDS model in the new project would fail.

Usually the CDS files are located in the following folders:

| Usage | Location in classic project | Location in new CAP Java project |
| --- | --- | --- |
| Database Model | `<CLASSIC-PROJECT-ROOT>/db/**` | `<NEW-PROJECT-ROOT>/db/**` |
| Service Model | `<CLASSIC-PROJECT-ROOT>/srv/**` | `<NEW-PROJECT-ROOT>/srv/**` |

If your CDS model depends on other reusable CDS models, add those dependencies to `<NEW-PROJECT-ROOT>/package.json`:

```json
...
"dependencies": {
	"@sap/cds": "^3.0.0",
	...  // add your CDS model reuse dependencies here
},
...
```

::: tip
In your CDS model, ensure that you explicitly define the data type of the elements whenever an aggregate function (max, min, avg etc.) is used, else the build might fail.
:::

In the following example, element `createdAt` has an explicitly specified datatype (that is `timestamp`):

```cds
view AddressView as select from Employee.Address {
    street, apartment, postal_code, MAX(createdAt) AS createdAt: timestamp
};
```

#### CDS Configuration

The CDS configuration is also part of `<PROJECT-ROOT>/package.json` and has to be migrated as well from the classic to the new project.
Therefore, copy and replace the whole `cds` section from your classic _package.json_ to the new project:

```json
...
"dependencies": {
	"@sap/cds": "^3.0.0",
},
"cds": { // copy this CDS configuration from your classic project
	...
}
...
```

::: tip
If there's also a `<CLASSIC-PROJECT-ROOT>/.cdsrc.json` in your classic project to configure the CDS build, copy this file to the new project.
:::

You can validate the final CDS configuration by executing a CDS command in the root folder of the new project:

```sh
cds env
```

It prints the effective CDS configuration on the console. Check, that this configuration is valid for your project.
Execute this command also in your classic project and compare the results, they should be same.

Further details about effective CDS configuration can be found in section [Effective Configuration](../node.js/cds-env#cli).

#### First Build and Deployment

After you've copied all your CDS files, maintained additional dependencies and configured the CDS build,
you can try to build your new CAP Java project the first time.
Therefore, execute the following Maven command in the root folder of your new CAP Java project:

```sh
mvn clean install
```

If this Maven build finishes successfully, you can optionally try to deploy your CDS model to an SAP HANA database by executing the following CDS command:

```sh
cds deploy --to hana
```

[See section **SAP HANA Cloud** for more details about deploying to SAP HANA.](../guides/databases-hana){.learn-more}


### Migrate Java Business Logic

#### Migrate Dependencies

Now, it's time to migrate your Java business logic. If your event handlers require additional libraries that go beyond the already provided Java Runtime API,
add those dependencies manually to section `dependencies` in file `<NEW-PROJECT-ROOT>/srv/pom.xml`, for example:

```xml
...
<dependencies>
	
	...
	<dependency>
		<groupId>com.sap.cds</groupId>
		<artifactId>cds-starter-spring-boot-odata</artifactId>
	</dependency>
	<dependency>
		<groupId>org.xerial</groupId>
		<artifactId>sqlite-jdbc</artifactId>
	</dependency>
	...
</dependencies>
...
```

::: tip
Don't add any dependencies of the classic Java Runtime to the new project. Those dependencies are already replaced with the corresponding version of the new CAP Java SDK.
:::


#### Migrate Event Handlers

In the next steps, you have to adapt your Java classes to be compatible with the new Java Runtime API.
That means, you'll copy and migrate your event handler classes from the classic to the new project.
It will be required to modify and adapt your Java source code to be compatible with the new Java SDK.

Usually the event handler classes and tests are located in these folders:

| Usage | Location in classic project | Location in new CAP Java project |
| --- | --- | --- |
| Handler classes| `<CLASSIC-PROJECT-ROOT>/srv/src/main/java/**` | `<NEW-PROJECT-ROOT>/srv/src/main/java/**` |
| Test classes  | `<CLASSIC-PROJECT-ROOT>/srv/src/test/java/**` | `<NEW-PROJECT-ROOT>/srv/src/test/java/**` |

Copy your Java class files (`*.java`) manually from the classic project to corresponding locations in the new project.
It's important that you re-create the same subfolder structure in the new project as it is in the classic project.
The subfolder structure reflects the Java package names of your Java classes.

##### Annotations

Annotate all of your event handler classes with the following annotations and ensure a unique service name:


```java
@org.springframework.stereotype.Component
@com.sap.cds.services.handler.annotations.ServiceName("serviceName")
```

::: tip
All event handler classes also *have* to implement the marker interface `com.sap.cds.services.handler.EventHandler`. Otherwise, the event handlers defined in the class won't get called.
:::

Finally, your event handler class has to look similar to this example:

```java
import org.springframework.stereotype.Component;
import com.sap.cds.services.handler.EventHandler;
import com.sap.cds.services.handler.annotations.ServiceName;

@Component
@ServiceName("AdminService")
public class AdminServiceHandler implements EventHandler {
  // ...
}
```

The new CAP Java SDK introduces new annotations for event handlers. Replace event annotations at event handler methods according to this table:

| Classic Java Runtime | CAP Java SDK |
| --- | --- |
| `@BeforeCreate(entity = "yourEntityName")` | `@Before(event = CqnService.EVENT_CREATE, entity = "yourEntityName")` |
| `@BeforeDelete(entity = "yourEntityName")` | `@Before(event = CqnService.EVENT_DELETE, entity = "yourEntityName")` |
| `@BeforeRead(entity = "yourEntityName")` | `@Before(event = CqnService.EVENT_READ, entity = "yourEntityName")` |
| `@BeforeQuery(entity = "yourEntityName")` | `@Before(event = CqnService.EVENT_READ, entity = "yourEntityName")` |
| `@BeforeUpdate(entity = "yourEntityName")` | `@Before(event = CqnService.EVENT_UPDATE, entity = "yourEntityName")` |
| `@Create(entity = "yourEntityName")` | `@On(event = CqnService.EVENT_CREATE, entity = "yourEntityName")` |
| `@Delete(entity = "yourEntityName")` | `@On(event = CqnService.EVENT_DELETE, entity = "yourEntityName")` |
| `@Query(entity = "yourEntityName")` | `@On(event = CqnService.EVENT_READ, entity = "yourEntityName")` |
| `@Read(entity = "yourEntityName")` | `@On(event = CqnService.EVENT_READ, entity = "yourEntityName")` |
| `@Update(entity = "yourEntityName")` | `@On(event = CqnService.EVENT_UPDATE, entity = "yourEntityName")` |
| `@AfterCreate(entity = "yourEntityName")` | `@After(event = CqnService.EVENT_CREATE, entity = "yourEntityName")` |
| `@AfterRead(entity = "yourEntityName")` | `@After(event = CqnService.EVENT_READ, entity = "yourEntityName")` |
| `@AfterQuery(entity = "yourEntityName")` | `@After(event = CqnService.EVENT_READ, entity = "yourEntityName")` |
| `@AfterUpdate(entity = "yourEntityName")` | `@After(event = CqnService.EVENT_UPDATE, entity = "yourEntityName")` |
| `@AfterDelete(entity = "yourEntityName")` | `@After(event = CqnService.EVENT_DELETE, entity = "yourEntityName")` |

::: tip
The `sourceEntity` annotation field doesn't exist in the new CAP Java SDK. In case your event handler should only be called for specific source entities you need to achieve this by [analyzing the CQN](./working-with-cql/query-introspection#using-the-iterator) in custom code.
:::

##### Event Handler Signatures

The basic signature of an event handler method is `void process(EventContext context)`.
However, it doesn't provide the highest level of comfort. Event handler signatures can vary on three levels:
- EventContext arguments
- POJO-based arguments
- Return type

Replace types from package `com.sap.cloud.sdk.service.prov.api.request` in the classic Java Runtime by types from package `com.sap.cds.services.cds` as described by the following table:

| Classic Java Runtime | New CAP Java SDK |
| --- | --- |
| `CreateRequest` | `CdsCreateEventContext` |
| `DeleteRequest` | `CdsDeleteEventContext` |
| `QueryRequest` | `CdsReadEventContext` |
| `ReadRequest` | `CdsReadEventContext` |
| `UpdateRequest` | `CdsUpdateEventContext` |
| `ExtensionHelper` | Use dependency injection provided by Spring |

You can also get your entities injected by adding an additional argument with one of the following types:
- `java.util.stream.Stream<yourEntityType>`
- `java.util.List<yourEntityType>`

[See section **Event Handler Method Signatures** for more details.](event-handlers/#handlersignature){.learn-more}

Also replace the classic handler return types with the corresponding new implementation:

| Classic Java Runtime | New CAP Java SDK |
| --- | --- |
| return `BeforeCreateResponse` | call `CdsCreateEventContext::setResult(..)` or return `Result` |
| return `BeforeDeleteResponse` | call `CdsDeleteEventContext::setResult(..)` or return `Result` |
| return `BeforeQueryResponse` | call `CdsReadEventContext::setResult(..)` or return `Result` |
| return `BeforeReadResponse` | call `CdsReadEventContext::setResult(..)` or return `Result` |
| return `BeforeUpdateResponse` | call `CdsUpdateEventContext::setResult(..)` or return `Result` |


### Delete Obsolete Files

There are numerous files in your classic project, which aren't required and supported anymore in the new project.
Don't copy any of the following files to the new project:

```txt
<PROJECT-ROOT>/
├─ db/
│  ├─ .build.js
│  └─ package.json
└─ srv/src/main/
           ├─ resources/
           │  ├─ application.properties
           │  └─ connection.properties
           └─ webapp/
              ├─ META-INF/
              │  ├─ sap_java_buildpack/config/resources_configuration.xml
              │  └─ context.xml
              └─ WEB-INF/
                 ├─ resources.xml
                 ├─ spring-security.xml
                 └─ web.xml
```


### Transaction Hooks

In the Classic Java Runtime, it was possible to hook into the transaction initialization and end phase by adding the annotations `@InitTransaction` or `@EndTransaction` to a public method. The method annotated with `@InitTransaction` was invoked just after the transaction started and before any operation executed. Usually this hook was used to validate incoming data across an OData batch request.

[See section **InitTransaction Hook** for more details about init transaction hook in classic CAP Java.](./custom-logic/hooks#inittransaction-hook){.learn-more}

The method annotated with `@EndTransaction` was invoked after all the operations in the transaction were completed and before the transaction was committed.

[See section **EndTransaction Hook** for more details about end transactions hook in classic CAP Java.](./custom-logic/hooks#endtransaction-hook){.learn-more}

The new CAP Java SDK doesn't support these annotations anymore. Instead, it supports registering a `ChangeSetListener` at the `ChangeSetContext` supporting hooks for `beforeClose` and `afterClose`.

[See section **Reacting on ChangeSets** for more details.](./event-handlers/changeset-contexts#reacting-on-changesets){.learn-more}

To replace the `@InitTransaction` handler, you can use the `beforeClose` method, instead. This method is called at the end of the transaction and can be used, for example, to validate incoming data across multiple requests in an OData batch *before* the transaction is committed. It's possible to cancel the transaction in this phase by throwing an `ServiceException`.

The CAP Java SDK sample application shows how such a validation using the `ChangeSetListener` approach can be implemented. See [here](https://github.com/SAP-samples/cloud-cap-samples-java/blob/cross-validation/srv/src/main/java/my/bookshop/handlers/ChapterServiceHandler.java) for the example code.

Note that to validate incoming data for *single* requests, we recommend to use a simple `@Before` handler, instead.

[See section **Introduction to Event Handlers** for a detailed description about `Before` handler.](event-handlers/#before){.learn-more}


### Security Settings

For applications based on Spring Boot, the new CAP Java SDK simplifies configuring *authentication* significantly: Using the classic CAP Java Runtime, you had to configure authentication for all application endpoints (including the endpoints exposed by your CDS model) explicitly. The new CAP Java SDK configures authentication for all exposed endpoints automatically, based on the security declarations in your CDS model.

*Authorization* can be accomplished in both runtimes with CDS model annotations  `@requires` and `@restrict` as described in section [Authorization and Access Control](../guides/security/authorization). Making use of the declarative approach in the CDS model is highly recommended.

In addition, the new CAP Java SDK enables using additional authentication methods. For instance, you can use basic authentication for mock users, which are useful for local development and testing. See section [Mock Users](./security#mock-users) for more details.

An overview about the general security configuration in the new CAP Java SDK can be found in section [Security](security).


#### Configuration and Dependencies

To make use of authentication and authorization with JWT tokens issued by XSUAA on the SAP BTP, add the following dependency to your `pom.xml`:

```xml
<dependency>
	<groupId>com.sap.cds</groupId>
	<artifactId>cds-feature-xsuaa</artifactId>
</dependency>
```

This feature provides utilities to access information in JWT tokens, but doesn't activate authentication by default. Therefore, as in the classic CAP Java Runtime, activate authentication by adding a variant of the [XSUAA library](https://github.com/SAP/cloud-security-xsuaa-integration) suitable for your application (depending on if you use Spring, Spring Boot, plain Java) as described in the following sections.

##### Spring Boot

Activate Spring security with XSUAA authentication by adding the following Maven dependency:

```xml
<dependency>
	<groupId>com.sap.cloud.security.xsuaa</groupId>
	<artifactId>xsuaa-spring-boot-starter</artifactId>
	<version>${xsuaa.version}</version>
</dependency>
```

Maintaining a `spring-security.xml` file or a custom `WebSecurityConfigurerAdapter` or `SecurityFilterChain` isn't necessary anymore because the new CAP Java SDK runtime *autoconfigures* authentication in the Spring context according to your CDS model:

- Endpoints exposed by the CDS model annotated with `@restrict` are automatically authenticated.
- Endpoints exposed by the CDS model *not* annotated with `@restrict` are public by definition and hence not authenticated.
- All other endpoints the application exposes manually through Spring are authenticated. If you need to change this default behavior either [manually configure these endpoints](./security#spring-boot) or turn off auto configuration of custom endpoints by means of the following application configuration parameter:

  ```yaml
  cds.security.authentication.authenticate-unknown-endpoints: false
  ```

##### Plain Java

The existing authentication configuration stays unchanged. No autoconfiguration is provided.

#### Enforcement API & Custom Handlers

The new CAP Java SDK offers a technical service called `AuthorizationService`, which serves as a replacement for the former Enforcement APIs. Obtain a reference to this service just like for all other services, either explicitly through a `ServiceCatalog` lookup or per dependency injection in Spring:

```java
@Autowire
AuthorizationService authService;
```
Information of the request user is passed in the current `RequestContext`:

```java
EventContext context;
UserInfo user = context.getUserInfo();
```

or through dependency injection within a handler bean:

```java
@Autowire
UserInfo user;
```

With the help of these interfaces, the classic enforcement API can be mapped to the new API as listed in the following table:

| classic API                                           | new API                                          | Remarks
| :---------------------------------------------------- | :----------------------------------------------------- | ------------------- |
| `isAuthenticatedUser(String serviceName)`  | `authService.hasServiceAccess(serviceName, event)` |
| `isRegisteredUser(String serviceName)` | no substitution required  |
| `hasEntityAccess(String entityName, String event)` | `authService.hasEntityAccess(entityName, event)`    |
| `getWhereCondition()	`  | `authService.calcWhereCondition(entityName, event)` |
| `getUserName()` | `user.getName()` | The user's name is also referenced with `$user` and used for `managed` aspect.
| `getUserId()` | `user.getId()` |
| `hasUserRole(String roleName)` | `user.hasRole(roleName)`           |
| `getUserAttribute(String attributeName)` | `user.getAttribute(attributeName)`    |
| `isContainerSecurityEnabled()` | no substitution required            |

[See section **Enforcement API & Custom Handlers in Java** for more details.](./security#enforcement-api){.learn-more}

<span id="moreenforcement" />
<Fragment target="#moreenforcement">

[Reference for former Enforcement APIs.](./custom-logic/authorization){.learn-more}

</Fragment>


### Data Access and Manipulation

There are several ways of accessing data. The first and most secure way is to use the Application Service through an `CqnService` instance. The second is to use `PersistenceService`, in that case the query execution is done directly against underlying datasource, bypassing all authority checks available on service layer. The third one is to use CDS4J component called `CdsDataStore`, which also executes queries directly.

#### Access Application Service in Custom Handler and Query Execution

To access an Application Service in custom handler and to execute queries, perform the following steps:

1) Inject the instance of `CqnService` in your custom handler class:

```java
	@Resource(name = "CatalogService")
	private CqnService catalogService;
```
[See section **Services Accepting CQN Queries** for more details.](cqn-services/#cdsservices){.learn-more}

2) In each custom handler, replace instance of `DataSourceHandler` as well as `CDSDataSourceHandler` with the `CqnService` instance.

3) Rewrite and execute the query (if any).

Example of query execution in *Classic Java Runtime*:

```java
CDSDataSourceHandler cdsHandler = DataSourceHandlerFactory
    .getInstance()
    .getCDSHandler(getConnection(), queryRequest.getEntityMetadata().getNamespace());

CDSQuery cdsQuery = new CDSSelectQueryBuilder("CatalogService.Books")
	.selectColumns("id", "title")
	.where(new ConditionBuilder().columnName("title").IN("Spring", "Java"))
	.orderBy("title", true)
	.build();

cdsHandler.executeQuery(cdsQuery);
```

[See section **CDS Data Source** for more details.](./custom-logic/remote-data-source#cds-data-source){.learn-more}

The corresponding query and its execution in *New CAP Java SDK* looks as follows:

```java
Select query =  Select.from("CatalogService.Books")
	.columns("id", "title")
	.where(p -> p.get("title")
	.in("Spring", "Java"))
	.orderBy("title");

catalogService.run(query);
```

[See section **Query Builder API** for more details.](./working-with-cql/query-api){.learn-more}

4) Rewrite and execute the CRUD operations (if any).

|Action|Classic Java Runtime|New CAP Java SDK|
|---|---|---|
|Create|`dsHandler.executeInsert(request.getData(), true)`|`catalogService.run(event.getCqn())` or `catalogService.run(Insert.into("Books").entry(book))`|
|Read|`dsHandler.executeRead(request.getEntityMetadata().getName(), request.getKeys(), request.getEntityMetadata().getElementNames());`|`catalogService.run(event.getCqn())` or `catalogService.run(Select.from("Books").where(b->b.get("ID").eq(42)))`|
|Update|`dsHandler.executeUpdate(request.getData(), request.getKeys(), true)`|`catalogService.run(event.getCqn())` or `catalogService.run(Update.entity("Books").data(book))`|
|Delete| `dsHandler.executeDelete(request.getEntityMetadata().getName(), request.getKeys())` |`catalogService.run(event.getCqn())` or `catalogService.run(Delete.from("Books").where(b -> b.get("ID").eq(42)))`|

As you can see in *New CAP Java SDK* it's possible to either directly execute a CQN of the event, or you can construct and execute your own custom query.

[See section **Query Builder API** for more details.](./working-with-cql/query-api){.learn-more}

#### Accessing `PersistenceService`

If for any reason you decided to use `PersistenceService` instead of `CqnService` in your custom handler, you need to inject the instance of `PersistenceService` in your custom handler class:

```java
@Autowired
private PersistenceService persistence;
```

[See section **Persistence API** for more details.](./cqn-services/#persistenceservice){.learn-more}

Example of Query execution in *Classic Java Runtime*:

```java
CDSDataSourceHandler cdsHandler = ...;

CDSQuery cdsQuery = new CDSSelectQueryBuilder("CatalogService.Books")
	.selectColumns("id", "title")
	.where(new ConditionBuilder().columnName("title").IN("Spring", "Java"))
	.orderBy("title", true)
	.build();

cdsHandler.executeQuery(cdsQuery);
```

The corresponding query execution in *New CAP Java SDK* looks as follows:

```java
Select query =  Select.from("CatalogService.Books")
	.columns("id", "title")
	.where(p -> p.get("title")
	.in("Spring", "Java"))
	.orderBy("title");

persistence.run(query);
```

#### Accessing `CdsDataStore`

If you want to use `CdsDataStore` in your custom handler, you first need to do the steps described in section [Accessing PersistenceService](#accessing-persistenceservice). After that you can get the instance of `CdsDataStore` using `persistence.getCdsDataStore()` method:

```java
Select query =  ...; // construct the query

CdsDataStore cdsDataStore = persistence.getCdsDataStore();
cdsDataStore.execute(query);
```


### CDS OData V2 Adapter { #v2adapter}

When you generate a new project using the [CAP Java Maven Archetype](./getting-started#new-project), OData V4 is enabled by default.

To be able to migrate the backend from the *Classic Java Runtime* without making changes in your frontend code, you can activate the *OData V2 Adapter* as follows:

1. Add the following dependency to the `pom.xml` of your `srv` module:

	```xml
	<dependency>
		<groupId>com.sap.cds</groupId>
		<artifactId>cds-adapter-odata-v2</artifactId>
		<scope>runtime</scope>
	</dependency>
	```

2. In addition, turn off the OData V4 adapter by replacing the following dependency:

	```xml
	<dependency>
		<groupId>com.sap.cds</groupId>
		<artifactId>cds-starter-spring-boot-odata</artifactId>
	</dependency>
	```

	with

	```xml
	<dependency>
		<groupId>com.sap.cds</groupId>
		<artifactId>cds-starter-spring-boot</artifactId>
	</dependency>
	```

	if present. Additionally, remove the dependency

	```xml
	<dependency>
		<groupId>com.sap.cds</groupId>
		<artifactId>cds-adapter-odata-v4</artifactId>
	</dependency>
	```

	if present.

3. To make the CDS Compiler generate EDMX for OData V2, add or adapt the following property in the _.cdsrc.json_ file:

	```json
	{
		...
		"odata": {
			"version": "v2"
		}
	}
	```

	::: tip
	In case you're using [multitenancy](./multitenancy), keep in mind to make the same change in the _.cdsrc.json_ of the _mtx-sidecar_.
	:::

After rerunning the Maven build and starting the CAP Java application, Application Services are served as OData V2. By default, the endpoints will be available under `<host:port>/odata/v2/<Service>`. The default response format is `xml`, to request `json` use `$format=json` or `Accept: application/json` header.

::: tip
The index page available at \<host:port\> lists service endpoints of all protocol adapters.
:::



#### Enabling OData V2 and V4 in Parallel

You can also use OData V2 and V4 in parallel. However, by default the Maven build generates EDMX files for one OData version, only. Therefore, you've to add an extra compile step for the missing OData version to the Maven build of your application:

1. In _.cdsrc_, choose `v4` for `odata.version`

2. Add an extra compile command to the subsection `commands` of the section with ID `cds.build` in the *pom.xml* file in the *srv* folder of your project:

	```xml
	<command>compile ${project.basedir} -s all -l all -2 edmx-v2 -o ${project.basedir}/src/main/resources/edmx/v2</command>
	```

	This command picks up all service definitions in the Java project base directory (`srv` by default) and generates EDMX for OData V2. It also localizes the generated EDMX files with all available translations. For more information on the previous command, call `cds help compile` on the command line. If your service definitions are located in a different directory, adopt the previous command. If your service definitions are contained in multiple directories, add the previous command for each directory separately. Make sure to use at least `cds-dk 3.2.0` for this step.
If you are using feature toggles in your CAP Java project, the list of models must also contain the features' root folder:

	```xml
	<command>compile ${project.basedir} ${session.executionRootDirectory}/fts/* -s all -l all -2 edmx-v2 -o ${project.basedir}/src/main/resources/edmx/v2</command>
	```
	This command includes the folder _/fts_ and all sub-folders into the CDS model.

3. Make sure that the dependencies to the OData V2 and V4 adapters are present in your *pom.xml* file:

	```xml
	<dependency>
		<groupId>com.sap.cds</groupId>
		<artifactId>cds-starter-spring-boot</artifactId>
	</dependency>

	<dependency>
		<groupId>com.sap.cds</groupId>
		<artifactId>cds-adapter-odata-v2</artifactId>
		<scope>runtime</scope>
	</dependency>

	<dependency>
		<groupId>com.sap.cds</groupId>
		<artifactId>cds-adapter-odata-v4</artifactId>
		<scope>runtime</scope>
	</dependency>
	```

4. Optionally it's possible to configure different serve paths for the application services for different protocols. See [Serve configuration](./cqn-services/application-services#serve-configuration) for more details.

After rebuilding and restarting your application, your Application Services are exposed as OData V2 and OData V4 in parallel. This way, you can migrate your frontend code iteratively to OData V4.



<span id="afterenablingodata" />
<Fragment target="#afterenablingodata">

### Multitenancy <Internal /> { #mt }

This guide won't explain how to enable multitenancy for your application, but point out the configuration settings that have changed when coming from the classic Java Runtime. If you're looking for a general introduction how to enable multitenancy for your application, see [Java > Multitenancy](./multitenancy).

#### Maven Dependencies

The Maven dependencies are described in section [Multitenancy](./multitenancy).

#### REST Endpoints

The REST endpoints that you configure for the `saas-registry` service instance have changed:

|Classic Java Runtime|Classic Java Spring Boot|New CAP Java SDK|
|-|-|-|
|`/callback/v1.0/dependencies`|`/mt_lib/callback/v1.0/dependencies`|`/mt/v1.0/subscriptions/dependencies`|
|`/callback/v1.0/tenants/{tenantId}`|`/mt_lib/callback/v1.0/tenants/{tenantId}`|`/mt/v1.0/subscriptions/tenants/{tenantId}`|

It's also possible to change these URLs through a property as described in section [Multitenancy](./multitenancy).

Also the endpoints to trigger a database deployment have changed:

|Classic Java Runtime|Classic Java Spring Boot|New CAP Java SDK|
|-|-|-|
|`/init_db`|`/mt_lib/v1.0/init_db`|`/mt/v1.0/subscriptions/deploy`|
|n.a|`/mt_lib/v1.0/init_db_async`|`/mt/v1.0/subscriptions/deploy/async`|
|n.a|`/mt_lib/v1.0/init_db_async/status/{jobId}`|`/mt/v1.0/subscriptions/deploy/async/status/{jobId}`|

The CAP Java SDK provides a main class that can be used to trigger database deployments. This is also described in section [Multitenancy](./multitenancy).

#### Parameters

General:

|Classic Java Spring Boot|New CAP Java SDK|
|-|-|
|`com.sap.mt.poolProvider`|`cds.multitenancy.datasource.pool`|
|`com.sap.mt.baseUiUrl`|`cds.multitenancy.app-ui.url`|
|`com.sap.mt.urlSeparator`|`cds.multitenancy.app-ui.tenant-separator`|
|`com.sap.mt.subscribeScope`|`cds.multitenancy.security.subscription-scope`|
|`com.sap.mt.initDbScope`|`cds.multitenancy.security.deployment-scope`|
|`com.sap.mt.healthCheckIntervalMillis`|`cds.multitenancy.health-check.interval-millis`|
|`com.sap.mt.securityCheckOff`|Not possible anymore. You can use mock users for local testing.|
|`com.sap.mt.enabled`|MT is enabled depending on the environment and configuration, for example, service bindings|

Dynamic HDI Deployer:

These parameters are configured through environment variables in the _mta.yaml_.

|Classic Java Spring Boot|New CAP Java SDK|
|-|-|
|`com.sap.mt.dynamicDbDeploymentUrl`|`cds.multitenancy.deployer.url`|
|`com.sap.mt.dynamicDbDeploymentUser`|`cds.multitenancy.deployer.user`|
|`com.sap.mt.dynamicDbDeploymentPassword`|`cds.multitenancy.deployer.password`|

Sidecar:

This parameter is configured through an environment variable in the _mta.yaml_.

|Classic Java Runtime|New CAP Java SDK|
|-|-|
|`com.sap.mt.sidecarUrl`|`cds.multitenancy.sidecar.url`|

#### Scope Names

The scope names can also be configured as described in section [Multitenancy](./multitenancy). The scope names are configured in the UAA service instance. This is either done in the _mta.yaml_ directly or in the security JSON.

|Classic Java Runtime|Classic Java Spring Boot|Classic Java Spring BootNew CAP Java SDK|
|-|-|-|
|`Callback`|`callback`|`mtcallback`|
|n.a.|`initdb`|`mtdeployment`|

#### User Exits

The user exits `DependencyExit`, `SubscribeExit`, `UnSubscribeExit`, and `InitDbExit` can't be used anymore. The functionality you implemented in these classes needs to be moved into `@Before` or `@After` handlers of the events.

- `EVENT_GET_DEPENDENCIES`
- `EVENT_SUBSCRIBE`
- `EVENT_UNSUBSCRIBE`
- `EVENT_DEPLOY`
- `EVENT_ASYNC_DEPLOY`
- `EVENT_ASYNC_DEPLOY_STATUS`

#### Tenant Overwrite

If you need to overwrite the default tenant, you can't use the class `TenantOverwrite` anymore. Instead, you must use the <CdsSrv latest link="services/runtime/RequestContextRunner.html">RequestContextRunner</CdsSrv> API as described in section [Request Contexts](./event-handlers/request-contexts).



</Fragment>

<div id="secondary-file">java/migration.fragment.md</div>


# Choose Your Preferred Tools
{{$frontmatter?.synopsis}}




<br>
<IndexList :pages='pages' />






# CDS Command Line Interface (CLI) {#cli}

To use `cds` from your command line, install package  `@sap/cds-dk` globally:

```sh
npm i -g @sap/cds-dk
```

<ImplVariantsHint />

## cds version

Use `cds version` to get information about your installed package version:


<pre class="log">
> cds version

<em>@cap-js/asyncapi</em>: 1.0.3
<em>@cap-js/cds-types</em>: 0.13.0
<em>@cap-js/db-service</em>: 2.2.0
<em>@cap-js/openapi</em>: 1.2.3
<em>@cap-js/sqlite</em>: 2.0.2
<em>@sap/cds</em>: 9.1.0
<em>@sap/cds-compiler</em>: 6.1.0
<em>@sap/cds-dk (global)</em>: 9.1.1
<em>@sap/cds-fiori</em>: 2.0.1
<em>@sap/cds-mtxs</em>: 3.1.0
<em>Node.js</em>: v22.17.0
<em>your-project</em>: 1.0.0
</pre>


Using `--markdown` you can get the information in markdown format:


<pre class="log">
> cds version --markdown

| your-project           | &lt;Add your repository here&gt;              |
| ---------------------- | --------------------------------------- |
| @cap-js/asyncapi       | 1.0.3                                   |
| @cap-js/cds-types      | 0.13.0                                  |
| @cap-js/db-service     | 2.2.0                                   |
| @cap-js/openapi        | 1.2.3                                   |
| @cap-js/sqlite         | 2.0.2                                   |
| @sap/cds               | 9.1.0                                   |
| @sap/cds-compiler      | 6.1.0                                   |
| @sap/cds-dk (global)   | 9.1.1                                   |
| @sap/cds-fiori         | 2.0.1                                   |
| @sap/cds-mtxs          | 3.1.0                                   |
| Node.js                | v22.17.0                                |
</pre>



## cds completion <Since version="7.9.0" of="@sap/cds-dk" />

The `cds` command supports shell completion with the <kbd>tab</kbd> key for several shells and operating systems.

For Linux, macOS and Windows use the following command to activate shell completion:

```sh
cds add completion
```

After that, restart your shell (or source the shell configuration) and enjoy shell completion support for all `cds` commands.

Currently supported shells:
| Operating System  | Shell |
|-------------------|-------|
| Linux             | bash, fish (version 8 or higher), zsh |
| macOS             | bash, fish (version 8 or higher), zsh |
| Windows           | PowerShell, Git Bash |
| WSL               | bash, fish (version 8 or higher), zsh |

To remove the shell completion, run the following command:
```sh
cds completion --remove
```
Then source or restart your shell.


## cds help

Use `cds help` to see an overview of all commands:


<pre class="log">
> cds --help

<strong>USAGE</strong>
    <em>cds</em> &lt;command&gt; [&lt;args&gt;]
    <em>cds</em> &lt;src&gt;  =  <em>cds compile</em> &lt;src&gt;
    <em>cds</em>        =  <em>cds help</em>

<strong>COMMANDS</strong>
    <em>i</em> | <em>init</em>        jump-start cds-based projects
    <em>a</em> | <em>add</em>         add a feature to an existing project
    <em> </em> | <em>gen</em>         generate models/data using a descriptive prompt [beta]
    <em>m</em> | <em>import</em>      add models from external sources
    <em>c</em> | <em>compile</em>     compile cds models to different outputs
    <em>p</em> | <em>parse</em>       parses given cds models
    <em>s</em> | <em>serve</em>       run your services in local server
    <em>w</em> | <em>watch</em>       run and restart on file changes
    <em> </em> | <em>mock</em>        call <i>cds serve</i> with mocked service
    <em>r</em> | <em>repl</em>        read-eval-event loop
    <em>e</em> | <em>env</em>         inspect effective configuration
    <em>b</em> | <em>build</em>       prepare for deployment
    <em>d</em> | <em>deploy</em>      deploy to databases
    <em> </em> | <em>up</em>          build and deploy your application to the cloud
    <em>y</em> | <em>bind</em>        bind application to remote services
    <em> </em> | <em>debug</em>       debug your application
    <em> </em> | <em>subscribe</em>   subscribe a tenant to a multitenant SaaS app
    <em> </em> | <em>unsubscribe</em> unsubscribe a tenant from a multitenant SaaS app
    <em>l</em> | <em>login</em>       login to extensible multitenant SaaS app
    <em> </em> | <em>logout</em>      logout from extensible multitenant SaaS app
    <em> </em> | <em>pull</em>        pull base model of extensible SaaS app
    <em> </em> | <em>push</em>        push extension to extensible SaaS app
    <em>t</em> | <em>lint</em>        run linter for env or model checks
    <em>v</em> | <em>version</em>     get detailed version information
    <em> </em> | <em>completion</em>  add/remove cli completion for cds commands
    <em>?</em> | <em>help</em>        get detailed usage information

  Learn more about each command using:
  <em>cds help</em> &lt;command&gt; or
  <em>cds</em> &lt;command&gt; <em>--help</em>
</pre>


Use `cds help <command>` or `cds <command> ?` to get specific help:


<pre class="log">
> cds repl --help

<strong>SYNOPSIS</strong>
    <em>cds repl</em> [ &lt;options&gt; ]

    Launches into a read-eval-print-loop, an interactive playground to
    experiment with cds' JavaScript APIs. See documentation of Node.js'
    REPL for details at <i>http://nodejs.org/api/repl.html</i>

<strong>OPTIONS</strong>
    <em>-r | --run</em> &lt;project&gt;

      Runs a cds server from a given CAP project folder, or module name.
      You can then access the entities and services of the running server.
      It's the same as using the repl's builtin <i>.run</i> command.

    <em>-u | --use</em> &lt;cds feature&gt;

      Loads the given cds feature into the repl's global context. For example,
      if you specify <i>xl</i> it makes the <i>cds.xl</i> module's methods available.
      It's the same as doing <i>{ref,val,xpr,...} = cds.xl</i> within the repl.

<strong>EXAMPLES</strong>
    <em>cds repl</em> --run bookshop
    <em>cds repl</em> --run .
    <em>cds repl</em> --use ql

<strong>SEE ALSO</strong>
    <em>cds eval</em>  to evaluate and execute JavaScript.
</pre>



## cds init

Use `cds init` to create new projects.

The simplest form creates a minimal Node.js project.  For Java, use

```sh
cds init --java
```

In addition, you can add (most of) the project 'facets' from [below](#cds-add) right when creating the project.
For example to create a project with a sample bookshop model and configuration for SAP HANA, use:

```sh
cds init --add sample,hana
```

::: details See the full help text of `cds init`

<pre class="log">
> cds init --help

<strong>SYNOPSIS</strong>
    <em>cds init</em> [&lt;project&gt;] [&lt;options&gt;]

    Initializes a new project in folder ./&lt;project&gt;, with the current
    working directory as default.

<strong>OPTIONS</strong>
    <em>--add</em> &lt;feature | comma-separated list of features&gt;

        Add one or more features while creating the project.
        &lt;feature&gt; can be one of the following:

      <em>completion</em>                   - shell completion for cds commands
      <em>java</em>                         - creates a Java-based project
      <em>nodejs</em>                       - creates a Node.js-based project
      <em>esm</em>                          - ESM-compatible Node.js project
      <em>typer</em>                        - type generation for CDS models
      <em>typescript</em>                   - add minimum configuration for a bare TypeScript project
      <em>extension</em>                    - Extension project
      <em>mta</em>                          - Cloud Foundry deployment using mta.yaml
      <em>cf-manifest</em>                  - Cloud Foundry deployment using manifest files
      <em>helm</em>                         - Kyma deployment using Helm charts
      <em>helm-unified-runtime</em>         - Kyma deployment using Unified Runtime Helm charts
      <em>containerize</em>                 - containerization using ctz CLI
      <em>tiny-sample</em>                  - add minimal sample files
      <em>sample</em>                       - add sample files including Fiori UI
      <em>handler</em>                      - handler stubs for service entities, actions and functions
      <em>test</em>                         - tests for services
      <em>xsuaa</em>                        - authentication via XSUAA
      <em>ias</em>                          - authentication via IAS
      <em>ams</em>                          - authorization via AMS
      <em>hana</em>                         - database support for SAP HANA
      <em>postgres</em>                     - database support for PostgreSQL
      <em>sqlite</em>                       - database support for SQLite
      <em>liquibase</em>                    - database migration using Liquibase
      <em>redis</em>                        - SAP BTP Redis, Hyperscaler Option
      <em>h2</em>                           - database support for H2
      <em>multitenancy</em>                 - schema-based multitenancy support
      <em>toggles</em>                      - allow dynamically toggled features
      <em>extensibility</em>                - tenant-specific model extensibility
      <em>side-by-side-extensibility</em>   - logic extensibility via extension points
      <em>mtx</em>                          - multitenancy + toggles + extensibility
      <em>attachments</em>                  - SAP BTP Object Store Service
      <em>malware-scanner</em>              - SAP Malware Scanning Service
      <em>local-messaging</em>              - messaging via local event bus
      <em>file-based-messaging</em>         - messaging via file system
      <em>enterprise-messaging</em>         - messaging via SAP Enterprise Messaging
      <em>enterprise-messaging-shared</em>  - messaging via shared SAP Enterprise Messaging
      <em>redis-messaging</em>              - messaging via Redis
      <em>kafka</em>                        - messaging via Apache Kafka
      <em>approuter</em>                    - dynamic routing using @sap/approuter
      <em>connectivity</em>                 - SAP BTP Connectivity Service
      <em>destination</em>                  - SAP BTP Destination Service
      <em>html5-repo</em>                   - SAP BTP HTML5 Application Repository
      <em>portal</em>                       - SAP BTP Portal Service
      <em>application-logging</em>          - SAP BTP Application Logging Service
      <em>audit-logging</em>                - SAP BTP Audit Logging Service
      <em>notifications</em>                - SAP BTP Notification Service
      <em>workzone-standard</em>            - SAP BTP Work Zone, Standard Edition
      <em>data</em>                         - add CSV headers for modeled entities
      <em>http</em>                         - add .http files for modeled services
      <em>lint</em>                         - configure cds lint
      <em>pipeline</em>                     - CI/CD pipeline integration

    <em>--java</em>

        Create a CAP Java project.

    <em>--java:mvn</em> &lt;Comma separated maven archetype specific parameters&gt;

        Add the given parameters to the archetype call.
        See <i>https://cap.cloud.sap/docs/java/developing-applications/building#the-maven-archetype</i>
        for parameters supported by the archetype.

    <em>--force</em>

        Overwrite all files.

<strong>EXAMPLES</strong>
    <em>cds init</em> bookshop
    <em>cds init</em> bookshop --java
    <em>cds init</em> bookshop --add hana
    <em>cds init</em> bookshop --add multitenancy,mta
    <em>cds init</em> --java --java:mvn DgroupId=myGroup,DartifactId=newId,Dpackage=my.company

<strong>SEE ALSO</strong>
    <em>cds add</em> - to augment your projects later on
</pre>

:::


## cds add

Use `cds add` to gradually add capabilities ('facets') to projects.

The facets built into `@sap/cds-dk` provide you with a large set of standard features that support CAP's grow-as-you-go approach:


| Feature                       |     Node.js      |       Java       |
|-------------------------------|:----------------:|:----------------:|
| `tiny-sample`                 |       <X/>       |       <X/>       |
| `sample`                      |       <X/>       |       <X/>       |
| `mta`                         |       <X/>       |       <X/>       |
| `cf-manifest`                 |       <X/>       |       <X/>       |
| `helm`                        |       <X/>       |       <X/>       |
| `helm-unified-runtime`        |       <X/>       |       <X/>       |
| `containerize`                |       <X/>       |       <X/>       |
| `multitenancy`                |       <X/>       |       <X/>       |
| `toggles`                     |       <X/>       |       <X/>       |
| `extensibility`               |       <X/>       |       <X/>       |
| `xsuaa`                       |       <X/>       |       <X/>       |
| `ias`                         |       <X/>       |       <X/>       |
| `ams`                         |       <X/>       |       <X/>       |
| `hana`                        |       <X/>       |       <X/>       |
| `postgres`                    | <X/><sup>1</sup> | <X/><sup>1</sup> |
| `sqlite`                      |       <X/>       |       <X/>       |
| `h2`                          |      <Na/>       |       <X/>       |
| `liquibase`                   |      <Na/>       |       <X/>       |
| `local-messaging`             |       <X/>       |       <O/>       |
| `file-based-messaging`        |       <X/>       |       <O/>       |
| `enterprise-messaging`        |       <X/>       |       <O/>       |
| `enterprise-messaging-shared` |       <X/>       |       <O/>       |
| `redis-messaging`             | <X/><sup>1</sup> |       <O/>       |
| `kafka`                       |       <X/>       |       <X/>       |
| `approuter`                   |       <X/>       |       <X/>       |
| `connectivity`                |       <X/>       |       <X/>       |
| `destination`                 |       <X/>       |       <X/>       |
| `html5-repo`                  |       <X/>       |       <X/>       |
| `portal`                      |       <X/>       |       <X/>       |
| `application-logging`         |       <X/>       |       <X/>       |
| `audit-logging`               |       <X/>       |       <X/>       |
| `notifications`               |       <X/>       |       <O/>       |
| `attachments`                 |       <X/>       |       <X/>       |
| [`data`](#data)               |       <X/>       |       <X/>       |
| [`http`](#http)               |       <X/>       |       <X/>       |
| `lint`                        |       <X/>       |       <X/>       |
| `pipeline`                    |       <X/>       |       <X/>       |
| `esm`                         |       <X/>       |      <Na/>       |
| `typer`                       |       <X/>       |      <Na/>       |
| `typescript`                  |       <X/>       |      <Na/>       |
| `completion`                  |       <X/>       |       <X/>       |
| [`handler`](#handler)         |       <X/>       |       <X/>       |

> <sup>1</sup> Only for Cloud Foundry <br>

::: details See the full help text of `cds add`

<pre class="log">
> cds add --help

<strong>SYNOPSIS</strong>
    <em>cds add</em> &lt;feature | comma-separated list of features&gt;

    Add one or more features to an existing project - grow as you go.

    Pick any of these:

      <em>completion</em>                   - shell completion for cds commands
      <em>esm</em>                          - ESM-compatible Node.js project
      <em>typer</em>                        - type generation for CDS models
      <em>typescript</em>                   - add minimum configuration for a bare TypeScript project
      <em>extension</em>                    - Extension project
      <em>mta</em>                          - Cloud Foundry deployment using mta.yaml
      <em>cf-manifest</em>                  - Cloud Foundry deployment using manifest files
      <em>helm</em>                         - Kyma deployment using Helm charts
      <em>helm-unified-runtime</em>         - Kyma deployment using Unified Runtime Helm charts
      <em>containerize</em>                 - containerization using ctz CLI
      <em>tiny-sample</em>                  - add minimal sample files
      <em>sample</em>                       - add sample files including Fiori UI
      <em>handler</em>                      - handler stubs for service entities, actions and functions
      <em>test</em>                         - tests for services
      <em>xsuaa</em>                        - authentication via XSUAA
      <em>ias</em>                          - authentication via IAS
      <em>ams</em>                          - authorization via AMS
      <em>hana</em>                         - database support for SAP HANA
      <em>postgres</em>                     - database support for PostgreSQL
      <em>sqlite</em>                       - database support for SQLite
      <em>liquibase</em>                    - database migration using Liquibase
      <em>redis</em>                        - SAP BTP Redis, Hyperscaler Option
      <em>h2</em>                           - database support for H2
      <em>multitenancy</em>                 - schema-based multitenancy support
      <em>toggles</em>                      - allow dynamically toggled features
      <em>extensibility</em>                - tenant-specific model extensibility
      <em>side-by-side-extensibility</em>   - logic extensibility via extension points
      <em>mtx</em>                          - multitenancy + toggles + extensibility
      <em>attachments</em>                  - SAP BTP Object Store Service
      <em>malware-scanner</em>              - SAP Malware Scanning Service
      <em>local-messaging</em>              - messaging via local event bus
      <em>file-based-messaging</em>         - messaging via file system
      <em>enterprise-messaging</em>         - messaging via SAP Enterprise Messaging
      <em>enterprise-messaging-shared</em>  - messaging via shared SAP Enterprise Messaging
      <em>redis-messaging</em>              - messaging via Redis
      <em>kafka</em>                        - messaging via Apache Kafka
      <em>approuter</em>                    - dynamic routing using @sap/approuter
      <em>connectivity</em>                 - SAP BTP Connectivity Service
      <em>destination</em>                  - SAP BTP Destination Service
      <em>html5-repo</em>                   - SAP BTP HTML5 Application Repository
      <em>portal</em>                       - SAP BTP Portal Service
      <em>application-logging</em>          - SAP BTP Application Logging Service
      <em>audit-logging</em>                - SAP BTP Audit Logging Service
      <em>notifications</em>                - SAP BTP Notification Service
      <em>workzone-standard</em>            - SAP BTP Work Zone, Standard Edition
      <em>data</em>                         - add CSV headers for modeled entities
      <em>http</em>                         - add .http files for modeled services
      <em>lint</em>                         - configure cds lint
      <em>pipeline</em>                     - CI/CD pipeline integration

<strong>OPTIONS</strong>
    <em>--for | -4</em> &lt;profile&gt;

      Write configuration data for the given profile.

    <em>--force</em>

      Overwrite all files in case the target files already exist.

    <em>--package</em> &lt;name&gt;

      Pull a package from your npm registry.


<strong>FEATURE OPTIONS</strong>
    <em>cds add audit-logging</em>

      --plan

        Specify the service plan.


    <em>cds add cloud-logging</em>

      --plan

        Specify the service plan.

      --with-telemetry

        Add telemetry capabilities.


    <em>cds add completion</em>

      --shell | -s

        &lt;optional&gt; Forces completion setup for a given shell and disables auto detection.
        Usually the shell is determined automatically and this is only for cases where the automatic
        detection fails. Valid values: bash, fish, gitbash, ps, zsh.


    <em>cds add data</em>

      --filter | -f

        Filter for entities matching the given pattern. If it contains meta
        characters like '^' or '*', it is treated as a regular expression,
        otherwise as an include pattern, i.e /.*pattern.*/i

      --data:for

        Deprecated. Use '--filter' instead.

      --records | -n

        The number of records to be created for each entity.

      --content-type | -c

        The content type of the data. One of "json" or "csv".

      --out | -o

        The output target folder.


    <em>cds add enterprise-messaging</em>

      --cloudevents | -c

        Use CloudEvents formatting.


    <em>cds add enterprise-messaging-shared</em>

      --cloudevents | -c

        Use CloudEvents formatting.


    <em>cds add extension</em>

      --base | -p

        The project to extend.


    <em>cds add handler</em>

      --filter | -f

        Filter for entities, actions or functions matching the given pattern.
        For Node.js, if it contains meta characters like '^' or '*', it is treated as a regular expression,
        otherwise as an include pattern, i.e /.*bookshop.*/i
        For Java, only '*' and '**' as suffix wildcards are allowed, as in 'my.bookshop.*' or 'my.**'

      --out | -o

        Custom output directory.
        For Java, the default is 'handlers'. For Node.js, the default is 'srv'.


    <em>cds add helm</em>

      --y

        If provided, the default values will be used for all prompts.


    <em>cds add http</em>

      --filter | -f

        Filter for services or entities or actions matching the given pattern. If it contains meta
        characters like '^' or '*', it is treated as a regular expression,
        otherwise as an include pattern, i.e /.*pattern.*/i

      --for-app | -a

        Specify the name of the app to generate requests for.
        If not specified, localhost and default auth will be used.

      --out | -o

        The output directory.
        By default, an `http` dir is created in either `test/`, `tests/`, `__tests__/`, or at the root level.

      --dry

        Print the generated requests to the console instead of writing them to a file.


    <em>cds add test</em>

      --filter | -f

        Filter for services or entities or actions matching the given pattern. If it contains meta
        characters like '^' or '*', it is treated as a regular expression,
        otherwise as an include pattern, i.e /.*pattern.*/i

      --out | -o

        Custom output directory. For Node.js, the default is 'test'.


    <em>cds add xsuaa</em>

      --plan

        Specify the service plan.


<strong>EXAMPLES</strong>
  <em>cds add</em> sample
  <em>cds add</em> multitenancy,hana,xsuaa
  <em>cds add</em> data --filter my.namespace.MyEntity
  <em>cds add</em> mta
  <em>cds add</em> helm

<strong>SEE ALSO</strong>
  <em>cds init</em>

<strong>SUMMARY</strong>
  <em>cds add</em> &lt;feature | comma-separated list of features&gt;
</pre>

:::

### sample {.add}

Creates a bookshop application including custom code (Node.js or Java) and a UI with [SAP Fiori Elements](../advanced/fiori).

```sh
cds add sample
```

This corresponds to the result of the [_Getting Started in a Nutshell_ guide](../get-started/in-a-nutshell).

### tiny-sample {.add}

Creates a minimal CAP application without UI.

```sh
cds add tiny-sample
```

### data {.add}

Adds files to the project that carry initial data, in either JSON and CSV format.

The simplest form of:

```sh
cds add data
```

adds _csv_ files with a single header line for all entities to the _db/data/_ folder.  The name of the files matches the entities' namespace and name, separated by `-`.

#### Filtering <Since version="7.9.0" of="@sap/cds-dk" /> {#data-filtering}

To create data for some entities only, use `--filter`.  For example:

```sh
cds add data --filter books
```

would only create data for entity names that include _books_ (case insensitive).

You can use regular expressions for more flexibility and precision.  For example, to only match _Books_, but not _Books.texts_, use:

```sh
cds add data --filter "books$"
```

::: details Special characters like `?` or `*` need escaping or quoting in shells

The escape character is usually the backslash, for example, `\?`.  Quote characters are `'` or `"` with varying rules between shells.  Consult the documentation for your shell here.
:::

#### Sample records <Since version="7.9.0" of="@sap/cds-dk" />

To create actual data (along with the header line), use `--records` with a number for how many records you wish to have.

This example creates 2 records for each entity:

```sh
cds add data --records 2
```

[Watch a short video by DJ Adams to see this in action.](https://www.youtube.com/shorts/_YVvCA2oSco){.learn-more}

#### Formats <Since version="7.9.0" of="@sap/cds-dk" />

By default, the data format is _CSV_.  You can change this to JSON with the `--content-type` option:

```sh
cds add data --content-type json
```

The result could look like this for a typical _Books_ entity from the _Bookshop_ application:

```jsonc
[
  {
    "ID": 29894036,
    "title": "title-29894036",
    "author": {
      "ID": 1343293
    },
    "stock": 94,
    "texts": [
      { ... }
    ]
  }
]
```

::: details Some details on the generated data
-  For the _JSON_ format, _structured_ objects are used instead of flattened properties, for example, `author: { ID: ... }` instead of `author_ID.` The flattened properties would work as well during database deployment and runtime though.  Flattened properties are also used in the _CSV_ format.
- `author.ID` refers to a key from the _...Authors.json_ file that is created at the same time.  If the _Authors_ entity is excluded, though, no such foreign key would be created, which cuts the association off.
- Data for _compositions_, like the `texts` composition to `Books.texts`, is always created.
- A random unique number for each record, _29894036_ here, is added to each string property, to help you correlate properties more easily.
- Data for elements annotated with a regular expression using [`assert.format`](../guides/providing-services#assert-format) can be generated using the NPM package [randexp](https://www.npmjs.com/package/randexp), which you need to installed manually.
- Other constraints like [type formats](../cds/types), [enums](../cds/cdl#enums), and [validation constraints](../guides/providing-services#input-validation) are respected as well, in a best effort way.
:::

#### Interactively in VS Code <Since version="7.9.0" of="@sap/cds-dk" />

In [VS Code](./cds-editors#vscode), use the commands _Generate Model Data as JSON / CSV_ to insert test data at the cursor position for a selected entity.


### http <Since version="7.9.0" of="@sap/cds-dk" /> {.add}

Adds `.http` files with sample read and write requests.

The simplest form of:

```sh
cds add http
```

creates `http` files for all services and all entities.


#### Filtering {#http-filtering}

See the filter option of [`add data`](#data-filtering) for the general syntax.
In addition, you can filter with a service name:

```sh
cds add http --filter CatalogService
```

#### Interactively in VS Code

In [VS Code](./cds-editors#vscode), use the command _Generate HTTP Requests_ to insert request data in an _http_ file for a selected entity or service.

#### Authentication / Authorization

##### To local applications

<div class="impl node">

By default, an authorization header with a [local mock user](../node.js/authentication#mock-users) is written to the `http` file, and `localhost` is the target host.

```http [Node.js]
@server = http://localhost:4004
@auth = Authorization: Basic alice:

### CatalogService.Books
GET {{server}}/odata/v4/admin/Books
{{auth}}
...
```
</div>

<div class="impl java">

By default, an authorization header with a [local mock user](../java/security#mock-users) is written to the `http` file, and `localhost` is the target host.

```http [Java]
@server = http://localhost:8080

### CatalogService.Books
GET {{server}}/odata/v4/admin/Books
{{auth}}
...
```
</div>


##### To remote applications

Use `--for-app <cf-appname>` to use a JWT token of a remote application.  For example:

```sh
cds add http --for-app bookshop
```

assumes a remote app named `bookshop` on CloudFoundry and a JWT token for this app is written to the request file:

```http
@server = https://...
@auth = x-approuter-authorization: bearer ...
```

::: details Cloud login required
For CloudFoundry, use `cf login ...` and select org and space.
:::

### handler <Since version="8.5.0" of="@sap/cds-dk" /> {.add}

Generates handler stubs for actions and functions for both Java and Node.js projects.

To generate handler files, run:

::: code-group
```sh [Node.js]
cds add handler
```
```sh [Java]
mvn compile  # let Java know what your model looks like
cds add handler
```
:::

The files contain handlers for
- actions and functions
- service entities (Node.js only)


#### Filtering {#handler-filtering}

Use the `--filter` option to create handlers for specific actions/functions or entities.

```sh
cds add handler --filter submitOrder
cds add handler --filter Books
```


## cds env

Use `cds env` to inspect currently effective config settings of your Node.js application:


<pre class="log">
> cds env requires.db

{
  impl: <em>'@cap-js/sqlite'</em>,
  credentials: { url: <em>':memory:'</em> },
  kind: <em>'sqlite'</em>
}
</pre>


::: details See the full help text of `cds env`

<pre class="log">
> cds env --help

<strong>SYNOPSIS</strong>
    <em>cds env</em> [&lt;key&gt;] [&lt;options&gt;]

<strong>EXPLANATION</strong>
    Displays the effective configuration for the given key, or all of the
    current environment.

<strong>OPTIONS</strong>
    <em>--sources</em>

       Lists the sources from with the current env has been compiled.

    <em>-k</em> | <em>--keys</em>

       Prints (top-level) keys of matching properties only

    <em>-p</em> | <em>--properties</em>
    <em>-l</em> | <em>--list</em>

       Prints output in .properties format

    <em>-j</em> | <em>--json</em>

       Prints output in JSON format

    <em>-r</em> | <em>--raw</em>

       Prints output with minimum formatting or decoration

    <em>-4</em> | <em>--for</em> | <em>--profile</em> &lt;profile,...&gt;

       Load configuration for the specified profile(s).
       The <em>development</em> profile is used by default.

    <em>-P</em> | <em>--process-env</em>

       Show properties from Node.js <i>process.env</i>.

    <em>-b</em> | <em>--resolve-bindings</em>

       Resolve remote service bindings configured via <em>cds bind</em>.
</pre>

:::

::: tip Inspect configuration for Java applications
While `cds env` does _not_ show the [runtime SpringBoot configuration for CAP Java applications](../java/developing-applications/configuring), you can still use it to learn about _designtime_ configuration, which applies to Java applications as well.  Examples are build tasks (`cds env build.tasks`) or build plugins (`cds env plugins`).<br>
Also, the [multitenancy sidecar](../java/multitenancy) is a Node.js application, for which `cds env` shows the entire configuration if executed in the _mtx/sidecar_ folder.
:::


## cds compile

Compiles the specified models to [CSN](../cds/csn) or other formats.

[See simple examples in the getting started page](../get-started/in-a-nutshell#cli).{.learn-more}

[For the set of built-in compile 'formats', see the `cds.compile.to` API](../node.js/cds-compile#cds-compile-to).{.learn-more}


In addition, the following formats are available:

### mermaid <Since version="8.0.0" of="@sap/cds-dk" /> {.compile}

This produces text for a [Mermaid class diagram](https://mermaid.js.org/syntax/classDiagram.html):

```sh
cds compile db/schema.cds --to mermaid
```

Output:

```log
classDiagram
  namespace sap_fe_cap_travel {
    class `sap.fe.cap.travel.Travel`["Travel"]
    class `sap.fe.cap.travel.Booking`["Booking"]
    class `sap.fe.cap.travel.Airline`["Airline"]
    class `sap.fe.cap.travel.Airport`["Airport"]
    class `sap.fe.cap.travel.Flight`["Flight"]
  }
```

If wrapped in a markdown code fence of type `mermaid`, such diagram text is supported by many markdown renderers, for example, on [GitHub](https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-diagrams).

````md
```mermaid
classDiagram
  namespace sap_fe_cap_travel {
    class `sap.fe.cap.travel.Travel`["Travel"]
    ...
  }
```
````

To customize the diagram layout, use these environment variables when calling `cds compile`:

```sh
CDS_MERMAID_ASSOCNAMES=false|true    # show association/composition names
CDS_MERMAID_ELEMENTS=false|all|keys  # no, all, or only key elements
CDS_MERMAID_MIN=false|true           # remove unused entities
CDS_MERMAID_NAMESPACES=false|true    # group entities by namespace
CDS_MERMAID_QUERIES=false|true       # show queries/projections
CDS_MERMAID_DIRECTION=TB|BT|LR|RL    # layout direction of the diagram
```

<div id="mermaid-cli-more" />
<Fragment target="#mermaid-cli-more">

::: details `namespace` syntax not supported on SAP GitHub <Internal />

Note that on SAP's GitHub instances _github.tools.sap_ and _github.wdf.sap.corp_, Mermaid's [`namespace` syntax](https://mermaid.js.org/syntax/classDiagram.html#define-namespace) is currently not supported and leads to a rendering error.  This should be fixed with a newer Mermaid version in one of the next GitHub upgrades.

To avoid namespaces for the time being, remove them manually from the text, disable the _Namespaces_ option in VS Code, or use the environment variable `CDS_MERMAID_NAMESPACES=false`.

:::

</Fragment>

#### Interactively in VS Code

To visualize your CDS model as a diagram in VS Code, open a `.cds` file and use the dropdown in the editor toolbar or the command _CDS: Preview as diagram_:

![The screenshot is described in the accompanying text.](assets/mermaid-preview.png) {}

If you don't see the graphics rendered, but only text, install the [Markdown Preview Mermaid Support](https://marketplace.visualstudio.com/items?itemName=bierner.markdown-mermaid) extension for VS Code.

To customize the diagram layout, use these settings in the _Cds > Preview_ category:

- [Diagram: Associations](vscode://settings/cds.preview.diagram.associations)
- [Diagram: Direction](vscode://settings/cds.preview.diagram.direction)
- [Diagram: Elements](vscode://settings/cds.preview.diagram.elements)
- [Diagram: Minify](vscode://settings/cds.preview.diagram.minify)
- [Diagram: Namespaces](vscode://settings/cds.preview.diagram.namespaces)
- [Diagram: Queries](vscode://settings/cds.preview.diagram.queries)

## cds watch

Use `cds watch` to watch for changed files, restarting your Node.js server.

::: details See the full help text of `cds watch`

<pre class="log">
> cds watch --help

<strong>SYNOPSIS</strong>
  <em>cds watch</em> [&lt;project&gt;]

  Tells cds to watch for relevant things to come or change in the specified
  project or the current work directory. Compiles and (re-)runs the server
  on every change detected.

  Actually, cds watch is just a convenient shortcut for:
  <em>cds serve all --with-mocks --in-memory?</em>

<strong>OPTIONS</strong>
  <em>--port</em> &lt;number&gt;

    Specify the port on which the launched server listens.
    If you specify '0', the server picks a random free port.
    Alternatively, specify the port using env variable <i>PORT</i>.

  <em>--ext</em> &lt;extensions&gt;

    Specify file extensions to watch for in a comma-separated list.
    <em>Example:</em> cds w --ext cds,json,js.

  <em>--include</em> &lt;paths,...&gt;

    Comma-separated list of additional paths to watch.

  <em>--exclude</em> &lt;paths,...&gt;

    Comma-separated list of additional paths to ignore.

  <em>--livereload</em> &lt;port | false&gt;

    Specify the port for the livereload server. Defaults to '35729'.
    Disable it with value <i>false</i>.

  <em>--open</em> &lt;url&gt;

    Open the given URL (suffix) in the browser after starting.
    If none is given, the default application URL will be opened.

  <em>--profile</em> &lt;profile,...&gt;

    Specify from which profile(s) the binding information is taken.
    <em>Example:</em> cds w --profile hybrid,production

  <em>--debug</em> / <em>--inspect</em> &lt;host:port | 127.0.0.1:9229&gt;

    Activate debugger on the given host:port.
    If port 0 is specified, a random available port will be used.

  <em>--inspect-brk</em> &lt;host:port | 127.0.0.1:9229&gt;

    Activate debugger on the given host:port and break at start of user script.
    If port 0 is specified, a random available port will be used.

<strong>SEE ALSO</strong>
  <em>cds serve --help</em> for the different start options.
</pre>

:::

::: tip Watch for Java
For CAP Java applications, you can use [`mvn cds:watch`](../java/developing-applications/running#cds-watch) instead.
:::

### Includes and Excludes <Since version="8.7.0" of="@sap/cds-dk" />

Additional watched or ignored paths can be specified via CLI options:

```sh
cds watch --include ../other-app --exclude .idea/
```

## cds repl

Use `cds repl` to live-interact with cds' JavaScript APIs in an interactive read-eval-print-loop.

<pre class="log">
<span class="cwd">$</span> <span class="cmd">cds</span> <span class="args">repl</span>
<em>Welcome to cds repl</em>

> <i>cds.parse`
  entity Foo { bar : Association to Bar }
  entity Bar { key ID : UUID }
`</i>
{
  definitions: {
    Foo: {
      kind: <em>'entity'</em>,
      elements: {
        bar: { type: <em>'cds.Association'</em>, target: <em>'Bar'</em> }
      }
    },
    Bar: ...
  }
}

> <i>SELECT.from(Foo)</i>
cds.ql {
  SELECT: { from: { ref: [ <em>'Foo'</em> ] } }
}
</pre>

There a couple of shortcuts and convenience functions:

- `.run` (a [REPL dot commands](https://nodejs.org/en/learn/command-line/how-to-use-the-nodejs-repl#dot-commands)) allows to start Node.js `cds.server`s:

  ```sh
  .run cap/samples/bookshop
  ```

- CLI option `--run` does the same from command line, for example:

  ```sh
  cds repl --run cap/samples/bookshop
  ```

- CLI option `--use` allows to use the features of a `cds` module, for example:

  ```sh
  cds repl --use ql # as a shortcut of that within the repl:
  ```

  ```js
  var { expr, ref, columns, /* ...and all other */ } = cds.ql
  ```

- `.inspect` command displays objects with configurable depth:

  ```sh
  .inspect cds .depth=1
  .inspect CatalogService.handlers .depth=1
  ```

::: details See the full help text of `cds repl`

<pre class="log">
> cds repl --help

<strong>SYNOPSIS</strong>
    <em>cds repl</em> [ &lt;options&gt; ]

    Launches into a read-eval-print-loop, an interactive playground to
    experiment with cds' JavaScript APIs. See documentation of Node.js'
    REPL for details at <i>http://nodejs.org/api/repl.html</i>

<strong>OPTIONS</strong>
    <em>-r | --run</em> &lt;project&gt;

      Runs a cds server from a given CAP project folder, or module name.
      You can then access the entities and services of the running server.
      It's the same as using the repl's builtin <i>.run</i> command.

    <em>-u | --use</em> &lt;cds feature&gt;

      Loads the given cds feature into the repl's global context. For example,
      if you specify <i>xl</i> it makes the <i>cds.xl</i> module's methods available.
      It's the same as doing <i>{ref,val,xpr,...} = cds.xl</i> within the repl.

<strong>EXAMPLES</strong>
    <em>cds repl</em> --run bookshop
    <em>cds repl</em> --run .
    <em>cds repl</em> --use ql

<strong>SEE ALSO</strong>
    <em>cds eval</em>  to evaluate and execute JavaScript.
</pre>

:::

::: tip Repl for Java
`cds repl` does not run Java code, but can still be useful:
For example, if you work on Node.js things like [building plugins](../guides/deployment/custom-builds#custom-build-plugins) that make use of Node.js APIs.
:::


## Debugging with `cds debug` {#cds-debug}

`cds debug` lets you debug applications running locally or remotely on SAP BTP Cloud Foundry.
Local applications will be started in debug mode, while (already running) remote applications are put into debug mode.

To debug an application on Cloud Foundry, the following is important:
- You're logged in to the space where the application is deployed to.
- You have developer permissions in that space. → [Space Developer role](https://help.sap.com/docs/btp/sap-business-technology-platform/about-roles-in-cloud-foundry-environment)
- The app is running and [reachable through SSH](https://docs.cloudfoundry.org/devguide/deploy-apps/ssh-apps.html#check-ssh-permissions).

Effectively, run:
```sh
cf login                   # select the correct org and space here
cf ssh-enabled <app-name>  # to check if SSH is enabled
```

::: tip Scale to one application instance only
We recommend to only scale to a _single_ app instance on SAP BTP Cloud Foundry, as then your request is guaranteed to hit this one instance.
If you scale out to more instances, only some of your requests will hit the instance that the debugger is connected to. This can result in 'missed breakpoints'.

However, it's possible to [route a request to a specific instance](https://docs.cloudfoundry.org/devguide/deploy-apps/routes-domains.html#surgical-routing), which is useful if you can't reduce the number of app instances.
:::

### Node.js Applications

#### Remote Applications

Run the following, to debug remote Node.js applications in the currently targeted CF space:

<pre class="log">
<span class="cwd">$</span> <span class="cmd">cds</span> <span class="args">debug</span> <span class="options">&lt;app-name&gt;</span>

Opening SSH tunnel on 9229:127.0.0.1:9229
Opening Chrome DevTools at devtools://devtools/bundled/inspector.html?ws=...

> Keep this terminal open while debugging.
</pre>

This opens an [SSH tunnel](https://docs.cloudfoundry.org/devguide/deploy-apps/ssh-apps.html), puts the application in debug mode, and connects and opens the [debugger of Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript).

<video src="./assets/cds-debug_compressed.mp4" autoplay loop muted webkit-playsinline playsinline alt="Video demonstrating the debugging process with cds debug command, as described in the accompanying text." />

::: details Under the hoods, these commands are executed:
```sh
cf ssh <app> -c "kill -usr1 `pidof node`"
cf ssh -N -L 9229:localhost:9229 <app>
```
:::

#### Local Applications

Without an `<app name>`, `cds debug` starts `cds watch --debug` locally:

<pre class="log">
<span class="cwd">$</span> <span class="cmd">cds</span> <span class="args">debug</span>
Starting 'cds watch --debug'
...
Debugger listening on ws://127.0.0.1:9229/...
Opening Chrome DevTools at devtools://devtools/bundled/inspector.html?ws=...

[cds] - ...
</pre>


### Java Applications <Since version="8.7.0" of="@sap/cds-dk" />

#### Remote Applications

Run the following, to debug remote Java applications in the currently targeted CF space:

<pre class="log">
<span class="cwd">$</span> <span class="cmd">cds</span> <span class="args">debug</span> <span class="options">&lt;app-name&gt;</span>
...
Debugging has been started.
Address : 8000

Opening SSH tunnel on 8000:127.0.0.1:8000

> Keep this terminal open while debugging.
</pre>

This opens an [SSH tunnel](https://docs.cloudfoundry.org/devguide/deploy-apps/ssh-apps.html) and puts the application in debug mode.

Afterwards, connect a debugger in your IDE at the given port.  In VS Code, for example, add a launch configuration like this one:

::: code-group
```json [.vscode/launch.json]
{
  "type": "java",
  "name": "Attach to Remote Java App",
  "request": "attach",
  "hostName": "localhost",
  "port": "8000"
}
```
:::

Make sure the port matches to what the debug tunnel uses (see the message in the terminal). The default port is `8000`.

> [!NOTE] SapMachine is required
> SapMachine is required as Java runtime environment for this feature to work.<br>
> There is nothing to do if you set up your MTA deployment descriptors with [`cds mta`](../guides/deployment/to-cf#add-mta-yaml) or CAP project wizards.
> See the [documentation of SapMachine](https://help.sap.com/docs/btp/sap-business-technology-platform/sapmachine) for how to configure this manually.

#### Local Applications

Without an app name, `cds debug` starts Maven with debug arguments locally:

<pre class="log">
<span class="cwd">$</span> <span class="cmd">cds</span> <span class="args">debug</span>
Starting 'mvn spring-boot:run -Dspring-boot.run.jvmArguments="-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000"'
...
Listening for transport dt_socket at address: 8000
...
</pre>

Then attach your IDE as explained before.

::: details See the full help text of `cds debug`

<pre class="log">
> cds debug --help

<strong>SYNOPSIS</strong>
    <em>cds debug</em> [&lt;app&gt;]

    Debug applications running locally or remotely on Cloud Foundry.
    Local applications will be started in debug mode, while remote applications
    are put into debug mode.

    If &lt;app&gt; is given, it's assumed to be running on the currently logged-in
    Cloud Foundry space (check with 'cf target').
    SSH access to the app is required (check with 'cf ssh-enabled').
    Chrome DevTools are opened automatically for Node.js applications.

    If no &lt;app&gt; is given, the app in the current working directory is started
    (with 'cds watch --debug' for Node.js and 'mvn spring-boot:run' for Java).

<strong>OPTIONS</strong>
    <em>-h</em> | <em>--host</em>

      the debug host (default: '127.0.0.1')

    <em>-p</em> | <em>--port</em>

      the debug port (default: '9229' for Node.js, '8000' for Java)

    <em>--no-devtools</em>

      don't open developer tools automatically

    <em>-f</em> | <em>--force</em>

      if necessary, automatically enable ssh for the app and restart it

<strong>EXAMPLES</strong>
    <em>cds debug</em>
    <em>cds debug</em> bookshop-srv --port 8001
    <em>cds debug</em> bookshop-srv --host 0.0.0.0
</pre>

:::

## Debugging with `cds watch`

Start `cds watch` and enter `debug`. This restarts the application in debug mode. Similarly, `debug-brk` will start debug mode, but pause the application at the first line, so that you can debug bootstrap code.

If you do this in VS Code's integrated terminal with the 'Auto Attach' feature enabled, debugging starts right away. If you executed `cds watch` on a standalone terminal, you can still attach a Node.js debugger to the process.

For example:
- In VS Code, use the _Debug: Attach to Node Process_ command.
- In Chrome browser, just open [chrome://inspect](chrome://inspect) and click _Inspect_.

<div id="secondary-file">tools/cds-cli.fragment.md</div>


# CDS Editors and IDEs

## SAP Business Application Studio {#bas}

[SAP Business Application Studio](https://help.sap.com/docs/bas/sap-business-application-studio/what-is-sap-business-application-studio) offers a modern development environment tailored for efficient development of business applications for the SAP Intelligent Enterprise.

#### Setup in BTP

If not already done, [set up SAP Business Application Studio](https://developers.sap.com/tutorials/appstudio-onboarding.html) on SAP BTP.


#### Set Up a Dev Space

1. Open the [SAP BTP cockpit](https://account.hanatrial.ondemand.com/) and choose *SAP Business Application Studio* from the _Quick Tool Access_ section.

1. Choose *Create Dev Space*.

1. Provide a name for your dev space.

1. Choose *Full Stack Cloud Application* as the application type.

   By selecting *Full Stack Cloud Application*, your dev space comes with several extensions out of the box that you need to develop CAP applications. For example, CAP Tools, Java Tools, and MTA Tools are built in to save setup time.
   See [Developer Guide](https://help.sap.com/products/SAP%20Business%20Application%20Studio/9d1db9835307451daa8c930fbd9ab264/84be8d91b3804ab5b0581551d99ed24c.html) for SAP Business Application Studio for more details.

1. Choose *Create Dev Space*.

   The creation of the dev space takes a while. You see that the status for your dev space changes from *STARTING* to *RUNNING*. See [Dev Space Types](https://help.sap.com/products/SAP%20Business%20Application%20Studio/9d1db9835307451daa8c930fbd9ab264/4142f786f3d345699c3d5fbebda5ded6.html) for more details.

1. Once the dev space is running, choose the dev space by clicking on the dev space name.

   >In the trial version, any dev space that hasn't been running for 30 days will be deleted. See the full list of [restrictions](https://help.sap.com/products/SAP%20Business%20Application%20Studio/9d1db9835307451daa8c930fbd9ab264/a45742a719704bdea179b4c4f9afa07f.html).

See [Developing a CAP Application in SAP Business Application Studio](https://help.sap.com/docs/SAP%20Business%20Application%20Studio/9c36fdb911ae4cadab467a314d9e331f/8a648174036a458688391c3ad7ee7cd5.html) {.learn-more}


#### Tutorials

+ [Combine CAP with SAP HANA Cloud to Create Full-Stack Applications](https://developers.sap.com/mission.hana-cloud-cap.html)
+ [Set Up SAP Business Application Studio for Development](https://developers.sap.com/tutorials/appstudio-onboarding.html)

+ Video showing [SAP Business Application Studio Productivity Tools](https://www.youtube.com/watch?v=KE6DKU1P9ic)






## Visual Studio Code {#vscode}

#### Install Visual Studio Code {#install-vscode}

1. Install [_Visual Studio Code_](https://code.visualstudio.com) and launch it.
2. Only for macOS: Install the `code` shell command.

![Press F1, type 'shell', and select 'Shell Command: install 'code' command in PATH'](assets/vscode/setup.png "Press F1, type 'shell', and select 'Shell Command: install 'code' command in PATH'"){ .ignore-dark}


#### Add CDS Editor

1. Go to [**Visual Studio Marketplace**](https://marketplace.visualstudio.com/items?itemName=SAPSE.vscode-cds).
2. Click *Install* and confirm the popup dialog.
3. In VS Code, choose *Install* to enable the extension.

<span id="invscodeeditor" />
<Fragment target="#invscodeeditor">

::: info For early adopters  <Internal />

If you want to give us early feedback, you can [install pre-releases](https://github.tools.sap/cap/npm-extension-updater#readme).
:::

</Fragment>



#### Add Useful Plugins

In addition we recommend installing these VS Code extensions:

- [REST Client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client)
- [SQLite Viewer](https://marketplace.visualstudio.com/items?itemName=qwtel.sqlite-viewer)
- [Rainbow CSV](https://marketplace.visualstudio.com/items?itemName=mechatroner.rainbow-csv)
- [ESLint](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint)




#### Run Services

To run services, just open the integrated terminal in VS Code and use one of the `cds serve` variants, for example, use `cds watch` to automatically react on changes.

Alternatively, you can use the preconfigured tasks or launch configurations you get when creating a project with `cds init`.
For example, in the _Debug_ view launch _cds run_ with the green arrow button:

![The explorer view highlighting the debug icon and the debug view with the run button.](assets/vscode/run.png "The explorer view highlighting the debug icon and the debug view with the run button."){ .ignore-dark}



#### Debug Services

You can add and stop at breakpoints in your service implementations. For example, add one to line 10 of our _srv/cat-service.js_ by clicking in the gutter as shown here:

![A breakpoint on line 10 in 'cat-service.js'.](assets/vscode/debug.png "A breakpoint on line 10 in 'cat-service.js'."){}

... then send the _[.../Books](http://localhost:4004/browse/Books)_ request again to stop there.



#### Restart the Server

Restart the server when you did changes to your code using the *Debug* views restart button:

![The green restart button from the debug bar.](assets/vscode/restart.png "The green restart button from the debug bar."){ .ignore-dark}



## IntelliJ

The [CAP CDS Language Support](https://github.com/cap-js/cds-intellij) plugin for IntelliJ IDEs provides syntax highlighting, code completion, formatting, and more.
It supports commercial IntelliJ IDEs including IntelliJ IDEA Ultimate and WebStorm.

![Screenshot showing an example of code completion in IntelliJ.](https://raw.githubusercontent.com/cap-js/cds-intellij/9dab0d1984e79b74074a820fe97ee6f9fb53cab7/.assets/code_completion.png){ .ignore-dark}

See the [detailed feature list](https://github.com/cap-js/cds-intellij/blob/main/FEATURES.md) and the [installation instructions](https://github.com/cap-js/cds-intellij#requirements) for how to get started.

[Report issues and provide feedback](https://github.com/cap-js/cds-intellij/issues).


## CDS Editors & LSP {#cds-editor}

Using the CDS language server implementation, editors can provide additional source code validation and Intellisense for _.cds_ files.

[Watch the **SAP CDS language support** extension for VS Code in action by DJ Adams.](https://www.youtube.com/watch?v=eY7BTzch8w0){.learn-more}

### Features and Functions

#### Syntax Coloring & Code Completion

<div class="cols-2">

<div>

<video src="./assets/vscode/syntax-coloring-completions_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

</div>

<div>

- Keywords
- Annotations
- Identifiers including ones defined in `using` references
- `using` paths 
- i18n translation IDs


</div>

</div>

#### Snippets

<div class="cols-2">

<div>

<video src="./assets/vscode/snippets_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

</div>

<div>

- `using`
- `namespace` and `context`
- `service` and `type`
- `entity` and `projection`
- `Association` and `Composition`
- `extend` and `annotate`
- Elements
- Annotations for documentation

</div>

</div>


#### Code Formatting

<div class="cols-2">

<div>

<video src="./assets/vscode/format_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

</div>

<div>

- the whole document
- a selected range
- on-the-fly when completing statements using ```;``` or ```}```
- on save (depending on the IDE)
- on paste (depending on the IDE)



</div>

</div>



#### Hover Information

<div class="cols-2">

<div>

<video src="./assets/vscode/hover_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

</div>

<div>

- Doc comments
- `@title`, `@description`, and ~~`@cds.doc`~~ (deprecated) annotations
- Translations

> With documentation extracts of [capire](../cds/cdl) explaining language concepts.

</div>

</div>

#### Where-used Navigation

<div class="cols-2">

<div>

<video src="./assets/vscode/where-used_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

</div>

<div>

- Navigate to definitions
- Navigate to references
- Highlight occurrences

</div>

</div>

#### Quick Fixes

<div class="cols-2">

<div>

<video src="./assets/vscode/quick-fixes_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

</div>

<div>

+ Create using statement for unknown artifacts.
+ Maintain missing translation.
+ Convert `@cds.doc` and `@description` annotations to doc comments.

</div>

</div>

#### Translation Support

<div class="cols-2">

<div>

<video src="./assets/vscode/translation-support_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

</div>

<div>

- Properties, JSON, and CSV files
- Navigate to translation definitions from translation IDs like `'{i18n>customerName}'`
- Show translations on hover

</div>

</div>

#### And More…

- Plugin framework for external handlers of annotation domains
- Dependency graph visualization


### Settings

##### Code formatting

These are settings coming with the CDS language server implementation.
Use the command *CDS: Show Formatting Options Configuration*.
You see the settings, grouped into three tabs: *Alignment*, *Other*, and *Whitespace*

##### Format on Type, Format on Paste, and Format on Save in VS Code

These are settings from the editor in VS Code:

1. Press <kbd>F1</kbd>
1. Open *Preferences: Open User Settings*
1. Filter for _Format_.
1. Tick the checkboxes to enable the settings.

##### Cds: [Workspace Validation Mode](vscode://settings/cds.workspaceValidationMode)

Default: *ActiveEditorOnly*

Keeps track of the active editor in focus. Only changes there are immediately validated.

The *ActiveEditorOnly* mode is especially useful in situations when navigating through a large model, that is, having multiple files open (even if they are not shown as tabs)
and editing a file that the others directly or indirectly depend on.

##### Cds > Contributions > [Enablement: Odata](vscode://settings/cds.contributions.enablement.odata)

Default: *on*

This setting enables extended support for annotations, that is, refined diagnostics and code completion. Can be switched *off* for performance gains.

##### Cds > [Workspace: ScanCsn](vscode://settings/cds.workspace.scanCsn)

Default: *off*

Switch *on* to scan the workspace also for CSN files, additionally to CDS source files.

Note: CSN files are still considered if used from a CDS source file.

##### Cds > [Quickfix: ImportArtifact](vscode://settings/cds.quickfix.importArtifact)

Default: *off*

Enable to get quickfix proposals for artifact names, like entities, that aren't imported via a `using` statement. For that, all definitions in the workspace need to be considered, which might be slow.

### Commands

##### Welcome page

1. Press <kbd>F1</kbd>
1. Open *CDS: Show CAP Release Notes*

If there are new release notes, this page opens on startup. You can disable this behavior using the *Cds > [Release Notes: Show Automatically](vscode://settings/cds.releaseNotes.showAutomatically)* setting.

##### CAP Notebooks Page { #cap-notebooks-page }

1. Press <kbd>F1</kbd>
1. Open *CDS: Open CAP Notebooks Page*

This page provides information on all of features available in a CAP Notebook with a brief description and examples on each.

##### Beautify settings

1. Press <kbd>F1</kbd>
1. Open *CDS: Show Formatting Options Configuration*

##### Preview CDS sources

You want to create a preview of a specific _.cds_ file in your project. You can do that using the command line. Here is how you do it in VS Code:
1. Open the file you want to preview.
1. Open the context menu.
1. Select _Preview CDS source as..._ .
1. Choose the preview you want to see.


##### Visualize CDS file dependencies

Use the command from the context menu on a folder or CDS file, or from within the popup when hovering over an _import_ path at the end of a _using_ statement.

A selection popup appears to choose one of three modes:

1. **_File to file_ (detailed)**: shows every model file on its own. For very large models, the number of files and interdependencies may be too complex to be graphically shown. A message about insufficient memory will appear. In this case use the second option.
2. **_File to file_ (reduced to folders)**: reduces the graph by only showing the folders of all involved files and their interdependencies. Only the files reachable from the start model where the command was invoked on are evaluated.
4. **_Complete folder to complete folder_**: always considers all files in a folder and their dependencies.
   This can be useful to understand architectural violations.
   > **Example for architectural violation:**<br>
   > You want a clean layering in your project: _app_ → _srv_ → _db_. With this option, you can visualize and identify that there is a dependency from a file in the service layer to an annotation file in the application layer.

Hovering over a node will show the number of files involved and their combined size. Use this function to get a rough understanding about complexity and compilation speed.

### Editor Performance

With the following [settings](#settings) you can influence the performance of the editor:

##### Editor > Goto Location: Alternative Definition Command

Do not select *goToReferences*. Otherwise, being already on a definition often requires all models to be recompiled.

##### Workbench > Editor > Limit: Value

If open editors have `using` dependencies, a change in one editor will lead to a recompile of related editors. To decrease the impact on performance, lower the number.

##### Workbench > Editor > Limit: Enabled

To enable the limit value above, switch *on*.



##### Additional Hints to Increase Performance:

- Within _SAP Business Application Studio_: close _CAP Data Models and Services_ view. Otherwise, it will ask for all workspace symbols at every change.
- Commands _Go to References_ / _Find All References_ will recompile all models that might have changed due to a change in a depending model. If there are index models, it often means that the complete workspace is being recompiled.
Until a further change, reference calculation is reasonably fast.
- Command _Go to Symbol in Workspace_ will recompile the complete workspace once, after that it is reasonable fast.
- Changing settings in _CDS_ section will currently perform a complete workspace invalidation, that is, required indexes will lead to recompilations on demand as described above.
- Changing certain `cds.env` settings, for example folder configurations, will invalidate the workspace as well.

### CDS Source Formatter { #cds-formatter}

The CDS code formatter provides a command line interface. Use it as a pre-commit hook or within your CI/CD pipeline to ensure consistent formatting.

#### Installation

Install the CDS language server globally as a library via

```sh
npm i -g @sap/cds-lsp
```

You can now use the formatter command:

```sh
format-cds
```

#### Usage

For detailed usage information run the help command:

```sh
format-cds -h
```

You can create a settings file (_.cdsprettier.json_) with custom formatting options for your project.

Run this to create an initial version:
```sh
format-cds --init
```
> Commit the _.cdsprettier.json_ file into your version control system.

::: tip Use the visual VS Code settings
Run `CDS: Show Formatting Options Configuration` to jump to the [SAP CDS Language Support](https://marketplace.visualstudio.com/items?itemName=SAPSE.vscode-cds) settings, which shows a preview of selected formatter options.
:::

The effective set of formatting options is calculated in order of precedence:
1. Command line options
2. Options from _.cdsprettier.json_
3. Default options

It is possible to have _.cdsprettier.json_ files in subfolders. In that case, the closest file in the folder hierarchy is used for the respective CDS source.

Use `format-cds <foldername1> <foldername2> <filename> ...` to restrict the set of CDS source files.

By default, backup files with the _.bak_ file extension will be created. Use the `-f` switch to force an overwrite without creating a backup.
This is on your own risk. Should there be problems data loss might occur, especially when formatting in a pre-commit hook.

> We recommend adding _.bak_ to your _.gitignore_ file.

### GitHub Integration

CAP is registered with GitHub [`linguist`](https://github.com/github-linguist/linguist) repository, which means you can use Markdown rendering on GitHub in `cds` code fences like so:

````md
```cds
entity Books {};
```
````

This will render like so:
```cds
entity Books {};
```


## CAP Notebooks { #cap-vscode-notebook }

A **CAP Notebook** is a [Custom Notebook in Visual Studio Code](https://code.visualstudio.com/blogs/2021/11/08/custom-notebooks) that serves you as a guide on how to create, navigate, and monitor CAP projects. With this approach, we want to encourage the CAP community to work with CAP in the same explorative manner that scientists work with their data, namely by:

- Visually interacting with their code
- Playing with REPL-type inputs (notebook input cells)
- Storing persistent code (notebook output cells)

The cell inputs/outputs are especially useful at later points in time when the project's details have long been forgotten. In addition, notebooks are a good way to share, compare, and also reproduce projects.

* To see which features are available in a CAP Notebook, open our [CAP Notebook page](#cap-notebooks-page): <kbd>F1</kbd> → *CDS: Open CAP Notebooks Page*

* Magics, or magic commands, known from [IPython](https://ipython.readthedocs.io/en/stable/interactive/magics.html) are convenient functions to solve common problems. To see which line- and cell-magics can be used within a CAP Notebook, run a code cell with `%quickref`.

* Start an empty CAP Notebook by creating a _*.capnb_ file.

> Provided that the [**CDS Editor**](#cds-editor) is installed, the CAP Notebook will be rendered automatically as the file is selected.


## Using Docker { #docker }

Prerequisite: You have installed [Docker](https://docs.docker.com/get-started/).

#### Build an Image

Create a file called `Dockerfile` and add this content for a quick setup:

```docker
FROM node:lts
# or use `FROM node:<NODEVERSION>` to match a specific Node version
# you have installed locally

USER node
ENV NPM_CONFIG_PREFIX=/home/node/.npm
ENV PATH=$NPM_CONFIG_PREFIX/bin:$PATH

RUN npm i -g @sap/cds-dk
```

Build your first image:

```sh
docker build -t cds .
```


#### Run a Service in a Container

1. Run a container that is based on the image:

   ```sh
   docker run --publish 4004:4004 -it cds sh
   ```

   > You see a `$` command prompt from _inside_ the container.

1. Move to the home directory:

   ```sh
   cd
   ```

1. Write a simple cds file:

   ```sh
   echo 'service CatalogService { entity Books { key ID: UUID; } }' \
       > services.cds
   ```

1. Run the service:

   ```sh
   cds run
   ```

1. Open [http://localhost:4004](http://localhost:4004) in a browser to test the application. You forwarded the port `4004` when running the container, which allows you to access the application as if it would run locally.

<div id="secondary-file">tools/cds-editors.fragment.md</div>


# CDS Lint

<div class="cols-2">

<div>

To catch issues in CDS models and the CDS environment early, CAP provides an [ESLint plugin](https://eslint.org/) for CDS [`@sap/eslint-plugin-cds`](https://www.npmjs.com/package/@sap/eslint-plugin-cds) with a set of *recommended* rules that are considered best practice and universal for every CAP project. This plugin, together with the [`cds lint` CLI](#usage-lint-cli) of [`@sap/cds-dk`](https://www.npmjs.com/package/@sap/cds-dk), comprises what we call **CDS Lint**.

</div>

<div>

![ESLint plugin for CDS logo](../assets/cdslint.svg){ class="ignore-dark"}

</div>

</div>

By nature of its design, the plugin can also be run with the [ESLint CLI](#usage-eslint-cli). However, we recommended using the [CDS Lint CLI](#usage-lint-cli) instead as it comes with all preconfigured settings.


### Setup {#cds-add-lint}

The following command automatically installs ESLint, the CDS ESLint plugin, and adds the ESLint configuration. VS Code settings are added to your project as well, to also be able to lint CDS alongside JavaScript or any other ESLint plugins you may have:

```sh
cds add lint
```

You may be asked to install ESLint as additional dependency in case it is not available in your project yet. Just follow the instructions on screen.


### CDS Lint CLI {#usage-lint-cli}

In your project's root folder, execute:

```sh
cds lint
```

It follows standard ESLint behaviour. If there are no lint errors, there is no output. If there are, a standard ESLint error report will be printed.


### CDS Lint in VS Code {#cds-lint-vscode}

::: tip
Make sure you have ESLint and our ESLint plugin installed via [`cds add lint`](#cds-add-lint).
:::

To turn on lint checking in your VS Code Editor simply download the [ESLint extension](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) for _Visual Studio Code_.
CDS Lint seamlessly integrates with it. For _SAP Business Application Studio_ this comes preinstalled.

Now you can see lint reports also in your editor. You can see all rules [marked as **Editor default** here](./rules/). Any other (project-based) rules are not turned on by
default but can be turned on via the `show` rule option. For example, if we want to show the [`valid-csv-header`](./rules/valid-csv-header) rule reports in the Editor, we would add the following to our ESLint
`rules` configuration:

```json
{
  "rules": {
    "@sap/cds/valid-csv-header": ["warn", "show"]
  }
}
```


### CDS Lint Rules

The **CDS Lint** rules are a set of generic rules based on CAP best practices.

[See our Rules Reference page to find out more](./rules/){ .learn-more}





### ESLint CLI (optional) {#usage-eslint-cli}

To have more control over the linting process, you can also access the CDS ESLint plugin natively via the [ESLint CLI](https://eslint.org/docs/user-guide/command-line-interface). To determine the proper command line options, it can help to refer to output of the equivalent call using the [CDS Lint CLI](#usage-lint-cli) with `DEBUG="lint"`, which shows all of the options and flags applied:

```sh
DEBUG=lint cds lint
```

<pre class="log">
Linting:
<span>[lint] - eslint --ext ".cds,.csn,.csv" ...</span>
</pre>






# Rules Reference

Below you can find all rules of the `@sap/eslint-plugin-cds` ESLint plugin.

They are grouped by categories [Model Validation](#model-validation) and [Environment](#environment) to help you understand their purpose.

Your standard CDS project configuration turns on a subset of these rules by default, namely the *recommended*
(&nbsp;✅&nbsp;) rules to ensure basic standards are met.

## Model Validation

Model Validation rules are used to validate CDS models within projects.
They are used to enforce security, naming conventions, or other best practices.

Note, that while all recommended (&nbsp;✅&nbsp;) model rules run with the CLI, only a number of them are
enabled and visible in the editor by default (&nbsp;👀&nbsp;).
::: details
* *Editor default* rules: Rules that are enabled in the editor by default only rely on the current file as their rule context. These are quick to execute and
can react on file changes.
* *Project-based* rules: Rules that are disabled in the editor by default usually rely on a series of (project) files for their rule context or include
slow or expensive processes. These are slow to execute and by default only run with the CLI.
:::

<RulesRefTable category="Model Validation"/>

## Environment

Environment rules are used to check for proper and up-to-date CDS project environments.
These are only run via the command line and are not available in the editor as they often can't be
pinpointed to any particular file.

<RulesRefTable category="Environment"/>


## JavaScript

JavaScript rules are designed to catch bad practices and common mistakes when implementing custom JavaScript handlers in CDS projects. These rules help ensure code quality, maintainability, and adherence to best practices when extending CDS with JavaScript logic.

<RulesRefTable category="Javascript"/>




# assoc2many-ambiguous-key

## Rule Details

In general an [association/composition to/of `MANY`](../../../cds/cdl#to-many-associations) that targets an entity without `ON` condition is not allowed (as it is an `n:1` relationship). Here, one should always specify an `ON` condition following the canonical expression pattern `<assoc>.<backlink> = $self`. The backlink can be any managed to-one association on the many side pointing back to the one side.

## Examples

#### ✅ &nbsp; Correct example

In the following example, we define a unique association from `Authors` to `Books` with a well-defined `ON` condition and backlink, thus satisfying the rule's conditions:

::: code-group
<<< ../examples/assoc2many-ambiguous-key/correct/db/schema.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="assoc2many-ambiguous-key"
  kind="correct"
  :rules="{'@sap/cds/assoc2many-ambiguous-key': ['error', 'show']}"
  :files="['db/schema.cds']"
/>

#### ❌ &nbsp; Incorrect example

If we extend this example by creating a view `AuthorView` with a key `ID` and the element `bookIDs` without an `ON` condition, the rule is triggered since the key is no longer unique and `bookIDs` leads to multiple entries:

::: code-group
<<< ../examples/assoc2many-ambiguous-key/incorrect/db/schema.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="assoc2many-ambiguous-key"
  kind="incorrect"
  :rules="{'@sap/cds/assoc2many-ambiguous-key': ['error', 'show']}"
  :files="['db/schema.cds']"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 1.0.1`.





# auth-no-empty-restrictions

## Rule Details

The [`@requires` annotation](../../../guides/security/authorization#requires) is a convenience shortcut for `@restrict`. You can use it to control which rule a user needs to have in order to access a given resource. Leaving this field empty is dangerous as it leads to unrestricted access to that service which is a security risk.

## Examples

#### ✅ &nbsp; Correct example

In the following example, the `AdminService` is correctly setup with `@requires` given the `admin` role:

::: code-group
<<< ../examples/auth-no-empty-restrictions/correct/srv/admin-service.cds#snippet{cds:line-numbers} [srv/admin-service.cds]
:::
<PlaygroundBadge
  name="auth-no-empty-restrictions"
  kind="correct"
  :rules="{'@sap/cds/auth-no-empty-restrictions': ['error', 'show']}"
  :files="['srv/admin-service.cds', 'db/schema.cds']"
/>

#### ❌ &nbsp; Incorrect example

If we were to replace the `admin` role by an empty string or provide an empty role array as shown in the next example,
we now have unrestricted access to that service, which the rule makes us aware of:

::: code-group
<<< ../examples/auth-no-empty-restrictions/incorrect/srv/admin-service.cds#snippet{cds:line-numbers} [srv/admin-service.cds]
:::
<PlaygroundBadge
  name="auth-no-empty-restrictions"
  kind="incorrect"
  :rules="{'@sap/cds/auth-no-empty-restrictions': ['error', 'show']}"
  :files="['srv/admin-service.cds', 'db/schema.cds']"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 1.0.1`.





# auth-restrict-grant-service

## Rule Details

Restrictions can be defined on different types of CDS resources, but there are some limitations with regard to supported privileges (see [limitations](../../../guides/security/authorization#supported-combinations-with-cds-resources)).

Unsupported privilege properties are ignored by the runtime. Especially, for bound or unbound actions, the `grant` property is implicitly removed (assuming `grant: '*'` instead). The same is true for functions. This rule ensures that `@restrict.grant` on service level and for bound/unbound actions and functions is limited to `grant: '*'`.

## Examples

#### ✅ &nbsp; Correct example

Let's consider the following example with the `CatalogService` where the function `getViewsCount()` is restricted to the *Admin* role, granting all CDS events:

::: code-group
<<< ../examples/auth-restrict-grant-service/correct/srv/cat-service.cds#snippet{cds:line-numbers} [srv/cat-service.cds]
:::
<PlaygroundBadge
  name="auth-restrict-grant-service"
  kind="correct"
  :rules="{'@sap/cds/auth-restrict-grant-service': ['error', 'show']}"
  :files="['srv/cat-service.cds', 'db/schema.cds']"
/>

#### ❌ &nbsp; Incorrect example

If we were to slightly modify the above example and use `grant: ['WRITE']` in the privilege of the function, the rule would be
triggered to inform us that the value of `grant` is limited to `'*'`:

::: code-group
<<< ../examples/auth-restrict-grant-service/incorrect/srv/cat-service.cds#snippet{cds:line-numbers} [srv/cat-service.cds]
:::
<PlaygroundBadge
  name="auth-restrict-grant-service"
  kind="incorrect"
  :rules="{'@sap/cds/auth-restrict-grant-service': ['error', 'show']}"
  :files="['srv/cat-service.cds', 'db/schema.cds']"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 2.6.4`.





# auth-use-requires

## Rule Details

Some annotations such as `@requires` or `@readonly` are just convenience shortcuts for `@restrict`. In actions and services with unrestricted events, it is recommended to use `@requires` instead of `@restrict.to`, which this rule enforces.

## Examples

#### ✅ &nbsp; Correct example

In the following example, the `CatalogService` action `addRating` correctly uses `@requires: 'Admin'` to indicate granting of unrestricted events to the `Admin` role:

::: code-group
<<< ../examples/auth-use-requires/correct/srv/cat-service.cds#snippet{cds:line-numbers} [srv/cat-service.cds]
:::
<PlaygroundBadge
  name="auth-use-requires"
  kind="correct"
  :rules="{'@sap/cds/auth-use-requires': ['warn', 'show']}"
  :files="['db/schema.cds', 'srv/cat-service.cds']"
/>

#### ❌ &nbsp; Incorrect example

In the following example, the `CatalogService` uses `@restrict` to assign unrestricted events (`grant: *`) to the `Admin` role (`to: Admin`). This which could be written more clearly using `@requires` and so the rule reports a warning:

::: code-group
<<< ../examples/auth-use-requires/incorrect/srv/cat-service.cds#snippet{cds:line-numbers} [srv/cat-service.cds]
:::
<PlaygroundBadge
  name="auth-use-requires"
  kind="incorrect"
  :rules="{'@sap/cds/auth-use-requires': ['warn', 'show']}"
  :files="['db/schema.cds', 'srv/cat-service.cds']"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 2.4.1`.





# auth-valid-restrict-grant

## Rule Details

The `grant` property of a `@restrict` privilege defines one or more events that the privilege applies. This rule checks for valid values of `@restrict.grant`, that is, all standard CDS events (such as `READ`, `CREATE`, `UPDATE`, and `DELETE`) on entities. It also suggests to use `*` only when listing events including `*` and to use `WRITE` only when using solely standard CDS events with write semantics (`CREATE`, `DELETE`, `UPDATE`, `UPSERT`).

## Examples

#### ✅ &nbsp; Correct example

In the following example, `CatalogService.ListOfBooks` is restricted to the `READ` event for the `Viewer` role, which is a valid value for `@restrict.grant`:

::: code-group
<<< ../examples/auth-valid-restrict-grant/correct/srv/cat-service.cds#snippet{cds:line-numbers} [srv/cat-service.cds]
:::
<PlaygroundBadge
  name="auth-valid-restrict-grant"
  kind="correct"
  :rules="{'@sap/cds/auth-valid-restrict-grant': ['warn', 'show']}"
  :files="['db/schema.cds', 'srv/cat-service.cds']"
/>

#### ❌ &nbsp; Incorrect example

In the next example, the `@restrict.grant` has a typo in the event (that is, `REAAD` instead of `READ`) for the `Viewer` role, which is not a valid value for `@restrict.grant` so the rule will report a warning:

::: code-group
<<< ../examples/auth-valid-restrict-grant/incorrect/srv/cat-service.cds#snippet{cds:line-numbers} [srv/cat-service.cds]
:::
<PlaygroundBadge
  name="auth-valid-restrict-grant"
  kind="incorrect"
  :rules="{'@sap/cds/auth-valid-restrict-grant': ['warn', 'show']}"
  :files="['db/schema.cds', 'srv/cat-service.cds']"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 2.4.1`.




# auth-valid-restrict-keys

## Rule Details

To define authorizations on a fine-grained level, the `@restrict` annotation allows you to add all kinds of restrictions that are based on static user roles, the request operation, and instance filters. The building block of such a restriction is a single privilege. This rule checks that the privileges defined in `@restrict` have properly spelled `to`, `grant`, and `where` keys.

## Examples

#### ✅ &nbsp; Correct example

In the following example, the `@restrict` annotation on `CatalogService.ListOfBooks` has correctly spelled `to`, `grant`, and `where` keys in the defined privilege:

::: code-group
<<< ../examples/auth-valid-restrict-keys/correct/srv/cat-service.cds#snippet{ts:line-numbers} [srv/cat-service.cds]
:::
<PlaygroundBadge
  name="auth-valid-restrict-keys"
  kind="correct"
  :rules="{'@sap/cds/auth-valid-restrict-keys': ['warn', 'show']}"
  :files="['db/schema.cds', 'srv/cat-service.cds']"
/>

#### ❌ &nbsp; Incorrect example

In the next example, the `@restrict` annotation on `CatalogService.ListOfBooks` has typos in the `grant` key (`grants` instead of `grant`), the `to` key (`too` instead of `to`), and the `where` key (`were` instead of `where`) and the rule will report them as a warning:

::: code-group
<<< ../examples/auth-valid-restrict-keys/incorrect/srv/cat-service.cds#snippet{ts:line-numbers} [srv/cat-service.cds]
:::
<PlaygroundBadge
  name="auth-valid-restrict-keys"
  kind="incorrect"
  :rules="{'@sap/cds/auth-valid-restrict-keys': ['warn', 'show']}"
  :files="['db/schema.cds', 'srv/cat-service.cds']"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 2.4.1`.




# auth-valid-restrict-to

## Rule Details

The `to` property of a `@restrict` privilege defines one or more [user roles](../../../guides/security/authorization#roles) or [pseudo roles](../../../guides/security/authorization#pseudo-roles) that the privilege applies to. This rule checks that the values of `@restrict.to` are valid, that is, roles cannot be missing, misspelled and that roles including `any` should be simplified to just `any`.

## Examples

#### ✅ &nbsp; Correct example

The following example shows a correct usage of the `@restrict.to` annotation, where the `to` property is set to the `Viewer` rule which is a valid value:

::: code-group
<<< ../examples/auth-valid-restrict-to/correct/srv/cat-service.cds#snippet{cds:line-numbers} [srv/cat-service.cds]
:::
<PlaygroundBadge
  name="auth-valid-restrict-to"
  kind="correct"
  :rules="{'@sap/cds/auth-valid-restrict-to': ['warn', 'show']}"
  :files="['db/schema.cds', 'srv/cat-service.cds']"
/>

#### ❌ &nbsp; Incorrect example

The next example shows the `@restrict.to` annotation being left empty, which is a violation of this rule and a warning is raised:

::: code-group
<<< ../examples/auth-valid-restrict-to/incorrect/srv/cat-service.cds#snippet{cds:line-numbers} [srv/cat-service.cds]
:::
<PlaygroundBadge
  name="auth-valid-restrict-to"
  kind="incorrect"
  :rules="{'@sap/cds/auth-valid-restrict-to': ['warn', 'show']}"
  :files="['db/schema.cds', 'srv/cat-service.cds']"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 2.4.1`.




# auth-valid-restrict-where

## Rule Details

The `where` property of a [`@restrict`](/guides/security/authorization#restrict-annotation) privilege defines a filter expression that restricts the access on an instance level (optional). This rule checks that the values of `@restrict.where` are valid, that is, the filter expression must be a valid expression that compiles without any errors.

## Examples

#### ✅ &nbsp; Correct example

In the following example, the `@restrict` privilege is defined with a valid `where` property `CreatedBy = $user'`:

::: code-group
<<< ../examples/auth-valid-restrict-where/correct/srv/cat-service.cds#snippet{cds:line-numbers} [srv/cat-service.cds]
:::
<PlaygroundBadge
  name="auth-valid-restrict-where"
  kind="correct"
  :rules="{'@sap/cds/auth-valid-restrict-where': ['warn', 'show']}"
  :files="['db/schema.cds', 'srv/cat-service.cds']"
/>

#### ❌ &nbsp; Incorrect example

In the next example, the `@restrict` privilege is defined with an invalid `where` property `CreatedBy === $user`. Since this is not a valid filter expression according to the CDS compiler, the rule reports a warning:

::: code-group
<<< ../examples/auth-valid-restrict-where/incorrect/srv/cat-service.cds#snippet{cds:line-numbers} [srv/cat-service.cds]
:::
<PlaygroundBadge
  name="auth-valid-restrict-where"
  kind="incorrect"
  :rules="{'@sap/cds/auth-valid-restrict-where': ['warn', 'show']}"
  :files="['db/schema.cds', 'srv/cat-service.cds']"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 2.4.1`.




# extension-restrictions

## Rule Details

CAP provides intrinsic extensibility, which means all your entities and services are extensible by default.
Your SaaS app becomes the base app for extensions by your customers, and your data model the base model. Normally,
you'll want to restrict which services or entities your SaaS customers are allowed to extend and to what degree they may do so.
This rule ensures that extensions do not violate any restrictions set by the extended SaaS app.

## Examples

#### ✅ &nbsp; Correct example

::: code-group
<<< ../examples/extension-restrictions/correct/db/schema.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="extension-restrictions"
  kind="correct"
  :rules="{'@sap/cds/extension-restrictions': 'warn'}"
  :files="['db/schema.cds', 'node_modules/base-app/.cdsrc.json', 'node_modules/base-app/index.csn']"
  :packages="{'dependencies': { '@sap/cds-mtxs': '^1' }, 'cds': { 'extends': 'base-app' } }"
/>

#### ❌ &nbsp; Incorrect example

::: code-group
<<< ../examples/extension-restrictions/incorrect/db/schema.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  nolink="true"
  name="extension-restrictions"
  kind="incorrect"
  :rules="{'@sap/cds/extension-restrictions': 'warn'}"
  :files="['db/schema.cds', 'node_modules/base-app/.cdsrc.json', 'node_modules/base-app/index.csn']"
  :packages="{'dependencies': { '@sap/cds-mtxs': '^1' }, 'cds': { 'extends': 'base-app' } }"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 2.6.0`.







# latest-cds-version

## Rule Details

It's recommended to always use the latest version of `@sap/cds` to benefit from the latest features and bug fixes.
This rule checks whether the latest `@sap/cds` version is being used and reports back in case a newer version is available.

## Examples

Let's suppose the latest version of `@sap/cds` available is `7.8.0`.

#### ✅ &nbsp; Correct example

If the current version in your environment is `7.8.0`, the rule passes and there's no output.

#### ❌ &nbsp; Incorrect example

If the current version in your environment is `7.0.0`, that is what the command `npm outdated @sap/cds` returns:

<pre class="log">
Package   Current  Wanted  Latest  Location               Depended by
<text>@sap/cds</text>    7.0.0   <text>7.8.0</text>   <text>7.8.0</text>  node_modules/@sap/cds  latest-cds-version
</pre>

Then the rule is triggered and prints the following output upon calling `cds lint` in the directory of your project (for example, _YOUR_PROJECT_PATH_):

<pre class="log">
/YOUR_PROJECT_PATH
  1:1  error  A newer CDS version is available!  <text>@sap/cds/latest-cds-version</text>

<text>✖ 1 problem (1 error, 0 warnings)</text>
</pre>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 1.0.4`.





# no-db-keywords

## Rule Details

The CDS compiler and CAP runtimes provide smart quoting for reserved words in SQLite so that they can still be used in most situations.
But in general reserved words cannot be used as identifiers and this rule warns you if you use any of the [reserved SQL keywords](https://www.sqlite.org/lang_keywords.html).

## Examples

#### ✅ &nbsp; Correct example

In the following example, none of the reserved SQL keywords are used as identifiers, so the rule doesn't raise any warnings:

::: code-group
<<< ../examples/no-db-keywords/correct/db/schema.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="no-db-keywords"
  kind="correct"
  :rules="{'@sap/cds/no-db-keywords': ['warn', 'show']}"
  :files="['db/schema.cds']"
  :packages="{'cds': { 'requires': {'db': { 'kind': 'sql' } } } }"
/>

#### ❌ &nbsp; Incorrect example

In the next example, the reserved SQL keyword `Order` is used as an entity name, so the rule will raise a warning:

::: code-group
<<< ../examples/no-db-keywords/incorrect/db/schema.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="no-db-keywords"
  kind="incorrect"
  :rules="{'@sap/cds/no-db-keywords': ['warn', 'show']}"
  :files="['db/schema.cds']"
  :packages="{'devDependencies': { '@cap-js/sqlite': '^1' } }"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 2.1.0`.




# no-dollar-prefixed-names

## Rule Details

Names must not start with $ to avoid possible shadowing of reserved variables.

## Examples

#### ✅ &nbsp; Correct example

In the following example, all elements names are well defined and do not start with `$`:

::: code-group
<<< ../examples/no-dollar-prefixed-names/correct/db/schema.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="no-dollar-prefixed-names"
  kind="correct"
  :rules="{'@sap/cds/no-dollar-prefixed-names': ['error', 'show']}"
  :files="['db/schema.cds']"
/>

#### ❌ &nbsp; Incorrect example

In the next example, the element `$pages` starts with `$` and so the rule will raise an error for this element:

::: code-group
<<< ../examples/no-dollar-prefixed-names/incorrect/db/schema.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="no-dollar-prefixed-names"
  kind="incorrect"
  :rules="{'@sap/cds/no-dollar-prefixed-names': ['error', 'show']}"
  :files="['db/schema.cds']"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 2.3.3`.




# no-java-keywords

## Rule Details

The CAP Java code generation bases its class and method names on CDS entities.
If reserved Java keywords are used as CDS identifiers, the code generation or compilation may fail.
This rule helps identify such identifiers early on and suggest to use the `@cds.java.name` annotation.

## Examples

#### ✅ &nbsp; Correct example

In the following example, use of the reserved Java keyword as identifiers is fixed via the `@cds.java.name` annotation, so the rule doesn't raise any warnings:

::: code-group
<<< ../examples/no-java-keywords/correct/db/schema.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="no-java-keywords"
  kind="correct"
  :rules="{'@sap/cds/no-java-keywords': ['warn', 'show']}"
  :files="['db/schema.cds']"
  :packages="{'cds': { 'requires': {'db': { 'kind': 'sql' } }} }"
/>

#### ❌ &nbsp; Incorrect example

In the next example, the reserved SQL keyword `new` is used as an element name, so the rule will raise a warning:

::: code-group
<<< ../examples/no-java-keywords/incorrect/db/schema.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="no-java-keywords"
  kind="incorrect"
  :rules="{'@sap/cds/no-java-keywords': ['warn', 'show']}"
  :files="['db/schema.cds']"
  :packages="{'devDependencies': { '@cap-js/sqlite': '^1' } }"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 3.2.0`.





# no-join-on-draft

## Rule Details

Draft-enabled entities shall not be used in views that make use of `JOIN`. This rule will report a warning for any violations.

## Examples

#### ✅ &nbsp; Correct example

In the following example, no draft-enabled entities are used in the service `CatalogService`:

::: code-group
<<< ../examples/no-join-on-draft/correct/srv/cat-service.cds#snippet{cds:line-numbers} [srv/cat-service.cds]
:::
<PlaygroundBadge
  name="no-join-on-draft"
  kind="correct"
  :rules="{'@sap/cds/no-join-on-draft': ['warn', 'show']}"
  :files="['db/schema.cds', 'srv/cat-service.cds']"
/>

#### ❌ &nbsp; Incorrect example

In the next example, the service `CatalogService` uses a draft-enabled entity and makes use of `JOIN`, which violates the rule:

::: code-group
<<< ../examples/no-join-on-draft/incorrect/srv/cat-service.cds#snippet{cds:line-numbers} [srv/cat-service.cds]
:::
<PlaygroundBadge
  name="no-join-on-draft"
  kind="incorrect"
  :rules="{'@sap/cds/no-join-on-draft': ['warn', 'show']}"
  :files="['db/schema.cds', 'srv/cat-service.cds']"
/>

### Version
This rule was introduced in `@sap/eslint-plugin-cds 2.2.1`.




# sql-cast-suggestion

## Rule Details

With compiler v2, appending a type declaration to a column expression in a view's query doesn't generate a cast in SQL anymore, as that created conflicts with various database-specific behaviors. This rule ensures that such casts are added explicitly by suggesting possible missing SQL casts.

## Examples

#### ✅ &nbsp; Correct example

In the following example, the entity `ListOfBooks` contains explicit casts for elements `name2` and `name3`, so the rule will not be triggered for these elements:

::: code-group
<<< ../examples/sql-cast-suggestion/correct/db/schema.cds#snippet{ts:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="sql-cast-suggestion"
  kind="correct"
  :rules="{'@sap/cds/sql-cast-suggestion': ['warn', 'show']}"
  :files="['db/schema.cds']"
/>

#### ❌ &nbsp; Incorrect example

In the next example, the rule will be triggered for elements `name1` and `name2` because they require explicit casts:

::: code-group
<<< ../examples/sql-cast-suggestion/incorrect/db/schema.cds#snippet{ts:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="sql-cast-suggestion"
  kind="incorrect"
  :rules="{'@sap/cds/sql-cast-suggestion': ['warn', 'show']}"
  :files="['db/schema.cds']"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 1.0.8`.




# sql-null-comparison

## Rule Details


Comparing values against `null` in views is a common pitfall in SQL.
This rules helps find places where incorrect SQL comparisons are used and proposes to use `IS NULL` or `IS NOT NULL` instead.

## Examples

#### ✅ &nbsp; Correct example

In the following example, the rule is satisfied because `null` comparison is valid:

::: code-group
<<< ../examples/sql-null-comparison/correct/srv/cat-service.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="sql-null-comparison"
  kind="correct"
  :rules="{'@sap/cds/sql-null-comparison': 'warn'}"
  :files="['db/schema.cds']"
/>

#### ❌ &nbsp; Incorrect example

In the next example, the rule reports a warning, because the comparison `= null` is not correct:

::: code-group
<<< ../examples/sql-null-comparison/incorrect/srv/cat-service.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="sql-null-comparison"
  kind="incorrect"
  :rules="{'@sap/cds/sql-null-comparison': 'warn'}"
  :files="['db/schema.cds']"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 3.1.0`.





# start-elements-lowercase

## Rule Details

According to our [naming conventions](../../../guides/domain-modeling#naming-conventions), to easily distinguish entity names from element names we recommend starting elements with a *lowercase* letter, which this rule ensures.

## Examples

#### ✅ &nbsp; Correct example

In the following example, the rule is satisfied because the element name `title` starts with a lowercase letter:

::: code-group
<<< ../examples/start-elements-lowercase/correct/db/schema.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="start-elements-lowercase"
  kind="correct"
  :rules="{'@sap/cds/start-elements-lowercase': 'warn'}"
  :files="['schema.cds']"
/>

#### ❌ &nbsp; Incorrect example

In the next example, the rule will report a warning, because the element name `Title` starts with an uppercase letter:

::: code-group
<<< ../examples/start-elements-lowercase/incorrect/db/schema.cds#snippet{ts:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="start-elements-lowercase"
  kind="incorrect"
  :rules="{'@sap/cds/start-elements-lowercase': 'warn'}"
  :files="['db/schema.cds']"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 1.0.4`.




# start-entities-uppercase

## Rule Details


According to our [naming conventions](../../../guides/domain-modeling#naming-conventions), to easily distinguish entity names from element names we recommend starting entity names with *capital* letters, which this rule ensures.

## Examples

#### ✅ &nbsp; Correct example

In the following example, the rule is satisfied because the entity name `Books` starts with a capital letter:

::: code-group
<<< ../examples/start-entities-uppercase/correct/db/schema.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="start-entities-uppercase"
  kind="correct"
  :rules="{'@sap/cds/start-entities-uppercase': 'warn'}"
  :files="['db/schema.cds']"
/>

#### ❌ &nbsp; Incorrect example

In the next example, the rule reports a warning, because the entity name `books` starts with a lowercase letter:

::: code-group
<<< ../examples/start-entities-uppercase/incorrect/db/schema.cds#snippet{cds:line-numbers} [db/schema.cds]
:::
<PlaygroundBadge
  name="start-entities-uppercase"
  kind="incorrect"
  :rules="{'@sap/cds/start-entities-uppercase': 'warn'}"
  :files="['db/schema.cds']"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 1.0.4`.




# valid-csv-header

## Rule Details

To provide your database with initial data, you can use CSV files. Their filenames are expected to match fully qualified names of respective entity definitions in your CDS models and their content is standard CSV content with the column titles corresponding to declared element names. This rule ensures that the header of the CSV file matches the column names of the entity definition.

## Examples

Let's consider the following model definition:

::: code-group
<<< ../examples/valid-csv-header/correct/db/schema.cds#snippet{cds:line-numbers} [db/schema.cds]
:::

#### ✅ &nbsp; Correct example

The following example shows a correct CSV file header that matches the column names of the entity definition:

::: code-group
<<< ../examples/valid-csv-header/correct/db/data/sap.capire.bookshop-Books.csv#snippet{csv:line-numbers} [db/data/sap.capire.bookshop-Books.csv]
:::
<PlaygroundBadge
  name="valid-csv-header"
  kind="correct"
  :rules="{'@sap/cds/valid-csv-header': ['warn', 'show']}"
  :files="['db/schema.cds', 'db/data/sap.capire.bookshop-Books.csv']"
/>

#### ❌ &nbsp; Incorrect example

In the next example, there's a typo in the header of the CSV file. The column name `title` is misspelled as `tile`, so the rule reports a warning:

::: code-group
<<< ../examples/valid-csv-header/incorrect/db/data/sap.capire.bookshop-Books.csv#snippet{csv:line-numbers{1}} [db/data/sap.capire.bookshop-Books.csv]
:::
<PlaygroundBadge
  name="valid-csv-header"
  kind="incorrect"
  :rules="{'@sap/cds/valid-csv-header': ['warn', 'show']}"
  :files="['db/schema.cds', 'db/data/sap.capire.bookshop-Books.csv']"
/>

## Version
This rule was introduced in `@sap/eslint-plugin-cds 2.3.0`.


# CDS Typer {#cds-typer}

The following chapter describes the [`cds-typer` package](https://www.npmjs.com/package/@cap-js/cds-typer) in detail using the [bookshop sample](https://github.com/SAP-samples/cloud-cap-samples/tree/main/bookshop) as a running example.

## Quickstart using VS Code {#cds-typer-vscode}

1. In your project's root, execute `cds add typer`.
2. Make sure you have the [SAP CDS Language Support extension for VS Code](https://marketplace.visualstudio.com/items?itemName=SAPSE.vscode-cds) installed.
3. See that cds-typer is enabled in your VS Code settings (CDS > Type Generator > Enabled).
4. Install the newly added dev-dependency using `npm i`.
5. Saving any _.cds_ file of your model from VS Code triggers the type generation process.
6. Model types now have to be imported to service implementation files by traditional imports of the generated files:

```js twoslash
// @noErrors
const cds = require('@sap/cds')
const service = new cds.ApplicationService
// ---cut---
//  without cds-typer
const { Books } = cds.entities('bookshop')
service.before('CREATE', Books, ({ data }) => { /* data is of type any */})
//                                 ^?
```
<p/>

```js twoslash
// @noErrors
// @paths: {"#cds-models/*": ["%typedModels:bookshop:resolved%"]}
const cds = require('@sap/cds')
const service = new cds.ApplicationService
// ---cut---
// ✨ with cds-typer
const { Books } = require('#cds-models/sap/capire/bookshop')
service.before('CREATE', Books, ({ data }) => { /* data is of type Books */})
//                                 ^?
```


::: details How it works:

The extension will automatically trigger the type generator whenever you hit _save_ on a _.cds_ file that is part of your model. That ensures that the generated type information stays in sync with your model. If you stick to the defaults, saving a _.cds_ file will have the type generator emit [its type files](#emitted-type-files) into the directory _@cds-models_ in your project's root.

Opening your VS Code settings and typing "`cds type generator`" into the search bar will reveal several options to configure the type generation process. Output, warnings, and error messages of the process can be found in the output window called "`CDS`".

:::

[Learn more about the `typer` facet.](#typer-facet){.learn-more}
[Learn about other options to use `cds-typer`.](#usage-options){.learn-more}

## Using Emitted Types in Your Service
The types emitted by the type generator are tightly integrated with the CDS API. The following section illustrates where the generated types are recognized by CDS.

### CQL

Most CQL constructs have an overloaded signature to support passing in generated types. Chained calls will offer code completion related to the type you pass in.

```js twoslash
// @paths: {"#cds-models/*": ["%typedModels:bookshop:resolved%"]}
const cds = require('@sap/cds')
// ---cut---
// previous approach (still valid, but prefer using reflected entities over string names)
SELECT('Books')  // etc...

// how you can do it using generated types
const { Book, Books } = require('#cds-models/sap/capire/bookshop')

// SELECT
SELECT(Books)
SELECT.one(Book)
SELECT(Books, b => { b.ID })  // projection
SELECT(Books, b => { b.author(a => a.ID.as('author_id')) })  // nested projection
//                       ^|

// INSERT / UPSERT
INSERT.into(Books)
INSERT.into(Books).columns(['title', 'ID'])  // column names derived from Books' properties

// DELETE
DELETE.from(Books, 42)
```

Note that your entities will expose additional capabilities in the context of CQL, such as the `.as(…)` method to specify an alias.

### CRUD Handlers
The CRUD handlers `before`, `on`, and `after` accept generated types:

```js twoslash
// @noErrors
// @paths: {"#cds-models/*": ["%typedModels:bookshop:resolved%"]}
const cds = require('@sap/cds')
const { Book, Books } = require('#cds-models/sap/capire/bookshop')
const service = new cds.ApplicationService
// ---cut---
// the payload is known to contain Books inside the respective handlers
service.before('READ', Books, req => {  })
//                            ^?


service.on('READ', Books, req => {  })
//                        ^?


service.after('READ', Books, (books, req) => {  })
//                            ^?
```

### Actions

In the same manner, actions can be combined with `on`:

```js twoslash
// @noErrors
// @paths: {"#cds-models/*": ["%typedModels:bookshop:resolved%"]}
const cds = require('@sap/cds')
const service = new cds.ApplicationService
// ---cut---
const { submitOrder } = require('#cds-models/CatalogService')
service.on(submitOrder, ({ data }) => {
  //                        ^?
  // action implementation
})
```
<br/><br/>

::: warning _Lambda Functions vs. Fully Fledged Functions_

Using anything but lambda functions for either CRUD handler or action implementation will make it impossible for the LSP to infer the parameter types.

You can remedy this by specifying the expected type with one of the following options.

Using [JSDoc](https://jsdoc.app/) in JavaScript projects:

```js twoslash
// @noErrors
// @paths: {"#cds-models/*": ["%typedModels:bookshop:resolved%"]}
const cds = require('@sap/cds')
const service = new cds.ApplicationService
// ---cut---
const { Books } = require('#cds-models/sap/capire/bookshop')
service.on('READ', Books, readBooksHandler)

/** @param { cds.TypedRequest<Books> } req */
function readBooksHandler (req) {
  req.data // req.data is now properly known to be of type Books again
//    ^?
}
```

<br>
Using `import` in TypeScript projects:

```ts twoslash
// @noErrors
// @paths: {"#cds-models/*": ["%typedModels:bookshop:resolved%"]}
import cds from '@sap/cds'
const service = new cds.ApplicationService
// ---cut---
import { Books } from '#cds-models/sap/capire/bookshop'
service.on('READ', Books, readBooksHandler)

function readBooksHandler (req: cds.TypedRequest<Books>) {
  req.data // req.data is now properly known to be of type Books again
//    ^?
}
```

:::


### Enums

CDS enums are supported by `cds-typer` and are represented during runtime as well. So you can assign values to enum-typed properties with more confidence:

<<< assets/incidents/db/schema.cds

```js twoslash
// @paths: {"#cds-models/*": ["%typedModels:incidents:resolved%"]}
const cds = require('@sap/cds')
const service = new cds.ApplicationService
// ---cut---
const { Ticket, Priority } = require('#cds-models/incidents')

service.before('CREATE', Ticket, (req) => {
  req.data.priority = Priority.L  // [!code focus]
//                              ^|


  req.data.status = Ticket.status.UNASSIGNED  // [!code focus]
//                          ^?





})

```

### Handling Optional Properties
Per default, all properties of emitted types are set to be optional. This reflects how entities can be partial in handlers.

CDS file:

```cds
entity Author {
    name: String; // [!code focus]
    …
}

entity Book {
    author: Association to Author; // [!code focus]
    …
}
```

Generated type file:

```ts
class Author {
    name?: string // [!code focus]
    …
}

class Book {
    author?: Association.to<Author>  // [!code focus]
    …
}
```

In consequence, you will get called out by the type system when trying to chain property calls. You can overcome this in a variety of ways:

```ts twoslash
// @paths: {"#cds-models/*": ["%typedModels:bookshop:resolved%"]}
import cds from '@sap/cds'
// ---cut---
import { Author, Book } from '#cds-models/sap/capire/bookshop'
const myBook = new Book()

// (i) optional chaining
myBook.author?.name

// (ii) explicitly ruling out the undefined and null types
if (myBook.author) myBook.author.name

// (iii) non-null assertion operator
myBook.author!.name

// (iv) explicitly casting your object to a type where all properties are attached
const myAttachedBook = myBook as Required<Book>
myAttachedBook.author?.name

// (v) explicitly casting your object to a type where the required property is attached
const myPartiallyAttachedBook = myBook as Book & { author: Author }
myPartiallyAttachedBook.author?.name
```

Note that (iii) through (v) are specific to TypeScript, while (i) and (ii) can also be used in JavaScript projects.

## Fine Tuning
### Singular/ Plural
The generated types offer both a singular and plural form for convenience. The derivation of these names uses a heuristic that assumes entities are named with an English noun in plural form, following the [best practice guide](../guides/domain-modeling#naming-conventions).

Naturally, this best practice can't be enforced on every model. Even for names that do follow best practices, the heuristic can fail. If you find that you would like to specify custom identifiers for singular or plural forms, you can do so using the `@singular` or `@plural` annotations.

CDS file:

<<< assets/animal-farm/db/schema.cds{3,6}

Generated classes:

```ts twoslash
// @paths: {"#cds-models/*": ["%typedModels:farm:resolved%"]}
import { Mouse, Mice, Sheep, FlockOfSheep } from '#cds-models/farm'
```

### Strict Property Checks in JavaScript Projects
You can enable strict property checking for your JavaScript project by adding the [`checkJs: true`](https://www.typescriptlang.org/tsconfig#checkJs) setting to your _jsconfig.json_ or _tsconfig.json_.
This will consider referencing properties in generated types that are not explicitly defined as error.

## Usage Options

Besides using the [SAP CDS Language Support extension for VS Code](https://marketplace.visualstudio.com/items?itemName=SAPSE.vscode-cds), you have the option to use `cds-typer` on the command line.

### Command Line Interface (CLI) {#typer-cli}

```sh
npx @cap-js/cds-typer /home/mybookshop/db/schema.cds --outputDirectory /home/mybookshop
```

The CLI offers several parameters which you can list using the `--help` parameter.

::: details You should then see the following output:

<pre class="log">
> cds-typer --help

SYNOPSIS

  cds-typer [cds file | "*"]

  Generates type information based on a CDS model.
  Call with at least one positional parameter pointing
  to the (root) CDS file you want to compile.

OPTIONS

  --buildTask
  --build_task: &lt;true | false&gt;
    (default: true)

    If set to true, the typescript build task will not be registered/ executed.
    This value must be set in your project configuration.
    Passing it as parameter to the cds-typer CLI has no effect.

  --cache: &lt;none | blake2s256&gt;
    (default: none)

    How to cache typer runs.
    none: fully run cds-typer whenever it is called
    blake2s256: only run if the blake2s256-hash of the model has changed. Hash is stored in a file between runs.

  --help

    This text.

  --inlineDeclarations
  --inline_declarations: &lt;flat | structured&gt;
    (default: flat)

    Whether to resolve inline type declarations
    flat: (x_a, x_b, ...)
    or structured: (x: {a, b}).

  --IEEE754Compatible
  --ieee754compatible: &lt;true | false&gt;
    (default: false)

    If set to true, floating point properties are generated
    as IEEE754 compatible '(number | string)' instead of 'number'.

  --jsConfigPath
  --js_config_path: &lt;string&gt;

    Path to where the jsconfig.json should be written.
    If specified, cds-typer will create a jsconfig.json file and
    set it up to restrict property usage in types entities to
    existing properties only.

  --logLevel
  --log_level SILENT | ERROR | WARN | INFO | DEBUG | TRACE | SILLY | VERBOSE
    (default: ERROR)

    Minimum log level that is printed.
    The default is only used if no explicit value is passed
    and there is no configuration passed via cds.env either.

  --legacyBinaryTypes
  --legacy_binary_types: &lt;true | false&gt;
    (default: false)

    If set to true, Binary and LargeBinary are generated
    as strings.

  --outputDirectory
  --output_directory: &lt;string&gt;
    (default: ./)

    Root directory to write the generated files to.

  --propertiesOptional
  --properties_optional: &lt;true | false&gt;
    (default: true)

    If set to true, properties in entities are
    always generated as optional (a?: T).
    Setting it to false makes properties non-optional instead (a: T).

  --targetModuleType
  --target_module_type: &lt;esm | cjs | auto&gt;
    (default: auto)

    Output format for generated .js files.
    Setting it to auto tries to derive the module type from
    the package.json and falls back to CJS.

  --useEntitiesProxy
  --use_entities_proxy: &lt;true | false&gt;
    (default: true)

    If set to true the 'cds.entities' exports in the generated 'index.js'
    files will be wrapped in 'Proxy' objects
    so static import/require calls can be used everywhere.
    
    WARNING: entity properties can still only be accessed after
    'cds.entities' has been loaded

  --version

    Prints the version of this tool.
</pre>

:::

### Configuration

Any CLI parameter described [above](#typer-cli) can also be passed to cds-typer via [`cds.env`](../node.js/cds-env) in the section `cds.typer`. For example, so set a project-wide custom output directory for cds-typer to `myCustomDirectory`, you would set

<Config>cds.typer.output_directory: myCustomDirectory</Config>


### Version Control
The generated types _are meant to be ephemeral_. We therefore recommend that you do not add them to your version control system. Adding the [typer as facet](#typer-facet) will generate an appropriate entry in your project's `.gitignore` file.
You can safely remove and recreate the types at any time.
We especially suggest deleting all generated types when switching between development branches to avoid unexpected behavior from lingering types.

## Integrate Into TypeScript Projects
The types emitted by `cds-typer` can be used in TypeScript projects as well! Depending on your project setup you may have to do some manual configuration for your local development setup.

1. Make sure the directory the types are generated into are part of your project's files. You will either have to add that folder to your `rootDirs` in your _tsconfig.json_ or make sure the types are generated into a directory that is already part of your `rootDir`.
2. Preferably run the project using `cds-ts`.
3. If you have to use `tsc`, you have to touch up on the generated files. Assume your types are in _@cds-models_ below your project's root directory and your code is transpiled to _dist/_, you would use:

```sh
tsc && cp -r @cds-models dist
```

## Integrate Into Your CI
As the generated types are build artifacts, we recommend to exclude them from your software versioning process. Still, as using `cds-typer` changes how you include your model in your service implementation, you need to include the emitted files when running tests in your continuous integration pipeline.
You should therefore trigger `cds-typer` as part of your build process. One easy way to do so is to add a variation of the following command to your build script:

```sh
npx @cap-js/cds-typer "*" --outputDirectory @cds-models
```
Make sure to add the quotes around the asterisk so your shell environment does not expand the pattern.

## Integrate Into Your Build Process
Having `cds-typer` present as dependency provides the `typescript` build task. If your project also depends on the `typescript` package, this build task is automatically included when you run `cds build`.

If you are [customizing your build task](../guides/deployment/custom-builds), you can add it after the `nodejs` build task:

```json {3}
"tasks": [
  { "for": "nodejs" },
  { "for": "typescript" },
  …
]
```

This build task will make some basic assumptions about the layout of your project. For example, it expects all source files to be contained within the root directory. If you find that the standard behavior does not match your project setup, you can customize this build step by providing a `tsconfig.cdsbuild.json` in the root directory of your project. We recommend the following basic setup for such a file:

::: code-group
```json [tsconfig.cdsbuild.json]
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "outDir": "./gen/srv",
  },
  "exclude": ["app", "gen"]
}
```
:::

## About The Facet {#typer-facet}
Type generation can be added to your project as [facet](../tools/cds-cli#cds-add) via `cds add typer`.

::: details Under the hood

Adding this facet effectively does four things:

1. Adds `@cap-js/cds-typer` as a dev-dependency (⚠️ which you still have to install using `npm i`)
2. Creates (or modifies) a _jsconfig.json_ file to support intellisense for the generated types
3. Modifies _package.json_ to enable [subpath imports](https://nodejs.org/api/packages.html#subpath-imports) for the generated types
4. Adds `@cds-models` (the default output folder for generated files) to your project's _.gitignore_
:::

::: warning _TypeScript Projects_

Adding the facet in a TypeScript project will adjust your _tsconfig.json_ instead. Note that you may have to manually add the type generator's configured output directory to the `rootDirs` entry in your
_tsconfig.json_, as we do not want to interfere with your configuration.

:::


## About the Emitted Type Files {#emitted-type-files}

The emitted types are bundled into a directory which contains a nested directory structure that mimics the namespaces of your CDS model. For the sake of brevity, we will assume them to be in a directory called _@cds-models_ in your project's root in the following sections.
For example, the sample model contains a namespace `sap.capire.bookshop`. You will therefore find the following file structure after the type generation has finished:

```zsh
@cds-models/
└── sap/
  └── capire/
    └── bookshop/
      ├── index.js
      └── index.ts
```

Each _index.ts_ file will contain type information for one namespace. For each entity belonging to that namespace, you will find two exports, a singular and a plural form:

```ts
// @cds-models/sap/capire/bookshop/index.ts
export class Author { … }
export class Authors { … }
export class Book { … }
export class Books { … }
```

The singular forms represent the entities from the original model and try to adhere to best practices of object oriented programming for naming classes in singular form.
The plural form exists as a convenience to refer to a collection of multiple entities. You can [fine tune](#fine-tuning) both singular and plural names that are used here.

You could import these types by using absolute paths, but there is a more convenient way for doing so which will be described in the next section.

## Subpath Imports

Adding type support via `cds add typer` includes configuring [subpath imports](https://nodejs.org/api/packages.html#subpath-imports). The facet adds a mapping of `#cds-models/` to the default path your model's types are assumed to be generated to (_\<project root\>/@cds-models/_). If you are generating your types to another path and want to use subpath imports, you will have to adjust this setting in your _package.json_ **and** _jsconfig.json_/ _tsconfig.json_ accordingly.

Consider [the bookshop sample](https://github.com/SAP-samples/cloud-cap-samples/tree/main/bookshop) with the following structure with types already generated into _@cds-models_:

```zsh
bookshop/
├── package.json
├── @cds-models/
│   └── ‹described in the previous section›
├── db/
│   ├── schema.cds
│   └── ...
├── srv/
│   ├── cat-service.cds
│   ├── cat-service.js
│   └── ...
└── ...
```

The following two (equally valid) statements would amount to the same import [from within the catalog service](https://github.com/SAP-samples/cloud-cap-samples/blob/main/bookshop/srv/cat-service.js):

```js
// srv/cat-service.js
const { Books } = require('../@cds-models/sap/capire/bookshop')
const { Books } = require('#cds-models/sap/capire/bookshop')
```

These imports will behave like [`cds.entities('sap.capire.bookshop')`](../node.js/cds-reflect#entities) during runtime, but offer you code completion and type hinting at design time:

```js twoslash
// @noErrors
// @paths: {"#cds-models/*": ["%typedModels:bookshop:resolved%"]}
const cds = require('@sap/cds')
// ---cut---
class CatalogService extends cds.ApplicationService { init(){
  const { Book } = require('#cds-models/sap/capire/bookshop')

  this.on ('UPDATE', Book, req => {
    // in here, req is known to hold a payload of type Book.
    // Code completion therefore offers all the properties that are defined in the model.
    req.data.t
//            ^|
  })
})
```

Similar to `cds.entities(…)`, you can't use static imports here. Instead, you need to use dynamic imports. However, there's an exception for [static top-level imports](#typer-top-level-imports).

```js twoslash
// @paths: {"#cds-models/*": ["%typedModels:bookshop:resolved%"]}
const cds = require('@sap/cds')
// ---cut---
// ❌ works during design time, but will cause runtime errors
const { Book } = require('#cds-models/sap/capire/bookshop')

class CatalogService extends cds.ApplicationService { init(){
  // ✅ works both at design time and at runtime
  const { Book } = require('#cds-models/sap/capire/bookshop')
}}
```

In TypeScript you can use [type-only imports](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export) on top level if you just want the types for annotation purposes. The counterpart for the JavaScript example above that works during design time _and_ runtime is a [dynamic import expression](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#dynamic-import-expressions):

```ts twoslash
// @noErrors
// @paths: {"#cds-models/*": ["%typedModels:bookshop:resolved%"]}
import cds from '@sap/cds'
// ---cut---
// ❌ works during design time, but will cause runtime errors
import { Book } from '#cds-models/sap/capire/bookshop'
// ✅ works during design time, but is fully erased during runtime
import type { Book } from '#cds-models/sap/capire/bookshop'

class CatalogService extends cds.ApplicationService { async init(){
  // ✅ works both at design time and at runtime
  const { Book } = await import('#cds-models/sap/capire/bookshop')
}}
```

### Static Top-Level Imports <Since version="0.26.0" of="@cap-js/cds-typer" /> {#typer-top-level-imports}
You can pass a new option, `useEntitiesProxy`, to `cds-typer`. This option allows you to statically import your entities at the top level, as you intuitively would. However, you can still only _use these entities_ in a context where the CDS runtime is fully booted, like in a service definition:

```ts twoslash
// @paths: {"#cds-models/*": ["%typedModels:bookshop:resolved%"]}
import cds from '@sap/cds'
// ---cut---
// ✅ top level import now works both during design time and runtime
import { Book } from '#cds-models/sap/capire/bookshop'

// ❌ works during design time, but will cause runtime errors
Book.actions

export class MyService extends cds.ApplicationService {
  async init () {
    // ✅ cds runtime is fully booted at this point
    Book.actions  // works
    this.on('READ', Book, req => { req.data.author  /* works as well */  })
  }
}
```


# Hybrid Testing { #hybrid-testing}

CAP enables you to run and test your CAP application using a local SQLite database and mocks to a large extent. However, you might want to test with actual cloud services at some point.

**Hybrid testing** capabilities help you stay in a local development environment and avoid long turnaround times of cloud deployments, by selectively connecting to services in the cloud.

## Bind to Cloud Services

### Services on Cloud Foundry

```sh
cds bind db --to bookshop-db
```

Binds the service `db` of your local CAP application to the service instance `bookshop-db`, using your currently targeted Cloud Foundry space. Here, `bookshop-db` is a _managed_ service of kind `hana` with plan `hdi-shared`.

::: tip `cds bind` automatically creates a service key for you
If no service key for your service `<srv>` is specified, a `<srv>-key` is automatically created.
The service name `db` can be omitted as it represents the default value for the service kind `hana`.
:::

[Got errors? See our troubleshooting for connection issues with SAP HANA Cloud.](../get-started/troubleshooting#connection-failed-89008){.learn-more}

Output:

```log
[bind] - Retrieving data from Cloud Foundry...
[bind] - Binding db to Cloud Foundry managed service bookshop-db:bookshop-db-key with kind hana.
[bind] - Saving bindings to .cdsrc-private.json in profile hybrid.
[bind] -
[bind] - TIP: Run with cloud bindings: cds watch --profile hybrid
```

For most commonly used services, CAP can automatically infer the service type and kind — in our example, the `db` CDS service is bound and set to the `hana` kind without additional parameters.

::: code-group
```json {5}[.cdsrc-private.json]
{
  "requires": {
    "[hybrid]": {
      "db": {
        "kind": "hana",
        "binding": {
          "type": "cf",
          "apiEndpoint": "https://api.sap.hana.ondemand.com",
          "org": "your-cf-org",
          "space": "your-cf-space",
          "instance": "bookshop-db",
          "key": "bookshop-db-key",
          "vcap": {
            "label": "hana",
            "plan": "hdi-shared"
          },
          "resolved": false
        }
      }
    }
  }
}
```
:::

Bindings are assigned to the `hybrid` profile by default.

::: tip No credentials are saved on-disk
Only the information about **where the credentials can be obtained** is stored on your machine.
:::

#### User-Provided Services on Cloud Foundry { #binding-user-provided-services}

```sh
cds bind my --to bookshop-ups
```

Binds the service `my` of your local CAP application to the user provided service instance `bookshop-ups`. The service name `my` has to match the service name used in the CDS `requires` service configuration.

Output:

```log
[bind] - Retrieving data from Cloud Foundry...
[bind] - Binding my to Cloud Foundry user provided service bookshop-ups. // [!code focus]
[bind] - Saving bindings to .cdsrc-private.json in profile hybrid.
[bind] -
[bind] - TIP: Run with cloud bindings: cds watch --profile hybrid
```

#### Shared Service Instances on Cloud Foundry <Since version="7.9.0" of="@sap/cds-dk" /> { #binding-shared-service-instances}

On SAP BTP Cloud Foundry, service instances can be shared across orgs and spaces. Even such shared instances can be used in `cds bind`:

```sh
cds bind messaging --to bookshop-redis
```

Binds the `messaging` service of your CAP application to the shared `bookshop-redis` service instance. `cds bind` retrieves the `org` and `space` where the service is shared from, as the service key needs to be created within that org and space. This requires the _Space Developer_ role for both spaces.

::: tip Use `cds bind --to bookshop-redis`
The service name `messaging` can be omitted as it represents the default value for the service kind `redis-messaging`.
:::

::: code-group
```json {5}[.cdsrc-private.json]
{
  "requires": {
    "[hybrid]": {
      "redis": {
        "binding": {
          "type": "cf",
          "apiEndpoint": "https://api.sap.hana.ondemand.com",
          "org": "shared-from-cf-org", // [!code focus]
          "space": "shared-from-cf-space", // [!code focus]
          "instance": "redis-cache",
          "key": "redis-cache-key",
          "resolved": false
        },
        "kind": "redis-messaging",
        "vcap": {
          "name": "messaging"
        }
      }
    }
  }
}
```
:::

`cds watch --profile hybrid` will automatically resolve shared service instance bindings using the correct org and space.

::: info Not all services can be shared
Only services that have the `shareable` flag in the metadata set to `true` can be shared. Use command `cf curl /v3/service_offerings` to read the service catalog metadata.
See the [CloudFoundry docs](https://docs.cloudfoundry.org/devguide/services/sharing-instances.html) for further details.
:::

::: tip Allow dynamic deploy targets
Service bindings created by `cds bind` contain the Cloud Foundry API endpoint, org, and space. You can allow your services to connect to the currently targeted Cloud Foundry org and space by removing these properties from the binding structure.
:::

### Services on Kubernetes


You can bind to **Service Bindings** of Open Service Broker service instances, such as SAP BTP services, on your Kubernetes cluster and to plain Kubernetes **Secrets** by adding the `--on k8s` option to the `cds bind` command:

```sh
cds bind -2 ‹service binding or secret› --on k8s
```

The command uses your current Kubernetes context. That is your current server and namespace. You need to be logged in as a precondition.

#### Bind to Kubernetes Service Bindings

To list all **Service Bindings** in your current Kubernetes context, you can use the `kubectl get servicebindings` command:

```log
NAME                   SERVICE-INSTANCE  SECRET-NAME           STATUS  AGE
bookshop-auth-binding  bookshop-auth     bookshop-auth-secret  Ready   11s
```

Use the service binding name for the `-2` option:

```sh
cds bind -2 bookshop-auth-binding --on k8s
```

Output:

```log
[bind] - Retrieving data from Kubernetes...
[bind] - Binding uaa to Kubernetes service binding bookshop-auth-binding with kind xsuaa
[bind] - Saving bindings to .cdsrc-private.json in profile hybrid
[bind] -
[bind] - TIP: Run with cloud bindings: cds watch --profile hybrid
```

The binding information is stored in the _.cdsrc-private.json_ file of your project in the `requires` section:

::: code-group
```json [.cdsrc-private.json]
{
  "requires": {
    "[hybrid]": {
      "auth": {
        "binding": {
          "type": "k8s",
          "name": "bookshop-auth-binding",
          "cluster": "https://apiserver.d9a6204.kyma-stage.shoot.live.k8s-hana.ondemand.com",
          "instance": "bookshop-auth",
          "namespace": "dev",
          "secret": "bookshop-auth-secret",
          "resolved": false,
          "vcap": {
            "label": "xsuaa",
            "plan": "application"
          }
        },
        "kind": "xsuaa"
      }
    }
  }
}
```
:::

#### Bind to Kubernetes Secrets

Alternatively, you can bind to Kubernetes **Secrets**.

You can use the `kubectl get secrets` command to list all secrets in your current Kubernetes context:

```log
NAME               TYPE      DATA   AGE
bookshop-db        Opaque    11     44h
```

Use the secret name for the `-2` option.

You need to provide either the service argument or the `--kind` option as well, because secrets have no service metadata.

```sh
cds bind -2 bookshop-db --on k8s --kind hana
```

Output:

```log
[bind] - Retrieving data from Kubernetes...
[bind] - Binding db to Kubernetes secret bookshop-db with kind hana
[bind] - Saving bindings to .cdsrc-private.json in profile hybrid
[bind] -
[bind] - TIP: Run with cloud bindings: cds watch --profile hybrid
```

::: warning Service bindings take precedence
If a service binding with the same name as the Kubernetes secret exists, `cds bind` will connect to the service binding instead.
:::

## Run with Service Bindings

### Run CAP Node.js Apps with Service Bindings { #node}

Now, you can run your CAP service locally using the cloud service bindings:

```sh
cds watch --profile hybrid
```

It will resolve the cloud bindings in your configuration:
1. **Bindings to Cloud Foundry:** The credentials are downloaded from the service key of the Cloud Foundry API endpoint, org, and space that were targeted when `cds bind` was called. This requires you to be logged in to the correct Cloud Foundry API endpoint.
2. **Bindings to Kubernetes:** The credentials are downloaded from the service bindings and secrets of the Kubernetes cluster and namespace that were in the current context when `cds bind` was called.

You can also resolve and display credentials using the `cds env` command:

```sh
cds env get requires.db.credentials --profile hybrid --resolve-bindings
```

Example output:

```js
{
  url: 'jdbc:sap://BDB9AC0F20CB46B494E6742047C4F99A.hana.eu10.hanacloud.ondemand.com:443?encrypt=true&validateCertificate=true&currentschema=BDB9AC0F20CB46B494E6742047C4F99A',
  host: 'bdb9ac0f20cb46b494e6742047c4f99a.hana.eu10.hanacloud.ondemand.com',
  port: '443',
  driver: 'com.sap.db.jdbc.Driver',
  schema: 'BDB9AC0F20CB46B494E6742047C4F99A',
  hdi_user: 'BDB9AC0F20CB46B494E6742047C4F99A_DT',
  hdi_password: 'abc...xyz',
  user: 'BDB9AC0F20CB46B494E6742047C4F99A_RT',
  password: 'abc....xyz',
  certificate: '-----BEGIN CERTIFICATE-----\n' +
    '...' +
    '-----END CERTIFICATE-----'
}
```

### Run Arbitrary Commands with Service Bindings

With `cds bind` you avoid storing credentials on your hard disk. If you need to start other local applications with cloud service bindings, you can use the `exec` option.

For example, you can run the App Router from an `approuter` child directory:

::: code-group
```sh [Mac/Linux]
cds bind --exec -- npm start --prefix approuter
```
```cmd [Windows]
cds bind --exec -- npm start --prefix approuter
```
```powershell [Powershell]
cds bind --exec '--' npm start --prefix approuter
```
:::

This works by constructing a `VCAP_SERVICES` environment variable. You can output the content of this variable as follows:

::: code-group
```sh [Mac/Linux]
cds bind --exec -- node -e 'console.log(process.env.VCAP_SERVICES)'
```
```cmd [Windows]
cds bind --exec -- node -e 'console.log(process.env.VCAP_SERVICES)'
```
```powershell [Powershell]
cds bind --exec '--' node -e 'console.log(process.env.VCAP_SERVICES)'
```
:::

### Run CAP Java Apps with Service Bindings

Start your CAP Java application with `cds bind --exec` to use remote service bindings:

```sh
cds bind --exec mvn spring-boot:run
```

### Bindings from a Cloud Application

Instead of binding to specific cloud services, you can bind to all supported service bindings of an application running on the SAP BTP Cloud Foundry environment:

```sh
cds bind -a bookshop-srv # ...or the spelled out way:
cds bind --to-app-services bookshop-srv
```
> This shortcut is only possible if you don't need to provide a `kind`.

If your application has multiple service bindings of the same kind, `cds bind` will log warnings since they can not be resolved automatically. In this case you can resolve the ambiguities by adding the correct service instance name to the cds service configuration using the `vcap.name` property.

Here is an example of adding `vcap.name` for services of kind `xsuaa`.

```json
"requires": {
  "auth": {
    "kind": "xsuaa",
    "vcap": {
      "name": "bookshop-auth1"
    }
  },
  "auth2": {
    "kind": "xsuaa",
    "vcap": {
      "name": "bookshop-auth2"
    }
  }
}
```

## `cds bind` Usage { #cds-bind-usage}

### By Cloud Service Only

The shortest way to use `cds bind` is to specify only the Cloud Foundry service instance name:

```sh
cds bind -2 bookshop-db
```

You can specify a different key after a colon ("`:`"):

```sh
cds bind -2 bookshop-db:my-db-key
```

### With different profile

By default `cds bind` uses the profile `hybrid` to store binding information. You can specify a different profile with `--for` or shortcut `-4`:

```sh
cds bind --to bookshop-db --for test
```

You have to use the same profile name for hybrid testing to correctly resolve any bindings you've created with this profile.

```sh
cds watch --profile test
```

### With CDS Service and Kind

If `kind` or CDS service cannot be determined automatically by `cds bind`, you need to specify it:

```sh
cds bind credstore -2 my-credstore --kind credstore
```

You are informed with an error message if this is required.

### Bind Multiple Services with One Command

There is a handy shortcut to bind multiple services with one command:

```sh
cds bind -2 bookshop-db,bookshop-auth
```
> This shortcut is only possible if you don't need to specify a `kind`.

### Overwrite Cloud Service Credentials { #overwriting-service-credentials}

Some hybrid test scenarios might require to overwrite dedicated service credential values. For example, if you want to connect to a Cloud Foundry service via an SSH tunnel. In the example below the value of the property _onpremise_proxy_host_ is updated with the value _localhost_.

```sh
cds bind -2 my-service --credentials '{ "onpremise_proxy_host": "localhost" }'
```

::: code-group
```json [.cdsrc-private.json]
{
  "requires": {
    "[hybrid]": {
      "my-service": {
        "binding": {
          "type": "cf",
          "apiEndpoint": "https://api.sap.hana.ondemand.com",
          "org": "your-cf-org",
          "space": "your-cf-space",
          "instance": "my-service",
          "key": "my-service-key",
          "credentials": { // [!code focus]
            "onpremise_proxy_host": "localhost" // [!code focus]
          }, // [!code focus]
          "resolved": false
         }
      }
    }
  }
}
```
:::

Now, you can run your CAP service locally using cloud service bindings in combination with merged custom credential values:

```sh
cds watch --profile hybrid
```

Example output:

```js
{
  onpremise_proxy_host: 'localhost', // [!code focus]
  // other cloud foundry credential values
}
```

You can also overwrite credential values for multiple services with a single `cds bind` call. Use the service instance together with an optional service key name as defined in the `--to` parameter to add the custom credential values for that service:

```sh
cds bind --to my-service,redis-cache:my-key,bookshop-xsuaa --credentials \
  '{ "my-service": { "onpremise_proxy_host": "localhost" }, "redis-cache:my-key":{ "hostname": "localhost", "port": 1234 }}'
```

Use the service instance name in combination with the option `--to-app-services` if you want to create bindings for all service instances of your application:

```sh
cds bind --to-app-services bookshop-srv --credentials \
  '{ "my-service": { "onpremise_proxy_host": "localhost" }, "redis-cache":{ "hostname": "localhost", "port": 1234 }}'
```

See [Accessing services with SSH](https://docs.cloudfoundry.org/devguide/deploy-apps/ssh-services.html) for further details on how you can gain direct command line access to your deployed service instance using SSH.

### With Profile and Output File

By default, the bindings for the `hybrid` profile are stored in the _.cdsrc-private.json_ file in your current working directory.

This can be overwritten using the `--out` option.

### Execute Commands with Bindings { #cds-bind-exec}

You can start arbitrary command line programs with your bindings.

The service bindings are [resolved from the cloud](#node) and [provided in the `VCAP_SERVICES` env variable](../node.js/cds-connect#provide-service-bindings) to the application. So it works with every application that can consume Cloud Foundry credentials.

```sh
cds bind --exec [--] <command> <args ...>
```

Use the double-dash (`--`) if your command has args starting with a dash (`-`) character. Otherwise the `cds` command line will try to parse them as their own options.

On PowerShell you need to quote the double dash (`--`) when an option with double dash follows:

```powershell
cds bind --exec '--' somecmd --someflag --some-double-dash-parameter 42
```

Profiles can be set using the optional `--profile` parameter. By default the `hybrid` profile is used.

```sh
cds bind --exec --profile <profile> [--] <command> <args ...>
```

The `--profile` parameter must follow `exec` directly.

## Use Cases

Most of the following use cases are shown for Node.js, but can be easily adapted for Java.

### Destinations

Learn how to [connect to remote services locally](../guides/using-services#connect-to-remote-services-locally) using SAP BTP destinations.

### Authentication and Authorization using XSUAA

Learn how to do hybrid testing using the XSUAA service in the [CAP Node.js authentication documentation](../node.js/authentication#xsuaa-setup).

### Integration Tests

`cds bind` can be handy for testing with real cloud services in your CI/CD pipeline.

Configure your required bindings for testing and save them to your project's _package.json_ file for your tests' profile:

```sh
cds bind -2 integration-test-hana -o package.json -4 integration-test
```

No credentials are saved!

In your CI/CD pipeline you can resolve the bindings and inject them into the test commands:

```sh
# Login
cf auth $USER $PASSWORD
# Optional if your bindings have org and space removed to be agnostic
cf target -o $ORG -s $SPACE

# Set profile
export CDS_ENV=integration-test  # [!code highlight]

# Set resolved bindings
export cds_requires="$(cds env get requires --resolve-bindings)"  # [!code highlight]

# Run tests
npm run integration-test  # [!code highlight]
```

Some comments to the previous snippet:
- With `CDS_ENV` you specify the [configuration profile](../node.js/cds-env#profiles) for the test, where you previously put the service binding configuration.
- [`cds env get requires`](../node.js/cds-env#services) prints the `requires` section of the configuration as a JSON string. Through `--resolve-bindings`, it includes the credentials of the service bindings from the cloud. To make the credentials available for all subsequent `cds` commands and the tests, the `requires` JSON string is put into the `cds_requires` script variable.
- In `npm run integration-test` any test code can run, for example, [`cds.test`](../node.js/cds-test).






# CDS Design Time APIs

This guide is about programmatic CDS design-time APIs.

## Install `@sap/cds-dk`

The design-time APIs are provided with package `@sap/cds-dk` which needs to be installed locally in your project:

```sh
npm add @sap/cds-dk
```

That given, you can use the APIs in your project like this:
```js
const cds = require('@sap/cds-dk')
cds.import(...)
```



<br>
<IndexList :pages='pages' />





# Plugins for `cds add`{#cds-add}

`cds add` commands add project configuration to your CAP project.

## Built-in

Many plugins are already part of `@sap/cds-dk`, and all are implemented using the public APIs documented here.
They provide you with a large set of standard features that support CAP's grow-as-you-go approach.

[See the list of built-in `add` plugins](../cds-cli#cds-add)

## Create a Plugin from Scratch

CAP provides APIs to create your own `cds add` plugins. In addition, we provide you with utility functions for common tasks, to easily replicate the behavior of built-in commands.

### Example: `cds add postgres`

In the following, we show you how to implement a `cds add` plugin for PostgreSQL support.

Our `cds add postgres` will:

1. Register with `cds-dk`
2. Add a Dockerfile to start a PostgreSQL instance for development
3. Integrate with `cds add mta` for [Cloud Foundry](../../guides/deployment/to-cf) deployment
4. Integrate with `cds add helm` for [Kyma](../../guides/deployment/to-kyma) deployment
5. Integrate with `cds help`

Starting with <span class="list-item">1</span>, register the plugin:

::: code-group
```js [cds-plugin.js]
cds.add?.register?.('postgres', require('lib/add')) // ...or inline:
cds.add?.register?.('postgres', class extends cds.add.Plugin {})
:::

In our example, we'll create a file _lib/add.js_:

::: code-group
```js [lib/add.js]
const cds = require('@sap/cds')

module.exports = class extends cds.add.Plugin {

}
```
:::

For step <span class="list-item">2</span> we need to implement the `run` method. Here we add all configuration that doesn't need integration with other plugins. In our example, we use this method to add a Docker configuration to the project to start the PostgreSQL instance locally:

::: code-group
```js [lib/add.js]
const cds = require('@sap/cds-dk') //> load from cds-dk
const { write, path } = cds.utils, { join } = path // [!code ++]

module.exports = class extends cds.add.Plugin {
  async run() { // [!code ++]
    const pg = join(__dirname, 'add/pg.yaml') // [!code ++]
    await copy(pg).to('pg.yaml') //> 'to' is relative to cds.root  [!code ++]
  } // [!code ++]
}
```
```yaml [lib/add/pg.yaml] {.added}
services: # [!code ++]
  db: # [!code ++]
    image: postgres:alpine # [!code ++]
    environment: { POSTGRES_PASSWORD: postgres } # [!code ++]
    ports: [ '5432:5432' ] # [!code ++]
    restart: always # [!code ++]
```
:::

Step <span class="list-item">3</span> requires us to integrate with another `cds add` command. Namely, we want `cds add mta` to include PostgreSQL configuration when generating the _mta.yaml_ deployment descriptor for Cloud Foundry. Vice versa, `cds add postgres` should augment the _mta.yaml_ if already present.

In this case, we can use the `combine` method, which is executed when any `cds add` command is run. This mechanism allows us to plug in accordingly.

We create an _mta.yaml.hbs_ file to use as a template. The _.hbs_ file also allows dynamic replacements using the [Mustache](https://mustache.github.io/mustache.5.html) syntax.

Using the `merge` helper provided by the `cds.add` API we can define semantics to merge this template into the project's `mta.yaml`:

::: code-group
```js [lib/add.js]
const cds = require('@sap/cds-dk') //> load from cds-dk
const { write, path } = cds.utils, { join } = path
const { readProject, merge, registries } = cds.add // [!code ++]
const { srv4 } = registries.mta // [!code ++]

module.exports = class extends cds.add.Plugin {
  async run() {
    const pg = join(__dirname, 'pg.yaml')
    await copy(pg).to('pg.yaml')
  }
  async combine() { // [!code ++]
    const project = readProject() // [!code ++]
    const { hasMta, srvPath } = project // [!code ++]
    if (hasMta) { // [!code ++]
      const srv = srv4(srvPath) // Node.js or Java server module  [!code ++]
      const postgres = { in: 'resources', // [!code ++]
        where: { 'parameters.service': 'postgresql-db' } // [!code ++]
      } // [!code ++]
      const postgresDeployer = { in: 'modules', // [!code ++]
        where: { type: 'nodejs', path: 'gen/pg' } // [!code ++]
      } // [!code ++]
      await merge(__dirname, 'add/mta.yml.hbs').into('mta.yaml', { // [!code ++]
        project, // for Mustache replacements  [!code ++]
        additions: [srv, postgres, postgresDeployer], // [!code ++]
        relationships: [{ // [!code ++]
            insert: [postgres, 'name'], // [!code ++]
            into: [srv, 'requires', 'name'] // [!code ++]
        }, { // [!code ++]
          insert: [postgres, 'name'], // [!code ++]
          into: [postgresDeployer, 'requires', 'name'] // [!code ++]
        }] // [!code ++]
      }) // [!code ++]
    } // [!code ++]
    // if (hasHelm) {// [!code ++]
    //  ... // [!code ++]
    // if (hasMultitenancy) {// [!code ++]
    //  ... // [!code ++]
  } // [!code ++]
}
```
```yaml [lib/add/mta.yaml.hbs]
modules: # [!code ++]
  - name: {{appName}}-srv # [!code ++]
    type: {{language}} # [!code ++]
    path: {{& srvPath}} # [!code ++]
    requires: # [!code ++]
      - name: {{appName}}-postgres # [!code ++]
  - name: {{appName}}-postgres-deployer # [!code ++]
    type: nodejs # [!code ++]
    path: gen/pg # [!code ++]
    parameters: # [!code ++]
      buildpack: nodejs_buildpack # [!code ++]
      no-route: true # [!code ++]
      no-start: true # [!code ++]
      tasks: # [!code ++]
        - name: deploy-to-postgresql # [!code ++]
          command: npm start # [!code ++]
    requires: # [!code ++]
      - name: {{appName}}-postgres # [!code ++]
resources: # [!code ++]
  - name: {{appName}}-postgres # [!code ++]
    type: org.cloudfoundry.managed-service # [!code ++]
    parameters: # [!code ++]
      service: postgresql-db # [!code ++]
      service-plan: development # [!code ++]
```
:::

Step <span class="list-item">4</span> integrates with `cds add helm`:

::: code-group
```js [lib/add.js]
const cds = require('@sap/cds-dk') //> load from cds-dk
const { copy, path } = cds.utils, { join } = path
const { readProject, merge, registries } = cds.add
const { srv4 } = registries.mta

module.exports = class extends cds.add.Plugin {
  async run() {
    const pg = join(__dirname, 'pg.yaml')
    await copy(pg).to('pg.yaml')
  }
  async combine() {
    const project = readProject()
    const { hasMta, hasHelm, srvPath } = project // [!code ++]
    const { hasMta, srvPath } = project // [!code --]
    if (hasMta) {
      ...
    }
    if (hasHelm) { // [!code ++]
      await merge(__dirname, 'add/values.yaml.hbs')
        .into('chart/values.yaml', { with: project }) // [!code ++]
    } // [!code ++]
  }
}
```
```yaml [lib/files/values.yaml.hbs]
srv: # [!code ++]
  bindings: # [!code ++]
    db: # [!code ++]
      serviceInstanceName: postgres # [!code ++]
postgres-deployer: # [!code ++]
  image: # [!code ++]
    repository: <your-container-registry>/{{appName}}-postgres-deployer # [!code ++]
    tag: latest # [!code ++]
  bindings: # [!code ++]
    postgres: # [!code ++]
      serviceInstanceName: postgres # [!code ++]
postgres: # [!code ++]
  serviceOfferingName: postgres # [!code ++]
  servicePlanName: default # [!code ++]
```
:::

::: tip Common integrations
Typically integrations are for deployment descriptors (`cds add mta` and `cds add helm`), security descriptors (`cds add xsuaa`), or changes that might impact your plugin configuration (`cds add multitenancy`).
:::

For step <span class="list-item">5</span> we'll add some command-specific options to let users override the output path for the `pg.yaml` file when running `cds add postgres --out <dir>`:

::: code-group
```js [lib/add.js]
const cds = require('@sap/cds-dk') //> load from cds-dk
const { copy, path } = cds.utils, { join } = path

module.exports = class extends cds.add.Plugin {
  options() { // [!code ++]
    return { // [!code ++]
      'out': { // [!code ++]
        type: 'string', // [!code ++]
        short: 'o', // [!code ++]
        help: 'The output directory for the pg.yaml file.', // [!code ++]
      } // [!code ++]
    } // [!code ++]
  } // [!code ++]

  async run() {
    const pg = join(__dirname, 'pg.yaml')
    await copy(pg).to('pg.yaml') //> 'to' is relative to cds.root // [!code --]
    await copy(pg).to(cds.cli.options.out, 'pg.yaml') //> 'to' is relative to cds.root  [!code ++]
  }
  async combine() {
    /* ... */
  }
}
```
:::

#### Call `cds add` for an NPM package <beta />

Similar to `npx -p`, you can use the `--package/-p` option to directly install a package from an *npm* registry before running the command.
This lets you invoke `cds add` for CDS plugins easily with a single command:

```sh
cds add my-facet -p @cap-js-community/example
```

::: details Install directly from your GitHub branch

 For example, if your plugin's code is in `https://github.com/cap-js-community/example` on branch `cds-add` and registers the  command `cds add my-facet`, then doing an integration test of your plugin with `@sap/cds-dk` in a single command:

```sh
cds add my-facet -p @cap-js-community/example@git+https://github.com/cap-js-community/example#cds-add
```

:::


## Plugin API

Find here a complete overview of public `cds add` APIs.

### `register(name, impl)` {.method}

Register a plugin for `cds add` by providing a name and plugin implementation:

::: code-group
```js [cds-plugin.js]
/* ... */

cds.add?.register?.('postgres',
  class extends cds.add.Plugin {
    async run() { /* ... */ }
    async combine() { /* ... */ }
  }
)
```
:::

...or use the standard Node.js `require` mechanism to load  it from elsewhere:
```js
cds.add?.register?.('postgres', require('./lib/add') )
```




### `run()` {.method}

This method is invoked when `cds add` is run for your plugin. In here, do any modifications that are not depending on other plugins and must be run once only.

```js
async run() { // [!code focus]
  const { copy, path } = cds.utils, { mvn, readProject } = cds.add // [!code focus]
  await copy (path.join(__dirname, 'files/pg.yaml')).to('pg.yaml') // [!code focus]
  const { isJava } = readProject() // [!code focus]
  if (isJava) await mvn.add('postgres') // [!code focus]
}
```

> In contrast to `combine`, `run` is not invoked when other `cds add` commands are run.

### `combine()` {.method}

This method is invoked, when `cds add` is run for other plugins. In here, do any modifications with dependencies on other plugins.

These adjustments typically include enhancing the _mta.yaml_ for Cloud Foundry or _values.yaml_ for Kyma, or adding roles to an _xs-security.json_.

```js
async combine() {
  const { hasMta, hasXsuaa, hasHelm } = readProject()
  if (hasMta)   { /* adjust mta.yaml */ }
  if (hasHelm)  { /* adjust values.yaml */ }
  if (hasXsuaa) { /* adjust xs-security.json */  }
}
```

### `options()` {.method}

The `options` method allows to specify custom options for your plugin:
```js
options() {
  return {
    'out': {
      type: 'string',
      short: 'o',
      help: 'The output directory. By default the application root.',
    }
  }
}
```

We follow the Node.js [`util.parseArgs`](https://nodejs.org/api/util.html#utilparseargsconfig) structure, with an additional `help` field to provide manual text for `cds add help`.

::: details Run `cds add help` to validate...

You should now see output similar to this:

<pre class="log" cont>
<span class="cwd">$</span> <span class="cmd">cds</span> <span class="args">help</span> <span class="option">add</span>
SYNOPSIS
    ···
OPTIONS
    ···
FEATURE OPTIONS
    ···
    <em>cds add postgres</em>

      --out | -o

        The output directory. By default the application root.

</pre>

:::

::: warning See if your command can do without custom options
`cds add` commands should come with carefully chosen defaults and avoid offloading the decision-making to the end-user.
:::

### `requires()` {.method}

The `requires` function allows to specify other plugins that need to be run as a prerequisite:
```js
requires() {
  return ['xsuaa'] //> runs 'cds add xsuaa' before plugin is run
}
```

::: warning Use this feature sparingly
Having to specify hard-wired dependencies could point to a lack of coherence in the plugin.
:::

## Utilities API

### `readProject()` {.method}

This method lets you retrieve a project descriptor for the productive environment.

```js
const { isJava, hasMta, hasPostgres } = cds.add.readProject()
```
Any plugin provided by `cds add` can be availability-checked. The readable properties are prefixed by `has` or `is`, in addition to being converted to camel-case. A few examples:
| facet | properties |
| ----- | --- |
| `java` | `hasJava` or `isJava` |
| `hana` | `hasHana` or `isHana` |
| `html5-repo` | `hasHtml5Repo` or `isHtml5Repo` |
| ... | ... |

### `merge(from).into(file, o?)` {.method}

CAP provides a uniform convenience API to simplify merging operations on the most typical configuration formats — JSON and YAML files.

::: tip For YAML in particular, comments are preserved
`cds.add.merge` can perform AST-level merging operations. This means, even comments in both your provided template and the user YAML are preserved.
:::

A large number of merging operations can be done without specifying additional semantics, but simply specifying `from` and `file`:

```js
const config = { cds: { requires: { db: 'postgres' } } }
cds.add.merge(config).into('package.json')
```

::: details Semantic-less mode merges and de-duplicates flat arrays

Consider this `source.json` and `target.json`:

<div class="cols-2">

<div>

```js
// source.json
{
  "my-plugin": {
    "x": "value",
    "z": ["a", "b"]
  }
}
```

</div>

<div>

```js
// target.json
{
  "my-plugin": {
    "y": "value",
    "z": ["b", "c"]
  }
}
```

</div>

</div>

A `cds.add.merge('source.json').into('target.json')` produces this result:

```js
// target.json
{
  "my-plugin": {
    "x": "value",  // [!code ++]
    "y": "value",
    "z": ["b", "c"]  // [!code --]
    "z": ["a", "b", "c"]  // [!code ++]
  }
}
```

:::

We can also specify options for more complex merging semantics or Mustache replacements:

```js
const { merge, readProject, registries } = cds.add

// Generic variants for maps and flat arrays
await merge(__dirname, 'lib/add/package-plugin.json').into('package.json')
await merge({ some: 'variable' }).into('package.json')

// With Mustache replacements
const project = readProject()
await merge(__dirname, 'lib/add/package.json.hbs').into('package.json', {
  with: project
})

// With Mustache replacements and semantics for nested arrays
const srv = registries.mta.srv4(srvPath)
const postgres = {
  in: 'resources',
  where: { 'parameters.service': 'postgresql-db' }
}
const postgresDeployer = {
  in: 'modules',
  where: { type: 'nodejs', path: 'gen/pg' }
}
await merge(__dirname, 'lib/add/mta.yml.hbs').into('mta.yaml', {
  with: project,
  additions: [srv, postgres, postgresDeployer],
  relationships: [{
    insert: [postgres, 'name'],
    into: [srv, 'requires', 'name']
  }, {
    insert: [postgres, 'name'],
    into: [postgresDeployer, 'requires', 'name']
  }]
})
```

### `.registries` {.property}

`cds.add` provides a default registry of common elements in configuration files, simplifying the merging semantics specification:

```js
const { srv4, approuter } = cds.add.registries.mta
```

...and use it like this:

```js
const project = readProject()
const { hasMta, srvPath } = project

if (hasMta) {
  const srv = registries.mta.srv4(srvPath)
  const postgres = {
    in: 'resources',
    where: { 'parameters.service': 'postgresql-db' }
  }
  await merge(__dirname, 'lib/add/mta.yml.hbs').into('mta.yaml', {
    project,
    additions: [srv, postgres, postgresDeployer],
    relationships: [
      ...
    ]
  })
}
```


### `mvn.add()` {.method}

For better Java support, plugins can easily invoke `mvn com.sap.cds:cds-maven-plugin:add` goals using `mvn.add`:

```js
async run() {
  const { isJava } = readProject()
  const { mvn } = cds.add
  if (isJava) await mvn.add('postgres')
}
```

## Checklist for Production

Key to the success of your `cds add` plugin is seamless integration with other technologies used in the target projects. As CAP supports many technologies out of the box, consider the following when reasoning about the scope of your minimum viable product:

- Single- and Multitenancy
- Node.js and Java runtimes
- Cloud Foundry (via MTA)
- Kyma (via Helm)
- App Router
- Authentication

## Best Practices

Adhere to established best practices in CAP-provided plugins to ensure your plugin meets user expectations.

### Consider `cds add` vs `cds build` {.good}

In contrast to `cds build`, `cds add` is concerned with source files outside of your _gen_ folder. Common examples are deployment descriptors such as _mta.yaml_ for Cloud Foundry or _values.yaml_ for Kyma deployment. Unlike generated files, those are usually checked in to your version control system.

### Don't do too much work in `cds add` {.bad}

If your `cds add` plugin creates or modifies a large number of files, this can be incidental for high component coupling. Check if configuration for your service can be simplified and provide sensible defaults. Consider generating the files in a `cds build` plugin instead.

### Embrace out-of-the-box{.good}

From a consumer point of view, your plugin is integrated by adding it to the _package.json_ `dependencies` and provides sensible default configuration without further modification.

### Embrace grow-as-you-go and separate concerns {.good}

A strength of `cds add` is the gradual increase in project complexity. All-in-the-box templates pose the danger of bringing maintainability and cost overhead by adding stuff you might not need. Decrease dependencies between plugins wherever possible.



# CDS Import API

## cds.import() {.method}

As an application developer, you have the option to convert OData specification (EDMX / XML), OpenAPI specification (JSON) or AsyncAPI specification (JSON) files to CSN from JavaScript API as an alternative to the `cds import` command.

> `cds.import` is available in the CDS development tool kit *version 4.3.1* onwards .

The API signature looks like this:

```js
const csn = await cds.import(file, options)
```

##### Arguments:

* `file` &mdash; Specify the path to a single input file to be converted for CSN.
* `options` &mdash; `cds.import()` support the following `options`:

#### <span>options</span>.keepNamespace

_This option is only applicable for OData conversion._ <br>

| Value   | Description                                        |
|---------|----------------------------------------------------|
| `true`  | Keep the original namespace from the EDMX content. |
| `false` | Take the filename as namespace.                    |

> If the option is not defined, then the CSN is generated with the namespace defined as EDMX filename.
<br>

#### <span>options</span>.includeNamespaces

_This option is only applicable for OData conversion._ <br>
It accepts a list of namespaces whose attributes are to be retained in the CSN / CDS file. To include all the namespaces present in the EDMX pass "*".

> For OData V2  EDMX attributes with the namespace "sap" & "m" are captured by default.

<br>

## cds.import.from.edmx() {.method}

This API can be used to convert the OData specification file (EDMX / XML) into CSN.
The API signature looks like this:
```js
const csn = await cds.import.from.edmx(ODATA_EDMX_file, options)
```


<br>

## cds.import.from.openapi() {.method}

This API can be used to convert the OpenAPI specification file (JSON) into CSN.
The API signature looks like this:
```js
const csn = await cds.import.from.openapi(OpenAPI_JSON_file)
```
<br>

[Learn more about OpenAPI to OData Mapping.](#openapi-to-cds-odata-csn-conversion-mapping){.learn-more}

## cds.import.from.asyncapi() {.method}

This API can be used to convert the AsyncAPI specification file (JSON) into CSN.
The API signature looks like this:
```js
const csn = await cds.import.from.asyncapi(AsyncAPI_JSON_file)
```
<br>

Example:

```js
const cds = require('@sap/cds-dk')
module.exports = async (srv) => {
  const csns = await Promise.all([
    // for odata
    cds.import('./odata_sample.edmx', { includeNamespaces: 'sap,c4c', keepNamespace: true }),
    // for openapi
    cds.import('./openapi_sample.json'),
    // for asyncapi
    cds.import('./asyncapi_sample.json'),
    // for odata
    cds.import.from.edmx('./odata_sample.xml', { includeNamespaces: '*', keepNamespace: false }),
    // for openapi
    cds.import.from.openapi('./openapi_sample.json')
    // for asyncapi
    cds.import.from.asyncapi('./asyncapi_sample.json')
  ]);

  for (let i = 0; i < csns.length; i++) {
    let json = cds.compile.to.json (csns[i])
    console.log (json)
  }
}
```



## OData Type Mappings

The following mapping is used during the import of an external service API, see [Using Services](../../guides/using-services#external-service-api). In addition, the [Mapping of CDS Types](../../advanced/odata#type-mapping) shows import-related mappings.

| OData                                                  | CDS Type                                                                     |
|--------------------------------------------------------|------------------------------------------------------------------------------|
| _Edm.Single_                                           | `cds.Double` + `@odata.Type: 'Edm.Single'`                                   |
| _Edm.Byte_                                             | `cds.Integer` + `@odata.Type: 'Edm.Byte'`                                    |
| _Edm.SByte_                                            | `cds.Integer` + `@odata.Type: 'Edm.SByte'`                                   |
| _Edm.Stream_                                           | `cds.LargeBinary` + `@odata.Type: 'Edm.Stream'`                              |
| _Edm.DateTimeOffset<br>Precision : Microsecond_        | `cds.Timestamp` + `@odata.Type:'Edm.DateTimeOffset'` + `@odata.Precision:<>` |
| _Edm.DateTimeOffset<br>Precision : Second_             | `cds.DateTime` + `@odata.Type:'Edm.DateTimeOffset'` + `@odata.Precision:0`   |
| _Edm.DateTime<br>Precision : Microsecond_ <sup>1</sup> | `cds.Timestamp` + `@odata.Type:'Edm.DateTime'` + `@odata.Precision:<>`       |
| _Edm.DateTime<br>Precision : Second_ <sup>1</sup>      | `cds.DateTime` + `@odata.Type:'Edm.DateTime'` + `@odata.Precision:0`         |

<sup>1</sup> only OData V2

## OpenAPI to CDS (OData CSN) Conversion Mapping

| **OpenAPI**                        | **OData Equivalent**                                   |
|---------------------------------------------|--------------------------------------------------------------|
| `info.title`                                 | `serviceName`, `@Core.Description`                           |
| `info.version`                               | `@Core.SchemaVersion`                                       |
| `info.description`                           | `@Core.LongDescription`                                     |
| `paths.{path}.{method}`                      | `function` (GET) or `action` (others)                        |
| `tags[0]`                                    | `@Common.Label`                                              |
| `summary` / `description`                    | `@Core.Description`, `@Core.LongDescription`                |
| `parameters[].in`                            | `@openapi.in`                                                |
| `parameters[].name`                          | Transformed param name + `@openapi.name` if needed           |
| `parameters[].required`                      | `@openapi.required`                                          |
| `parameters[].style`, `explode`, `allowReserved` | `@openapi.style`, `@openapi.explode`, `@openapi.allowReserved` |
| `parameters[].default`                       | `default: { val: ... }`                                      |
| `parameters[].description`                   | `@description`                                               |
| `requestBody.content.application/json.schema` | `params.body`                                               |
| `requestBody.$ref`                           | Dereferenced and used                                       |
| `responses["2XX"].content.application/json`  | `returns`                                                    |
| `$ref`                                       | `type` or `includes`                                         |
| `components.schemas` / `definitions`         | Named `types`                                                |
| `enum`                                       | `enum`, `@assert.range`                                      |
| `format: date/time/uuid/binary`              | `cds.Date`, `cds.Time`, `cds.Timestamp`, `cds.UUID`, etc.    |
| `pattern`                                    | `@assert.format`                                             |
| `allOf`, `anyOf`, `oneOf`                    | `@openapi.allOf`, `@openapi.anyOf`, `@openapi.oneOf`         |
| `example` / `examples[0]`                    | `@Core.Example.Value`                                        |
| `type: object` with `properties`             | `elements`                                                   |
| `required` (on properties)                   | `@mandatory`                                                 |



# CAP Plugins & Enhancements

Following is a curated list of plugins that are available for the SAP Cloud Application Programming Model (CAP) which provide integration with SAP BTP services and technologies, or other SAP products.

::: tip Maintained by CAP and SAP
The `@cap-js`-scoped plugins are created and maintained in close collaboration and shared ownership of CAP development teams and other SAP development teams.
:::





## As _cds-plugins_ for Node.js

For Node.js all these plugins are implemented using the [`cds-plugin`](../node.js/cds-plugins) technique, which features minimalistic setup and **plug & play** experience. Usually usage is as simple as that, like for the [Audit Logging](../guides/data-privacy/audit-logging) plugin:

1. Add the plugin:

   ```sh
   npm add @cap-js/audit-logging
   ```

2. Add annotations to your models:

   ```cds
   annotate Customer with @PersonalData ...;
   ```

3. Test-drive locally:

   ```sh
   cds watch
   ```
   > → audit logs are written to console in dev mode.

4. Bind the platform service.

   > → audit logs are written to Audit Log service in production.

## As Plugin for CAP Java

The [CAP Java plugin technique](../java/building-plugins) makes use of _jar_-files which are distributed as Maven packages.
By adding an additional Maven dependency to the project, the plugin automatically adds functionality or extensions to the CDS model.
For [Audit Logging V2](../java/auditlog#handler-v2) it looks like this:

1. Add the Maven dependency (in _srv/pom.xml_):
   ```xml
   <dependency>
     <groupId>com.sap.cds</groupId>
     <artifactId>cds-feature-auditlog-v2</artifactId>
     <scope>runtime</scope>
   </dependency>
   ```
2. Add annotations to your model:

   ```cds
   annotate Customer with @PersonalData ...;
   ```
   > → audit logs are written to console in dev mode.

3. Bind the platform service.

   > → audit logs are written to SAP Audit Log service.

## Support for Plugins

Use one of the support channels below, in this order:

1. Open an issue in the **plugin's GitHub repository**.

   Find the link in the plugin list below (if the plugin has a public repository).

2. Ask a question in the [SAP community](/resources/ask-question-vscode).

   This applies to all plugins, especially those without public repositories. Or if you're not quite sure that the problem is caused by the plugin.

3. Open incidents through [SAP Support Portal](/resources/#support-channels).

   Note that plugins by external parties, like the [CAP JS](https://github.com/cap-js-community/) community, are out of scope for incidents.

:::tip Public channels help everyone.
Prefer public repositories and issues over private/internal ones, as they help everyone using CAP to find solutions quickly.
:::


<div id="internal-support" />
<Fragment target="#internal-support">

:::details For SAP-internal information

- Be aware to not post internal information publicly.
- Use [cap/issues](https://github.tools.sap/cap/issues) or the internal [Stack@SAP](https://sap.stackenterprise.co/) only as a fallback option to share internal information.

[Find here all internal resources.](/resources/#internal-resources){.learn-more}
:::

</Fragment>

<br>

:::info Complete list of plugins
As CAP is blessed with an active community, there are many useful plugins available created by the community. Have a look at the [CAP JS community](https://github.com/cap-js-community) to browse all available plugins. A broader collection of plugins can be found at [bestofcapjs.org](https://bestofcapjs.org/)
:::

## OData V2 Adapter {#odata-v2-proxy}

OData V2 has been deprecated. Use the plugin only if you need to support existing UIs or if you need to use specific controls that don't work with V4 **yet** like, tree tables (sap.ui.table.TreeTable). The CDS OData V2 Adapter is a protocol adapter that allows you to expose your services as OData V2 services. For Node.js, this is provided through the [@cap-js-community/odata-v2-adapter](https://www.npmjs.com/package/@cap-js-community/odata-v2-adapter) plugin, which converts incoming OData V2 requests to CDS OData V4 service calls and responses back. For Java, this is built in.

Available for:

[![Node.js](../assets/logos/nodejs.svg 'Link to the plugins repository.'){}](https://github.com/cap-js-community/odata-v2-adapter#readme)
[![Java](../assets/logos/java.svg 'Link to the documentation of the OData feature.'){}](../java/migration#v2adapter)

See also [Cookbook > Protocols/APIs > OData APIs > V2 Support](../advanced/odata#v2-support) {.learn-more}

## WebSocket

Exposes a WebSocket protocol via WebSocket standard or Socket.IO for CDS services.

```cds
@protocol: 'websocket'
service ChatService {
  function message(text: String) returns String;
  event received {
    text: String;
  }
}
```

Available for:

[![Node.js](../assets/logos/nodejs.svg 'Link to the plugins repository.'){}](https://github.com/cap-js-community/websocket#readme)

## UI5 Dev Server


The UI5 Dev Server is a CDS server plugin that enables the integration of UI5 (UI5 freestyle or Fiori elements) tooling-based projects into the CDS server via the UI5 tooling express middlewares. It allows to serve dynamic UI5 resources, including TypeScript implementations for UI5 controls, which get transpiled to JavaScript by the plugin automatically.

Available for:

[![Node.js](../assets/logos/nodejs.svg 'Link to the plugins repository.'){}](https://github.com/ui5-community/ui5-ecosystem-showcase/tree/main/packages/cds-plugin-ui5#cds-plugin-ui5)

## GraphQL Adapter

The GraphQL Adapter is a protocol adapter that generically generates a GraphQL schema for the models of an application and serves an endpoint that allows you to query your services using the [GraphQL](https://graphql.org) query language. All you need to do is to add the `@graphql` annotation to your service definitions like so:

```cds
@graphql service MyService { ... }
```

Available for:

[![Node.js](../assets/logos/nodejs.svg 'Link to the plugins repository.'){}](https://github.com/cap-js/graphql#readme)



## Attachments


The Attachments plugin provides out-of-the-box support for attachment handling. On Node.js, attachments are stored on AWS S/3 through [SAP BTP's Object Store service](https://discovery-center.cloud.sap/serviceCatalog/object-store), whereas Java stores attachments on the SAP HANA database. To use it, simply add a composition of the predefined aspect `Attachments` like so:

```cds
using { Attachments } from '@cap-js/attachments';
entity Incidents { ...
  attachments: Composition of many Attachments // [!code focus]
}
```

That's all we need to automatically add an interactive list of attachments to your Fiori UIs as shown below.

![Screenshot showing the Attachments Table in a fiori app](assets/index/attachments-table.png)

Features:

- Pre-defined type `Attachment` to use in entity definitions
- Automatic handling of all upload and download operations
- Automatic malware scanning for uploaded files
- (Automatic) Fiori Annotations for Upload Controls
- Streaming and piping to avoid memory overloads
- Support for different storage backends
- Support for Multitenancy


Available for:

[![Node.js logo](../assets/logos/nodejs.svg 'Link to the repository for cap-js attachments.'){}](https://github.com/cap-js/attachments#readme)
[![Java](../assets/logos/java.svg 'Link to the repository for cap-java-attachments.'){}](https://github.com/cap-java/cds-feature-attachments#readme)



## SAP Document Management Service {#sdm}
{#@cap-js/sdm}

The SAP Document Management Service  plugin lets you easily store attachments (documents) in an [SAP Document Management service Repository](https://help.sap.com/docs/document-management-service).

To use this CAP-level integration, extend a domain model by using the predefined aspect called Attachments:

```cds
extend my.Incidents with {
  attachments: Composition of many Attachments
}
```

![Screenshot showing the Attachments Table in a Fiori app](assets/index/sdm-table.png)

Features:

- **Pre-defined Type Attachment for Entity Definitions**: Seamlessly integrate attachments into your entity definitions with our pre-defined type, simplifying the process of linking files.
- **Automatic Management of File Operations**: Effortlessly manage file operations, including upload, view, download, delete, and rename functions, with built-in automation. This ensures a smooth and user-friendly experience.
- **Automated Malware Scanning for Uploaded Files**: Enhance security by automatically scanning all uploaded files for malware, ensuring the integrity and safety of your data.
- **Automatic Fiori Annotations for Upload Controls**: Streamlined user interactions with automatic SAP Fiori annotations that enhance upload controls, providing a more intuitive and seamless user experience.
- **Support for SAP Document Management Service-Hosted Cloud Repository**: Leverage the robust capabilities of the SAP Document Management service-hosted cloud repository to store and manage your documents efficiently.
- **Support for Third-Party CMIS-Compliant Repositories**: Integrate with third-party repositories that adhere to the Content Management Interoperability Services (CMIS) standard, offering flexibility and compatibility with various document management systems.
- **Intrinsic Multitenancy Handling**: Benefit from built-in multi-tenancy support, allowing for efficient management of multiple tenants without additional configuration.

Outlook:
- **Support for Versioned Repository**: Ensure better document control and historical tracking with native support for versioned repositories, enabling you to manage document revisions effectively.
- **Native Document Management Features with SAP Document Management Service**: Access a wide array of native document management features provided by the SAP Document Management service, including metadata management, advanced search capabilities, and audit trails. For more information, see [SAP Document Management Service](https://help.sap.com/docs/document-management-service/sap-document-management-service/what-is-document-management-service).

Available for:

[![Node.js logo](../assets/logos/nodejs.svg){}](https://github.com/cap-js/sdm/#readme)
[![Java](../assets/logos/java.svg){}](https://github.com/cap-java/sdm/#readme)



## Audit Logging


The new Audit Log plugin provides out-of-the box support for logging personal data-related operations with the [SAP Audit Log Service](https://discovery-center.cloud.sap/serviceCatalog/audit-log-service). All we need is annotations of respective entities and fields like that:

```cds
annotate my.Customers with @PersonalData : {
  DataSubjectRole : 'Customer',
  EntitySemantics : 'DataSubject'
} {
  ID           @PersonalData.FieldSemantics: 'DataSubjectID';
  name         @PersonalData.IsPotentiallyPersonal;
  email        @PersonalData.IsPotentiallyPersonal;
  creditCardNo @PersonalData.IsPotentiallySensitive;
}
```

Features:

- Simple, Annotation-based usage → automatically logging personal data-related events
- CAP Services-based programmatic client API → simple, backend-agnostic
- Logging to console in development → fast turnarounds, minimized costs
- Logging to [SAP Audit Log Service](https://discovery-center.cloud.sap/serviceCatalog/audit-log-service) in production
- Transactional Outbox → maximised scalability and resilience

Available for:

[![Node.js logo](../assets/logos/nodejs.svg 'Link to the plugins repository.'){}](https://github.com/cap-js/audit-logging#readme)
![Java](../assets/logos/java.svg){}

Learn more about audit logging in [Node.js](../guides/data-privacy/audit-logging) and in [Java](../java/auditlog) {.learn-more}


## Change Tracking


The Change Tracking plugin provides out-of-the box support for automated capturing, storing, and viewing of the change records of modeled entities. All we need is to add @changelog annotations to your models to indicate which entities and elements should be change-tracked.

```cds
annotate my.Incidents {
  customer @changelog: [customer.name];
  title    @changelog;
  status   @changelog;
}
```

![Change history table in an SAP Fiori UI.](assets/index/changes.png)

Available for:

[![Node.js](../assets/logos/nodejs.svg 'Link to the plugins repository.'){}](https://github.com/cap-js/change-tracking#readme)
[![Java](../assets/logos/java.svg 'Link to the documentation of the change-tracking feature.'){}](../java/change-tracking)


## Notifications


The Notifications plugin provides support for publishing business notifications in SAP Build WorkZone. The client is implemented as a CAP service, which gives us a very simple programmatic API:

```js
let alert = await cds.connect.to ('notifications')
await alert.notify({
   recipients: [ ...supporters ],
   title: `New incident created by ${customer.info}`,
   description: incident.title
})
```

Features:

- CAP Services-based programmatic client API → simple, backend-agnostic
- Logging to console in development → fast turnarounds, minimized costs
- Transactional Outbox → maximised scalability and resilience
- Notification templates with i18n support
- Automatic lifecycle management of notification templates


Available for:

[![Node.js](../assets/logos/nodejs.svg 'Link to the plugins repository.'){}](https://github.com/cap-js/notifications#readme)


## Telemetry


The Telemetry plugin provides observability features such as tracing and metrics, including [automatic OpenTelemetry instrumentation](https://opentelemetry.io/docs/concepts/instrumentation/automatic).
By enabling the plugin in your project, various kinds of telemetry data will be automatically collected. For Node.js, you will find telemetry output written to the console as follows:

```txt
[odata] - GET /odata/v4/processor/Incidents
[telemetry] - elapsed times:
  0.00 → 2.85 = 2.85 ms  GET /odata/v4/processor/Incidents
  0.47 → 1.24 = 0.76 ms    ProcessorService - READ ProcessorService.Incidents
  0.78 → 1.17 = 0.38 ms      db - READ ProcessorService.Incidents
  0.97 → 1.06 = 0.09 ms        @cap-js/sqlite - prepare SELECT json_object('ID',ID,'createdAt',createdAt,'creat…
  1.10 → 1.13 = 0.03 ms        @cap-js/sqlite - stmt.all SELECT json_object('ID',ID,'createdAt',createdAt,'crea…
  1.27 → 1.88 = 0.61 ms    ProcessorService - READ ProcessorService.Incidents.drafts
  1.54 → 1.86 = 0.32 ms      db - READ ProcessorService.Incidents.drafts
  1.74 → 1.78 = 0.04 ms        @cap-js/sqlite - prepare SELECT json_object('ID',ID,'DraftAdministrativeData_Dra…
  1.81 → 1.85 = 0.04 ms        @cap-js/sqlite - stmt.all SELECT json_object('ID',ID,'DraftAdministrativeData_Dr…
```

Telemetry data can be exported to [SAP Cloud Logging](https://help.sap.com/docs/cloud-logging) and Dynatrace. Node.js additionally supports Jaeger.

Available for:

[![Node.js](../assets/logos/nodejs.svg 'Link to the plugins repository.'){}](https://github.com/cap-js/telemetry#readme)
[![Java](../assets/logos/java.svg 'Link to the documentation of the telemetry feature.'){}](../java/operating-applications/observability#open-telemetry)

## ORD (Open Resource Discovery)

This plugin enables generation of [Open Resource Discovery (ORD)](https://open-resource-discovery.github.io/specification/) documents for CAP based applications.

When you adopt ORD, your application gains a single entry point, known as the Service Provider Interface. This interface allows you to discover and gather relevant information or metadata. You can use this information to construct a static metadata catalog or to perform a detailed runtime inspection of your actual system landscapes.

![](./assets/index/ordCLI.png){ .mute-dark}

You can get the ORD document in multiple ways, see the readme of the plugin.

Available for:

[![Link to the repository for cap-js ORD](../assets/logos/nodejs.svg){}](https://github.com/cap-js/ord)


## CAP Operator for Kubernetes {#cap-operator-plugin}

The [CAP Operator](https://sap.github.io/cap-operator/) manages and automates the lifecycle operations involved in running multitenant CAP applications on Kubernetes (K8s) clusters. If you deploy an application using the CAP Operator, you must manually define the custom resources for the application in a helm chart, which needs time and deep knowledge of helm concepts.

This is where the CAP Operator **plugin** is very useful, as it provides an easy way to generate such a helm chart, which can be easily modified.

Available for:

[![Node.js logo](../assets/logos/nodejs.svg){}](https://github.com/cap-js/cap-operator-plugin#readme)
![Java logo](../assets/logos/java.svg){}


## SAP Cloud Application Event Hub {#event-hub}

The plugin provides out-of-the-box support for consuming events from [SAP Cloud Application Event Hub](https://discovery-center.cloud.sap/serviceCatalog/sap-event-hub) -- for example emitted by SAP S/4HANA Cloud -- in stand-alone CAP applications.

```js
const S4Bupa = await cds.connect.to ('API_BUSINESS_PARTNER')
S4bupa.on ('BusinessPartner.Changed', msg => {...})
```

<div id="eh-plugin-mt" />
<Fragment target="#eh-plugin-mt">

For SAP-provided SaaS applications, the plugins not only provide support for receiving events from, but also publishing events to SAP Cloud Application Event Hub. <Internal />

</Fragment>

For more details, please see [Events and Messaging &rarr; Using SAP Cloud Application Event Hub](../guides/messaging/#sap-event-broker).

Available for:

[![Node.js logo](../assets/logos/nodejs.svg){}](https://github.com/cap-js/event-broker#readme)
[![Java logo](../assets/logos/java.svg){}](https://github.com/cap-java/cds-feature-event-hub#readme)


## SAP Integration Suite, Advanced Event Mesh <Beta /> 
{#advanced-event-mesh}

[SAP Integration Suite, advanced event mesh](https://www.sap.com/products/technology-platform/integration-suite/advanced-event-mesh.html) allows you to, amongst others, integrate non-SAP systems into your event-driven architecture.

Available for:

[![Node.js logo](../assets/logos/nodejs.svg){}](https://github.com/cap-js/advanced-event-mesh#readme)
[![Java logo](../assets/logos/java.svg){}](https://github.com/cap-java/cds-feature-advanced-event-mesh#readme)


## ABAP RFC

The  `@sap/cds-rfc` plugin allows to import the API of RFC-enabled function modules from
ABAP systems and to call these functions in your custom code.

Available for:

[![Node.js](../assets/logos/nodejs.svg 'Link to the plugin page.'){}](https://www.npmjs.com/package/@sap/cds-rfc)

<div id="rfc-plugin" />
<Fragment target="#rfc-plugin">

::: tip Use the plugin without a license <Internal />
At SAP, configure this NPM registry to consume the plugin without a commercial license:

```sh
npm set @sap-rfc:registry=https://int.repositories.cloud.sap/artifactory/api/npm/build-releases-npm
```

:::

</Fragment>

<div id="internal-plugins" />
<Fragment target="#internal-plugins">

## Deploy with Confidence <Internal />

Plugin to enable support for CAP Applications in [Deploy with Confidence (DwC)](https://pages.github.tools.sap/deploy-with-confidence/solar-system/documentation/) infrastructure.

DwC is a higher-level framework that aims to simplify development and lifecycle of mid-size or large scale cloud applications on SAP BTP.
It addresses all DevOps aspects from development to delivery of microservice based applications at a daily basis.

Features:

- Connects with DwC authentication and user propagation
- Supports DwC feature toggles
- Configures MTX Sidecar
- Integrates with tenant subscription and unsubscription events

Simple usage (_srv/pom.xml_):

```xml
<dependency>
 <groupId>com.sap.dwc</groupId>
 <artifactId>util-cap</artifactId>
 <version>2.8.0</version>
</dependency>
```

Available for:

![Java](../assets/logos/java.svg){style="height:3em; display:inline; margin:0 0.2em;}

[Read the guide about deployment with DwC.](../guides/deployment/dwc) {.learn-more}

</Fragment>

<div id="upcoming-plugins" />
<Fragment target="#upcoming-plugins">

## Apache Kafka <Beta />

This plugin provides out-of-the box support for publishing and consuming messages to and from Apache Kafka. While the APIs used by application developers stay the same for both Node.js and Java, you just need to bind a Kafka service, for example, like that in your `mta.yaml`:

```yaml
# ...
modules:
  - name: my-cap-app
    requires:
      - name: kafka
#...
resources:
  - name: kafka
    type: org.cloudfoundry.managed-service
    parameters:
      service: kafka
      service-plan: standard
# ...
```

Features:

- Configuration-free with respect to Kafka topics, based on defaults
- Customizable, for example to using multiple Kafka channels
- Intrinsic support for multitenancy

Available for:

![Node.js](../assets/logos/nodejs.svg){}
![Java](../assets/logos/java.svg){}

[Read the guide about messaging with Apache Kafka.](../guides/messaging/apache-kafka) {.learn-more}

## Security: AMS

The AMS plugins ensure `@requires` restrictions are compiled to corresponding AMP access policies in `cds build` and `cds deploy`, as well as resolving user roles with AMS service on incoming requests.

[Free & Open Source Notices](https://support.sap.com/content/dam/launchpad/en_us/osln/osln/67837800100900008826_20170821125934.pdf){.learn-more}

Available for:

[![Node.js](../assets/logos/nodejs.svg){style="height:2.5em; display:inline; margin:0 0.2em;}](https://github.wdf.sap.corp/CPSecurity/cloud-authorization-client-library-nodejs)
[![Java](../assets/logos/java.svg){style="height:3em; display:inline; margin:0 0.2em;}](/java/ams)

## Enterprise Search <Internal />

SAP HANA Enterprise Search is a robust search solution that enables searches across multiple business entities stored in HANA, providing both free-style and advanced search options. It supports search federation across applications and is already embedded in systems like S/4 and Datasphere. It uses optimized fuzzy search algorithms and supports various authorization concepts without requiring data replication. It is model-driven, with search behavior controlled by search models. The technical components include a generic search engine, embedded search services with application-specific logic, and a UI delivered as an SAP UI5 library for seamless integration into FLP, cFLP, and Workzone.

The [@sap/cds-plugin-enterprise-search](https://github.wdf.sap.corp/InA/cds-plugin-enterprise-search) is a build and server plugin, that enables you to define and consume Enterprise Search models. It requires an SAP HANA database. The definition of Search Models is done by annotating service-level entities with @EnterpriseSearch annotations.

```cds
  @EnterpriseSearch.model: true
  @EnterpriseSearch.resultItemKey: ['ID']
  @EnterpriseSearch.title: { titleField: 'title' }
  @EnterpriseSearch.modelName: 'Book'
  @EnterpriseSearch.modelNamePlural: 'Books'
  entity ListOfBooks as projection on Books{
    key ID,
    @EnterpriseSearch.freeStyleField: { importance: #HIGH, withAutoCompletion: true }
    @EnterpriseSearch.responseField.standard: { displayPosition: 1 }
    @Search.fuzzinessThreshold: 0.77
    @EnterpriseSearch.searchOptions: 'similarCalculationMode=substringsearch'
    title,
    @EnterpriseSearch.freeStyleField: { importance: #HIGH }
    @EnterpriseSearch.responseField.standard: { displayPosition: 2 }
    @Search.fuzzinessThreshold: 0.77
    @EnterpriseSearch.searchOptions: 'similarCalculationMode=substringsearch'
    @EnterpriseSearch.filteringFacet: {default, displayPosition: 3}
    author
  };
```

The plugin does the following:

- Automatically creates a search configuration at build. The search configuration is deployed as an hdi artifact.
- At runtime, the plugin creates a search service available at `/odata/v4/enterprise-search`

You can use the enterprise search through this endpoint. Examples:

- `/odata/v4/enterprise-search/$metadata`
- `/odata/v4/enterprise-search/$all?$top=10&$skip=0&whyfound=true&$count=true&$apply=filter(Search.search(query='wuthering heights'))`

The plugin also supports federation of search results from multiple apps. You can find more details on it in the [readme](https://github.wdf.sap.corp/InA/cds-plugin-enterprise-search#federation-of-search-results-from-different-apps){.learn-more}

[Watch a demo video.](https://video.sap.com/media/t/1_qigruvp4){.learn-more}
[Learn more about search annotations.](https://help.sap.com/docs/ABAP_PLATFORM_NEW/5d7d37af2a864fe7942178707914e3ec/6e6e6c71efb94268b1c02efd4e4eef0c.html?version=202310.000){.learn-more}
[Learn more about the search query language.](https://pages.github.tools.sap/hana-enterprise-search/hana-search-documentation/2024_QRC1/esh/query_language/){.learn-more}
[Free & Open Source Notices](https://support.sap.com/content/dam/launchpad/en_us/osln/osln/73555000100900007903_20240607064247.pdf){.learn-more}

Available for:

![Node.js logo](../assets/logos/nodejs.svg){}

</Fragment>

<div id="planned-plugins" />
<Fragment target="#planned-plugins">

## Analytics

### Embedded Analytics

The CDS Enterprise Analytics plugins provide out-of-the-box support for embedded analytics with SAP Analytics Cloud.
Define an analytical service as part of your CDS model and get an InA request
handler via the Java or Node.js runtime plugin.

```cds
@protocol: 'ina'
service FlightService {
  @ObjectModel.modelingPattern: #ANALYTICAL_CUBE
  @ObjectModel.supportedCapabilities: [ #ANALYTICAL_PROVIDER]
  view FlightByAirport as select from my.Flight {
    // ...
  }
}
```

Design time plugin:

[![Node.js](../assets/logos/nodejs.svg){}](https://github.wdf.sap.corp/orca/seal-ea-core/tree/main/packages/cds-ea-plugin)

Runtime plugins available for:

![Node.js](../assets/logos/nodejs.svg){}
![Java](../assets/logos/java.svg){style="height:3em; display:inline; margin:0 0.2em;}

[Read the guide about Embedded Analytics with CAP.](../advanced/embedded-analytics){.learn-more}
[Free & Open Source Notices: ENTERPRISE ANALYTICS PLUGIN](https://support.sap.com/content/dam/launchpad/en_us/osln/osln/73554900100900008392_20241207062410.pdf){.learn-more}
[Free & Open Source Notices: CDS INA ADAPTER](https://support.sap.com/content/dam/launchpad/en_us/osln/osln/73554900100900008521_20241210055941.pdf){.learn-more}

### More Coming

- Fiori Analytics
- Embedded DragonFly UIs <Concept />
- Datasphere <Concept />

</Fragment>


<div id="secondary-file">plugins/index.fragment.md</div>


# Release Notes

This section provides information about what is new and what has changed in SAP Cloud Application Programming Model (CAP) since the last release.

:::tip
For important updates for SAP Business Technology Platform (BTP), refer to section [What's New](https://help.sap.com/whats-new/cf0cb2cb149647329b5d02aa96303f56) published for the SAP BTP.
:::



<br>
<IndexList :pages='pages' />

## Major Versions

Here is a list of release notes for [CAP major versions](schedule#yearly-major-releases).  They can help you migrate your applications to the recent major version.

- [cds 9, CAP Java 4 (May 2025)](./may25)
- [cds 8, CAP Java 3 (June 2024)](./archive/2024/jun24)
- [cds 7, CAP Java 2 (June 2023)](./archive/2023/jun23)
- [cds 6 (June 2022)](./archive/2022/jun22)
- [cds 5 (May 2021)](./archive/2021/may21)
- [cds 4 (February 2020)](./archive/2020/feb20)




# CAP Release Schedule

New **major versions** of CAP will be released **every 12 months**, in May 2024, 2025, and so forth.
Active CAP-based projects are strongly recommended to adopt new majors as soon as possible, as **former releases will receive critical bug fixes only**. This schedule gives a reliable basis for planning adoption accordingly.

![A kind of Gantt chart, showing the active and maintenance version of CAP](assets/schedule-overview.drawio.svg)

## Major Releases {#yearly-major-releases}

### CAP Node.js

CAP releases are linked to the [Node.js Release Schedule](https://github.com/nodejs/release#release-schedule/): New major releases are triggered by end of life of Node.js LTS releases, as depicted in the following figure. Active releases always only support the *two* Active and Maintenance LTS versions of Node.js.

![A kind of Gantt chat, showing which CAP version supports which Node.js version.](assets/schedule-yearly-overview.drawio.svg)

Example: CAP v7

- Was released in April 2023, when Node.js 14 reached end of life
- Dropped support for Node 14, as that became out of maintenance
- Supports Node 16 and Node 18

Major version upgrades *may* incorporate **breaking changes** to public APIs, yet we will avoid that as much as possible. Public APIs are explicitly documented in public and official docs only – that is [capire](https://cap.cloud.sap); excluding tutorials, sample code, blogs, or similar.

**Individual components of CAP** can have independent major, minor, and patch version numbers. Yet, all major version upgrades will be synchronized to the yearly major version upgrades of CAP overall, without intermediate major version upgrades of individual components in between.

### CAP Java

CAP Java **major versions** are usually developed and offered over a period of one or even several years.
In general, public APIs are kept *compatible* within a major version. Incompatible changes are only done if *unavoidable* and are documented in [release notes](../releases/) accordingly.

A new major version may introduce incompatible changes to APIs or may adjust behavior of APIs. Such changes are done for good reason only and are documented in a [migration guide](../java/migration).

A new major version might be driven by the release and maintenance schedule of crucial dependencies such as [Spring Boot](https://github.com/spring-projects/spring-boot/wiki/Supported-Versions) or if the minimum JDK version needs to be increased.
Hence, there is no fixed schedule of major releases.
For instance, CAP Java 2.0 has been introduced to support Spring Boot 3 on basis of JDK 17.

:::tip New major versions are announced several months in advance
You will find information [here](../java/versions#dependencies) and in the [release notes](../).
:::

Only the current major version has the [active status](#active). New (CAP) features are provided in this version only.
Whereas the previous major version has [maintenance status](#maintenance-status). This version will be maintained for a period of time appropriate for migrations.

::: tip Stay updated
Active CAP-based projects are strongly encouraged to adopt new major versions as soon as possible,
as **a version in maintenance status will receive critical bug fixes only**.
:::

<br>

[See the release notes of recent major versions.](./#major-versions){.learn-more}

## Monthly Minor Releases {#minor}

Releases in [active status](#active) are equal to the latest development branches of CAP components, hence receiving ongoing feature development. Such new features are *published* in monthly *minor releases*, with accompanying [release notes](../releases/).

Minor version upgrades come **without breaking changes** to public APIs. They *may* incorporate breaking changes to undocumented, hence private interfaces though, which should never be used in projects using CAP.

**In between official releases**, we publish new [patch versions](#patch) or minor version updates of individual CAP packages to *[npmjs.com](https://www.npmjs.com)* or to *[Maven](https://search.maven.org)*.

## Patch Releases {#patch}

A patch release of a minor release receives critical bug fixes only. It could also include code for new features, which are not considered public until officially released with according documentation. Such features will not be active by default.

<div id="beforeactivereleasestatus" />
<Fragment target="#beforeactivereleasestatus">

## Release Candidates <Internal />

Two to three months prior to upcoming new major releases, we will try to make release candidate versions available. These are meant for projects to prepare for upcoming major upgrades in advance.

</Fragment>

## Active Release Status { #active }

New major releases enter *active* status on date of release.

Active releases are updated with [monthly minor releases](#minor) to receive the following:

- New CAP features
- Support for new versions of platform services, including databases
- Support for new major versions of Node.js and Java
- Support for new major versions of 3rd party libraries
- All kinds of minor fixes

They are updated with a [patch release](#patch) in case of urgent hot fixes. Only the latest minor release of the active version receives patches.

::: tip Stay updated
CAP-based projects are strongly encouraged to adopt the [latest minor release of the active version as soon as possible](#adoption-strategy) during their development cycles to benefit from these updates.
:::

## Maintenance Status

Whenever a new major CAP version is released, the former major version enters *maintenance* status. It receives **critical bug fixes only** and for a period of at most twelve more months. After this, it reaches [end of life](#end-of-life-status).

A release in *maintenance* status **does not** receive the following:

- Updates with new features at all
- Support for new versions of platform services or databases
- Support for new versions of Node.js and Java
- Fixes for *minor* bugs and gaps
- Support for new (major) versions of 3rd party libraries

In essence, critical bugs are security incidents, and bugs showing up in customer usages of already developed and shipped applications. Gaps and bugs detected in new developments with functional enhancements are not considered critical bugs.

## End of Life Status

After at most twelve months in [maintenance status](#maintenance-status) former releases reach *end of life*. They **don't receive any fixes at all** from that point on – all bug reports are rejected by default. Projects sticking to *end of life* versions of CAP must ensure to also stick to non-changing environments, that means:

- Freeze on Node.js, Spring Boot or Java versions, only patch updates allowed
- No updates of platform services or databases beyond hotfixes
- No updates of 3rd party libraries beyond patch versions
- No new development beyond hotfixes

In essence, projects sticking to *end of life* releases of CAP can continue to run *'as is'*, but should not be touched beyond hotfixes and cosmetic changes.

## Adoption Strategy

As stated already, projects using CAP are recommended to upgrade to *latest minor* release of the *active* version as soon as possible.

Assumed a project is planned to have a big go-live release R1 to customers (RTC) in May 2022, the project's dev schedule might look like that:

- Current development for R1 is on **CAP v5**
- Dev close for R1 in March/April 2022 → intensive testing
- Start of R1.1 dev cycle in parallel on **CAP v6**
- Release of R1 in May 2022 on CAP v5
- Main development for R1.1 on CAP v6
- Release of R1.1 in September 2022 on CAP v6

In general, upgrading as soon as possible doesn't mean that deployed applications need to upgrade, they continue to run with latest frozen versions, of course. Also near-term go-lives should not be endangered by adopting new major versions. But all forward-looking development should happen on *active* releases only.

<div id="secondary-file">releases/schedule.fragment.md</div>


# July 2025


::: tip Preview Release Notes
This is a preview of the release notes of our upcoming release.
With these notes we want to share with you in advance what to expect soon.
Note though that these notes are still work in progress, not official yet,
and might still change.
:::

## Custom Messages for Generic Validations

Validation annotations `@mandatory`, `@assert.range`, `@assert.format`, and `@disabled` (CAP Java only), now support custom messages. Use the annotation `@<anno>.message` with an error text or [text bundle key](../guides/i18n#externalizing-texts-bundles):

```cds
entity Person : cuid {
  name  : String;

  @assert.format: '/^\S+@\S+\.\S+$/'
  @assert.format.message : 'Provide a valid email address'
  email : String;

  @assert.range: [(0),_]
  @assert.range.message: '{i18n>person-age}'
  age   : Int16;
}
```

Learn more about
* [input validation](../guides/providing-services#input-validation){.learn-more}
* [localization and text bundles](../guides/i18n){.learn-more}


## Hierarchical Tree Views

The [UI5 Tree Table](https://www.sap.com/design-system/fiori-design-web/ui-elements/tree-table/?external) (aka "Tree View") has now unrestricted support by CAP in the _generic_ flow. This means this feature is not "beta" any longer - provided that no custom code is involved to handle the OData requests of the UI5 tree table.

CAP supports read-only usage as well as hierarchy maintenance for [draft enabled](../advanced/fiori#draft-support) entities. Tree table can be used on a list page, on an object page as well as in value help.

<video src="./assets/jun25/node-tree-maint_compressed.mp4" autoplay loop muted webkit-playsinline playsinline class="bright"/>

The generic flow is supported on SAP HANA, H2 (CAP Java only), PostgreSQL and SQLite (CAP Node.js only).

::: warning
The CQN representation of hierarchical requests is not finalized and considered an internal API. Also CAP Java's programatic API to handle `CqnTransformation`s is still beta. These APIs might change without notice.
:::

Try it out yourself in our SAP Fiori bookshop sample apps for 
* [CAP Java](https://github.com/SAP-samples/cloud-cap-samples-java){.learn-more}
* [CAP Node.js](https://github.com/SAP-samples/cloud-cap-samples){.learn-more}

[See more on hierarchical transformations](../advanced/odata#hierarchical-transformations){.learn-more}

## CDS Language & Compiler {#cds}

## Node.js {#cds-js}

### Important Changes ❗️ { #changes-in-node-js .important }

### xssec token caching

- Enable `@sap/xssec`'s caching mechanisms (requires `@sap/xssec^4.8`)
  + The signature cache can be configured via `cds.requires.auth.config`, which is passed to `@sap/xssec`'s authentication services
  + The token decode cache can be configured programmatically via `require('@sap/xssec').Token.enableDecodeCache(config?)` and deactivated via `require('@sap/xssec').Token.decodeCache = false`

### xsuaa fallback

(falls rechtzeitig gemergt)

- `ias`-auth: Support for fallback XSUAA-based authentication meant to ease migration to IAS
  + The fallback is automatically enabled if XSUAA credentials are available. To enable the credentials look-up, simply add `cds.requires.xsuaa = true` to your env.
  + In case you need a custom config for the fallback (passed through to `@sap/xssec` as is!), configure it via `cds.requires.xsuaa = { config: { ... } }`

### Numeric values in .csv files

Numeric values in .csv files are now returned as numbers instead of strings, e.g. 1 instead of '1'; when pre-padded with zeros, e.g., 0123, they are returned as strings, e.g. '0123' instead of 123.

### TBD: check cds.infer

### TBD: Revised Error Handling

mostly under the hood but err.code is now the real application error code, also used for i18n lookup. status should contain http status. message should be error message and not code.
if error sanitization should be suppressed `err.$sanitize=false` --> add docs
if custom error format has to be returned, implement `err.$response` function --> add docs
only errors in within srv.dispatch will call on('error') handler, otherwise express error middleware

<span id="node-deep-authorizations" />

## Java {#cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

### Generic Exception Handling for `Result.single`

By default the `Result.single` methods throw an `EmptyResultException` the query returns an empty result, which can be handled by custom code.

To avoid this boiler-plate code we now offer a configuration option `cds.errors.preferServiceException: true` that advises the runtime to handle an empty result generically. With this option, a `ServiceException` with HTTP status code 404 (Not Found) is thrown by the `Result.single` methods in case of an empty result. No custom code is needed then.

### Simplified API of DraftService

To programatically update or delete a draft via the `DraftService` you so far had to use the dedicated `patchDraft(CqnUpdate, ...)` and `cancelDraft(CqnDelete, ...)` methods.

Now, when a statement exclusively targets inactive entities, you can alternatively use the `run(CqnUpdate, ...)` or `run(CqnDelete, ...)` methods. The `DraftService` will then automatically delegate to `patchDraft(CqnUpdate, ...)` and `cancelDraft(CqnDelete, ...)`.

::: tip
This now allows to write handler code in a uniform way for draft-enabled and not draft-enabled entities.
:::

Learn more about [Editing Drafts](../java/fiori-drafts#editing-drafts) in CAP Java{.learn-more}


### Deletion of Change Logs

By default, change logs of a tracked entity are _preserved_ even if the entity is deleted. To _delete_ the change logs of an entity when the entity gets deleted annotate the `changes` association your change tracked entity like this:

```cds
annotate model.Books.changes:change with @cascade: { delete };
```

[See more in Change Tracking](../java/change-tracking#how-changes-are-stored){.learn-more}

### Restrictions on `$expand`

Runtime now checks following restrictions related to `$expand`:

- `@Capabilities.ExpandRestrictions.Expandable: false` prevents any expands from the entity.
- `@Capabilities.ExpandRestrictions.NonExpandableProperties: [...]` prevents expands for the specified properties.
- `@Capabilities.ExpandRestrictions.MaxLevels: ...` sets maximum allowed depth of an `$expand` from this entity.

[See more about these restrictions](../guides/security/aspects?impl-variant=java#http-server-and-cap-protocol-adapter){.learn-more}

## Tools { #tools}

### Go to Implementations (Experimental)

The CDS text editor now supports "Go to Implementations" for CDS services and entities, for NodeJS and Java.
On NodeJS, actions, functions and events are supported additionally.
This feature is still experimental and might not cover all cases. Please report any issues you encounter.

<video src="./assets/jul25/editor-goto-implementation_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

### Formatting Parameter Lists

The new formatting options `whitespaceBeforeColonInParamList` and `whitespaceAfterColonInParamList` provide fine-grained control over spaces before and after colons in parameter lists for actions, functions, entities, and views.



# June 2025


## Node.js {#cds-js}

### Hierarchy Maintenance in Tree Views <Beta />

CAP Node.js now also supports hierarchy maintenance for [draft enabled](../advanced/fiori#draft-support) entities. It's possible to create new nodes and to add them as root or child nodes to the hierarchy. You can also modify and delete nodes. In addition, one can change a parent of a child node (move a node).

If a node is deleted, its descendant nodes are only deleted if they are in a composition relationship with the deleted node.

<video src="./assets/jun25/node-tree-maint_compressed.mp4" autoplay loop muted webkit-playsinline playsinline class="bright"/>

The same set of modifications is supported on the Object Page as well.


:::info Supported on all databases
This feature is supported on SQLite, Postgres and SAP HANA.
:::


[Try it out yourself in our SAP Fiori bookshop sample app.](https://github.com/SAP-samples/cloud-cap-samples){.learn-more}

[CAP Java supports this beta feature since February 2025.](../releases/archive/2025/feb25#hierarchy-maintenance-in-tree-table){.learn-more}

### UI5 State Messages for Drafts <Beta />

CAP Node.js now also supports persisting (error) messages for draft-enabled entities and providing _state messages_ to the UI5 OData V4 model.

The same precondition as for CAP Java applies:
- Enable the feature flag <Config>cds.cdsc.beta.draftMessages:true</Config>
- Enable OData containment mode with <Config>cds.odata.containment: true</Config>

We are working on a solution that does not require containment.

<video src="./assets/jun25/node-draft-validations_compressed.mp4" autoplay loop muted webkit-playsinline playsinline  class="bright"/>

If activated, you can observe the following improvements, without changing the application code:

- Error messages for annotation-based validations (`@assert...`) already appear while editing the draft.
- Errors stemming from custom validations for the `PATCH` event are persisted as well. The invalid value is still persisted, as expected by the draft choreography.
- Messages no longer unexpectedly vanish from the UI after editing another field.
- Messages are automatically loaded when reopening a previously edited draft.

Setting this property adds additional elements to your draft-enabled entities and `DraftAdministrativeData`, which are required to store and serve state messages.


::: warning Requires Schema Update
Enabling draft messages requires a database schema update, as it adds an additional element to `DraftAdministrativeData`.
:::

[CAP Java supports this beta feature since February 2025.](../releases/archive/2025/feb25#ui5-state-messages-for-drafts){.learn-more}

## Java {#cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

#### Add DevDependency to `@sap/cds-mtxs`

`@sap/cds-mtxs` is now a [CAP plugin](../plugins/). In order to pull the build configuration correctly, you have to add `@sap/cds-mtxs` to the root-level _package.json_ `devDependencies`:

```sh
npm add -D @sap/cds-mtxs
```

### Tree Views w/ H2 Database <Beta/>

To simplify local development and testing with the [SAP Fiori Tree Table](https://www.sap.com/design-system/fiori-design-web/ui-elements/tree-table/?external), you can now also use a local H2 database, instead of connecting to SAP HANA.

![Tree View Support on H2](assets/may25/NodeTreeView.png){}

### Event Handler Enhancements

We have made several enhancements, that allow for cleaner and more intuitive custom event handler implementations.

The below examples refer to the following example model:

```cds
service Universe {
  entity World {
    name: String;
  } actions {
    function hello() returns String;
  }
}
```

#### Returning Arbitrary Types

You can now return objects of arbitrary types in your event handlers and the runtime takes care of putting them into the EventContext as `result`. Also, the runtime sets the context to completed.

Instead of setting the string as a context `result`:
```java
@On(event = WorldHelloContext.CDS_NAME)
public void hello(WorldHelloContext context) {
  context.setResult("Hello World");
}
```

You can now return the string directly:
```java
@On(event = WorldHelloContext.CDS_NAME)
public String hello() {
  return "Hello World";
}
```

#### Accessing the Service

You can now get the Service that is processing the event directly provided to your event handler, by defining a corresponding argument in the method signature.

This avoids manual casts, especially when having to access the `DraftService` interface or generated typed service interfaces:

Instead of obtaining the service from the context and casting it to a more specific sub-type:

```java
@On(event = WorldHelloContext.CDS_NAME)
public void hello(WorldHelloContext context) {
  Universe service = (Universe) context.getService();
  service.run(...);
}
```

You can now define the specific service directly as an argument:

```java
@On(event = WorldHelloContext.CDS_NAME)
public void hello(Universe service) {
  service.run(...);
}
```

#### Typed Entity References

You can now directly get a typed entity reference reflecting the reference of the currently processed CQN statement, by declaring a corresponding argument in your method signature.

You can directly use this reference to build type-safe queries:

```java
@On(event = WorldHelloContext.CDS_NAME)
public void hello(World_ ref) {
  Select.from(ref).columns(w -> w.name());
}
```

CAP Java infers the entity for the event handler registration from the argument, so that it doesn't need to be explicitly defined in the annotation again.

#### Bringing It All Together

These features nicely play together like this:

```java
@On(event = WorldHelloContext.CDS_NAME)
public String hello(Universe service, World_ ref) {
  Result result = service.run(Select.from(ref).columns(w -> w.name()));
  return "Hello " + result.single(World.class).getName();
}
```

### Media Data in Actions and Functions

Media data like images, CSVs, and so on, can now also be used as a return type of actions and functions. The return type annotated with `@Core.MediaType` has to be defined within the same service of the action or function.

**Example:**

::: code-group
```cds
service OrderService {
  @(Core: {
     MediaType: 'application/pdf',
     ContentDisposition.Filename: 'order.pdf'
  })
  type pdf: LargeBinary;
  entity Orders { ... } actions {
    function exportAsPdf() returns pdf;
  }
}
```
:::

::: code-group
```java
@On (event = OrdersExportAsPdfContext.CDS_NAME)
public InputStream exportAsPdf(CqnElementRef order) {
    byte[] pdf = createPdf(order);
    return new ByteArrayInputStream(pdf);
}
```
:::

[CAP Node.js supports this feature since February 2025.](./archive/2025/feb25#media-data-in-actions-and-functions){.learn-more}

### Media Elements in Remote OData

You can now read and write [media elements](/guides/providing-services#annotating-media-elements) annotated with `@Core.MediaType` from remote services with CQN statements.

If you want to read `image` of this entity, you need to create a statement like this:

```java
Select.from(Media_.class, m -> m.filter(f -> f.ID().eq("..."))).columns(Media_::image);
```

You can also write the same property with an `Update` statement:

```java
Media payload = Media.create();
payload.setId(...);
payload.setImage(...);

Update.entity(Media_.class).entry(payload);
````

[Learn more in Consuming Media Elements.](../java/cqn-services/remote-services#consuming-media-elements){.learn-more}

## Tools { #tools}

### IntelliJ Community Edition Supported by CDS Plugin

Triggered by your feedback, the [CDS plugin for the IntelliJ IDEs](https://github.com/cap-js/cds-intellij), version 2, now also runs on the _Community editions_, lifting the need for a commercial variant.

It will soon be availabe as an update on the [JetBreains Marketplace](https://plugins.jetbrains.com/plugin/25209-sap-cds-language-support).

![Example of code completion in IntelliJ](./archive/2023/assets/dec23/code_completion.png){ .ignore-dark}

[Join the discussions about the plugin on GitHub.](https://github.com/cap-js/cds-intellij){.learn-more}

### Faster Editor Feedback in VS Code

We have improved the responsiveness and CPU usage of the CDS editor, especially for larger models.
- During typing it will defer error indicators and other diagnostics until typing finished.
- Performance while typing has been improved by aborting compilations that are not needed anymore.

:::info This behavior can be configured:
There is a new setting `cds.workspace.fastDiagnosticsMode` (default: `Clear`).
With the option `Parse`, an immediate error feedback is provided that relies solely on the CDS grammar, which is less accurate but faster.
The old behavior of updating diagnostics after (each intermediate) compilation is finished is still available with the option `Off`.
:::



# May 2025


> [!note]
> This is a revision of the version published initially on June 5th with these corrections:
> - [CDS — Association to many w/o `ON` Conditions](#unspecified-assoc) with fixed troubleshooting instructions.
> - [Node.js — Opt-in Replacement for Generic-Pool](#generic-pool) using a better config flag.
> - [Node.js — Improved Error Handling](#improved-error-handling) was missing in the initially published version.


## New Major Versions

### CAP Node.js v9

The May 2025 release includes version 9 for CAP Node.js (`@sap/cds` and `@sap/cds-dk`). Along with these changes, we're also updating these minimum required dependencies:

| Dependency  | Required Version | Recommended                    |
|-------------|------------------|--------------------------------|
| **Node.js** | 20               | [22 (LTS)](https://nodejs.org) |

> [!danger] End of Life for cds7

`@sap/cds` 7, `@sap/cds-dk` 7, and `@sap/cds-compiler` 4, which have been in [maintenance status](./schedule#maintenance-status) so far, have reached [end of life](./schedule#end-of-life-status) and won't be patched any longer.

If you still use `@sap/cds` 7 or lower, you get an error from `cds` CLI commands.
To resolve this, upgrade to `@sap/cds` 9. Only as a fallback downgrade `@sap/cds-dk`.

### CAP Java v4

The May 2025 releases also brings the new major version 4 for CAP Java. This version includes several enhancements and new features to improve the development experience.

> [!danger] End of Life for CAP Java 2.10

`cds-services` and `cds4j-api` version 2.10, which have been in [maintenance status](./schedule#maintenance-status) so far, have reached [end of life](./schedule#end-of-life-status) and won't be patched any longer.


### Migration

Following are the most important changes that you need to be aware of when upgrading to the new major versions:

- [Transactional Event Queues — Enabled by default](#enabled-by-default)
- [CDS Language — Association to many w/o ON Conditions](#unspecified-assoc)
- [CDS Language — `$now` is Transaction Time](#now-is-transaction-time)
- [Databases — Skipped Native Associations for SAP HANA](#skipped-native-associations-for-sap-hana)
- [Databases — Consistent Operators](#consistent-operators)
- [Databases — Removed `hdbcds` Format](#removed-hdbcds-format)
- [Syntax Cleanup](#syntax-cleanup)
- [Changed Structure of `req.params`](#changed-structure-of-req-params)
- [Service Level Restrictions](#service-level-restrictions)
- [Revised Handling of PUT Requests](#revised-handling-of-put-requests)
- [Open-Sourced `cds.test`](#open-sourced-cds-test)
- [New Database Services v2](#new-database-services-v2)
- [Node.js - Removed Features](#removed-features)
- [ESLint 9 Required](#eslint-9-required)
- [Removed Legacy Build Configuration](#removed-legacy-build-configuration)
- [Java - Important Changes](#important-changes-in-java)
- [Multitenancy - Important Changes](#changes-in-multitenancy)



### New License

All CAP Node.js packages starting with `@sap` as well as the CAP Java libraries now come with the [_SAP Developer License 3.2 CAP_](https://cap.cloud.sap/resources/license/developer-license-3_2_CAP.txt).

The formerly used _SAP Developer License 3.1 / 3.2_ imposed strict rules on CAP users with respect to CAP usage and customer support. By shifting to the _SAP Developer License 3.2 CAP_, SAP allows customers of SAP Business Technology Platform (BTP) or any other SAP platform to use CAP applications productively and to request support in line with their existing licensing agreement with SAP.

[See more on our license page.](../resources/cap-license){.learn-more}



## Hierarchical Tree Views, beta 2 <Beta /> {#tree-views}

The support for hierarchical tree view support is making progress. In this release, we consolidated the configuration between CAP Node.js and CAP Java, so that you can use the same configuration for both runtimes, following these step-by-step instructions, as well as adding support for SQLite and PostgreSQL (in Node.js).

### Consolidated Configuration

Given a domain model like this:

```cds
entity Genres { //...
  parent : Association to Genres;
}
```
[As found in _cap/samples/bookshop_](https://github.com/SAP-samples/cloud-cap-samples/tree/main/bookshop/db/schema.cds#L26-L31){.learn-more}

#### 1. Configure the TreeTable in UI5's _manifest.json_, for example:

```jsonc
  "sap.ui5": { ...
    "routing": { ...
      "targets": { ...
        "GenresList": { ...
          "options": {
            "settings": { ...
              "controlConfiguration": {
                "@com.sap.vocabularies.UI.v1.LineItem": {
                  "tableSettings": {
                    "hierarchyQualifier": "GenresHierarchy", // [!code focus]
                    "type": "TreeTable" // [!code focus]
                  }
                }
              }
            }
          }
        },
      },
    },
```

> Note: `hierarchyQualifier` should be chosen as: <br>
> `"<entity name in service>Hierarchy"`

#### 2. Annotate/extend the entity in the service as follows:

```cds
// Tell Fiori about the structure of the hierarchy
annotate AdminService.Genres with @Aggregation.RecursiveHierarchy #GenresHierarchy : {
  ParentNavigationProperty : parent, // navigates to a node's parent
  NodeProperty             : ID, // identifies a node, usually the key
};

// Fiori expects the following to be defined explicitly, even though they're always the same
extend AdminService.Genres with @(
  // The columns expected by Fiori to be present in hierarchy entities
  Hierarchy.RecursiveHierarchy #GenresHierarchy : {
    LimitedDescendantCount : LimitedDescendantCount,
    DistanceFromRoot       : DistanceFromRoot,
    DrillState             : DrillState,
    LimitedRank            : LimitedRank
  },
  // Disallow filtering on these properties from Fiori UIs
  Capabilities.FilterRestrictions.NonFilterableProperties: [
    'LimitedDescendantCount',
    'DistanceFromRoot',
    'DrillState',
    'LimitedRank'
  ],
  // Disallow sorting on these properties from Fiori UIs
  Capabilities.SortRestrictions.NonSortableProperties    : [
    'LimitedDescendantCount',
    'DistanceFromRoot',
    'DrillState',
    'LimitedRank'
  ],
) columns { // Ensure we can query these fields from database
  null as LimitedDescendantCount : Int16,
  null as DistanceFromRoot       : Int16,
  null as DrillState             : String,
  null as LimitedRank            : Int16,
};
```
[As showcased in _cap/samples/fiori_](https://github.com/SAP-samples/cloud-cap-samples/blob/main/fiori/app/genres/tree-view.cds){.learn-more}

That's it! You can now start the server with `cds watch` and see the hierarchical tree view in action in the [_Browse Genres_](http://localhost:4004/fiori-apps.html#Genres-display) app.

### Support for SQLite and PostgreSQL

In addition to the already supported SAP HANA, the hierarchical tree view is now also supported for SQLite and PostgreSQL with the new major versions of `@cap-js/sqlite` and `@cap-js/postgres` for the CAP Node.js stack.

[Learn more about that in the Node.js section below.](#cds-js){.learn-more}

The same is in progress for the CAP Java stack.


## Transactional Event Queues <Beta /> { #task-queues }

As an evolution of the _persistent outbox_, we have introduced CAP-native task queues to enhance the processing of events and requests to so-called _queued services_.

In a nutshell, queued events are ...
1. written to the database within the current transaction and executed asynchronously after said transaction has been committed (→ **_atomicity_**).
2. retried until they succeed, thereby adding **_resilience_** to the queued service - even beyond the current runtime.
3. **_recoverable_** in case of unrecoverable errors (or if the maximum retry count was reached) via the dead letter queue.

[Learn more about CAP's Event Queues](../guides/messaging/task-queues){.learn-more}

### In Node.js

Simply _queue_ or _unqueue_ a service via `cds.queued(srv)` or `cds.unqueued(srv)`, respectively, and the subsequent dispatch on the returned service is either executed as an asynchronous task or immediately.

[Learn more about CAP Node.js' cds.queued() API.](../node.js/queue){.learn-more}

Additionally, the Node.js runtime added the following experimental features/ APIs:

#### Event Scheduling <Alpha />

New `<srv>.schedule()` as variant of [`cds.queued(<srv>).send()`](../node.js/core-services#srv-send-request) with fluent API options:

- `.after(<ms>)`
- `.every(<ms>)`

Allows you to schedule a background task to be executed after a delay or in a certain interval (as minimum value after completion of the previous task).

#### Event Callbacks <Alpha />

Register callbacks as follows:

- `<srv>.after('<event>/#succeeded', (results, req))`
- `<srv>.after('<event>/#failed', (error, req))`

Allows you to react to succeeded and failed asynchronous tasks, for example, replicating the full business object from a remote system once its creation was successful.

#### More Efficient Locking <Alpha />

We introduced an application-level event queue status management that avoids long-lasting database locks.
That is - in a nutshell - instead of holding the lock during processing, the task runner only locks a message for maintaining its status.

The feature can be enabled via <Config>cds.requires.queue.legacyLocking = false</Config>.

:::tip Application-level task status management only works...
if all active task runners are on cds9.
:::

### In Java

The technical outbox API allows to trigger asynchronous workloads.

[Learn more about CAP Java's Technical Outbox API](../java/outbox#technical-outbox-api){.learn-more}

Furthermore, CAP Java already announced the [optimized outbox in last month's release](./apr25#optimized-outbox) as a first building block for more efficient task processing.

![Diagram showing the architecture of a Task Controller in a CAP application. The diagram illustrates the flow of tasks from the application layer to the database, highlighting components such as the Task Queue, Dead Letter Queue, and Task Runner. Arrows indicate the movement of tasks between these components. The environment is clean and technical, designed to explain asynchronous task processing. Text in the image includes Task Controller, Task Queue, Dead Letter Queue, and Task Runner. The tone is informative and neutral.](assets/may25/TaskController.png){width=80%}


### Inbox

Utilizing the new event queues feature, inbound messages can be accepted as asynchronous tasks as well.
Simply configure your messaging service for Node.js as <Config>cds.requires.messaging.inboxed = true</Config> and for CAP Java as <Config java keyOnly>cds.messaging.services=[{"name": "messaging-name", "inbox": {"enabled": true}}]</Config>

**Inboxing moves the dead letter queue into your CAP app.**

Enabling the inbox feature means that all messages are acknowledged towards the message broker - regardless of whether their processing was successful or not.
Hence, any failures would need to be managed via the dead letter queue built on `cds.outbox.Messages`.


### Enabled By Default

Migrating from the outbox to general-purpose event queues is seamless.
For example, the table name remains `cds.outbox.Messages` and `cds.outboxed(srv)` is kept as a synonym for the new `cds.queued(srv)`.

However, event queues are **enabled by default**.
Hence, a database deployment is required when migrating to cds9/ CAP Java 4 in case the persistent outbox was not yet used in your project.

If this is an issue for your project, you can opt out of the event queues feature by adding <Config>cds.requires.queue = false</Config> (for Node.js and Java projects!) until you are ready for a database deployment.




## CDS Language & Compiler {#cds}


### New Parser for CDL

![The graphic is explained in the accompanying text.](assets/may25/newParser.drawio.svg){}

In cds9 we switch over to the new CDS parser.


The new parser comes with the following:

* Reduced installation size of the compiler package by 40%
* Faster parsing
* Enhanced code completion

:::tip The new parser doesn't come with any breaking changes...

... and is fully compatible with the old parser.

:::




### Agnostic Database Functions

The `@sap/cds-compiler`, the CAP Node.js database services, and the CAP Java runtime<sup>1</sup> come with out-of-the-box support
for a specified [set of standard functions](../guides/databases#standard-database-functions)
inspired by OData and SAP HANA:

* `min`, `max`, `count`, `countdistinct`, `sum`, and `average`
* `concat`<sup>1</sup>
* `trim`
* `contains`, `startswith`, and `endswith`
* `matchespattern`
* `indexof`
* `substring`
* `length`
* `tolower` and `toupper`
* `ceiling`, `floor`, and `round`
* `year`, `month`, `day`, `hour`, `minute`, and `second`<sup>1</sup>
* `time` and `date`<sup>1</sup>
* `fractionalseconds`<sup>1</sup>
* `years_between`, `months_between`, `seconds_between`, and `nano100_between`<sup>1</sup>

::: warning
<sup>1</sup> not yet supported by CAP Java
:::

These functions can be used reliably throughout CAP. The framework translates
them to suitable native SQL functions.

Example: Function `startswith`

- used in OData queries as follows:
  ```http [OData]
  GET /Books?$filter=startswith(title, 'Raven')
  ```
- used in CQL queries like in the following view:
  ```cds
  entity V as select from Books {
    startswith(title, 'Raven') as found // mapped to native SQL equivalent
  }
  ```

:::details For SAP HANA, the resulting SQL is:
```sql
CREATE VIEW V AS SELECT
  CASE WHEN locate(title, 'Raven') = 1 THEN TRUE ELSE FALSE END AS found
FROM Books;
```
:::

::: details For SQLite, the resulting SQL is:
```sql
CREATE VIEW V AS SELECT
  coalesce((instr(Books.title, 'Raven') = 1), false) AS found
FROM Books;
```

:::

::: warning Case sensitivity

The function mappings are case-sensitive.
When written in lower case, they are recognized as a standard function call and rewritten.
Otherwise, the function call is passed to SQL as is.

:::

[Learn more about Standard Database Functions.](../guides/databases#standard-database-functions){.learn-more}




### Consistent Operators

CAP consistently supports the operators `==` and `!=` in CDS models (including [annotations with expression value](../cds/cdl#expressions-as-annotation-values))
and in CQN.
Like the standard SQL operators `IS [NOT] DISTINCT FROM`, they have two-valued Boolean logic and
behave like in JAVA or Javascript.

Two-valued logic means, they always evaluate to `true` or `false`, but never to `null` or `unknown`.
For example, the following expression evaluates to `true` also if `a` is `null`:

```cds
  a != 42
```

::: warning In essence, `!=` changes from three-valued logic to two-valued logic

Operator `!=` has already been available in CAP before with three-valued logic
and now has changed to two-valued logic. In case you really want and need three-valued logic, use operators `=` and `<>`, respectively.

:::




### Miscellaneous


#### Nesting Definitions when Compiling to CDL

`cds compile --to cdl` now lexically nests definitions into services and contexts.
This affects only the appearance of the resulting CDL files, their semantics are unchanged.

As an example, look at the following CSN, translated into CDL:

<div class="cols-2">

```json
{
  "definitions": {
    "sap.com.Bookshop": {
      "kind": "service"
    },
    "sap.com.Bookshop.Books": {
      "kind": "entity",
      "elements": { /* ... */ }
    }
  }
}

```

<br/>

```cds
namespace sap.com;
service Bookshop {
  entity Books {
    // ...
  };
};
```
</div>

#### Generated Entities and `@cds.persistence.journal`

Using the annotation `@cds.persistence.journal` controls whether a CDS entity is
deployed to SAP HANA using `.hdbmigrationtable` instead of `.hdbtable`.

In addition, this annotation is now copied from an entity to the corresponding compiler-generated `.texts` entity for [_localized elements_](../guides/localized-data#localized-data) and child entities for [_Composition of aspects_](../cds/cdl#managed-compositions). This means these text tables are managed by `.hdbmigrationtable` instead of `.hdbtable`. This change requires a migration: undeploy the `.hdbtable` artifact and deploy the `.hdbmigrationtable` artifact in the same deployment.

Example:
```cds
@cds.persistence.journal
entity Books {
  key id : Integer;
  title : localized String;
  chapters : Composition of many {
    key chapter : Integer;
    synopsis : String;
  }
}
```
In addition to entity `Books`, the compiler generates a text entity `Books.texts` for the localized element,
and a child entity `Books.chapters` for the managed composition of aspect. Both generated entities now inherit
the annotation `@cds.persistence.journal` from the `Books` entity.

If you don't want the generated entities to behave like the corresponding main entity, you can
explicitly annotate the generated entities with `@cds.persistence.journal: false`.

Example:
```cds
annotate Books.chapters with @cds.persistence.journal: false;
```

[Learn more about `@cds.persistence.journal`.](../guides/databases-hana#schema-updates-with-sap-hana){.learn-more}


#### Syntax Cleanup

You may encounter syntax errors for definitions that are unclear.

1. Providing default `null` for a not-nullable element or parameter is now an error:
    
    ```cds
    entity E {
      foo : Integer not null default null;
    }
    ```

2. In CDS, it is not possible to provide a default for an array. A default for an
   array like parameter has been silently ignored so far and now is rejected. If you get this error, just remove the default.  Example:
    
    ```cds
    action A(par: array of Integer default 42);
    ```



### Important Changes ❗️  { #changes-in-cds .important }


#### Association to many w/o `ON` Conditions {#unspecified-assoc}

Previously, a `to many` association or composition with missing an `ON` condition like that:

```cds
entity Authors { // ...
  books: Association to many Books; // missing on condition // [!code focus]
}
```

... was wrongly interpreted as a [_managed association_](../cds/cdl#managed-associations) with `to one` cardinality, that is, as if you would have declared it like that:

```cds
entity Authors { // ...
  books: Association to Books; // managed to-one association // [!code focus]
}
```

And in effect the compiler _SQL_ backends generated foreign keys for it _on the source side_. While this even might have silently worked in some cases, it was not the intended behavior and can only have been wrong.

This has been fixed in this release, such that an to-many association with missing `ON` condition is treated as an _unspecified_ association. On one hand, this change allows for more flexible API modeling, which was not possible before. On the other hand, such _unspecified_ associations cannot be generically served, but can be (have to be) handled through custom implementations.

In case you get compiler errors like that after upgrading to the May 25 release:

> _[**ERROR**{.bad}] Expected association with target cardinality ‘to many’ to have an ON-condition_

This can be resolved in one of the following ways:

1. If you meant to declare an [association **_to many_**](../cds/cdl#to-many-associations), correct it like that:

    ```cds
    books: Association to many Books; // [!code --]
    books: Association to many Books on books.author = $self; // [!code ++]
    ```

2. If you meant to declare a [managed association **_to one_**](../cds/cdl#managed-associations), correct it like that:

    ```cds
    books: Association to many Books; // [!code --]
    books: Association to Books; // [!code ++]
    ```

3. If that was correctly modelled and you indeed wanted to declare an _unspecified_ association, ensure you don't deploy such entities to the database, and handle them with custom handlers.




#### Virtual Elements in Views

You can now define a virtual element in a view or projection without providing a value or an expression.

Example:
```cds
entity P as projection on E {
  // ...,
  virtual v1 : String(11),  // new virtual element
  virtual v2                // new virtual element w/o type
}
```
This defines new virtual elements `v1` and `v2` in `P`. In previous releases this resulted in an error
if entity `E` didn't have elements `v1` or `v2`.

Previous ways to define virtual elements in a view or projection are deprecated and may be removed
in a future major release. We recommend replacing them with the new syntax.
```cds
entity P as select from E {
  virtual null   as myV1,  // deprecated
  virtual a      as myV2   // deprecated
}
```

[Learn more about virtual elements in views.](../cds/cdl#virtual-elements-in-views){.learn-more}

#### $now is Transaction Time

We have changed the semantics of `$now` in CDS models. When generating SQL, `$now` is now
translated to `session_context($now)` and reflects the transaction time (in UTC)
pinned by the CAP runtimes.
If you need the old behavior, replace `$now` by `current_timestamp` in your models.

An exception is the `default` clause, where `$now` is still mapped to `current_timestamp`
(databases don't support `session_context()` there). But for `default $now` the
database default is less important, as already the runtimes provide the current server timestamp
as default value.

#### Doc Comments are not Propagated

Doc comments are no longer propagated, as this is the expected behavior in most cases.
For example, a doc comment defined on an entity isn't automatically copied
to projections of this entity.

[Learn more about Doc Comments.](../cds/cdl#doc-comment){.learn-more}



## Databases

### SAP HANA using `ALTER TABLE ADD COLUMN`

On SAP HANA, large tables can now get deployed faster.  This is due to [HDI's new option `try_fast_table_migration`](https://help.sap.com/docs/SAP_HANA_PLATFORM/42668af650f84f9384a3337bcd373692/361b7a91488a4129aba2457bfc2a8520.html) that uses `ALTER` statements instead of expensively copying whole table content.

[CAP's multitenant library](../guides/multitenancy/) has enabled this option by default, as well as most single-tenant projects.
Existing single-tenant projects with a _custom db/package.json_ need to set the option manually in their start script though:
::: code-group
```jsonc [db/package.json]
"scripts": {
  "start": ".../deploy.js --parameter com.sap.hana.di.table/try_fast_table_migration=true ..."
}
```
:::

### Skipped Native Associations for SAP HANA

On SAP HANA, CDS associations are no longer reflected in database tables and views
by native HANA associations (HANA SQL clause `WITH ASSOCIATIONS`), as they are no longer
needed by the CAP framework. This can significantly reduce database (re-)deployment times.

In the unlikely case that you need native HANA associations (for example, because you have defined
native HANA objects that use them), you can switch them back on through <Config>cds.sql.native_hana_associations:true</Config>.

::: warning First deployment

Be aware that the first deployment after upgrading to cds9 may take longer:
For each entity with associations, the respective database object is touched
(DROP/CREATE for views, migration for tables). However, subsequent deployments will benefit.

To avoid full table migrations via shadow table and data copy,
ensure that your project uses [faster table changes on SAP HANA](#sap-hana-using-alter-table-add-column).

:::

[Learn more about Native HANA Associations.](../guides/databases-hana#native-associations){.learn-more}



### Removed `hdbcds` Format

The deploy format `hdbcds` for SAP HANA has been deprecated with cds8 a year ago
and can now no longer be used.
If you haven't already done so, switch to the default deploy format `hdbtable` instead.
This is not relevant for SAP HANA Cloud, where deploy format `hdbcds` was never available.

[Learn more about moving from .hdbcds to .hdbtable.](../cds/compiler/hdbcds-to-hdbtable){.learn-more}





## Node.js {#cds-js}

### Improved Error Handling

Error handling in CAP Node.js has received a major overhaul, mostly behind the scenes, but with some visible changes for you as a developer.

First, error responses now include reasonable `code` properties, for example `ASSERT_FORMAT`, which can be used in clients and tests to reliable identify the types of errors (before they were too aggressively replaced by status codes as strings).

```http
Status: 400
Content-Type: application/json

{
  "error": {
    "code": "ASSERT_FORMAT",
    "message": "Input is not in the expected format.",
    "target": "emailAddress"
  }
}
```

Second, [error sanitation](../node.js/events#error-responses), that is, removing error details in responses now is only done in production, instead of aggressively too early and always, which greatly improves testing in development profiles.

Third, input validation errors are now logged as *warnings* only, not as *errors*, as before. This is because input validation errors are not unexpected errors, but foreseen application behavior. In addition, duplicate logging of the same errors has been fixed.

Finally, we **publicly documented** now how errors are constructed using [`req.reject()`](../node.js/events#req-reject) and [`req.error()`](../node.js/events#req-error) and handled in the framework. Here's an excerpt of that:

![image-20250606162617459](assets/may25/image-20250606162317346.png){}

[Learn more in the Node.js reference docs](../node.js/events#req-reject){.learn-more}


> [!warning] (Non) Breaking Changes
> These fixes and improvements required some changes to internal implementation details, and to private interfaces, such as:
>
> - Property `code` property is now used correctly to identify the type of error, which was previously not done in the same way.
> - Some error `message`s have changed to be more user-friendly and consistent.
> - Some private technical properties like `numericSeverity` or `@Common.numericSeverity` have been removed from some error responses.
>
> While these changes are not breaking any public APIs and hence shouldn't affect your productive applications, they may require adjustments in your tests in case you checked on error responses by deep object equality or similar. → Never do that, but always check on now stable `code` properties instead, as shown above.


### Tree Views w/ SQLite, Postgres <Beta/>

cds9 simplifies the handling of OData hierarchies which are now also supported also in the new major versions of `@cap-js/sqlite` and `@cap-js/postgres`.

![A hierarchical tree view in a user interface displays a list of genres and subgenres such as Fiction, Mystery, and Science Fiction. Each genre can be expanded to reveal related subcategories. The interface uses folder and document icons to indicate expandable and leaf nodes. The environment is a clean, modern application window with a neutral tone, designed for browsing and selecting genres.](assets/may25/NodeTreeView.png){}

You can try it out in the [bookshop sample for SAP Fiori](https://github.com/SAP-samples/cloud-cap-samples/blob/main/fiori). Run `cds watch`. The `Browse Genres` application and the value help for `Genres` in the `Manage Books` application use the SAP Fiori Tree Table.



### New Database Services v2

With cds9 the new major version 2 of the `@cap-js` based database services is required.

#### Assumptions for Unique Constraints

Until version 2, the database services made these assumptions:

- A violated unique constraint on `INSERT` or `UPSERT` is always the key constraint and was reported as `ENTITY_ALREADY_EXISTS` to the end user.
- A violated unique constraint on `UPDATE` is always a custom constraint and was reported as `UNIQUE_CONSTRAINT_VIOLATION` to the end user.

These assumptions are now removed. The violated unique constraint is not interpreted and treated as any other error raised by the database. If the error should be reported to the client, the database-specific errors have to be inspected and enriched in custom code.

#### Opt-in Replacement for Generic-Pool <Alpha/> {#generic-pool}

The configuration <Config>cds.requires.db.pool.builtin = true</Config> enables a built-in resource pool that improves error handling in multitenancy scenarios. Instead of a generic error `ResourceRequest timed out` the underlying error of the service manager is returned.

::: code-group
```json [package.json]
{
  "cds": {
    "features": {
      "pool": "builtin"
    }
  }
}
```
```yaml [.cdsrc.yaml]
cds:
  features:
    pool: builtin
```
:::

### Open-Sourced `cds.test`

The [test support for CAP Node.js applications](../node.js/cds-test) moved to [`@cap-js/cds-test`](https://www.npmjs.com/package/@cap-js/cds-test).  Add it to your _devDependencies_ with:

```sh
npm add -D @cap-js/cds-test
```

This package comes with dependencies that you had to maintain separately until now. So, get rid of the unnecessary dependencies and only maintain the `@cap-js/cds-test` package going forward.

```sh
npm rm axios chai chai-subset chai-as-promised
```

### Removed Features

The following features were deprecated since *cds8*, or longer, and have been removed:

| Removed Packages | Replacement |
| --- | --- |
| Legacy Protocol Adapters | The new, compatible protocol adapters are used automatically |
| Legacy Database Services | Use the new database services [from `@cap-js`](https://github.com/cap-js/cds-dbs?tab=readme-ov-file#readme) instead |
| Obsolete `@sap/cds-hana` | Use `@cap-js/hana` instead. |
| Support for Cloud SDK v3 | Use latest [`@sap-cloud-sdk` v4](https://github.com/SAP/cloud-sdk-js/blob/main/V4-Upgrade-Guide.md) |
| Support for `@sap/xssec` v3 | Use latest [`@sap/xssec` v4](https://www.npmjs.com/package/@sap/xssec) |
| `INSERT.as` | Use [`INSERT.entries` or `INSERT.from`](../node.js/cds-ql#from) instead |
| `@odata.default.order` | Add an `order by` clause to the modeled view instead. |
| `@cds.default.order` | Add an `order by` clause to the modeled view instead. |
| `srv.impl()` and `.with()` | Use [`srv.prepend()`](../node.js/core-services#srv-prepend) instead |

In addition the following compatibility options for features already deprecated in _cds8_ or longer have been removed:

| Compatibility Options | Replacement |
| --- | --- |
| `cds.fiori.draft_compat` | Use the [stable registration](../node.js/fiori#draft-support) for Draft handlers |
| `cds.features.compat_restrict_bound` | Restrict the bound action instead |
| `cds.features.compat_restrict_where` | Add a custom handler instead |
| `cds.features.stream_compat` | Adapt custom implementation to cope with streams |



### Important Changes ❗️ { #changes-in-node-js .important }

#### Changed Structure of `req.params`

[`req.params`](../node.js/events#params) now always returns an array of objects, also for entities with a single key `ID`. If you rely on the previous behavior, you can opt out with <Config>cds.features.consistent_params=false</Config>.

Assume the following HTTP request:
```http
GET /catalog/Authors(101)/books(title='Eleonora',edition=2) HTTP/1.1
```

Then `req.params` looks as follows:

```js
const [ author, book ] = req.params
// > author === { ID: 101}, was 101 before
// > book === { title: 'Eleonora', edition: 2 }
```

#### Service Level Restrictions

Local application service calls which do not satisfy the `@requires` annotation of a service are rejected. If you rely on the previous behavior, you can use the [privileged user](../node.js/authentication#privileged-user) or opt out with <Config>cds.features.service_level_restrictions=false</Config> until the next major release.


#### No Fallback to Default Language for Technical APIs

`cds.context.locale` does not fall back to the default language if no locale is specified in the incoming request. This improves the performance of database statements for technical APIs for the following reasons:

- Data is not localized in the default language.
- Data is not sorted in the default language.

If you rely on the previous behavior, you can either request the data in the default language (for example, using the `Accept-Language` header) or opt out with <Config>cds.features.locale_fallback=true</Config> until the next major release.

[Find more details on Localization.](../guides/i18n){.learn-more}

#### Revised Handling of PUT Requests

In cds8 and lower PATCH and PUT requests triggered the creation of the resource if it did not yet exist. The often used but unofficial feature flag `cds.runtime.allow_upsert` suppressed this behavior.

With cds9, the unofficial feature flag is divided into separate flags with following defaults:

| Flag                                                         | Behavior                                  | Default |
|--------------------------------------------------------------|-------------------------------------------|---------|
| <Config keyOnly>cds.runtime.patch_as_upsert = false</Config> | Create resource if it does not yet exist. | false   |
| <Config keyOnly>cds.runtime.put_as_upsert = true</Config>    | Create resource if it does not yet exist. | true    |
| <Config keyOnly>cds.runtime.put_as_replace = false</Config>  | Payload is enriched with default values.  | false   |


## Java {#cds-java}


<span id="java" />
<Fragment target="#java">

### UCL Integration <internal /> <beta />

CAP Java applications that integrate with the Unified Customer Landscape (UCL) can now leverage support for UCL´s Tenant Mapping API (that is: Service Provider Integration Interface (SPII)) to integrate with UCL formations.
By using `cds-feature-ucl` in your `pom.xml`, the CAP application automatically exposes an endpoint that fulfills the SPII API. Your application can participate in UCL formation assign or unassign notifications by defining an Event Handler that implements the logic required for the specific formation.

```java
@Component
@ServiceName(UclService.DEFAULT_NAME)
public class FormationHandler implements EventHandler {

	@On
	public void onAssign(AssignEventContext context) {
		Map<String, Object> configuration = new HashMap<>();
		// implement your specific logic and populate the configuration map


		// set the result of the assign operation
		SpiiResult result = SpiiResult.create();
		result.setConfiguration(configuration);
		result.setReady(true);
		context.setResult(result);
	}
}
```

Note that the onboarding to UCL (that is, registering a system type in UCL) is not part of this feature and needs to be done by the application separately.

[Learn more about UCL SPII Support in CAP Java](/java/integrating-applications/ucl){.learn-more}

### CDS JSON Converter API <internal /> <alpha />

CAP Java applications can now use a publicly available API to convert JSON strings to CDS data using
`CdsJsonConverter`. Instances of this interface can be configured to suit the special needs of stakeholders:

```java
CdsModel model;
CdsJsonConverter converter = CdsJsonConverter
    .build(model)
    .unknownPropertyHandling(UnknownPropertyHandling.REJECT)
    .decimalSerialization(DecimalSerialization.STRING)
    .build();
```

If it's a JSON string containing an array, JSON strings can be converted to instances of POJOs generated by the cds-maven-plugin, to plain CDS Data, or to lists of them:

```java
String bookJson;
Books book = converter.fromJsonObject(bookJson, Books.class);
CdsStructuredType booksType;
CdsData bookData = converter.fromJsonObject(bookJson, booksType);
```

CDS Data objects can be converted to JSON using the same instance:

```java
Books book;
String bookJson = converter.toJson(book);
```

</Fragment>


### Important Changes ❗️  { .important #important-changes-in-java}

This release brings the new major version CAP Java `4.0`.
In essence, it activates advanced security features by default and updates some minimum dependency versions.

::: tip
All of the changes can be consumed in the previous version `3.10.x` already which guarantees a smooth transition.
:::

[Learn more in the migration guide.](/java/migration#three-to-four){.learn-more}

The following changes are particularly worth mentioning:

New [**minimum versions**](/java/versions#dependencies-version-4) apply:

| Dependency | Minimum Version |
|------------|-----------------|
| cds-dk     | `^8`            |
| SAP Security      | `3.1`    |

Some **default behavior** has changed, most notably:

* Enabled advanced instance-based feature to check [authorizations deeply](/java/security#deep-auth)
    (<Config java label="authorization.deep">cds.security.authorization.deep.enabled: true</Config>).
* Enabled advanced instance-based feature to reject entity selections with `forbidden` (`403`) accordingly
    (<Config java label="rejectSelectedUnauthorizedEntity">cds.security.authorization.instanceBased.rejectSelectedUnauthorizedEntity.enabled: true</Config>).
* Enabled advanced instance-based feature to check [input data](/java/security#input-data-auth)
    (<Config java label="checkInputData">cds.security.authorization.instanceBased.checkInputData.enabled: true</Config>).
* Translations from the framework's default language bundle are used
    (<Config java label="defaultTranslations">cds.errors.defaultTranslations.enabled: true</Config>).


Removed some **deprecated properties**:

| Feature  | Removed Property | Recommendation
| ---      | ---         | --- |
| Structured messages in Messaging API | `cds.messaging.services.<key>.structured` | [Use structured messages only](/java/migration#removed-unstructured) |
| Unrestricted XSUAA attributes | <Config java label="emptyAttributeValuesAreRestricted">cds.security.authorization.emptyAttributeValuesAreRestricted</Config> | [Model unrestricted XSUAA attributes explicitly in the condition](../guides/security/authorization#user-attrs) |
| Event Hub Plugin | module `cds-feature-event-hub` | Use [CDS Plugin for SAP Cloud Application Event Hub](https://github.com/cap-java/cds-feature-event-hub) (same artifact and group ID) |
| SMS certificate header | <Config java label="cds.multiTenancy...clientCertificateHeader">cds.multiTenancy.subscriptionManager.clientCertificateHeader</Config> | Use <Config java>cds.security.authentication.clientCertificateHeader</Config> instead |
| Goal `cds-maven-plugin:generate` | `sharedInterfaces` and `uniqueEventContexts` | adapt custom code accordingly |


Stay up to date and benefit from latest and greatest features by migrating to `4.0`! Find a step-by-step instruction to upgrade in the [migration guide](/java/migration#three-to-four).

:::warning
* cds-services `3.10.x` is now in [maintenance](./schedule#maintenance-status) mode and **only receives critical bugfixes**.
* All versions < `3.10.x` have reached [end of live](./schedule#end-of-life-status) and **won't be patched anymore**.
:::


## Tools { #tools}

### Richer Tooltips in CDS Editor

When hovering over a [CDS built-in type](../cds/cdl#built-in-types), you get detailed documentation for it:

![Screenshot of the CDS editor displaying a tooltip for the built-in type String. The tooltip provides detailed documentation, including the type name String, its description Text of arbitrary length, and additional information about its usage and constraints. The editor interface is clean and modern, with a focus on accessibility and clarity. The overall tone is informative and supportive, helping users understand the built-in type in context.](assets/may25/lsp-explainBuiltinTypes.png){width=95% .ignore-dark}

Likewise, for [specific compiler errors](../cds/compiler/messages), extended documentation is shown on hover:

![Screenshot of the CDS editor displaying a tooltip that explains a compiler error message. The tooltip provides detailed information about the error, including the error code, a description, and suggested actions to resolve the issue. The editor interface is modern and user-friendly, with a focus on accessibility and clarity. The overall tone is informative and supportive, helping users understand and fix compiler errors efficiently. Text in the image includes: Compiler messages explained.](assets/may25/lsp-explainCompilerMessage.png){width=95% .ignore-dark}


### Compact Formatting of `case` Expressions

To reduce vertical space, the CDS Code Formatter now omits line breaks after `when`, `then` or `else` in `case` expressions. It also aligns the `then` keyword with `when` arguments to improve visual structuring. Also, sub-expressions after `and` and `or` are now aligned with each other for better readability:

Compare old vs. new:

<div class="cols-2">


```cds
... case
      when
        (
          metric_a     >  12
          or metric_b  >= 5000
          and metric_c <  3
        )
        and category   = 'PREMIUM'
        or status_flag = 'ACTIVE'
      then
        'High priority'
      when
        state            =  'ACTIVE'
        and rating_value >= 4
        or quality_score >  8
      then
        'Standard priority'
      else
        'Low priority'
    end;
```

<br>


```cds
... case
      when (
            metric_a     >  12
            or  metric_b >= 5000
            and metric_c <  3
          )
          and category      =  'PREMIUM'
          or  status_flag   =  'ACTIVE'
          then 'High priority'
      when state             =  'ACTIVE'
          and rating_value  >= 4
          or  quality_score >  8
          then 'Standard priority'
      else 'Low priority'
    end;
```
</div>

The new formatting option `boolOpsAtLineEnd` enables you to position Boolean operators at the end of a line instead of at the start:


```cds
when contract_renewal_status     = 'PENDING' and
      subscription_duration_days > 180 and
      (
        customer_satisfaction_score >= 8 or
        loyalty_program_tier        =  'GOLD'
      )
```

### Miscellaneous  {#tools-misc}

#### ESLint 9 Required

Package `@sap/eslint-plugin-cds` 4 now requires ESLint 9. To migrate your ESLint 8 configuration to ESLint 9, follow the [official migration guide](https://eslint.org/docs/latest/use/migrate-to-9.0.0).

Also, `cds lint` now requires package `eslint` to be installed as an application dependency and is no longer bundled with `@sap/cds-dk`. Run `npm add -D eslint` to install it.

#### Removed Legacy Build Configuration

`cds build` no longer supports the undocumented legacy build configurations through <Config keyOnly>cds.data={"model":"...cds"}</Config> and <Config keyOnly>cds.service={"model":"...cds"}</Config>. To migrate, first check if the build defaults are ok by removing these properties.  Otherwise, see the page on [build configuration](../guides/deployment/custom-builds#properties) for how to configure build tasks, especially the `model` property.

`--clean` is no longer a supported `cds build` argument. The build output folder is always cleaned anyway.

## Multitenancy {#cds-mtxs}

### Important Changes ❗️ { #changes-in-multitenancy .important }

#### Configuration

- Configuration `cds.mtx` is no longer supported. <br/> → Use the [Extensibility Service Configuration](../guides/multitenancy/mtxs#extensibility-config) instead.
- Legacy extensibility configuration (`entity-whitelist`, `service-whitelist`, `namespace-blacklist`) will cause an error. <br/> → Use the [Extensibility Service Configuration](../guides/multitenancy/mtxs#extensibility-config) instead.
- Old `cds.xt.DeploymentService` configuration for HANA container creation `hdi.create.provisioning_parameters.<parameter>` is no longer supported. <br/> → Use [`hdi.create.<parameter>`](../guides/multitenancy/mtxs#deployment-config) instead.
- The MTX Sidecar now always uses the compiler settings (`cds.cdsc`) of the root project to ensure consistent compilation without the need to replicate the root compiler settings into the MTX Sidecar configuration.

#### Java Setup
- If you get the message 'Invalid MTX sidecar configuration', you need to add the dependency to `@sap/cds-mtxs` also to the `package.json` in your project _root_. This is a known, temporary issue in `@sap/cds-mtxs@3`.

#### Extensibility
- The default for extension validation has been changed. The extension validation now always checks all existing extensions instead of only the extension with the ID to be uploaded.
- The application base model downloaded using [`cds pull`](../guides/extensibility/customization#pull-base) will also contain all existing extensions except the one implemented in the current extension project.

## CAP Plugins

### SAP Cloud Application Event Hub { #eh }

Distribute business events across the SAP cloud landscape by integrating your CAP application with [SAP Cloud Application Event Hub](https://help.sap.com/docs/sap-cloud-application-event-hub/sap-cloud-application-event-hub-service-guide/what-is).

![Illustration showing the SAP Cloud Application Event Hub logo centered on a blue background with interconnected nodes radiating outward, symbolizing event distribution across cloud applications. The environment is clean and modern, conveying a sense of connectivity and technological innovation. No visible text is present in the image. The tone is professional and forward-looking.](assets/may25/eh.png){width=40%}

The integration is provided by the open-source plugins [`@cap-js/event-broker`](https://github.com/cap-js/event-broker) for Node.js and [`com.sap.cds:cds-feature-event-hub`](https://github.com/cap-java/cds-feature-event-hub) for Java.

[Find more details in the Plugins page entry.](../plugins/#event-hub){.learn-more}

### SAP Integration Suite, Advanced Event Mesh <Beta /> { #aem }

[SAP Integration Suite, advanced event mesh](https://www.sap.com/products/technology-platform/integration-suite/advanced-event-mesh.html) enables applications to engage in real-time asynchronous communication across distributed environments using a fully managed cloud service designed for event-driven architectures.

![SAP Integration Suite Advanced Event Mesh logo centered on a light blue background with interconnected lines and nodes radiating outward, symbolizing real-time asynchronous communication and event-driven architecture. The environment is clean and modern, conveying a sense of connectivity and technological innovation. No visible text is present in the image. The tone is professional and forward-looking.](assets/may25/aem.png){width=90%}

The open-source plugins [`@cap-js/advanced-event-mesh`](https://github.com/cap-js/advanced-event-mesh) for Node.js and [`com.sap.cds:cds-feature-advanced-event-mesh`](https://github.com/cap-java/cds-feature-advanced-event-mesh) for Java provide out-of-the-box support.

[Find more details in the Plugins page entry.](../plugins/#advanced-event-mesh){.learn-more}


## Microservices with CAP

Here's a new [guide](../guides/deployment/microservices) that shows how to deploy multiple Node.js CAP applications, which share one database schema. The guide is based on the collection of sample applications at [cap-samples](https://github.com/SAP-samples/cloud-cap-samples?tab=readme-ov-file#welcome-to-capsamples).

![Diagram illustrating a microservices architecture for a bookstore application](../@external/guides/deployment/assets/microservices/bookstore.excalidraw.svg)

<div id="secondary-file">releases/may25.fragment.md</div>


# April 2025



## Prepare for Major Release

Along with new features, the next major release CDS 9 will contain some changes that you'll need to react on.
You can do this already **now**, which eases the transition. You can't use the mentioned **deprecated functions** with the CDS 9 release. The corresponding compatibility flags won't be respected any longer.

See [CDS Language & Compiler](#cds) and [Node.js](#cds-js).

<span id="internalnote" />
<Fragment target="#internalnote">

:::tip Internal: Major release notes

In addition to already announced changes that you can find in public release notes, also start to read the, still work in progress, release note for our upcoming major release:

[==> **Major / May 2025**](./may25.md)

:::

</Fragment>

## CDS Language & Compiler {#cds}

In preparation for the upcoming major release, [**switch on** the new CDS parser.](archive/2025/feb25#new-parser)

## Node.js {#cds-js}

Use this month to get prepared for the upcoming major release. Here's are the things you can and should already enable and test:

- [**Upgrade to** `@sap/xssec 4`.](archive/2025/jan25#upgrade-to-sapxssec-4) _--> remove compat flag_
- [**Adapt to changed behavior** when processing `@restrict.where` checks.](archive/2024/dec24#consolidated-authorization-checks)
- [**Adopt** @cap-js database services now.](archive/2024/jun24#new-database-services-ga)
- [**Switch on** the new protocol adapters.](archive/2024/jun24#new-protocol-adapters-ga) _--> remove compat flag_
- [**Switch on** lean draft.](archive/2024/jun24#lean-draft) _--> remove compat flag_
- [**Migrate** ESLint Configuration](archive/2025/feb25#migrate-eslint-configuration)
- [**Add** Test Support Package](archive/2025/feb25#add-test-support-package)


## Java {#cds-java}

### Optimized Outbox
Technical [Outbox Service](../java/outbox#persistent) offers CAP applications a generic API to emit events to (Remote) CDS Services in a resilient way.
By default, CAP auditlog and messaging events are sent via the Outbox.
The internal Outbox processing is now optimized to serve high-scale load profiles across many tenants using task queues internally.
As a consequence, the persistence of a tenant's outbox only needs to be queried when needed, and resource consumption is significantly reduced due to the massively reduced DB connection usage.

To benefit from the task-based Outbox processing, you need to explicitly set <Config java>cds.taskScheduler.enabled: true</Config>.
In future versions of CAP Java, the optimized Outbox will be enabled by default.

<span id="java-flows" />
<Fragment target="#java-flows">

### State Transition Flows <Internal/> <Alpha/>

The new feature `cds-feature-flow` supports typical state transition flows in your business application.
For instance, think of an approval flow for an `Orders` entity with several states as outlined in the following diagram:

![A diagram showing the state transitions of an Order, including states like Open, Approved, Placed, and Canceled, with arrows indicating valid transitions.](assets/april25/orders-flow.svg){width=50%}

This flow can be explicitly defined in the application's CDS model:

```cds
type OrderStatus : String enum {Open; Approved; Placed; Canceled;}

entity Orders {
  @flow.status
  @readonly status : OrderStatus default 'Open';
  // [...]
} actions {
  @(flow : {from: ['Open'], to: 'Approved' })
  action approve();
  @(flow : {from: ['Approved'], to: 'Open' })
  action reopen();
  @(flow : {from: ['Approved'], to: 'Placed' })
  action place();
  @(flow : {from: ['Open', 'Approved'], to: 'Canceled' })
  action cancel();
};
```

The annotation `@flow.status` is used to mark an entity field that represents a flow status containing enum values such as `Open`, `Approved` and so on. Using `@flow.from` and `@flow.to`, you model valid state transitions on bound actions according to the business flow graph.

For example, when an `approve` action is triggered, the plugin validates the current status (for example, `Open`) and transitions it to the target status (`Approved`) automatically, ensuring that the application logic adheres to the defined state transitions.

[Learn more about CAP Java Flows](/java/flows){.learn-more}

</Fragment>

<span id="java-assert-constraints" />
<Fragment target="#java-assert-constraints">

### Assert Constraints <Internal/> <Alpha/>

You can use model [assertions](../guides/providing-services#input-validation) to benefit from generic input validation.
The latest version of CAP Java supports new assertion `@assert.constraint`, which allows you to model advanced constraints involving multiple fields, such as ensuring logical relationships or dependencies between them:

```cds
@assert.constraint.deliveryDates: {
    condition: (deliveryEarliest < deliveryLatest),
    message: 'ORDER_DELIVERY_DATES_UNORDERED',
    targets: [(deliveryEarliest), (deliveryLatest)]
}
entity Orders {
  deliveryEarliest : Date;
  deliveryLatest : Date;
  // [...]
}
```

In the example, the constraint `deliveryDates` ensures ordered input for `deliveryEarliest` and `deliveryLatest` in `INSERT` and `UPDATE` queries.
If the constraint is violated (`deliveryEarliest` is later than `deliveryLatest`), an error message with the key `ORDER_DELIVERY_DATES_UNORDERED` is generated targeting the involved fields.
This key is typically configured in the application's i18n files or error message catalog to provide a user-friendly error description.

`@assert.constraint` helps you to minimize custom handler code for validations.

::: tip
You can conveniently annotate a single field with `@assert.constraint` without specifying the `targets` property.
:::

[Learn more about `@assert.constraint`.](/guides/providing-services#assert-constraint){.learn-more}

</Fragment>

<span id="java-dynamic-validation" />
<Fragment target="#java-dynamic-validation">

### Dynamic Validations <Internal/> <Alpha/>

Sometimes, input validation rules need to be adjusted based on specific conditions.
To support such scenarios, CAP Java provides the capability to define the annotations `@mandatory` and `@readonly` dynamically, on basis of [compiler expressions](../cds/cdl#expressions-as-annotation-values), which are conditional expressions evaluated at runtime. For example, `@readonly: (status <> 'Open')` ensures that a field is read-only unless the status is `Open`.
For instance in the sample entity `Orders`, mode `diffBillingAddress` can only be set in `Open` state.
Similarly, the field `billingAddress` becomes mandatory in `diffBillingAddress` mode:

```cds
type OrderStatus : String enum {Open; Approved; Placed; Canceled; }

entity Orders {
    @readonly
    status : OrderStatus default 'Open'; // modified by actions

    @readonly: (status <> 'Open')
    diffBillingAddress: Boolean default false;

    @mandatory: (diffBillingAddress)
    billingAddress: String;
}
```

Note that dynamic field control is also required for UI services in addition to the runtime's dynamic validation.
The `@Common.FieldControl` annotation is used to control the behavior of fields in the UI, such as making them mandatory or optional based on specific conditions.
For instance, depending on the address mode, `billingAddress` needs to be mandatory in the UI:

```cds
// 7: Mandatory / 3: Optional
annotate Orders.billingAddress with @Common.FieldControl: (diffBillingAddress ? 7 : 3);
```

[Learn more about Input Validation.](/guides/providing-services#input-validation){.learn-more}

</Fragment>

<span id="java-cf-profiler" />
<Fragment target="#java-cf-profiler">

### CAP Java Profiling on CF <Internal/>

Starting with version 17, [SapMachine](https://sap.github.io/SapMachine/) contains [Async Profiler](https://github.com/async-profiler/async-profiler?tab=readme-ov-file#async-profiler) as integrated profiling backend.
The [Java Plugin](https://github.com/SAP/cf-cli-java-plugin) for the [Cloud Foundry CLI](https://github.com/cloudfoundry/cli) tool now provides a convenient way to profile CAP Java applications in this environment.
On JVM level, it allows to analyse and track down the following:

- Performance bottlenecks
- (IO-) waiting times
- Extraordinary memory consumption and massive object allocations
- Lock contentions

The plugin also provides capture thread and heap dumps locally.
All you need to capture profiling data is an active `cf` session with a running instance of your applications.

![Ths graphic shows a Flamegraph, a visualization of CPU consumption.](assets/april25/asprof-flamegraph.png){width=100%}

::: tip
Async Profiler can also be used on SAP BTP, Kyma Environment.
:::

[Learn more about CAP Java supportability](/java/operating-applications/optimizing#cloud-foundry-command-line-java-plugin){.learn-more}

</Fragment>

### Remote OData Singletons

CAP Java now supports consuming _singleton_ instances from remote OData services during remote service consumption. This is particularly useful for scenarios where a single, globally shared entity needs to be accessed. For example, `OverallStatus` could represent the health status of an entire system:

```xml
<edmx:Edmx Version="4.0" xmlns:edmx="http://docs.oasis-open.org/odata/ns/edmx">
  <edmx:DataServices>
      <EntityContainer Name="EntityContainer">
        <Singleton Name="OverallStatus" Type="health.OverallStatus"/> 
      </EntityContainer>
      <EntityType Name="OverallStatus">
        <Key>
          <PropertyRef Name="id"/>
        </Key>
        <Property Name="id" Type="Edm.Int32" Nullable="false"/>
        <Property Name="status" Type="Edm.String"/>
      </EntityType>
    </Schema>
  </edmx:DataServices>
</edmx:Edmx>
```

This EDMX model defines the singleton `OverallStatus`. It can now be accessed using remote service consumption as usual:

```java
CqnSelect selectStatus = Select.from(OVERALL_STATUS);
OverallStatus status = remoteService.run(selectStatus).single(OverallStatus.class);
```

### Enhanced Search

The `@Common.Text` annotation allows you to specify a property that holds a text to be displayed on the UI instead of the value of the annotated property. To enhance the user experience, the property that holds the display text is now searched by default:

```cds
entity Books : cuid {
title  : String;
@Common.Text : author.name
author : Association to Authors;
}
entity Authors : cuid {
name : String;
}
```

Here the value of the `name` property of the `Authors` entity is displayed instead of the `author` association and is now also searched automatically, without requiring additional configuration.


### To-many Expand on Subqueries

You can now expand to-many associations from [subqueries](../java/working-with-cql/query-api#from-select) if the association is selected implicitly via select all in the inner query:

```java
CqnSelect authorsUnder40 = Select.from(AUTHORS)
   .excluding(a -> a.placeOfBirth())
   .where(a -> a.age().lt(40));
Select.from(authorsUnder40).columns(
    a -> a.get("name"),
    a -> a.to("books").expand("title"));
```

### New Functions in CDS QL

The following new functions are now supported by CDS QL in CAP Java:

#### Arithmetic Functions

* round
* floor
* ceiling

#### String Functions

* length
* indexof (zero-based)
* trim

The functions are available on the `Value` interface as well as on the `CQL` helper class. Examples:

```java
CqnSelect booksWithShortTitle = Select.from(BOOKS).where(b -> title().length().lt(10));
CqnSelect averagePriceRoundedByGenre = Select.from(BOOKS)
    .columns(b -> b.genre().name(), b.price().avg().round())
    .groupBy(b -> b.genre().name());
```

The functions are implemented in a database-agnostic way with semantics aligned with OData v4:
* [Arithmetic Functions](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31361011)
* [String Functions](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31360991)

### Miscellaneous
* The `Result.rowType()` method, which returns the structured type of each row of a query result, is now also supported for insert, upsert, and update results.
* Expands from and to entities with aliased keys are now also supported.


## CAP Plugins

<span id="ams-local" />
<Fragment target="#ams-local" type="">

### AMS Local Testing <Internal/>

CAP is tightly integrated with Authorization Management Service (AMS) which allows user administrators to recombine base policies provided by the application and assign them to business users.
With the latest release of the AMS plugins, AMS policies can be assigned to mock users for local testing:

::: code-group

```yaml [Java (application.yaml)]
mock:
  users:
    MyTestUser:
      policies:
        - "cap.SalesAuditor"
        - "local.SalesManager_EMEA"
```

```json [Node.js (.cdsrc.json)]
 "requires": {
        "auth": {
            "[development]": {
                "kind": "mocked",
                "users": {
                    "alice": {
                        "policies": [
                            "cap.SalesAuditor",
                            "local.SalesManager_EMEA"
                        ]
                    }
```

:::

::: details In CAP Java an additional maven plugin is required to compile the policies in the local project

::: code-group

```xml [srv/pom.xml]
<plugin>
 <groupId>com.sap.cloud.security.ams.client</groupId>
 <artifactId>dcl-compiler-plugin</artifactId>
 <version>${sap.cloud.security.ams.version}</version>
 <executions>
    <execution>
   <id>compile</id>
   <goals>
    <goal>compile</goal>
   </goals>
   <configuration>
        <sourceDirectory>${project.basedir}/src/main/resources/ams</sourceDirectory>
    <dcn>true</dcn>
    <dcnParameter>pretty</dcnParameter>
    <compileTestToDcn>true</compileTestToDcn>
   </configuration>
  </execution>
 </executions>
</plugin>
```

:::

CDS tooling also allows to conveniently add the required dependencies:

```sh
cds add ams
```

[Learn more about CAP AMS integration in Java](/java/ams){.learn-more}
[Learn more about CAP AMS integration in Node.js](https://www.npmjs.com/package/@sap/ams#cap-integration){.learn-more}

</Fragment>

### Attachments: Multitenancy

[@cap-js/attachments](https://github.com/cap-js/attachments) now supports multitenancy with both shared and tenant-specific object store instances. By default, the plugin uses a separate object store instance for each tenant to ensure complete data isolation.

The tenant-specific object store instance scenario is sketched in the following figure:

![Attachments - Multitenancy Separate Mode](assets/april25/attachments-mtx.drawio.svg){width=600px}

### Change Tracking: Multitenancy

[@cap-js/change-tracking](https://github.com/cap-js/change-tracking) now supports multitenancy and extensibility using MTX-S sidecar deployments.


<span id="guide-shared" />
<Fragment target="#guide-shared" type="">

## Guides { #guides}

### Microservices with shared database

New [guide](../guides/deployment/microservices) that shows how to deploy multiple node.js CAP applications sharing one database schema. Based on the collection of sample apps at [cap-samples](https://github.com/SAP-samples/cloud-cap-samples?tab=readme-ov-file#welcome-to-capsamples).

![multiple applications with a shared database, utilizing remote service calls and events](../@external/guides/deployment/assets/microservices/bookstore.excalidraw.svg)


</Fragment>

<div id="secondary-file">releases/apr25.fragment.md</div>


# Archive of Former Releases

- [Parts of 2025](2025/)
- [All of 2024](2024/)
- [All of 2023](2023/)
- [All of 2022](2022/)
- [All of 2021](2021/)
- [All of 2018-2019](18-19)



# Parts of 2025



<br>
<IndexList :pages='pages' />



# March 2025



## Prepare for Major Release

Along with new features, the next major release CDS 9 will contain some changes that you'll need to react on.
For the items listed below, you can do this already **now**, which eases the transition. You can't use the mentioned **deprecated functions** with the CDS 9 release. The corresponding compatibility flags won't be respected any longer.

- [**Migrate** ESLint Configuration](feb25#migrate-eslint-configuration)
- [**Add** Test Support Package](feb25#add-test-support-package)
- [**Switch on** the new CDS parser.](feb25#new-parser)
- [**Upgrade to** `@sap/xssec 4`.](jan25#upgrade-to-sapxssec-4) _--> remove compat flag_
- [**Switch on** OData containment.](../2024/dec24#odata-containment)
- [**Adapt to changed behavior** when processing `@restrict.where` checks.](../2024/dec24#consolidated-authorization-checks)
- [**Adopt** @cap-js database services now.](../2024/jun24#new-database-services-ga)
- [**Switch on** the new protocol adapters.](../2024/jun24#new-protocol-adapters-ga) _--> remove compat flag_
- [**Switch on** lean draft.](../2024/jun24#lean-draft) _--> remove compat flag_

## CDS Language & Compiler {#cds}

### New Parser

Switch over to the new parser already now.
Set option <Config showPrivate>cds.cdsc.newparser: true</Config> in your private `~/.cdsrc.json` to switch on
the new parser on your local machine. Switch it on in your project's development and test pipelines.
If that's successful, use it in production.

### Actions in Composition of Aspects

Actions and functions of a CDS aspect are now available in the generated child entity when defining a composition of aspect.

In this example, the compiler-generated child entity `Orders.items` has an action `close`:

```cds
aspect Item {
  key id : String;
} actions {
  action close(); // [!code highlight]
};

entity Orders {
  key id : String;
  items: Composition of Item; // [!code highlight]
};
```

[Learn more about the composition of aspects.](/cds/cdl#managed-compositions ){.learn-more}


## Node.js {#cds-js}

### Recursive Hierarchies and Fiori Tree Table Support <Beta />

CAP Node.js now supports [Recursive Hierarchies](https://sap.github.io/odata-vocabularies/vocabularies/Hierarchy.html) with OData v4 on SAP HANA Cloud, allowing to serve read requests for the [SAP Fiori Tree Table](https://experience.sap.com/fiori-design-web/tree-table/), including sort, filter, and search on hierarchical data.

<video src="./assets/mar25/tree-view-node_compressed.mp4" autoplay loop muted webkit-playsinline playsinline alt="Video demonstrating a nested tree in an SAP Fiori Elements application, incl. expanding, collapsing and searching for elements" class="bright"/>

You can try it out in our [bookshop sample for SAP Fiori](https://github.com/SAP-samples/cloud-cap-samples/blob/main/fiori). Simply run
- `cds deploy -2 hana --production`
- `cds watch --profile hybrid`

The `Browse Genres` app as well as the value help for `Genres` in the `Manage Books` app use the SAP Fiori Tree Table.

[Find more technical details in the OData Guide.](/advanced/odata#hierarchical-transformations){.learn-more}


## Java {#cds-java}

### Log CDS Configuration

Upon start-up, you can now get an overview of the configured [CDS properties](/java/developing-applications/properties). Turn on by setting the log level for `com.sap.cds.properties` to `DEBUG` in the _application.yaml_ file:

::: code-group
```yaml [srv/src/main/resources/application.yaml]
logging:
  level:
    com.sap.cds.properties: DEBUG  # [!code highlight]
```
:::

::: details Sample output:

```sh
... DEBUG ... com.sap.cds.properties : 'cds.dataSource.autoConfig.enabled': 'false' (default: 'true')
... DEBUG ... com.sap.cds.properties : 'cds.dataSource.embedded': 'true' (default: 'false')
...  WARN ... com.sap.cds.properties : 'cds.security.authorization.emptyAttributeValuesAreRestricted': 'false' (default: 'true', deprecated, not documented)
... DEBUG ... com.sap.cds.properties : 'cds.security.mock.users.admin.name': 'admin'
... DEBUG ... com.sap.cds.properties : 'cds.security.mock.users.admin.password': '***' (sensitive)
... DEBUG ... com.sap.cds.properties : 'cds.security.mock.users.admin.roles[0]': 'admin'
... DEBUG ... com.sap.cds.properties : 'cds.security.mock.users.admin.roles[1]': 'cds.Developer'
... DEBUG ... com.sap.cds.properties : 'cds.security.mock.users.admin.attributes.businessPartner[0]': '10401010'
... DEBUG ... com.sap.cds.properties : 'cds.odataV4.endpoint.path': '/api' (default: '/odata/v4')
... DEBUG ... com.sap.cds.properties : 'cds.errors.defaultTranslations.enabled': 'true' (default: 'false')
```
:::

### Miscellaneous

* Subscription dependencies for _portal_ and _html5-apps-repo_ are automatically created if the corresponding service is bound to the CAP Java application.
* The result of the execution of a `CqnUpsert` statement now provides an [entity reference](/java/working-with-cql/query-execution#entity-refs) to the upserted entity via the `Row.ref()` method.



## Multitenancy {#cds-mtxs}

### Extension Drafts <Beta/>

The API [`PUT /-/cds/extensibility/Extensions/<id>`](/guides/multitenancy/mtxs#put-extensions) can now be used to upload extensions as drafts. This allows to trigger the upload, validation, and activation of extensions separately.

Example:
```http [Request]
PUT /-/cds/extensibility/Extensions/isbn-extension HTTP/1.1
Content-Type: application/json

{
  "csn": ["using my.bookshop.Books from '_base/db/data-model';
           extend my.bookshop.Books with { Z_ISBN: String };"],
  "i18n": [{ "name": "i18n.properties", "content": "Books_stock=Stock" },
           { "name": "i18n_de.properties", "content": "Books_stock=Bestand" }],
  "status": 1 // draft = 1, activation = 2 [!code highlight]
}
```
This request adds an extension with `ID` `isbn-extension` as draft. It will not be publicly visible and necessary changes are not deployed to the database.
```http [Request]
POST /-/cds/extensibility/validate HTTP/1.1
Content-Type: application/json

{
  "ID": "isbn-extension"
}
```
This request validates the extension with `ID` `isbn-extension`.
```http [Request]
POST /-/cds/extensibility/Extensions/activate HTTP/1.1
Content-Type: application/json

{
  "ID": "isbn-extension",
  "status": 2 // target status 2 = activation [!code highlight]
}
```


This request promotes the extension with `ID` `isbn-extension` to status `2`, making it visible to everyone and applying any necessary changes to the database. Note that `2` is the default value for `status`, so it can be omitted if the goal is to make extensions publicly visible.

Please note: `status` was `level` in the first version of the API.

## Tools { #tools}

### Deployment With `cds up` <Beta /> {#cds-up}

Given you have fulfilled the prerequisites for [Cloud Foundry](/guides/deployment/to-cf#prerequisites) or [Kyma](/guides/deployment/to-kyma#prerequisites) deployments, a new command allows for a simpler way to build and deploy CAP applications:

```sh
cds up
```

This deploys your CAP app to Cloud Foundry by default.

::: details Essentially, this command automates the following steps...

```sh
# Depending on your deployment method...
cds add mta # Cloud Foundry
cds add helm,containerize # Kubernetes

# Installing app dependencies, e.g.
npm i app/browse
npm i app/admin-books

# If project is multitenant
npm i --package-lock-only mtx/sidecar

# If package-lock.json doesn't exist
npm i --package-lock-only

# Final assembly and deployment...

### Cloud Foundry
mbt build -t gen --mtar mta.tar
cf deploy gen/mta.tar -f

### Kyma/Kubernetes, e.g.
ctz containerize.yaml --log --push
helm upgrade --install bookshop ./gen/chart --wait --wait-for-jobs --set-file xsuaa.jsonParameters=xs-security.json
kubectl rollout status deployment bookshop-srv --timeout=8m
kubectl rollout status deployment bookshop-approuter --timeout=8m
kubectl rollout status deployment bookshop-sidecar --timeout=8m
```

:::

For Kyma (Kubernetes), simply run:

```sh
cds up --to k8s
```

### Initial Type Generation With `cds watch`

[`cds-typer`](/tools/cds-typer) is now run once by `cds watch`.
This is useful for newly cloned projects to generate the model types initially. For example, model imports like this no longer error out at startup:

::: code-group
```js [srv/cat-service.js]
const { Books } = require('#cds-models/sap/capire/bookshop')
```
:::

Manual invocations, like `npx cds-typer`, are no longer needed for this local scenario but still relevant for CI workflows, though.

### Ad-hoc SAP HANA Deployment on Kyma

[`cds deploy --to hana`](/guides/databases-hana#cds-deploy-hana) is now also supported for Kubernetes:

```sh
cds deploy --to hana:<binding or secret name> --on k8s
```

> Omitting the binding or secret name creates a new HDI container and binding called `<appName>-db-binding`.



# February 2025


## Prepare for CDS 9

Along with new features, the next major release CDS 9 will contain some changes that you'll need to react on.
For the items listed below, you can do this already **now**, which eases the transition. You can't use the mentioned **deprecated functions** with the CDS 9 release. The corresponding compatibility flags won't be respected any longer.

> This section will be a regular part of all upcoming release notes and includes links to all changes relevant to the next major release.

### Migrate ESLint Configuration

ESLint v8 was [officially discontinued in October 2024](https://eslint.org/version-support/). To migrate your ESLint v8 configuration to ESLint v9, follow the [official migration guide](https://eslint.org/docs/latest/use/migrate-to-9.0.0).

Starting with CDS 9, [`cds lint`](/tools/cds-lint/) will only support ESLint v9.

### Add Test Support Package

With CDS 9, package `@cap-js/cds-test` will be required for tests to run.  You can use it already now with `npm add -D @cap-js/cds-test`.

[Learn more about the new package.](#cds-test){.learn-more}

### Remove Compat Flags and Enable `@sap/cds 9` Features

- [**Switch on** the new CDS parser.](#new-parser)
- [**Upgrade to** `@sap/xssec 4`.](jan25#upgrade-to-sapxssec-4) _--> remove compat flag_
- [**Switch on** OData containment.](../2024/dec24#odata-containment)
- [**Adapt to changed behavior** when processing `@restrict.where` checks.](../2024/dec24#consolidated-authorization-checks)
- [**Adopt** @cap-js database services now.](../2024/jun24#new-database-services-ga)
- [**Switch on** the new protocol adapters.](../2024/jun24#new-protocol-adapters-ga) _--> remove compat flag_
- [**Switch on** lean draft.](../2024/jun24#lean-draft) _--> remove compat flag_

## CDS Language & Compiler {#cds}

### New Parser

The new CDS parser is now available, and you should start using it.

Switching to the new parser reduces installation times and speeds up parsing. It also enhances code completion. Additionally, some new features are only supported with the new parser.

Roadmap:

| Date   | Status                   | Remarks                                                |
| ------ | ------------------------ | ------------------------------------------------------ |
| Feb 25 | Released                 | opt-in usage; default still with old parser            |
| May 25 | Used by default          |                                                        |

> [!tip] The new parser doesn't come with any breaking changes...
>
> ... and is fully compatible with the old parser. Enable it now as follows:
>
> - Set option <Config showPrivate>cds.cdsc.newparser: true</Config> in your private `~/.cdsrc.json` to switch on the new parser on your local machine.
> - Switch it on in your project's development and test pipelines.
> - If that's successful, use it in production.

#### New CDS Parser Support in VS Code

The new version of our [CDS plugin for VS Code](/tools/cds-editors#vscode) is able to use the [new CDS parser](./jan25#reminder-new-parser). For the current minor release, though, the default remains to use the old parser. You can switch via the user setting [`cds.compiler.useOldParser`](vscode://settings/cds.compiler.useOldParser). Please report any issues.

### Type as Projection

Define a structured type as a projection on another structured type, entity, aspect, or event,
where you pick only a subset of elements.


```cds
entity Name {
  firstName  : String @label: '...';
  middleName : String @label: '...';
  lastName   : String @label: '...';
  initials   : String @label: '...';
  title      : String @label: '...';
}

type ShortName : projection on Name {
  firstName,
  lastName
};
```


> [!tip]
> Only available with the new parser via option <Config showPrivate>cds.cdsc.newparser: true</Config>.

[Learn more about type projections.](/cds/cdl#structured-types){.learn-more}


### Use Enums Like Constants

Instead of using literals, enum symbols defined in CDS can be used where the compiler can deduce the corresponding enum type. See the following example:

```cds
type Status : String enum { open; closed; in_progress; };
entity Order {
  key id : Integer;
  status : Status default #open; // [!code highlight]
}
entity OpenOrder as projection on Order {
  id,
  (status = #in_progress ? 'is in progress' : 'is open') // [!code highlight]
    as status_txt : String,
} where status = #open or status = #in_progress; // [!code highlight]
```

[Learn more about Enums.](/cds/cdl#enums){.learn-more}

### Annotating Managed Associations <Beta />

When you annotate a managed annotation with an [expression-valued annotation](/cds/cdl#expressions-as-annotation-values),
the annotation is now automatically copied to the respective foreign key elements in the OData API generation.

Previously, the copy mechanism has only been applied for non-expression annotations.

In the following example, the annotation is also applied to the generated foreign key element `author_ID` of `Books`:
```cds
entity Authors { key ID : Integer; name : String; }
entity Books   { author : Association to Authors; }

annotate Books:author with @Common.Text: (author.name); // [!code highlight]
```


## Node.js {#cds-js}

### Media Data in Actions and Functions

Media data like images, CSVs, and so on, can now also be used as a return type of actions and functions. The same set of [media data annotations](/guides/providing-services#annotating-media-elements) is supported.

```cds
@(Core.MediaType: 'text/csv', Core.ContentDisposition.Filename: 'Books.csv')
type csv:  LargeBinary;
entity Books { ... } actions {
  function csvExport () returns csv;
}
```

```js
this.on('csvExport', req => {
  return new Readable() // the csv stream
})
```

In addition, `req.reply` can be used to set the mime type and filename dynamically.

```js
this.on('csvExport', req => {
  req.reply(new Readable(), { mimetype, filename })
})
```

[Learn more about media streaming in general.](/guides/providing-services#serving-media-data){.learn-more}
[Learn more about media streaming in custom handlers.](/node.js/best-practices#custom-streaming-beta){.learn-more}

### Hints on SAP HANA

The new [`SELECT.hints`](/node.js/cds-ql.md#hints) method of the [`cds.ql`](/node.js/cds-ql.md) API passes hints to the database query optimizer that can influence the execution plan.

```js
SELECT ... .hints('IGNORE_PLAN_CACHE', 'MAX_CONCURRENCY(1)')
```

::: info SAP HANA only
Hints are only respected by the SAP HANA database service.
:::

### New Package for `cds.test` {#cds-test}

The [test support for CAP Node.js applications](/node.js/cds-test) moves to its own package [`@cap-js/cds-test`](https://www.npmjs.com/package/@cap-js/cds-test).  You can start using it now, so install it as follows:

```sh
npm add -D @cap-js/cds-test
```

This package comes with dependencies you had to maintain separately until now. So get rid of the unnecessary dependencies and only maintain the `@cap-js/cds-test` package going forward.

```sh
npm rm axios chai chai-subset chai-as-promised
```

With CDS 9, the new package will be required for the `cds.test` API to work.


## Java {#cds-java}

### Important Change ❗️ { .important #important-changes-in-java}

Before this release, the comparison operator `!=` was equivalent to the not equals operator (`<>`) and evaluated on a database with _three-valued_ comparison logic.
Now, the `!=` operator is treated as equivalent with the [is not](/java/working-with-cql/query-api#comparison-operators) operator and is evaluated with _Boolean_ logic.

The changed behavior might be observable in [instance-based authorization](/guides/security/authorization#instance-based-auth) but only if a rule's `where` clause uses the `!=` operator. Then, you must check if Boolean or three-valued logic is appropriate. If you want to stick with three-valued logic, you need to use the `<>` operator.

### UI5 State Messages for Drafts <Beta />

CAP Java now supports persisting (error) messages for draft-enabled entities and providing _state messages_ to the UI5 OData V4 model.
To enable this feature, set the following properties in your `.cdsrc.json`:

::: code-group
```json [.cdsrc.json]
{
  "odata": {
    "containment": true
  },
  "cdsc": {
    "beta": {
      "draftMessages": true
    }
  }
}
```
:::

::: warning Document-based URLs
The state messages feature relies on UI5 to use _document URLs_. Currently UI5 only uses the document URLs when containment is enabled in the OData metadata.
Enabling containment narrows the API surface and only makes composition child entities accessible via their parent, which might be incompatible.
It's planned to provide options to instruct UI5 to use document URLs, without enforcing containment on the server-side.
:::

Setting this property adds additional elements to your draft-enabled entities and `DraftAdministrativeData`, which are required to store and serve state messages.

If this feature is activated, you can observe the following improvements, without changing the application code:

- Error messages for annotation-based validations (for example, `@mandatory` or `@assert...`) already appear while editing the draft.
- Custom validations can now be bound to the `DRAFT_PATCH` event and can write (error) messages. It's ensured that the invalid value is still persisted, as expected by the draft choreography.
- Messages no longer unexpectedly vanish from the UI after editing another field.
- Messages are automatically loaded when reopening a previously edited draft.

By default, side-effect annotations are generated in the EDMX that instruct UI5 to fetch state messages after every `PATCH` request.
In case more precise side-effect annotations are required you can disable the default side-effect annotation per entity:

```cds
annotate MyService.MyEntity with @Common.SideEffects #alwaysFetchMessages: null;
```

::: warning Requires Schema Update
Enabling draft messages requires a database schema update, as it adds an additional element to `DraftAdministrativeData`.
:::


### Hierarchy Maintenance in Tree Table

In the UI5 tree table, on SAP HANA, CAP Java now supports _hierarchy maintenance_ for [draft-enabled](/advanced/fiori#draft-support) hierarchies. It's now possible to create new nodes and to add them as parent or child nodes to the hierarchy. You can also modify and delete nodes. In addition, one can change a parent of a child node (move a node).

If a node is deleted, its descendant nodes are only deleted if they are in a composition relationship with the deleted node.

#### Inline Editing

If a hierarchy appears on an object page, CAP Java now supports inline editing:

![expandEntireNode.png](assets/feb25/inline-edit-hierarchy.png){width=80%}

#### Order of Sibling Nodes

If a hierarchy is defined by a view _with a sort specification_, CAP Java uses this sort specification as the default sort order for sibling nodes in the hierarchy:

```cds {9}
entity Genre : cuid {
      name        : String;
      parent      : Association to Genre;
      siblingRank : Integer;  // [!code highlight]
}

service GenreAdminService {
  entity GenreHierarchy as projection on Genre
                           order by siblingRank
    actions {
      action moveSiblingAction(NextSibling : cuid);  // [!code highlight]
    };
}
```

In this example sibling nodes within the genre hierarchy are sorted by the value of the `siblingRank` property. You can use this property for a custom implementation of a
[ChangeNextSiblingAction](https://github.com/SAP/odata-vocabularies/blob/main/vocabularies/Hierarchy.md#template_changenextsiblingaction-experimental), which allows to move a sibling node to an exact position between siblings.

### Expand on Subqueries

You can now expand to-one associations from [subqueries](/java/working-with-cql/query-api#from-select) if the association is selected explicitly or implicitly via select all in the inner query:

```java
CqnSelect booksOnCAP = Select.from(BOOKS).columns(
    b -> b.title(),
    b -> b.author())  // [!code highlight]
   .search("CAP")
   .orderBy(b -> b.title())
   .limit(10);
Select.from(booksOnCAP).columns(
    b -> b.get("title"),
    b -> b.to("author").expand("name"));  // [!code highlight]
```

### $expand on $apply in OData v4

CAP Java now supports `$expand` of managed to-one associations in combination with non-aggregating [$apply](/advanced/odata#data-aggregation) transformations such as `filter`, `search`, `top`, `skip`, and `orderby`, as well as [hierarchy](/advanced/odata#hierarchical-transformations) transformations such as `TopLevels`, `ancestors`, and `descendants`:

```http {6}
GET /SalesOrganizations?$apply=
     ancestors($root/SalesOrganizations,SalesOrgHierarchy,ID
     /search(\"CAP\"),keep start)
     /com.sap.vocabularies.Hierarchy.v1.TopLevels(HierarchyNodes=$root/SalesOrganizations,HierarchyQualifier='SalesOrgHierarchy',NodeProperty='ID')
&$select=DistanceFromRoot,DrillState,LimitedDescendantCount,Name,ID&$top=10
&$expand=Superordinate($select=Name)
```

### SQL Window Functions

You can now use an [SQL window function](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-sql-reference-guide/windows-functions) to _partition_ data and compute an aggregated value per partition without grouping the data. Use the new `over` method to turn an aggregate function into window function.
The following example _partitions_ the sales by region. For every partition the sum of sales are is computed but the raw amount is preserved:

```java
Select.from(SALES)
      .columns(s -> s.region(),
               s -> s.saleId(),
               s -> s.amount(),
               s -> s.amount().sum().over(s.region()).as("sum"));  // [!code highlight]
````

This query produces such a result:

| region | saleId | amount | sum |
|--------|--------|-------:|----:|
| EU     | eu1    |     10 |  60 |
| EU     | eu2    |     30 |  60 |
| EU     | eu3    |     20 |  60 |
| UK     | uk1    |     90 |  90 |
| US     | us1    |      5 |  20 |
| US     | us2    |     15 |  20 |


### Expressions in Runtime Views

You can now use expressions in [runtime views](/java/working-with-cql/query-execution#runtimeviews).

Runtime-view definition:

```cds
@cds.persistence.skip
entity BooksView as projection on Books {
    id,
    toUpper(title) as title, // [!code highlight]
    author.forename || author.surname as author, // [!code highlight]
    (stock < 10 ? 'low' : 'high') as stock : String // [!code highlight]
};
```

Allowed query:

```java
Select.from(BooksView).columns(
    b -> b.title(),  // [!code highlight]
    b -> b.author(), // [!code highlight]
    b -> b.stock()); // [!code highlight]
```

<span id="java-remote-rfc" />
<Fragment target="#java-remote-rfc">

### Remote RFC Services <Beta />

CAP Java now supports [Remote Service](/java/cqn-services/remote-services#remote-rfc-services)s with protocol type RFC, which allows convenient use of RFC-enabled function modules from SAP S/4 HANA systems.
The feature is based on the [JCo](https://support.sap.com/en/product/connectors/jco.html#section) framework embedded for Cloud Foundry runtime and local environment.

To setup the RFC _Remote Service_ you need to prepare the following:

1. Import the CDS service definition of the remote RFC API either through `cds import` or by SAP Business Application Studio as described in the [@sap/cds-rfc plugin](https://www.npmjs.com/package/@sap/cds-rfc).
2. Create a BTP destination pointing to the remote S/4 system.
3. Add a Remote Service representing the remote RFC S/4 service:

::: code-group

```yaml [srv/src/main/resources/application.yaml]
cds:
  remote.services:
    system:
      type: "rfc"
      destination:
        name: "S4H"
```

:::

4. Execute RFC calls via the Remote Service API:


```java
@Autowired
private System system;
...
// prepare parameters
BAPIContractGETDETAILContext.OptionalArguments opts =
        BAPIContractGETDETAILContext.OptionalArguments.create();
opts.setAccount(List.of(DdicBapimeoutaccount.create().setAssetNo("123")));
opts.setPurchasingdocument("123");

// call BAPI
BAPIContractGetdetailResultType result = system.BAPI_CONTRACT_GETDETAIL(opts);
```


:::tip
`cds import` will automatically create a Remote Service configuration in your project.
:::

[Learn more about Remote Services for RFC.](/java/cqn-services/remote-services#remote-rfc-services){.learn-more}


</Fragment>

### Miscellaneous

- CAP Java now offers a [typesafe API](/java/change-tracking#reacting-on-changes) for the ChangeTracking Service which can be used to observe and customize detected changetracking entities.
- The `build` goal of the `cds-maven-plugin` can now be run from the root folder of the CAP Java project. It's no longer required to change into the `srv` folder to run this goal. It supports also the new parameter `goals` to let the user choose, which goals shall be executed to build the project.
- Event Handler methods can now take `CqnStatement` or one of its subtypes as argument. This works for events that operate on a `CqnStatement`, like all CRUD events or bound actions or functions. In addition, it's now also possible to use a `CqnStructuredTypeRef` as parameter type, which is useful, when handling a bound action.


## CAP Plugins

### Attachments: Multitenancy

[@cap-js/attachments](https://github.com/cap-js/attachments) now supports multitenancy with a shared object store instance. Within a shared object store instance, attachments are stored with tenant ID prefix to identify tenant-specific data.


## Tools { #tools}

### Command-line formatter

The `format-cds` command-line formatter included in _@sap/cds-lsp_ now considers ignore files (one of _.cdsignore_ and _.gitignore_). Matching files will not be formatted.

[Learn more about the CDS Source Formatter.](/tools/cds-editors#cds-formatter){.learn-more}

### CDS Plugin for Community IntelliJ IDEs

We got numerous feedback for our current [IntelliJ plugin](https://github.com/cap-js/cds-intellij) only supporting _commercial_ versions of IntelliJ IDEs.
Now, we publish a version 2 of the plugin as the first preview that supports the free _Community_ editions of IntelliJ IDEs. It includes _all_ features of our previous version.

This preview version is not available on the IntelliJ Marketplace. You need to install it manually from [Github](https://github.com/cap-js/cds-intellij/releases) via _Settings -> Plugins -> Config Wheel Icon (right to Marketplace and Installed) -> Install Plugin from Disk..._

Given the early stage, we would be happy if you try this out and give us [feedback](https://github.com/cap-js/cds-intellij/issues/new/choose). Please tag the issue with the new _2.x.x Community Edition_ label.

<div id="secondary-file">releases/archive/2025/feb25.fragment.md</div>


# January 2025


## Prepare for Major Release

We understand that you want to be well prepared for changes in our major releases. This section will be a regular part of all upcoming release notes and includes links to all changes relevant to the next major release. As the legacy variants will be removed after the major release, it's crucial that you start adopting and testing these changes now to ensure a smooth transition. Please provide feedback if you encounter any issues or if you're satisfied with the updates.

#### `@sap/cds-compiler^6`

- [New Parser](#reminder-new-parser)

#### `@sap/cds^9`

- [Upgrade to `@sap/xssec 4`](#upgrade-to-sapxssec-4)
- [OData Containment](../2024/dec24#odata-containment)
- [Consolidated Authorization Checks](../2024/dec24#consolidated-authorization-checks)
- [@cap-js Database Services](../2024/jun24#new-database-services-ga)
- [Protocol Adapters](../2024/jun24#new-protocol-adapters-ga)
- [Draft Handler Compatibility](../2024/jun24#lean-draft)

## AI-friendly Content in Capire

This documentation site now exposes two new files, [llms.txt](/llms.txt) and [llms-full.txt](/llms-full.txt), that help LLMs better understand the content of the pages.
You can link it in your prompts, for example, to give more context.

[Learn more about llms.txt](https://towardsdatascience.com/llms-txt-414d5121bcb3){.learn-more}

## CDS Language & Compiler {#cds}

### Reminder: New Parser

As already announced with the November '24 release, we're in full swing finalizing the new CDS parser. Replacing the old parser brings significantly reduced installations and faster parsing, as well as improved code completion. While we rolled it out as alpha last November, it's in a Release Candidate status now.

> [!tip]
>
> 1. The new parser doesn't come with any breaking changes.
> 2. We already started using the new parser by default in all CAP development and tests.
> 3. Current status is **Release Candidate** → you **can, and should** start using it.

Roadmap is as follows:

| Date   | Status                   | Remarks                                               |
| ------ | ------------------------ | ----------------------------------------------------- |
| Nov 24 | Alpha                    | opt-in usage; default still with old parser           |
| Dec 24 | Beta                     | opt-in usage; default still with old parser           |
| Jan 25 | Release Candidate        | opt-in usage; default still with old parser           |
| May 25 | Release                  | new parser by default; **w/o fallback to old parser** |

> [!warning] No fallback as of May '25
>
> As there won't be a fallback to the old parser in May anymore, we **strongly recommend testing your projects** already now with the new parser to detect issues before it becomes the default. Set option <Config showPrivate>cds.cdsc.newParser: true</Config> in your private `~/.cdsrc.json` to do so on your local machine. If that’s successful, start using it in development and test pipelines of your project.

### Use Enums for Defaults

It's now possible to use enum symbols when defining a default value.

```cds
type Status : String enum { open = 'O'; closed = 'C' };

entity Orders {
  key id : Integer;
  status : Status default #open; // [!code highlight]
}
```

Enum symbols are going to be supported in more places, for example `where status = #open`, in one of the next releases.

## Node.js {#cds-js}

### Basic Support for cds.Map

The [built-in `cds.Map` type](/cds/types) for storing and retrieving arbitrary structured data is now available. Values of elements with type `Map` are represented as plain Javascript objects.

```cds
entity Person {
  key ID      : UUID;
      name    : String;
      details : Map; // [!code highlight]
}
```

Given this CDS model using the new `Map` type for `Person.details`, you can store arbitrary data in `details`:

```js
await INSERT.into(Person).entries({
  name: 'Peter',
  details: { // [!code highlight]
    age: 40, // [!code highlight]
    address: { // [!code highlight]
      city: 'Walldorf', // [!code highlight]
      street: 'Hauptstrasse' // [!code highlight]
    } // [!code highlight]
  } // [!code highlight]
})
await SELECT.from(Person).columns('name', 'details')
```

::: info OData v4 only
This feature is available for OData v4 services only.
:::

::: info Temporary Limitations
In this version, `cds.Map` serves as a _dumb_ object storage which can be retrieved/written as a whole. Filters as well as partial selects, updates, and deletes are not yet supported.
:::

### Upgrade to `@sap/xssec 4`
{#upgrade-to-sapxssec-4}

The [authentication strategies](/node.js/authentication#strategies) migrated to the new API of [`@sap/xssec` version 4](https://www.npmjs.com/package/@sap/xssec). Even though there's no change in behavior, you can fall back to the previously used compatibility API of `@sap/xssec` in case of issues with <Config>cds.features.xssec_compat = true</Config>.

Compatibility as well as support for `@sap/xssec@3` will be dropped with the next major version of `@sap/cds`. **Please upgrade to `@sap/xssec@4` now** if not yet done.

## Java {#cds-java}

### Predicates as Select List Items

Use predicates as select items to evaluate boolean expressions on the database.

```java
Select.from(BOOKS).byId(17).columns(
  b -> b.year().gt(2000).as("isFrom21stCentury"),
  b -> b.author().name().eq("J.K. Rowling").as("byJKRowling"));
```

This query tests whether a given book was written in the 21<sup>st</sup> century by J.K. Rowling. The query result maps the aliases `isFrom21stCentury` and `byJKRowling` to boolean values indicating the result of the evaluation. The evaluation is performed on the database without transferring the underlying data to the client.

### Typed Entity References

With the new `CQL.entity(Class<StructuredType>, ref)` method you can use a generic `CqnStructuredTypeRef` with generated [model interfaces](/java/cqn-services/persistence-services#staticmodel) to build a query in fluent style:

```java
import static bookshop.Bookshop_.BOOKS; // generated model type
import static com.sap.cds.ql.CQL.entity;

CqnStructuredTypeRef ref; // generic entity reference

Select.from(entity(BOOKS, ref)).where(b -> b.author().name().eq("J.K. Rowling"));
```

### Invoke Functions with Parameters Aliases

OData V4.01 allows you to invoke functions using [implicit parameter aliases](https://docs.oasis-open.org/odata/new-in-odata/v4.01/cn04/new-in-odata-v4.01-cn04.html#sec_NewInvokingFunctionswithImplicitPara). This invocation style is now also supported by the CAP Java runtime. The following example illustrates the usage:

```http
GET sue/stock(id=2)         // traditional syntax
GET sue/stock(id=@ID)?@ID=2 // explicit parameter alias
GET sue/stock?id=2          // implicit parameter alias
```

[Learn more about functions in CAP Java](/java/cqn-services/application-services#actions) {.learn-more}

### Expand all Subnodes in Hierarchy

In the SAP Fiori Tree Table, you can now expand all children of a selected node:

![expandEntireNode.png](assets/jan25/expandEntireNode.png){width=80%}

### Default Runtime Messages Bundle

CAP Java has a built-in mechanism to [localize runtime messages](/java/event-handlers/indicating-errors#formatting-and-localization) being sent to the UI, for example, resulting from input validation.
Previously, applications had to [provide resource bundle files](/java/event-handlers/indicating-errors) to provide the translations for such standard runtime messages.
With this update, CAP Java retrieves translated text from a prepared resource bundle file containing all CAP-supported languages, streamlining the localization process.
CAP Java now sends more user-friendly message texts to the UI. This enhancement is designed to improve the user experience, while still maintaining detailed technical information in the logs for debugging purposes. To benefit from this feature, you need to set property [<Config java>cds.errors.defaultTranslations.enabled: true</Config>](/java/developing-applications/properties#cds-errors-defaultTranslations-enabled).

::: warning Impact for unit tests
Rewrite unit tests in your application which contain assertions about message texts. Alternatively, use message codes instead.
:::

[Learn more about messages in CAP Java](/java/event-handlers/indicating-errors#messages) {.learn-more}

### Authorization Checks On Input Data <Beta />

CAP Java now can also validate input data of `CREATE` and `UPDATE` events with regards to instance-based authorization conditions.
Invalid input that does not meet the condition is rejected with response code `400`.

Let's assume an entity `Orders` which restricts access to users classified by assigned accounting areas:

```cds
annotate Orders with @(restrict: [
  { grant: '*', where: 'accountingArea = $user.accountingAreas' } ]);
```

A user with accounting areas `[Development, Research]` is not able to send an `UPDATE` request, that changes `accountingArea` from `Research` or `Development` to `CarFleet`, for example.
Note that the `UPDATE` on instances _not matching the request user's accounting areas_ (for example, `CarFleet`) are rejected by standard instance-based authorization checks.

Activate this feature: <Config java>cds.security.authorization.instanceBased.checkInputData: true</Config>.

### `cds debug` for Java Applications

We have extended [`cds debug`](../2024/nov24#cds-debug) to Java, so that you can easily debug local and remote Java applications. Without an app name, `cds debug` starts Maven with debug arguments **locally**:
<pre class="log">
<span class="cwd">$</span> <span class="cmd">cds</span> <span class="args">debug</span>
Starting 'mvn spring-boot:run -Dspring-boot.run.jvmArguments="-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000"'
...
Listening for transport dt_socket at address: 8000
...
</pre>

If you add a **remote application** name from the currently targeted Cloud Foundry space, it opens an [SSH tunnel](https://docs.cloudfoundry.org/devguide/deploy-apps/ssh-apps.html) and puts the remote application into debug mode:

<pre class="log">
<span class="cwd">$</span> <span class="cmd">cds</span> <span class="args">debug</span> <span class="options">&lt;app-name&gt;</span>
...
Debugging has been started.
Address : 8000

Opening SSH tunnel on 8000:127.0.0.1:8000

> Keep this terminal open while debugging.
</pre>

Then connect a debugger in your IDE at the given port.

[Learn more about `cds debug`](/tools/cds-cli#cds-debug){.learn-more}

## Tools { #tools}

### `cds watch` with Include and Exclude Paths

You can now specify which additional paths `cds watch` watches and ignores:

```sh
cds watch --include ../other-app --exclude .idea/
```

[Learn more about `cds watch` and its options.](/tools/cds-cli#cds-watch){.learn-more}

### Sample Code for TypeScript

When executed in a TypeScript project, `cds add sample` now creates proper TypeScript code for the service handlers instead of `.js` files.

This means you can now create a full-fledged TypeScript project with:

```sh
cds init bookshop --add typescript,sample
```

[Also see the SFlight application on TypeScript.](https://github.com/SAP-samples/cap-sflight){.learn-more}

### Code Formatting in CDS IntelliJ Plugin

[SAP CDS Language Support for IntelliJ](https://plugins.jetbrains.com/plugin/25209-sap-cds-language-support) now provides all CDS formatting options for configuration under **Settings > Editor > Code Style > CDS**. The plugin adds any non-default settings to a _.cdsprettier.json_ file in the root of a CDS project for consumption by the included LSP server.

![intellij-formatting-options.png](assets/jan25/intellij-formatting-options.png){.ignore-dark}

Additionally, the most suitable Node.js runtime for the server is now automatically selected from the Node.js interpreters registered under **Settings > Languages & Frameworks > Node.js**.



# All of 2024



<br>
<IndexList :pages='pages' />



# December Release




<span id="eanode" />
<Fragment target="#eanode">

## Embedded Analytics for CAP Node.js <Internal />

The Embedded Analytics capabilities of CAP can now be used for applications running on the CAP Node.js as well as the CAP Java stack. Previously this was limited to CAP Java.

With Embedded Analytics you can evaluate and analyze real-time business data directly in your
SAP HANA-based CAP application, without having to replicate data to an external data warehouse.

For CAP Node.js, install the plugins as follows:

```sh
npm add @sap/cds-ea-plugin
npm add @sap/cds-adapter-ina-js
```

With these plugins added to your project, you get a built-in endpoint for handling analytical queries using the InA (Information Access) protocol.

[Learn more about Embedded Analytics for Node.js and Java projects.](/advanced/embedded-analytics) {.learn-more}

</Fragment>

<span id="ams" />
<Fragment target="#ams">

## Streamlined AMS Integration

CAP Node.js and Java are tightly integrated with [Authorization Management Service (AMS)](https://github.wdf.sap.corp/pages/CPSecurity/ams-docu/) now.
Applications that run with IAS-based authentication can benefit from AMS which allows central access policy management at the business level.
The integration with AMS comes as an easy-to-consume plugin for CAP applications

![The graphic is explained in the following text.](./assets/dec24/ams.png){ }

The interaction between the CAP application and AMS (via plugin) is as follows:

1. IAS-Authentication is performed independently as a pre-step.
2. The plugin injects **user roles and filters** according to AMS policies assigned to the current request user.
3. CAP performs the authorization on basis of the CDS authorization model and the injected user claims.

**AMS is transparent to CAP application code** and can be easily consumed via plugin dependency.

In oder to enhance your project with IAS and AMS you may make use of new CDS CLI tooling:

```sh
cds add ias
cds add ams
```

This automatically adds required configuration for IAS/AMS taking into account the concrete application context (tenant mode and runtime environment etc.).

The CDS model and technical authorization rules in the application domain are fully decoupled from AMS business policies which are defined on top:

::: details Define your CDS model along with technical authorization rules

```cds
aspect fromSystem {
  systemType : String enum { DEV; QS; PROD; };
}

entity Issues : fromSystem {
  key ID: UUID;
      description: String;
      resolved: Boolean;
}

annotate Issues with @(restrict: [
    { grant: ['READ'], to: 'ReviewIssues' },
    { grant: ['READ', 'WRITE'], to: 'ManageIssues' }
]);
```

:::

::: details Optionally, link your CDS model to AMS attributes by `@ams` annotation


```cds
annotate fromSystem with @(ams.attributes: [
  { element: (systemType), attribute: 'SystemType' }
);
```

:::

::: details Define AMS policies that combine roles and attribute filters at business level

```yaml
SCHEMA {
 SystemType : String
}

POLICY QualityAuditor {
 ASSIGN ROLE ReviewIssues WHERE SystemType IS NOT RESTRICTED;
}

POLICY SupportEngineer {
 USE QualityAuditor RESTRICT SystemType = 'PROD';
}
```

:::

::: details Assign users to AMS policies

![Screenshot showing the AMS Policy Assignment](assets/dec24/ams-assignment.png)

:::

Find more details in the [documentation for Java](https://github.wdf.sap.corp/CPSecurity/cloud-authorization-client-library-java/tree/master/cap-ams-support) resp. [documentation für Node.js](https://github.wdf.sap.corp/CPSecurity/cloud-authorization-client-library-nodejs#sapams).

::: warning
Make sure to use at least version `2.0.0` of `@sap/ams` resp. at least version `2.0.0` of `com.sap.cloud.security.ams.client:cap-ams-support`.
:::

[AMS plugin for CAP Java](https://github.wdf.sap.corp/CPSecurity/cloud-authorization-client-library-java/tree/master/cap-ams-support){.learn-more}
[Find an example CAP Java project with AMS](https://github.com/SAP-samples/cloud-cap-samples-java/tree/identity-ams){.learn-more}
[AMS plugin for CAP Node.js](https://github.wdf.sap.corp/CPSecurity/cloud-authorization-client-library-nodejs){.learn-more}
[Find an example CAP Node.js project with AMS](https://github.wdf.sap.corp/CPSecurity/ams-cap-sample-nodejs){.learn-more}

</Fragment>

## CDS Language & Compiler {#cds}

### New `CQN` Spec Using `.d.ts`

We rewrote the [CQN specification](/cds/cqn) using TypeScript declarations ([`.d.ts` files](https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html)).
This not only fills in many gaps that we had in our former documentation, it also allows for better IntelliSense
and easier integration with other projects.

```tsx
class SELECT { SELECT: {
  distinct?   : true
  count?      : true
  one?        : true
  from        : source
  columns?    : column[]
  where?      : xo[]
  having?     : xo[]
  search?     : xo[]
  groupBy?    : expr[]
  orderBy?    : order[]
  limit?      : { rows: val, offset: val }
}}
```

[See the new _CQN specification_](/cds/cqn) {.learn-more}

### Annotating Foreign Keys <Beta />

Now, you can specifically annotate a _foreign key element_ of a [managed association](/cds/cdl#managed-associations):

```cds
entity Authors { key ID : Integer; }
entity Books   { author : Association to Authors; }

annotate Books:author.ID with @label: 'Author'; // [!code highlight]
```

Previously it wasn't possible to specifically annotate the foreign key elements of
a managed association. The workaround was a mechanism in the OData API generation
that copied all annotations assigned to a managed association to the respective foreign key elements.

## Node.js {#cds-js}

### `cds.on` w/ new `compile` Events <Beta/>

We introduced new [lifecycle events](/node.js/cds-compile#lifecycle-events) emitted by different [`cds.compile`](/node.js/cds-compile) commands. In contrast to [`cds.on('loaded')`](/node.js/cds-server#loaded) that was used before, these new events allow plugins to transform models for specific usages, and even more important, also work for multitenant usages.

The individual events are:

- [`compile.for.runtime`](/node.js/cds-compile#compile-for-runtime)
- [`compile.to.dbx`](/node.js/cds-compile#compile-for-dbx)
- [`compile.to.edmx`](/node.js/cds-compile#compile-for-edmx)

> [!note]
>
> You can already try out using these new events, but there's not much documentation yet, and they're still beta, so could change in the final release. Next, we'll adapt the plugins maintained by us and with that, validate, document, and showcase the new events.

### `cds.env` Enhancements

The [`cds.env`](/node.js/cds-env) module has been optimized and enhanced with these new features:

- Config can be provided also in `.cdsrc.js` and `.cdsrc.yaml` files, also in plugins.
- Profile-specific `.env` files can be used, for example, `.hybrid.env` or `.attic.env`.

::: code-group

```yaml [.cdsrc.yaml]
cds:
  requires:
    db:
      kind: sql
      "[hybrid]":
        kind": hana
```

```js [.cdsrc.js]
module.exports = {
  cds: {
    requires: {
      db: {
        kind: 'sql',
        '[hybrid]': {
          kind: 'hana'
        }
      }
    }
  }
}
```

```json [.cdsrc.json]
{
  "cds": {
    "requires": {
      "db": {
        "kind": "sql",
        "[hybrid]": {
          "kind": "hana"
        }
      }
    }
  }
}
```

```properties [.hybrid.env]
cds.requires.kind = hana
```

:::

> [!tip]
>
> As these enhancements apply also to any configuration for `cds-dk` and `cds-mtxs`, you can now use the same configuration files for all tools, even in Java projects.

::: warning Do not load `@sap/cds` in _.cdsrc.js_
You can generally use any JavaScript code within a _.cdsrc.js_ file. However, you **must not** import or load any `@sap/cds` module, as this can create circular dependencies in `cds.env`, leading to undefined behaviors.
:::

### `cds.ql` Enhancements

The `cds.ql` module has been optimized, consolidated, and improved for robustness, as well as enhanced with new functions to facilitate programmatic construction of CQN objects. In detail:

- Besides being a facade for all related features, [`cds.ql`](/node.js/cds-ql) now also is a function to turn any respective input into an instance of respective subclasses of [`cds.ql.Query`](/node.js/cds-ql#class-cds-ql-query); for example, the following all produce an equivalent instance of [`cds.ql.SELECT`](/node.js/cds-ql#select):

  ```js
  let q = cds.ql `SELECT from Books where ID=${201}`
  let q = cds.ql (`SELECT from Books where ID=${201}`)
  let q = cds.ql ({
    SELECT: {
      from: { ref: [ 'Books' ] },
      where: [ { ref: [ 'ID' ] }, '=', { val: 201 } ]
    }
  })
  let q = SELECT.from('Books').where({ID:201})
  ```

- New [CXL-level helper functions](/node.js/cds-ql#expressions) to facilitate construction of CQN objects have been added, which you can use like that:

  ```js
  const { expr, ref, val, columns, expand, where, orderBy } = cds.ql
  let q = {
    SELECT: {
      from: ref`Authors`,
      columns: [
        ref`ID`,
        ref`name`,
        expand (ref`books`, where`stock>7`, orderBy`title`,
          columns`ID,title`
        )
      ],
      where: [ref`name`, 'like', val('%Poe%')]
    }
  }
  await cds.run(q)
  ```

- All `cds.ql` functions, as well as all `cds.parse` functions, and all related `srv.run` methods now consistently support [tagged template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates). For example, all of these work now:

  ```js
  await cds.run (cds.parse.cql `SELECT ID,title from Books`)
  await cds.run `SELECT ID,title from Books`
  await cds.ql `SELECT ID,title from Books`
  await SELECT `ID,title from Books`
  await SELECT `ID,title`.from`Books`
  await SELECT.from `Books {ID,title}`
  await cds.read `ID,title from Books`
  await cds.read `Books`
  await cds.read `Books where ID=201`
  ```

> [!warning]
> In course of this, former globals `CDL`, `CQL`, and `CXL` have been deprecated
> in favor of respective [`cds.parse.cdl`](/node.js/cds-compile#parse-cdl), [`.cql`](/node.js/cds-compile#parse-cql), and [`.expr`](/node.js/cds-compile#parse-cxl) counterparts.

[Learn more in the reference docs for _`cds.ql`_](/node.js/cds-ql) {.learn-more}

[Note in there the recommendation for _`cds repl`_](/node.js/cds-ql#using-cds-repl) {.learn-more}

### OData Containment

The new config option <Config>cds.odata.containment: true</Config> allows to switch on containment mode which maps CDS Compositions to effective OData Containment Navigation Properties as [introduced in OData v4](http://docs.oasis-open.org/odata/odata/v4.0/cos01/part3-csdl/odata-v4.0-cos01-part3-csdl.html#_Toc372793924) and supported meanwhile by Fiori clients.

For example, given the following CDS model:

```cds
service Sue {
  entity Orders { //...
    Items : Composition of many { /*...*/ }
  }
}
```

That will be exposed like that with containment mode enabled (the removed line indicates what is not exposed anymore):

```xml
 <EntityContainer Name="EntityContainer">
   <EntitySet Name="Orders" ... />
-  <EntitySet Name="Orders_Items" ... /> 
 </EntityContainer>
```

Contained entities can only be reached via navigation from their roots reducing the entry points of the OData service.

> [!tip]
> While we think that containment mode is best for most applications, and fully supported by Fiori clients, we provide it as an opt-in for the time being, for you to test it in your apps. It's planned to become the default in the next major release.



### Function Parameters via Query Options

The [OData V4.01 specification](https://docs.oasis-open.org/odata/new-in-odata/v4.01/cn04/new-in-odata-v4.01-cn04.html#sec_NewInvokingFunctionswithImplicitPara) allows providing parameters of functions as query options which is now supported by the Node.js runtime. The example below illustrates the usage:

```http
GET sue/stock(id=2) // traditional syntax
GET sue/stock?id=2  // new syntax
```

[Learn more about functions in CDS](/guides/providing-services#calling-actions-functions) {.learn-more}

### Consolidated Authorization Checks

The processing of `@restrict.where` was aligned with the CAP Java stack.
As a result, there are the following behavioral changes in edge cases, each with their own compat feature flag to deactivate the change until the next major:

- Read restrictions on the entity are no longer taken into consideration when evaluating restrictions on bound actions/ functions. Instead, only the restrictions that apply to the bound action/ function are evaluated. <br>
Deactivate via <Config>cds.features.compat_restrict_bound: true</Config>.

- For `UPDATE` and `DELETE` requests, additional filters (these are, those not originating from key predicates) are no longer considered during the authorization check. For example, assumed we got the equivalent of this query:

  ```sql
  UPDATE Books SET title = 'foo' WHERE title = 'bar'
  ```

  The filter `title = 'bar'` is ignored for access control checks, and, effectively, the user needs to be allowed to update all books.

Please note that `UPDATE` and `DELETE` requests from a client always contain key predicates, making this change only affect service calls executed in custom handlers. In case you encounter issues with the new behavior, you can deactivate it via <Config>cds.features.compat_restrict_where: true</Config>.

## Java {#cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

#### NPM Build-Plugin Support { #npm-build-plugins }

To support a growing number of NPM build-plugins for CDS build,
we recommend a slightly different CAP Java project setup which uses `devDependencies` section in the _package.json_ file.
Consequently, also the required dependency to `@sap/cds-dk` now should be added there.

To ensure stable versions of the packages, `npm ci` should be configured for the CDS build:

```xml [srv/pom.xml]
<execution>
  <id>cds.npm-ci</id>
  <goals>
    <goal>npm</goal>
  </goals>
  <configuration>
    <arguments>ci</arguments>
  </configuration>
</execution>
```

The goal `install-cdsdk` of the cds-maven-plugin has been deprecated and should be removed from the project.

[Learn how to Migrate From Goal `install-cdsdk` to `npm ci`.](/java/developing-applications/building#migration-install-cdsdk){.learn-more}

::: info New projects in recommended setup
The built-in [Maven Archetype](/java/getting-started#run-the-cap-java-maven-archetype) creates a Java project with the recommended setup.
:::

<span id="java-mTLS-kafka" />
<Fragment target="#java-mTLS-kafka">

#### mTLS Authentication for Kafka <Internal />

`cds-feature-kafka` now makes use of mTLS authentication by default.
CAP applications just need to consume the new version `3.6.0` to switch to mTLS.

::: warning
OAuth authentication is deprecated by Kafka on BTP and will be removed step by step starting in February 2025.
:::

</Fragment>

### SAP Document Management Service Plugin

The new Calesi plugin [com.sap.cds/sdm](https://central.sonatype.com/search?q=com.sap.cds.sdm) is now available as [open source on GitHub](https://github.com/cap-java/sdm). You can easily add the dependency to your application's dependencies and use the `Attachments` type in your model.

::: code-group

```xml [srv/pom.xml]
<dependency>
  <groupId>com.sap.cds</groupId>
  <artifactId>sdm</artifactId>
  <version>1.0.0</version>
</dependency>
```

:::

![Screenshot showing the attachments table in an SAP Fiori UI.](assets/jun24/sdm-table.png)

[Find more details about the SAP Document Management Service Plugin.](https://github.com/cap-java/sdm#readme)

<span id="java-ord" />
<Fragment target="#java-ord">

### Open Resource Discovery Support

CAP Java now automatically serves endpoints for [Open resource Discovery (ORD)](https://sap.github.io/open-resource-discovery/).
ORD is an open source protocol by SAP that allows applications to self-describe the offered resources and capabilities in a standardized manner.

To enable ORD metadata endpoints for your service you first need to add build configuration:

- Switch your project setup to enable NPM build plugin support as [described](#npm-build-plugins).
- Add the [ORD build plugin](https://github.com/cap-js/ord) as `devDependencies`: `npm add -d @cap-js/ord`
- Add a dependency to the corresponding `cds-services` feature as well as an additional compile command in the `pom.xml` of the services:

   ::: details Configuration details

   ```xml [srv/pom.xml]
   <dependency>
      <groupId>com.sap.cds</groupId>
      <artifactId>cds-feature-ord</artifactId>
      <version>${cds-services.version}</version>
   </dependency>
   [...]
   <execution>
    <id>cds.build</id>
    <goals>
     <goal>cds</goal>
    </goals>
    <configuration>
     <commands>
      <command>build --for java</command>
      <command>compile --to ord srv -o "${project.basedir}/src/main/resources/ord/open-resource-discovery.json"</command>
     </commands>
    </configuration>
   </execution>
   ```

   The compile will generate an ORD metadata file which is used a basis to serve ORD requests.

   :::

::: info Base app only
The ORD metadata document will not reflect model extensions defined by subscribers in multitenant applications.
:::

Runtime configuration can be adjusted in `application.yaml` in section `cds.ord` in order to

- Customize the servlet parameters. <br> Endpoint `/.well-known/open-resource-discovery` is active by default.
- Specify the ORD resource path relative to the `resources` folder of the service. <br> Default: _ord/open-resource-discovery.json_
- Add additional ORD links.

Feature `cds-feature-ord` now also exposes EDMX metadata documents which are linked from ORD documents with the same authentication scheme as the ORD document.

</Fragment>

<span id="java-kafka-dwc" />
<Fragment target="#java-kafka-dwc">

### Apache Kafka for Deploy with Confidence <Internal />

Applications which make use of CAP Java's [Kafka messaging integration](/java/messaging#configuring-apache-kafka-support) for service-to-service communication
and which run in the in context of [Deploy-with Confidence](https://pages.github.tools.sap/deploy-with-confidence/solar-system/),
should publish messages only within the same deployment vector.

To accomplish this, CAP Java applications should add a Maven dependency to [util-cap-kafka](https://github.tools.sap/deploy-with-confidence/spring-utils/tree/master/util-cap-kafka)
**instead of** `cds-feature-kafka`.
`util-cap-kafka` takes care of sending the messages to appropriate receivers only:

```xml [srv/pom.xml]
<dependency>
    <groupId>com.sap.dwc</groupId>
    <artifactId>util-cap-kafka</artifactId>
    <version>${util-cap-kafka.version}</version>
</dependency>
```

::: info
This library is a thin adapter layer between [CAP messaging API](/java/messaging) and [CALM Iris API](https://pages.github.tools.sap/CALMBuild/adlib/).
:::

</Fragment>

### IAS Support for Kyma

CAP Java now offers out-of-the-box [integration](/java/security#xsuaa-ias) for [SAP Cloud Identity Authentication](https://help.sap.com/docs/cloud-identity-services) (IAS) in the [SAP BTP, Kyma runtime](https://discovery-center.cloud.sap/serviceCatalog/kyma-runtime). It performs proof-of-possession checks on the client certificates passed by calling IAS applications in the context of Kyma runtime.

### SAP HANA Connection Pooling Optimized

Multitenant applications configured with a [shared database pool](/java/multitenancy#combine-data-pools) for all tenants help reduce resource consumption from database connections. However, this mode requires logging in with the technical database user of the current business tenant for each request. To optimize performance, CAP Java now skips the login if the pooled connection is already connected to the corresponding user, saving an extra roundtrip and reducing CPU consumption in the database.

### Outbox Message Versioning

Messages written to [Transactional Outbox](/java/outbox#transactional-outbox) can originate from application instances of different versions.
Instances of an outdated version might introduce failures or inconsistencies when trying to collect messages of younger versions.

To avoid such a situation, you can now configure CAP Java to write an application version outbox message being published.
Outbox collectors of an application instance will not collect messages of younger versions.

Using [<Config java keyOnly filesOnly>cds.environment.deployment.version: ${project.version}</Config>](/java/developing-applications/properties#cds-environment-deployment-version), we recommend configuring the application with the version identifier from the Maven build automatically.

This requires the build version available in the resources folder:

::: code-group

```xml [srv/pom.xml]
<build>
  <resources>
    <resource>
      <directory>src/main/resources</directory>
      <filtering>true</filtering>
    </resource>
  </resources>
</build>
```

:::

CAP Java can only support version identifiers which have an ordering.

[Learn more about Outbox Event Versions.](/java/outbox#outbox-event-versions){.learn-more}

### CDS Config in `.cdsrc.yaml` Files

Alternative to `.cdsrc.json` files, Java projects can now also use `.cdsrc.yaml` files
to configure the CDS compiler and `cds-dk`.

[See respective entry in the Node.js section.](#cds-env-enhancements) {.learn-more}

## Tools { #tools}

### `cds repl` Enhancements

As you know, [`cds repl`](/tools/cds-cli#cds-repl) is your friend when you want to find out, how things work. While this is especially relevant for Node.js projects, it also applies to Java projects. For example, to find out how a CSN or CQN object notation for a given CDL or CQL could look like that:

```sh
cds repl  # from your command line
```

```js
cds.parse`
  entity Foo { bar : Association to Bar }
  entity Bar { key ID : UUID }
`
```

```js
cds.ql`SELECT from Authors {
  ID, name, books [order by title] {
    ID, title, genre.name as genre
  }
} where exists books.genre[name = 'Mystery']`
```

This release brings a few new enhancements to `cds repl` as follows:

- New [REPL dot command](https://nodejs.org/en/learn/command-line/how-to-use-the-nodejs-repl#dot-commands) `.run` allows to start Node.js `cds.server`s:

  ```sh
  .run cap/samples/bookshop
  ```

- New CLI option `--run` to do the same from command line, for example:

  ```sh
  cds repl --run cap/samples/bookshop
  ```

- New CLI option `--use` to easily use the features of a `cds` module, for example:

  ```sh
  cds repl --use ql # as a shortcut of that within the repl:
  ```

  ```js
  var { expr, ref, columns, /* ...and all other */ } = cds.ql
  ```

- New [REPL dot command](https://nodejs.org/en/learn/command-line/how-to-use-the-nodejs-repl#dot-commands) `.inspect` to display objects with configurable depth:

  ```sh
  .inspect cds .depth=1
  .inspect CatalogService.handlers .depth=1
  ```

### `cds watch` for TypeScript

In a TypeScript project, you can now just run `cds watch` as if it was a JavaScript project.
It will automatically detect TypeScript mode based on a `tsconfig.json` and run [`cds-tsx`](/node.js/typescript#cds-tsx) under the hood.
In other words, it's not necessary anymore to use `cds-tsx watch`.

```sh
cap/sflight $ cds watch

Detected tsconfig.json. Running with tsx.
...
[cds] serving TravelService { impl: 'srv/travel-service.ts', path: '/processor' }
...
```

<div id="secondary-file">releases/archive/2024/dec24.fragment.md</div>




# November Release




## Documentation (Capire)

Quite some time has passed, and many things happened, and were added, since we wrote the current versions of our central cookbook guides, so it was time to give them a thorough overhaul... We did that now...

### Revised Getting Started Guides

As so many things happened since we wrote our getting started and cookbook guides, many of them need major updates and thorough overhauls. We started that journey now with the Welcome page, and the guides in the Getting Started section:

- [Welcome](/) page → got a minor face lift; the bullets in the four boxes are adjusted
- [Getting Started](/get-started/) index page → got streamlined and reduced to the gist of initial setup
- [Introduction - What is CAP?](/about/) → 90% newly written; replaces former *About CAP*
- [Best Practices](/about/best-practices) → 100% new: **key concepts** and **do's**; was always missing
- [Anti Patterns](/about/bad-practices) → 100% new: bad practices / the **don'ts** <UnderConstruction/>
- [Learn More](/get-started/learning-sources) → combines info formerly spread across several pages

![image-20241204173314024](assets/nov24/image-20241204173314024.png){.zoom20 .ignore-dark}

### New: Aspect-oriented Modeling

We added a new guide for [*Aspect-Oriented Modeling*](/cds/aspects) to the CDS reference. It explains how you can use aspects for separation of concerns, as well as to reuse and adapt definitions in your models.

![image-20241204173736533](assets/nov24/image-20241204173736533.png){.zoom20 .ignore-dark}

### Improved CDL Reference

We improved the structure of the [*Conceptual Definition Language (CDL)*](/cds/cdl) reference, mainly putting *[Language Preliminaries](/cds/cdl#language-preliminaries)* sections to the top, introducing the basics for keywords, identifiers, built-in types, literals, and so on.

![image-20241204174043802](assets/nov24/image-20241204174043802.png){.zoom20 .ignore-dark}

## CDS Language & Compiler {#cds}

### New CDL Parser <Alpha/>


The CDL Parser currently has an installation size of nearly 2 MB (runtime code and generated files).
We plan to transition to a new parser with a significant size reduction
(to around 200 kB installation size and having no package dependency) in three phases:

- Now: The new parser can be switched on via configuration for testing (see the following snippet).
- The new parser is switched on by default; the old parser is still installed and can be reactivated, if necessary (Jan/Feb 25).
- Completely remove the old parser including its dependency to the ANTLR4 runtime (next major release).

Set the following option in your private `~/.cdsrc.json` to switch on the new parser on your local machine:

::: code-group

```json [~/.cdsrc.json]
{
  "cdsc": {
    "newParser": true
  }
}
```

:::

We appreciate any feedback that helps us to detect and fix issues before using the new parser by default.

### Enhanced `@assert.range`

We now support open intervals with `@assert.range` by wrapping *min* or *max* values in parentheses:


```cds
@assert.range: [(0),100]    // 0 < input ≤ 100
@assert.range: [0,(100)]    // 0 ≤ input < 100
@assert.range: [(0),(100)]  // 0 < input < 100
```

In addition an underscore `_` can be used as a stand-in for *infinity*:

```cds
@assert.range: [(0),_]  // positive numbers only, _ means +Infinity here
@assert.range: [_,(0)]  // negative number only, _ means -Infinity here
```

[Learn more in the documentation of `@assert.range`](/guides/providing-services#assert-range) {.learn-more}

## Node.js

### New Plugin for RFC

With the new [cds-rfc plugin](https://www.npmjs.com/package/@sap/cds-rfc) you can import
the API of RFC-enabled function modules from an SAP S/4HANA system:

![Shows the VS code editor with the service center pane open and a function of an API is selected. It can be added to the CAP project using a button.](assets/nov24/Screenshot-20241125113652.png){.ignore-dark}

... and call the functions as if you're  calling them from a local CAP service:

```js
const S4 = await cds.connect.to('SYS')
const user = await S4.BAPI_USER_GET_DETAIL({
  USERNAME: 'display', ...
})
```

[Learn more about the new plugin](/plugins/#abap-rfc){.learn-more}

### New `cds.i18n` API

The new [`cds.i18n` API](/node.js/cds-i18n) is used consistently for both serving localized SAP Fiori UIs, as well as for localized messages at runtime. You can also use it in your own Node.js applications to localize your own messages. Here are some examples:

```js
const cds = require('@sap/cds')
cds.i18n.labels.at('CreatedAt','de')  // Erstellt am
cds.i18n.labels.at('CreatedAt')      // Created At
cds.i18n.messages.at('ASSERT_FORMAT',['wrong email',/\w+@\w+/])
```

You can also lookup translated UI labels for CSN definitions:

```js
let {Books} = CatalogService.entities, {title} = Books.elements
cds.context = {locale:'fr'}  // as automatically set by protocol adapters
cds.i18n.labels.at(Books)    //> 'Livre'
cds.i18n.labels.at(title)    //> 'Titre'
```

[Learn more about that in the documentation of `bundle.at(key,...)`.](/node.js/cds-i18n#at-key) {.learn-more}

::: warning Fixes to former i18n for runtime messages

With this new implementation used consistently for all i18n, we also fixed some flaws of the former implementation for runtime messages.

- Bundles are always loaded from the [*neighborhood* of *.cds* sources](/node.js/cds-i18n#from-models-neighborhood).
- Only files from the *first* match of [`i18n.folders`](/node.js/cds-i18n#folders) are used, not all.
- [Arguments for `{<>}` placeholders](/node.js/cds-i18n#at-key) aren't recursively localized anymore.

While these changes are unlikely to affect any users or projects, take note of them, and take appropriate action if you relied on the former behavior.
:::

### Fuzzy Search

The default fuzziness threshold used by CAP Node.js is 0.7 and is now configurable. If the default doesn't suite your needs, you can adapt it globally with <Config keyOnly>cds.hana.fuzzy: 0.9</Config>.

Besides the configurable default, now also the `@Search.fuzzinessThreshold`and `@Search.ranking` annotation is supported by the CAP Node.js runtime.

```cds
entity Books {
      @Search.fuzzinessThreshold: 0.5
      @Search.ranking: HIGH
      title         : String;
      @Search.ranking: LOW
      description   : String;
}
```

In this example, the `title` is the important criteria while the search needs to be less exact compared to the default fuzziness.

If you don't want to use the fuzzy search, you can set <Config>cds.hana.fuzzy: false</Config> and `LIKE` expressions are used instead.

[Learn more about Fuzzy Search in CAP.](/guides/providing-services#fuzzy-search) {.learn-more}

### `cds debug` <Beta />

The new CLI command `cds debug` lets you easily debug local or remote Node.js applications in Chrome DevTools.

For local applications, `cds debug` is simply a shortcut to `cds watch --debug`:

```sh
cds debug
```

```log
  Starting 'cds watch --debug'
  ...
  Debugger listening on ws://127.0.0.1:9229/...
  Opening Chrome DevTools at devtools://devtools/bundled/inspector.html?ws=...
```

For remote applications add the name of your application in the currently targeted Cloud Foundry space:

```sh
cds debug bookshop-srv
```

```log
  Opening SSH tunnel for CF app 'bookshop-srv'
  Opening Chrome DevTools at devtools://devtools/bundled/inspector.html?ws=...
```

 This command opens an [SSH tunnel](https://docs.cloudfoundry.org/devguide/deploy-apps/ssh-apps.html), puts the application in debug mode, and connects and opens the debugger in [Chrome DevTools](https://developer.chrome.com/docs/devtools/javascript).

<video src="./assets/nov24/cds-debug_compressed_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

### `cds add handler`

You can now also have automatic handler stubs in Node.js projects for both JavaScript and TypeScript.
In your project, run:

```sh
cds add handler
```

This [facet](/tools/cds-cli#cds-add) creates [event handlers](/node.js/core-services#implementing-services) for service entities and actions like this:

::: code-group

```js [JavaScript]
const cds = require('@sap/cds')
module.exports = class CatalogService extends cds.ApplicationService { init() {
  const { Books } = cds.entities('CatalogService')

  this.before (['CREATE', 'UPDATE'], Books, async (req) => {
    console.log('Before CREATE/UPDATE Books', req.data)
  })
  this.on ('submitOrder', async (req) => {... })

  return super.init()
}}
```

```ts [TypeScript]
import cds from '@sap/cds'
import { Books, submitOrder } from '#cds-models/CatalogService'

export class CatalogService extends cds.ApplicationService { init() {
  this.before (['CREATE', 'UPDATE'], Books, async (req) => {
    console.log('Before CREATE/UPDATE Books', req.data)
  })
  this.on (submitOrder, async (req) => {... })

  return super.init()
}}
```

:::

For action stubs of *Java* projects, this feature has already been available since [September](./sep24.md#add-handler-stubs).

[Learn more about handler generation.](/tools/cds-cli#handler){.learn-more}

### `cds init --add esm` <Beta />

You can now create [ECMAScript module projects (ESM)](https://nodejs.org/api/esm.html) with `cds init --add esm` or switch to ESM later with `cds add esm`.
 Sample code added with `cds add sample` or `cds add handler` honors the setting. However, it doesn't migrate existing code.

::: details Should CAP projects use ESM?

The CAP Node.js runtime can be used in both CommonJS and ESM applications.

Our recommendation is to stay on CommonJS. Here are some guidelines to help you decide:

- The [Jest](https://jestjs.io/) test framework is known to only have [experimental support for ESM](https://jestjs.io/docs/ecmascript-modules).
- If you need to use ESM-only libraries like [SAP Cloud SDK for AI](https://github.com/SAP/ai-sdk-js) now, switching to ESM is necessary. [chai 5](https://www.npmjs.com/package/chai) is ESM-only as well, but version 4 on CommonJS is still supported.
- However, Node.js 23 already has [experimental support for ESM imports](https://nodejs.org/api/modules.html#loading-ecmascript-modules-using-require) into CommonJS applications. This approach improves ESM compatibility in CommonJS projects.

:::

## Java

### Simpler Recursive Hierarchies

To create a recursive hierarchy for a UI5 tree table, applications so far had to define a [projection](/cds/cdl#views-projections) to rename the `node` property and the foreign key to adhere to SAP HANA naming conventions.

CAP Java now automatically evaluates the `@Aggregation.RecursiveHierarchy` to identify the `node` property and the `parent` navigation property, and automatically does the renaming. It's now also possible to use a [managed association](/cds/cdl#managed-associations) for the parent navigation.

```cds
context db {
  entity SalesOrgs : cuid {
    name     : String;
    parentID : String(36); // [!code --]
    parent   : Association to SalesOrg
                on parent.ID = parentID;  // [!code --]
  }
}

service S {
  @Aggregation.RecursiveHierarchy #SalesOrgHierarchy: {
    $Type                   : 'Aggregation.RecursiveHierarchyType',
    NodeProperty            : ID,
    ParentNavigationProperty: parent
  }
  entity SalesOrgHierarchy as projection on db.SalesOrgs {
      *,
      ID       as node_id, // [!code --]
      parentID as parent_id // [!code --]
    };
}
```

### Filter & Sort by Elements in cds.Map <Beta />

You can now filter and sort by sub-elements of `cds.Map` elements. Given the CDS model using the `Map` type for `Person.details`:

```cds
entity Person {
  key ID      : UUID;
      name    : String;
      details : Map;
}
```

You can filter by sub-elements of `cds.Map` elements, for example, to select all persons named "Peter", which live in Walldorf:

```java
Select.from(PERSON).where(p -> p.name().eq("Peter").and(
    p.get("details.address.city").eq("Walldorf")));
```

You can also sort by sub-elements of `cds.Map` elements, for example, to sort by `address.city` in the `details` Map:

```java
Select.from(PERSON).where(p -> p.name().eq("Peter"))
      .orderBy(p -> p.get("details.address.city")
                     .type(CdsBaseType.String).asc());
```

To ensure that type-specific sorting is applied, specify the expected type of the sub-element.

::: warning
Avoid Filtering and sorting by elements within maps on large data sets as it's an expensive DB operation.
:::

### Enhanced Instance-Based Authorization

Entities having an instance-based authorization condition, that is [`@restrict.where`](/guides/security/authorization#restrict-annotation), are guarded by the CAP Java runtime by
adding a filter condition to the DB query. Instances that don't match the filter condition are excluded from the result. If the user isn't authorized to query an entity, OData requests targeting a *single* entity return a *404 - Not Found* even though the entity exists.

To allow the UI to distinguish between *not found* and *forbidden*, CAP Java now introduces a new configuration option <Config java label="reject-selected-unauthorized-entity">cds.security.authorization.instance-based.reject-selected-unauthorized-entity.enabled: true</Config>. If enabled, unauthorized `PATCH` and `DELETE` requests to single entities are rejected with *403 - Forbidden*.
The additional authorization check may affect performance.

[Learn more about `@restrict.where` in the instance-based authorization guide.](/guides/security/authorization#instance-based-auth){.learn-more}

::: info
It isn't checked whether the user can read the targeted entity. The handler could disclose to unauthorized users that an entity under a given key exists.
:::

## MTX

### Annotation Allowlist for Extensions

In June, we announced that [only a few annotations are allowed as extensions](/releases/archive/2024/jun24#more-extension-linter-restrictions).

You can now add exceptions for these restrictions, at your own risk, using the `annotations` property as follows:

```jsonc
"cds.xt.ExtensibilityService": {
  "extension-allowlist": [
    {
      "for": ["CatalogService"],
      // allow @readonly annotations in CatalogService
      "annotations": ["@readonly"]
    }
  ]
}
```



# October Release




## Richer Configuration Properties in cap≽ire

In cap≽ire, configuration keys are now specially highlighted with a <code class="cfg"></code> symbol.  They also open a popover that shows how to set them in various ways.

Hover over the sample properties below and switch the different tabs in the popover. You can conveniently copy the configuration snippets using the copy button.

- <Config>cds.requires.db: sqlite</Config> (Node.js)
- <Config java>cds.odata-v4.endpoint.path: /api</Config> (Java)

Let us know what you think of this feature and which configuration properties we have missed to adjust in cap≽ire.

## CDS Language & Compiler {#cds}

### New Type: cds.Map

We have introduced the [built-in type](/cds/types) `cds.Map` for representing an unspecified JSON Object structure.

```cds
service People {
  entity Person {
    key ID      : UUID;
        name    : String;
        details : Map;
  }
}
```

In OData V4 EDMX, an element of type `cds.Map` is represented as an empty, open complex type. On SAP HANA, the `Map` type is mapped to `NCLOB`, on SQLite it is mapped to `JSON_TEXT`, on H2 to `JSON`,
and on Postgres it is mapped to `JSONB`.

:::warning Currently restricted to CAP Java with OData V4
The type `cds.Map` currently is [only supported by the CAP Java runtime](#basic-support-for-cds-map) with OData v4.
:::

## Node.js {#cds-js}

### Customizing OData $batch Request Limits

We introduced a new configuration option that enables you to specifically raise the limit for the individual requests in a `$batch` request with content-type `multipart/mixed` and not for the server in general. This limit can be set with the new configuration option <Config keyOnly>cds.odata.max_batch_header_size:64KiB</Config> which comes with a default value of 64 KiB.

To maximize performance, the [new OData protocol adapter](/releases/archive/2024/jun24#new-protocol-adapters-ga) utilizes Node.js' native HTTP parser when parsing the body of `$batch` requests. By default, the parser has a limit of 16 KiB as described in [`http.maxHeaderSize`](https://nodejs.org/api/http.html#httpmaxheadersize).

> The limit for [`maxHeaderSize`](https://nodejs.org/api/http.html#httpmaxheadersize) applies to the headers but also to the [request line](https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages#request_line).

In OData requests where the filters in the request target become very long, the request line can exceed the default limit. The common workaround is to wrap GET requests with URLs exceeding the server's limit into `$batch` requests. Our new configuration option enables you to use this workaround while preserving a reasonable limit.

## Java {#cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

#### Removed Dependency to Deprecated Multitenant Library

To support multitenancy, CAP Java internally consumes APIs offered by SAP BTP [multitenant libraries](https://central.sonatype.com/namespace/com.sap.cloud.mt) (Maven group ID `com.sap.cloud.mt`).
These libraries have been put into maintenance mode, so starting with this version, CAP Java has removed these dependencies and adopted the base implementation.

:::details I used multitenancy APIs directly. What can I do?
If you made *explicitly* use of these multitenancy APIs, you can continue to offer most of them through new packages CAP Java offers. The new packages are `com.sap.cds.feature.mt.lib` and `com.sap.cds.services.utils.lib` respectively. You need to adapt package names in your custom code accordingly.

:::warning
Direct usage of these multitenant APIs is deprecated and might be removed in future versions. Consume public APIs offered by CAP instead.
:::

#### Hardened Authorization of Tenant Lifecycle Endpoints

By default, internal user access to tenant lifecycle endpoints, that is subscribe, unsubscribe or upgrade, is rejected in production profile now.
You can control internal user access by property <Config java keyOnly>cds.multi-tenancy.security.internal-user-access.enabled:true</Config>.

<span id="inoct24java" />
<Fragment target="#inoct24java">

:::warning Important for applications on DwC
Make sure to adopt at least version `2.3.15` of `utils-cap`.
:::

</Fragment>

:::warning Important Note for applications on DwC
Make sure to adopt at least version `2.3.15` of `utils-cap`.
:::

### Basic Support for cds.Map <Beta />

You can now use the new [built-in `cds.Map` type](/cds/types) for storing and retrieving arbitrary structured data. Values of elements with type `Map` are represented in CAP Java as `Map<String, Object>`.

- On write, the map data is *serialized* to a JSON object and stored on the database.
- On read, the JSON object is deserialized into a Java Map.

Since the map is serialized to a JSON object, the type of elements inside `Map` is limited to what is supported by JSON: strings, numbers, Boolean values and null, as well as nested maps and lists.

Given the CDS model using the new `Map` type for `Person.details`:

```cds
entity Person {
  key ID      : UUID;
      name    : String;
      details : Map;
}
```

You can store arbitrary data in `details`:

```java
Map<String, Object> person =
  Map.of("name", "Peter",
         "details", Map.of(
            "age", 40,
            "address", Map.of(
              "city", "Walldorf",
              "street", "Hauptstraße")));

Insert.into("Person").entry(person);
```

When you read the `Person` entity, `details` is deserialized into a Java map:

```java
Person p = db.run(Select.from(PERSON).byId(1024)).single(Person.class);
CdsData details = p.getDetails();
Integer age = details.get("age"); // 40
String city = details.getPath("address.city"); // Walldorf
```

You can also extract data from within a map using paths:

```java
Select.from("Person").byId(1024).columns("details.address");
// -> { address : { city : 'Walldorf', street: 'Hauptstraße' } }

Select.from("Person").byId(1024).columns("details.address.city");
// -> { city : 'Walldorf' }
```

:::info Temporary Limitations
Filters on `cds.Map` elements, as well as partial updates and deletes are not yet supported.
:::

### Enhancements for CDS QL

#### `IN` Subqueries

Use an in-subquery predicate to test if an element or a tuple of elements is contained in the result of a subquery. In the following, we select all authors, with the same name as a journalist:

```java
import static bookshop.Bookshop_.AUTHORS;
import static socialmedia.Journalists_.JOURNALISTS;

// fluent style
Select.from(AUTHORS).where(author -> author.name().in(
  Select.from(JOURNALISTS).columns(journalist -> journalist.name())
));
```

You may also use `CQL.in` to create an in-subquery predicate. In the following, we search for matches of the element pair `(firstName, lastName)`:

```java
// tree style
CqnListValue fullName = CQL.list(CQL.get("firstName"), CQL.get("lastName"));
CqnSelect subquery = Select.from("socialmedia.Journalists").columns("firstName", "lastName");
Select.from("bookshop.Authors").where(CQL.in(fullName, subquery));
```

[Learn more about `IN` subqueries.](/java/working-with-cql/query-api#in-subquery-predicate){.learn-more}

#### Case-When-Then Expressions

You can now use a convenient API to compose case expressions:

```java
Select.from(PERSONS).columns(
  p -> p.name(),
  p -> p.when(p.age().lt(25)).then("young")
        .when(p.age().ge(75)).then("elderly")
        .orElse("adult").as("ageTxt").type(CdsBaseType.String));
```

This query converts a person's numeric `age` value to a textual `ageTxt` representation.

### Enhancements for OData v4

#### Content Disposition Type

For stream properties, you may now use the `@Core.ContentDisposition.Type` annotation to indicate whether the content is expected to be displayed *inline* in the browser, or as an attachment that is downloaded and saved locally.

```cds
entity Books : uuid {
  ...
  @Core.MediaType: 'image/jpeg'
  @Core.ContentDisposition.Type: 'inline'
  coverImage : LargeBinary ;
}
```

When downloading the `coverImage` the runtime will set a `Content-Disposition: inline` header to advise the browser to display the cover image in the browser.

#### Omitting Null Values

In a GET request, the client may now specify a `Prefer: omit-values=nulls` header to indicate that the server may omit `null` value in the response.

### Tool Support for AMS

Use the [add](/java/assets/cds-maven-plugin-site/add-mojo.html){target="_blank"} goal of the [CDS Maven Plugin](/java/developing-applications/building#cds-maven-plugin) to add [AMS](/guides/security/authorization#role-assignments-with-ias-and-ams) integration to a CAP Java project:

```sh
mvn cds:add -Dfeature=AMS
```

## Tools { #tools}

### Renaming CDS Files in VS Code

When you rename a *.cds* file or a folder which contains CDS files, this automatically updates usages in other *.cds* files.

<video src="./assets/oct24/Rename_CDS_files_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

If you delete a *.cds* file, the plugin shows you usages in other *.cds* files.

Note: Currently, Visual Studio Code asks for confirmation first, then shows the additional refactorings in other files. At that point, it is no longer possible to cancel the deletion.
The refactorings are only for information. Applying them will likely lead to (other) compilation errors. Use (git) `Undo` in case.

<video src="./assets/oct24/Delete_CDS_files_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

<div id="secondary-file">releases/archive/2024/oct24.fragment.md</div>


# September Release


## Analytics for cap≽ire

With this release, we start using [Matomo](https://matomo.org/) to collect anonymized usage data for cap≽ire. This helps us understand, for example, key topics and prioritize areas for improvement. If you want to change your decision, visit our [Cookie Statement](/resources/cookies) page.

![This screenshot shows the box and it's radio buttons that you find following the previous link to the cookie statement.](assets/sep24/cookie-statement.png){}

## Node.js {#cds-js}

### Top Level Imports of Typed Models <Beta />

You can now import type definitions generated by [cds-typer](/tools/cds-typer) on top-level, even in test code:

```ts
import { Books } from '#cds-models/sap/capire/bookshop' // static import // [!code ++]

describe("My Tests", () => {
  cds.test(...)

  test ("first test", () => {
    const { Books } = await import('#cds-models/sap/capire/bookshop') // [!code --]
    await SELECT.from(Books)
  })
})
```

Use option <Config>cds.typer.use_entities_proxy:true</Config> in `package.json` to opt-in to this behavior. Version 0.26.0 of `cds-typer` is required at the minimum.

We would like to thank user [stockbal](https://github.com/stockbal) for this contribution to `cds-typer`.

### Richer JS/TS Snippets

In cap≽ire, JavaScript and Typescript documentation snippets can now carry type information, allowing you to get better insights in the APIs used there.

The example from [cds-typer](/tools/cds-typer) highlights the generated model-specific types in a popover and a code completion box:

```ts{2,4} twoslash
// @noErrors
// @paths: {"#cds-models/*": ["%typedModels:bookshop:resolved%"]}
import cds from '@sap/cds'
const service = new cds.ApplicationService
// ---cut---
import { Books } from '#cds-models/sap/capire/bookshop'
service.before('CREATE', Books, ({ data }) => {
//                                 ^?
  /* data is of type Books */
  data.t
//      ^|
})
```

In this example from [cds-server](/node.js/cds-server), hover over `express` or `app` objects to explore `express` APIs:

```js twoslash
const cds = require('@sap/cds')
const express = require('express')
cds.on('bootstrap', app => {
  // serve static resources incl. index.html
  app.use(express.static(__dirname+'/srv/public'))
})
```

[Let us know](https://github.com/cap-js/docs/issues) which snippets you think would benefit from type information.

### Instance-based Restrictions for Bound Actions and Functions

Instance-based restrictions for bound actions and functions are now enforced.

```cds
@restrict : [
  {grant: 'approve', to: 'Employee', where: ($user.role = 'manager') },
  {grant: 'revoke', to: 'Employee', where: (createdBy = $user) },
]
entity Travel {
  key ID: UUID;
  createdBy: String;
} actions {
  action approve();
  action revoke();
}
```

In this example, `revoke` can only be called by the employee who created it and `approve` when the user attribute 'role' equals 'manager'.
If the action or function is bound against the collection and includes any property reference, like `createdBy = $user`, it is not being enforced.

[Learn more about Authorization](/guides/security/authorization){.learn-more}

### SAP Cloud Application Event Hub for Stand-alone Apps <Beta />

[SAP Cloud Application Event Hub](https://help.sap.com/docs/event-broker) is the new default offering for messaging in SAP Business Technology Platform (SAP BTP).
Integration with SAP Cloud Application Event Hub is provided via CDS plugin [`@cap-js/event-broker`](https://github.com/cap-js/event-broker).
See [Using SAP Cloud Application Event Hub in Cloud Foundry](/guides/messaging/event-broker) for how to consume events emitted by SAP S/4 HANA Cloud in your CAP application.

[Learn more about Messaging](/node.js/messaging){.learn-more}

## Java {#cds-java}

### Enhancements to Code Generator

#### Stricter Setters in Accessor Interfaces

The [generate](/java/assets/cds-maven-plugin-site/generate-mojo.html){target="_blank"} goal of the [CDS Maven Plugin](/java/developing-applications/building#cds-maven-plugin) got a new parameter `strictSetters`, which controls wether to generate strict type-safe setter methods for associations in the accessor interfaces. Strict type-safe setters accept only collections of accessor interfaces corresponding to the target type of the association.

Let's have a look at the following model:

```cds
entity Books : cuid {
  title  : String;
  author : Association to Authors;
}

entity Authors : cuid {
  name  : String;
  books : Association to many Books on books.author = $self;
}
```

The following table shows generated accessors, based on the `strictSetters` parameter.

|mode|`false`|`true`|
|---|---|---|
|to one|`setAuthor(Map<String, ?> a)`|`setAuthor(Author a)`|
|to many|`setBooks(List<? extends Map<String, ?>> bs)`|`setBooks(List<Books> bs)`|

#### New Factory Method

Accessor interfaces now offer the new factory method `of(Map<String, Object> map)` to access the data in a given map. The method statement `Books.of(map)` is a shortcut for `Struct.access(map).as(Books.class)`.

```java
var map = Map.of("title", "CAP Rules", "year", 2024);

Books book = Books.of(map);
book.getTitle(); // CAP Rules
book.getYear(); // 2024
```

[Learn more about Working with Data](/java/cds-data#cds-data){.learn-more}

### Monitor Health Status of MTX Sidecar

A new health indicator `modelProvider` includes the health status of the [MTX sidecar](/guides/multitenancy/mtxs#sidecars), which serves the [Model Provider Service](/java/reflection-api#the-model-provider-service), into the application's [actuator/health](/java/operating-applications/observability#spring-health-checks) endpoint.

### Parameters Aliases in OData v4

In OData v4, you may now use [parameter aliases](https://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#sec_ParameterAliases) for key values as well as for parameters in function calls. Parameters aliases are names beginning with an at sign (`@`).

::: tip Special characters
Using parameter aliases allows to use special characters like slash (`/`) in values, which is not possible otherwise.
:::

#### Parameter Aliases for Entity Key Values

In the URL, you may use parameter aliases in place of literal entity keys values. Examples:

```http
GET MyService/Orders(ID=@id)?@id=ec806c06-abfe-40c0-b096-c8749aa120f0
GET MyService/Orders(ID=@order, IsActiveEntity=@active)/items(@ID=@item)?@order=ec806c06-abfe-40c0-b096-c8749aa120f0&@active=true&@item=3
```

:::warning Not within system query parameters
Such aliases can't be used within system query parameters like `$filter` or `$orderby`.
:::

#### Parameter Aliases for Function Parameter Values

In function calls, you can now use parameter aliases in the [inline parameter syntax](https://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#sec_InlineParameterSyntax) as placeholders for parameter values. Examples:

```http
GET MyService/EmployeesByManager(ManagerID=@p1)?@p1=3
GET MyService/EmployeesByManager(ManagerID=@p1)?@p1=3
```

This syntax is especially useful to supply values to function parameters with structured or arrayed type.

Considering the following CDS model:

```cds
service MyService {
  function EmployeesByIDs(IDs : many Int32) returns Employee;
  function EmployeesByName(name : { first : String; last : String; })
    returns Employee;
}
```

These are parameter aliases you can use:

```http
GET MyService/EmployeesByIDs(IDS=@ids)?@ids=[1, 5, 8]
GET MyService/EmployeesByName(name=@name)?@name={ "first" : "Sam", "last" : "Smith" }
```

### Add Handler Stubs

With the new `cds add handler` CLI command, it is now possible to generate handler stubs for actions and functions in Java projects. The feature helps you get your project up and running even quicker.

```sh
cds add handler
```

The feature is currently available for Java projects only.

[Learn more about handler generation.](/tools/cds-cli#handler){.learn-more}

### Miscellaneous

<span id="java-attachments-public" />
<Fragment target="#java-attachments-public">

- The Attachment feature is now released to [Maven Central](https://central.sonatype.com/artifact/com.sap.cds/cds-feature-attachments) and can be consumed like the other *cds-service* artifacts.

</Fragment>

- A new [CDS property](/java/developing-applications/properties) <Config java keyOnly>cds.odata-v4.fiori-preview.ui5.version:1.125.0</Config> allows to configure the UI5 version used by the [Fiori Preview](/advanced/fiori?impl-variant=java#sap-fiori-preview).

## Tools { #tools}

### Visualize Deployment Descriptor <Beta />

The _CDS Preview as diagram_ command in VS Code can visualize an _mta.yaml_:

![](./assets/sep24/mta-hint.png){.ignore-dark}

> This feature requires the [Markdown Preview Mermaid Support](https://marketplace.visualstudio.com/items?itemName=bierner.markdown-mermaid) extension

This helps you get a graphical overview of your microservices architecture and the interplay between applications and services.



![Visualization of an _mta.yaml_ file](./assets/sep24/mta-mermaid-dark.svg){.only-dark .ignore-dark}
![Visualization of an _mta.yaml_ file](./assets/sep24/mta-mermaid.svg){.only-light}

The sample rendered here was created using the following command:

```sh
cds init bookshop --add hana,xsuaa,portal,multitenancy,mta
```

::: details This also works as a visual linter...

Missing required resources or unused provided ones are highlighted in red.

This is a malformed _mta.yaml_ and its output:

```yaml{12,19}
ID: bookshop
modules:
  - name: bookshop-srv
    type: nodejs
    path: gen/srv
    requires:
      - name: my-service
    provides:
      - name: srv-api
        properties:
          srv-url: ${default-url}
      - name: unused-api # not used

resources:
  - name: my-service
    type: org.cloudfoundry.managed-service
    requires:
      - name: srv-api
      - name: incorrect-srv-api # not defined

```

![Visualization of a malformed _mta.yaml_ file](./assets/sep24/mta-mermaid-malformed.svg){.only-light}
![Visualization of a malformed _mta.yaml_ file](./assets/sep24/mta-mermaid-malformed-dark.svg){.only-dark .ignore-dark}

:::



### New Checks in CDS Lint

There are two new experimental [CDS Lint checks](/tools/cds-lint/rules/):

- `@sap/cds/sql-null-comparison` checks your model for comparisons against SQL's `NULL` value and proposes to use `IS NULL` and `IS NOT NULL` instead.
- `@sap/cds/no-java-keywords` helps you identify CDS identifiers that may clash with CAP Java's code generation, such as Java keywords.

Enable these rules by adding them to your `eslint.config.js` or `.eslintrc.json`.

Furthermore, authentication checks for `@restrict` have been reworked and improved and should no longer report false positives.

Last but not least, we have fixed bugs that prevented the CDS ESLint plugin from reporting issues in your model,
meaning running `eslint` on your command line will now work as expected.

<div id="secondary-file">releases/archive/2024/sep24.fragment.md</div>


# August Release


## Native HANA Associations

For SAP HANA, CDS associations are by default reflected in the respective database tables and views
by _Native HANA Associations_ (HANA SQL clause `WITH ASSOCIATIONS`).

These native associations are no longer needed for CAP:

* The CAP JAVA runtime used native associations only in very early versions.
* The [new HANA database service](./jun24#new-database-services-ga) in the CAP Node.js runtime
  doesn't need native associations, either.

Generation of native HANA associations increase deploy times:
They need to be validated in the HDI deployment, and they can introduce
indirect dependencies between other objects, which can trigger other unnecessary revalidations
or even unnecessary drop/create of indexes. By switching them off, all this effort is saved.

::: tip

Unless you explicitly use them in other native HANA objects, we recommend switching off their generation. For new projects, `cds add hana` automatically adds this configuration.

:::

::: code-group

```json [package.json]
{
  "cds": {
    "sql": {
      "native_hana_associations": false
    }
  }
}
```

```json [cdsrc.json]
{
  "sql": {
    "native_hana_associations": false
  }
}
```

:::

Note that the first deployment after this configuration change may take longer, as for
each entity with associations the respective database object will be touched
(DROP/CREATE for views, full table migration via shadow table and data copy for tables).
This is also the reason why we haven't changed the default so far.
Subsequent deployments will benefit, however.

[Learn more in the Database Guide.](/guides/databases-hana#native-associations){.learn-more}

## CDS Language & Compiler {#cds}

### Generating Scripts for Postgres Schema Migration

You can use `cds deploy --script ...` to generate a SQL script as a starting point for a manual
schema migration. In contrast to option `--dry`, it accepts and produces DDL statements
for changes that potentially lead to data loss and therefore are
[not supported](/guides/databases-postgres#limitations) in automatic schema migration.

In the resulting script, dangerous statements are accompanied by a warning:

```sql
-- [WARNING] this statement is lossy
ALTER TABLE sap_capire_bookshop_Books DROP price;
```

:::warning

Always check and, if necessary, adapt the generated script before you apply it
to your database!

:::

[Learn more about Generating Scripts for Schema Evolution.](/guides/databases-postgres#generate-scripts) {.learn-more}

## Node.js {#cds-js}

### Important Changes ❗️ { #changes-in-node-js .important }

* Removed array methods `forEach`, `filter`, `find`, `map`, `some`, `every` from [`LinkedDefinitions`](/node.js/cds-reflect#iterable). Convert linked definitions into arrays before using these methods, for example:

   ```js
   [...linked.definitions].map(d => d.name)
   ```

### Dynamic `cds.debug()`

The `cds.debug(<id>)` convenient helper used in CAP implementation now supports dynamic debug output activation at runtime.
In effect, you can now programmatically enable debug output for CAP modules, for example, like that:

```js
cds.log('sql','debug') // dynamically enable SQL debug output for database modules
```

## Java {#cds-java}

### Recursive Hierarchies and Fiori Tree Table Support <Beta />

CAP Java now comes with basic support for [Recursive Hierarchies](https://sap.github.io/odata-vocabularies/vocabularies/Hierarchy.html) with OData v4 on SAP HANA Cloud, allowing to serve read requests for the SAP Fiori [Tree Table](https://experience.sap.com/fiori-design-web/tree-table/), including sort, filter and search on hierarchical data.

![SAP Fiori Tree Table](assets/aug24/tree-table.png){}{.no-icon}

[For more information, refer to the OData guide.](/advanced/odata#hierarchical-transformations){.learn-more}

<span id="java-deep-authorizations" />
<Fragment target="#java-deep-authorizations">

### Deep Authorizations With Complex Conditions <Beta />

Deep authorizations are now also evaluated for associated entities that have complex restrictions with path expressions.
In the example

```cds
entity Employees @(restrict: [
    { grant:'READ', to:'Employee' }]) : cuid {
  name: String;
  contract: Association to one Contracts;
}

entity Contracts @(restrict: [
    { grant:'READ', to:'Employee', where:($user = user.logonName) }]) : cuid {
  user: Association to one Users;
  salary: Integer;
}

entity Users : cuid {
  logonName: String;
}
```

the query `READ /Employees?$expand=contract` sent by a user with role `Employee` returns all employees,
but only expands the contract owned by the user (that is, matching the user's logon name).

::: tip
Enable deep authorizations by setting<br><Config java>cds.security.authorization.deep.enabled:true</Config>.
:::

::: warning
Using path expressions and complex conditions can have a significant performance impact.
:::

</Fragment>

### Control Interface Names

Using the new `@cds.java.this.name` annotation, you can now define the name of the generated Java interfaces for entities and structured types:

```cds
@cds.java.this.name: 'MyJavaClass'
entity Class {
  key ID: String;

  @cds.java.name : 'clazz'
  class : String;
}
```

```java
@CdsName("Class")
public interface MyJavaClass extends CdsData {
  String ID = "ID";
  String CLAZZ = "class";

  @CdsName(ID)
  MyJavaClass id(String id);

  @CdsName(CLAZZ)
  String getClazz();

  // [...]
}
```

::: info

In contrast to `@cds.java.name`, the `@cds.java.this.name` annotation does **not** rename projections on the annotated entity when using cds-dk 8.2 or later.
:::

[Learn more about Renaming Types in Java.](/java/cds-data#renaming-types-in-java) {.learn-more}

### Miscellaneous

* `cds add application-logging` now adds a configuration to your CAP Java project to enhance it with [SAP Application Logging](https://discovery-center.cloud.sap/serviceCatalog/application-logging-service) support.

* `TenantProviderService.readTenants()` is now optimized for large sets of tenants and consumes significantly less memory.

## MTX

### Asynchronous Extension Activation

The activation of extensions via the Extensibility Service API can now be run asynchronously.

If you're using the [`PUT Extension/ID` API](/guides/multitenancy/mtxs#put-extensions) just set the `Prefer: respond-async` header in your request:

```http
PUT /-/cds/extensibility/Extensions/isbn-extension HTTP/1.1
Content-Type: application/json
Prefer: respond-async

{
  "csn": ["using my.bookshop.Books from '_base/db/data-model';
           extend my.bookshop.Books with { Z_ISBN: String };"],
  "i18n": [{ "name": "i18n.properties", "content": "Books_stock=Stock" },
           { "name": "i18n_de.properties", "content": "Books_stock=Bestand" }]
}
```

A URL to the job to be polled can be found in the `Location` response header.

## Tools { #tools}

### CDS IntelliJ Plugin on JetBrains Marketplace

The [SAP CDS Language Support plugin for IntelliJ](https://github.com/cap-js/cds-intellij) is now available on the [JetBrains Marketplace](https://plugins.jetbrains.com/plugin/25209-sap-cds-language-support?noRedirect=true) and thus directly installable from within IntelliJ:

[![CDS Plugin in the installation UI of IntelliJ IDE](assets/aug24/cds-jb-marketplace.png){.ignore-dark}](https://plugins.jetbrains.com/plugin/25209-sap-cds-language-support?noRedirect=true){.no-icon}

It is available for commercial IntelliJ products including IntelliJ IDEA Ultimate and WebStorm and adds features like syntax highlighting, code completion, formatting, diagnostics, and more.

> If you installed the plugin manually before from GitHub, please uninstall it first.

### Faster TypeScript Development with `cds-tsx` <Beta />

Use the `cds-tsx` CLI command as an alternative to `cds-ts`:

```sh
cds-tsx watch
# or
cds-tsx serve
```

The [`tsx`](https://tsx.is/) engine used by `cds-tsx` is much faster as it omits the type checks.

[Learn more about developing with `cds-tsx`.](/node.js/typescript#cds-tsx){.learn-more}

### Add Logging and Telemetry

If you want to use the [SAP Cloud Logging](https://discovery-center.cloud.sap/serviceCatalog/cloud-logging) service as an alternative to [SAP Application Logging](https://discovery-center.cloud.sap/serviceCatalog/application-logging-service), this is how you can configure it in your project:

```sh
cds add cloud-logging
```

In case telemetry configuration is required, add it like so:

```sh
cds add telemetry
```

> This is equivalent to `cds add cloud-logging --with-telemetry`

Alternatively, you can run this command if you prefer telemetry using Dynatrace:

```sh
cds add dynatrace
```

[See our telemetry plugins for more.](/plugins/#telemetry){.learn-more}

<div id="secondary-file">releases/archive/2024/aug24.fragment.md</div>


# July Release


## CDS Language & Compiler {#cds}

### `IsActiveEntity` In Expression Annotations

If you have enabled draft for an entity, you can now use the generated element `IsActiveEntity` in expression-like annotation values by using the prefix `$draft`:
```cds
@odata.draft.enabled
entity SomeEntity {
  key ID: UUID;
  @UI.Hidden: ( not $draft.IsActiveEntity )
  notVisibleInDraft: String;
  // ...
}
```
[Learn more about Expressions as Annotation Values.](/cds/cdl#expressions-as-annotation-values) {.learn-more}



## Node.js {#cds-js}

### Request Body Limits

The global configuration <Config keyOnly>cds.server.body_parser.limit:100kb</Config> restricts the accepted request body size for all endpoints of the server. If the payload exceeds the configured value, the request is rejected with _413 - Payload too large_.

```jsonc
{
  "cds": {
    "server": {
      "body_parser": {
        "limit": "1mb" // also accepts b, kb, etc...
      }
    }
  }
}
```

The default limit is _100 kb_, as defined by the built-in [body parsers of the underlying express framework](https://expressjs.com/en/api.html#express.json).

In addition to the global configuration, there's a service-specific annotation `@cds.server.body_parser.limit` as the expected request body sizes might vary between different services within the application.

```cds
annotate AdminService with @cds.server.body_parser.limit: '1mb';
```

[Learn more about configuring the Maximum Request Body Size.](/node.js/cds-server#maximum-request-body-size) {.learn-more}

## Java {#cds-java}


### Avoiding Transactions for Select

By default, CAP Java automatically starts one transaction per ChangeSet Context when there is a first call. Started transactions consume a significant amount of system resources, such as a database connection from the connection pool. This can lead to a bottleneck in high-load situations. However, `READ` events actually don't require transactions in most cases and can be executed in JDBC auto commit mode instead. To further limit the transaction time, setting property <Config java>cds.persistence.changeSet.enforceTransactional:false</Config> avoids initiating transactions for these Select queries in the ChangeSet Context. This significantly increases application throughput.

[Learn more about avoiding transactions for select.](/java/event-handlers/changeset-contexts#avoid-transactions) {.learn-more}

### Weighted Fuzzy Search on HANA

Use the [@Search.ranking](https://help.sap.com/doc/saphelp_nw75/7.5.5/en-US/38/baf2fc3a8e4ed887b29de738296fa9/content.htm) annotation to specify how relevant the value of an element is for the computation of the [fuzzy search](/guides/providing-services#fuzzy-search) score. The allowed values are `HIGH`, `MEDIUM` (default), and `LOW`:

```cds
entity Books {
  key id            : UUID;

      @Search.ranking: HIGH
      title         : String;

      description   : String;

      @Search.ranking: LOW
      publisherName : String;
}
```

In this `Books` entity, the element `title` is most relevant, whereas `publisherName` contributes only little to the score of the search result.

<span id="hana-hierarchy-function" />
<Fragment target="#hana-hierarchy-function">

### HANA Hierarchy Functions <Beta />

You can now use [SAP HANA Hierarchy Functions](https://help.sap.com/docs/hana-cloud-database/sap-hana-cloud-sap-hana-database-sql-reference-guide/hierarchy-functions) to work with recursive hierarchies in your domain model.

::: tip Use with SAP UI5 Tree Table
SAP HANA hierarchy functions can be used in custom code to handle the OData requests of the [SAP UI5 Tree Table](https://ui5.sap.com//#/entity/sap.ui.table.TreeTable)
:::

Hierarchies can be created on an entity that defines a recursive parent-child relation. It must declare a `node_id` element that identifies a node, as well as a `parent_id` element, which identifies a node's parent, like in this example:

```cds
entity Category {
  key node_id     : Int32;
      parent_id   : Int32;
      description : String;
}
```

Let's assume the following data:

| node_id | parent_id | description            |
|--------:|----------:|:-----------------------|
|       0 |      NULL | Software               |
|       1 |         0 | Office Software        |
|      11 |         1 | Text Editor            |
|      12 |         1 | Spreadsheet            |
|      13 |         1 | Presentation Software  |
|       2 |         0 | Content Creation       |
|      21 |         2 | Design Software        |
|     211 |        21 | Graphics Editor        |
|    2111 |       211 | Raster Graphics Editor |
|    2112 |       211 | Vector Graphics Editor |

Use the hierarchy generator function `HANA.hierarchy` to create a recursive hierarchy on this data. In the following, we define a hierarchy of all software categories where the sibling nodes are ordered by the description:

```java
Select.from(HANA.hierarchy(CQL.entity("Category")).orderBy("description"));
```

The result of this query includes additional elements `hierarchy_rank`, `hierarchy_level` and `hierarchy_tree_size` that represents the rank of a node in the tree representation, the level of a node relative to the root and the number of descendants of a node (+1), resp.:

| node_id | parent_id | description            | hierarchy_ rank | hierarchy_ level | hierarchy_ tree_size |
|--------:|----------:|:-----------------------|----------------:|-----------------:|---------------------:|
|       0 |      NULL | Software               |               1 |                1 |                   10 |
|       1 |         0 | Office Software        |               2 |                2 |                    4 |
|      13 |         1 | Presentation Software  |               3 |                3 |                    1 |
|      12 |         1 | Spreadsheet            |               4 |                3 |                    1 |
|      11 |         1 | Text Editor            |               5 |                3 |                    1 |
|       2 |         0 | Content Creation       |               6 |                2 |                    5 |
|      21 |         2 | Design Software        |               7 |                3 |                    4 |
|     211 |        21 | Graphics Editor        |               8 |                4 |                    3 |
|    2111 |       211 | Raster Graphics Editor |               9 |                5 |                    1 |
|    2112 |       211 | Vector Graphics Editor |              10 |                5 |                    1 |

In a recursive hierarchy, you can use the functions `HANA.ancestors` and `HANA.descendants` to determine the ancestor or descendant nodes of given start nodes. The following example determines the descendants of "Content Creation" node. Only descendants, which are at most two levels apart from the start node are included, and the start node itself is excluded:

```java
Hierarchy categories = HANA.hierarchy(CQL.get("Category"));
Select.from(HANA.descendants(categories)
                .startWhere(CQL.get(desciption).eq("Content Creation"))
                .distance(2, false));
```

The result of this query includes only nodes, which are at most two levels apart from the start node, and the start itself is excluded. The added element `hierarchy_distance` indicates the distance from the start node:

| node_id | parent_id | description     | hierarchy_ rank | hierarchy_ level | hierarchy_ tree_size | hierarchy_ distance |
|--------:|----------:|:----------------|----------------:|-----------------:|---------------------:|--------------------:|
|      21 |         2 | Design Software |               7 |                3 |                    4 |                   1 |
|     211 |        21 | Graphics Editor |               8 |                4 |                    3 |                   2 |

::: warning Hierarchy functions can be used with SAP HANA only
:::

</Fragment>

## Tools { #tools}

### Add Portal Configuration

A new command to set up [SAP Cloud Portal](https://discovery-center.cloud.sap/serviceCatalog/cloud-portal-service):

```sh
cds add portal
```

### Add Work Zone Configuration <Beta />

Likewise, add configuration for [SAP BTP Work Zone, Standard Edition](https://discovery-center.cloud.sap/serviceCatalog/sap-build-work-zone-standard-edition):

```sh
cds add workzone-standard
```

<div id="secondary-file">releases/archive/2024/jul24.fragment.md</div>


# June Release


## New Majors: cds8 & CAP Java 3

The June 2024 release includes updates to the major versions, version 8 for Node.js (`@sap/cds` and `@sap/cds-dk`) and version 3 for Java. Along with these changes, we're also updating the minimum required dependencies. These include:

| Dependency  | Required Version | Recommended                    |
|-------------|------------------|--------------------------------|
| **Node.js** | 18               | [20 (LTS)](https://nodejs.org) |
| **Maven**   | 3.6.3            |                                |

### (No) Breaking Changes

::: tip No breaking changes to public APIs
As usual, we've aimed to minimize breaking changes with the major updates as much as we could. In fact, we've succeeded in making **no breaking changes to public APIs**. However, there are a few changes to Node.js package dependencies that you should be aware of. These include changes to [Typescript declarations](#cds-types-dependency) and [the new database services](#new-database-services-ga).  Also, [some features are deprecated](#deprecated-features) with cds8, and some previously [deprecated ones finally got removed](#removed-features).
:::

::: warning
There are changes to the internal implementation, of course. These might affect your applications if you used any undocumented features (**which you never should**). We tried to anticipate such situations and bring these to your attention in their respective sections below.
:::

## Tools / CLI

### Mermaid Preview in VS Code

You can now visualize your CDS model as a diagram in VS Code.
Use the dropdown in the title area of the CDS editor, or the command *CDS: Preview as diagram*:

![The screenshot is explained in the accompanying text.](../../../@external/tools/assets/mermaid-preview.png) {}

[Learn more about the new Mermaid exporter that is used under the hoods.](/tools/cds-cli#mermaid) {.learn-more}

### New `cds add` Commands

#### Automate Containerization of Modules

To deployment of CAP applications to the SAP BTP Kyma Runtime or to a Kubernetes cluster, you have to containerize your modules can now be automated using the [CTZ cli](https://www.npmjs.com/package/ctz).

The new `cds add containerize` command generates a `containerize.yaml` file with all the configuration required to containerize your modules, according to the CTZ tool. After configuring your repository in the `containerize.yaml` file, you can use the below command to containerize all your modules:

```sh
ctz containerize.yaml
```

[Learn more about the `ctz` command.](https://www.npmjs.com/package/ctz) {.learn-more}

#### Add Audit Log and Attachments Configuration

You can now easily add the deployment configuration for `@cap-js/audit-logging` using:

```sh
cds add audit-logging
```

Similarly, add the deployment configuration for `@cap-js/attachments` using:

```sh
cds add attachments
```

#### Add Typescript Configuration

Add the typescript configuration to your CAP project using the command:

```sh
cds add typescript
```

### Drafts in `.http` Scripts

Support for draft entities has been added to the `cds add http` and the `Generate HTTP Requests` VS Code command. If an entity is annotated with `@odata.draft.enabled`, then the commands generate requests that can display, edit and activate the drafts.

```http
GET {{server}}/admin/Books?$filter=(IsActiveEntity eq false) HTTP/1.1
Content-Type: application/json
Authorization: Basic alice:
```

[Learn more about request generation](/tools/cds-cli#http){.learn-more}

### `cds deploy` with --*profile*

If you use `--profile` when calling `cds deploy`, it now also resolves additionally binding information based on that profile's settings. If a corresponding binding exists its service name and service key will be used. The development profile is used by default.

### Miscellaneous

#### `@sap/cds-dk` 8 Requires `@sap/cds` 7 at the Minimum

This means that if you still use `@sap/cds` 6 or lower, you will get an error from `cds` CLI commands.
To resolve this, upgrade to `@sap/cds` 8.

::: details Only as a fallback, downgrade `@sap/cds-dk`.
Run this to globally install `@sap/cds-dk` in the previous version:

```sh
npm install -g @sap/cds-dk@7
```

:::

## CDS Language & Compiler

### Transitive Localized Views Removed

As explained in the [*Localized Data* guide](/guides/localized-data#localized-helper-views), localized views are created for entities with localized data, recursively.
In previous releases this included also entities which don't have localized elements on their own,
but only associations to such. This is what we call a *transitive* localized view.

With the [New Database Services](#new-database-services-ga) the Node.js runtime doesn't need these
transitive localized views any longer (the Java runtime has been able to do without them already
for quite a while). They have become obsolete and are no longer generated.
This reduces the total number of database objects in your application and thus reduces
(re-)deployment times.

Example: Entity `Authors` has no own localized data, but only an association to
an entity with localized data. No localized view is generated for `Authors` any more.

```cds
entity Books { ...
  title : localized String; // has own localized data
}
entity Authors { ...  // has no own localized data
  books : Association to many Books;
}
```

In case you should want to switch transitive localized views back on, use the configuration shown in
[Deprecated Features](#deprecated-features) in the Node.js section below.

### Native HANA Associations

For SAP HANA, CDS associations are by default reflected in the respective database tables and views
by *Native HANA Associations* (HANA SQL clause `WITH ASSOCIATIONS`).

These native associations are no longer needed for CAP:

* The CAP JAVA runtime used native associations only in very early versions.
* The [new HANA database service](#new-database-services-ga) in the CAP Node.js runtime
  doesn't need native associations, either.

Unless you explicitly use them in other native HANA objects, we recommend
switching off the generation of native HANA associations, as they increase deploy times:
They need to be validated in the HDI deployment, and they can introduce
indirect dependencies between other objects, which can trigger other unnecessary revalidations
or even unnecessary drop/create of indexes. By switching them off, all this effort is saved.

```json
{
  "cds": {
    "sql": {
      "native_hana_associations": false
    }
  }
}
```

Note that the first deployment after this configuration change may take longer, as for
each entity with associations the respective database object will be touched
(DROP/CREATE for views, full table migration via shadow table and data copy for tables).
This is also the reason why we haven't changed the default so far.
Subsequent deployments will benefit, however.

### Association-like Calculated Elements

In previous releases we have introduced
[Publishing Association With Filter](/cds/cdl#publish-associations-with-filter)
and
[Association-Valued Calculated Elements](/cds/cdl#association-like-calculated-elements)
as beta features.
They are now generally available without restriction.

In views or projections, you can publish an association with a filter.
The ON condition of the resulting association is the ON condition of
the original association plus the filter condition, combined with `and`.
In this example, projection `P_Authors` has a new association `availableBooks`
that points only to those books where `stock > 0`:

```cds
entity P_Authors as projection on Authors {
  *,
  books[stock > 0] as availableBooks
}
```

Alternatively, you can define a filtered association already as a calculated element
in the base entity:

```cds
entity Authors : managed {
  key ID       : Integer;
  name         : String;
  books        : Association to many Books on books.author = $self;
  unavailableBooks = books[stock = 0];
}
```

### Deprecated `--to hdbtable`

Use the `cds compile --to hana` command instead of the deprecated command `cds compile --to hdbtable`. The CLI command uses the corresponding compiler method [`cds.compile.to.hana()`](/node.js/cds-compile#hana). The produced `.hdbtable/.hdbview` output is identical.

### Miscellaneous

#### Deprecation of Deploy Format `hdbcds`

The deploy format `hdbcds` for SAP HANA is deprecated. Switch to the default deploy format `hdbtable` instead.
This is not relevant for SAP HANA Cloud, where deploy format `hdbcds` could never be used.

[Learn more about Moving From *.hdbcds* To *.hdbtable*](/cds/compiler/hdbcds-to-hdbtable){.learn-more}

#### Reject Non-assignable Annotations

Annotations can only be assigned to a definition (entity, type, ...) or its
elements. Annotations in other locations
have so far resulted in a warning and are now rejected with an error like
"Annotations can't be used in a column with ‘.{ ‹inline› }’".

Example:

```cds
entity PAuthors as projection on Authors {
    @Anno: 'I am misplaced'
    books.{*},
}
```

You can safely remove these annotations, as they didn't have any effect before.

#### No `$self` in *ON* Condition of *join*

In the *ON* condition of a *join*, references starting with `$self` are no longer allowed and
will result in a compiler error:

> "Referring to the query's own elements here might lead to invalid SQL references; use source elements only".

Use table aliases instead. With `$self` it was too easy to create invalid SQL.

Example:

```cds
entity V as select from A join
  ( B join C on C.c = B.b + $self.a ) // error, use A.a instead
  on A.a = B.b;
```

#### No Definition Named `$self`

Defining an object (entity, type, ...) named `$self` is no longer allowed and
will result in the compiler error "Do not use “$self” as name for an artifact definition".
Reason: such an object causes conflicts with the special variable `$self` in some places.

```cds
entity $self {  // error
  // …
}
```

#### OData: Entities Must Have a Key

Entities without key are illegal in OData and can lead to runtime errors that are hard to detect.
The OData backend now raises the error "Expected entity to have a primary key"
for such an entity, so that problems can be detected already at compile time.

You should fix your model accordingly. If this is not possible,
you can downgrade the error to a warning or an info message:

::: code-group

```json [package.json]
{
  "cds": {
    "cdsc" {
      "severities": {
        "odata-spec-violation-no-key": "Warning"
      }
    }
  }
}
```

:::

#### OData: Collections are Nullable by Default

When defining an array element without explicitly specifying `null` or `not null`,
the resulting collection in OData now by default has `Nullable=true`.
The reason for this change is to have a consistent default within CAP.

CDS:

```cds
foo : Array of String;
```

EDMX:

```xml
<Property Name="foo" Type="Collection(Edm.String)" Nullable="true"/>
```

#### Localized Entities and `@cds.persistence.exists`

If you annotate an entity `ExistingEntity` containing localized elements with `@cds.persistence.exists`,
then the compiler will now also generate the "localized" view `localized_ExistingEntity`
on the database.
If you have already defined this view yourself as a native database object, either remove your
definition, or tell the compiler not to generate the view with

```cds
annotate localized.ExistingEntity with @cds.persistence.exists: true;
```

#### Session Variables `$at.from` and `$at.to` are Deprecated

The session variables `$at.from` and `$at.to`, used in the context of
[Temporal Data](/guides/temporal-data#serving-temporal-data),
have been deprecated, as the names are misleading.
Replace them by `$valid.from` and `$valid.to`, respectively.

## Node.js

### Important Changes❗️

Please take notice of the following changes to internal APIs, which may break your code in case you relied on such undocumented behavior, or tests that compare result snapshots which include undocumented data.

<span id="odataold-link" />
<Fragment target="#odataold-link">

- [Deprecated OData `x4` and `w4` flavours](#x4) <Internal />

</Fragment>

* [Optimizations in New Protocol Adapter](#changes-in-noa)
* [Changed: VCAP filters are *AND*-ed now](#vcap)
* [Disabled `index.html` in production](#index-html)
* [Removed`cds.ql` 'quirks' mode](#quirks-mode)
* [Standalone `@cap-js/cds-types` package](#typescript)
* [Improved Error Responses](#improved-error-responses)
* See also: [Deprecated Features](#deprecated-features)
* See also: [Removed Features](#removed-features)

### New Database Services (GA)

With *cds7* we started our journey to re-implement our database services based on a new database service architecture, which we conclude with cds8 with all currently supported databases (`@cap-js/sqlite`, `@cap-js/postgres`, `@cap-js/hana`) being **generally available** (GA) and the defaults.

For example, when creating new projects with `cds init` or when preparing for production with `cds add hana --for production`, the new database service packages are added, with the outcome looking like that in  your package.json:

```json
  "dependencies": {
    "@cap-js/hana": "^1"
  },
  "devDependencies": {
    "@cap-js/sqlite": "^1"
  },
```

There are many benefits of the new database services; highlights are:

* Various **optimizations** like using [database-native JSON functions](/guides/databases-sqlite#optimized-expands) for deep queries in single roundtrips, user-defined functions and more, to push data-processing tasks down to the database (→ improves utilization).
* Maximized **feature parity & consistency** such that tests running with SQLite will run similar with SAP HANA. Learn more about this in these sections of the database guides: [Standard Operators](/guides/databases#standard-operators), [Standard Functions](/guides/databases#functions-mappings-for-runtime-queries), and [Consistent Timestamps](/guides/databases-sqlite#consistent-timestamps).
* Full support for **eliminating transitive localized views** ([see above](#transitive-localized-views-removed)), reducing number of views by ~50%, which in turn results in significant speedup of SAP HANA upgrades.
* Support for [search on associated entities](/guides/providing-services#extend-search-to-associated-entities).

::: tip Open Source – contribution welcome!

All new database services are open source at <https://github.com/cap-js/cds-dbs>. Feel free and be invited to file features requests, bug reports, fixes, pull requests there → **contributions are welcome**.

:::

::: warning Former database implementations are deprecated...

While they are still supported with *cds8*, they will not receive new features anymore. For example, the [elimination of transitive localized views](#transitive-localized-views-removed) is not possible with the old implementations, as well as all the other improvements mentioned above.

Also expect the old implementations to be **less tested** over time, and be removed with *cds9* latest. → We strongly recommend to **use the new database services as soon as possible.**

:::

<div id="sqlite-sap" />
<Fragment target="#sqlite-sap">

::: warning For xMake builds using SQLite, you need to configure different binaries. <Internal />
The binaries for the new `better-sqlite3` package differ from the former binaries, so make sure to [change the mirror URL in the xMake environment](/get-started/troubleshooting#builds-fail-because-of-sqlite-binaries).

:::

</Fragment>

#### Plug & Play – Don't Add Driver Packages

The new database service packages are implemented as *[cds-plugins](/node.js/cds-plugins)* which makes them plug & playable. In particular that means you don't have to add any additional configuration like `cds.requires.db` (you still can of course).

More importantly: you don't have to add additional dependencies to database driver packages like `sqlite3`, `hdb` or `@sap/hana-client` → and we strongly recommend you to not do so, but leave the choice of the most suitable one to us, please. This especially applies to the choice of `hdb`  vs `@sap/hana-client`.

::: tip Don't add driver packages yourself!

... but leave the choice of the most suitable one to us, please.

:::

#### New Option `cds.features.ieee754compatible`

Set this option to `true` to force all `Decimal` and `Int64` data read from databases to be read as strings. For example given that model definition:

```cds
entity Foo {
   dec : Decimal;
   i64 : Int64;
}
```

You can write data either by providing strings or numbers, including JavaScript bigints:

```js
await INSERT.into('Foo').entries(
  { dec:  123.45,  i64:  12345  }, // plain numbers
  { dec:  123.45,  i64:  12345n }, // w/ bigints
  { dec: '123.45', i64: '12345' }, // w/ strings
)
```

When you read data as follows, it will always return strings:

```js
let foos = await SELECT.from('Foo') //>
[
  { dec: '123.45', i64: '12345' },
  { dec: '123.45', i64: '12345' },
  { dec: '123.45', i64: '12345' },
]
```

Without this flag set to `true` the behavior is database-driver-dependent, as before: SAP HANA drivers return strings, SQLite returns numbers.

::: tip CAP doesn't *cause* precision loss, but cannot *avoid* it completely

Note that this flag merely consolidates the behavior across different databases. It does not *avoid* precision loss, because that requires databases with suitable native types. This is the case for SAP HANA and PostgreSQL, but not for SQLite. For SAP HANA and PostgreSQL you can avoid precision loss by sending strings for data input, and already today get back strings, when reading data through CAP, even without this flag set to `true`. CAP never *causes* precision loss, as we never convert given data to JavaScript numbers.

:::

#### New Option `cds.features.sql_simple_queries`

Use this flag to opt out from always using json functions with the new database services as follows:

```jsonc
{ "cds": {
  "features": {
   "sql_simple_queries": 0, // always use json functions (the default)
   "sql_simple_queries": 1, // use json functions only for expands and booleans
   "sql_simple_queries": 2, // use json functions only for expands
  }
}
```

Note: when choosing level 2, values for booleans read from the database are returned as `1` and `0` instead of `true` and `false`. So ensure to always use truthy / falsy checks or `==` instead of strict checks like `===` when using that option. In all cases, the responses to HTTP requests will have the correct `true` and `false` values, of course.

#### Removed `cds.ql` 'quirks' Mode {#quirks-mode}

From now on, `cds.ql` as well as all protocol adapters, generate spec-compliant [`ref` paths](/cds/cxn#references) in `INSERT`/`UPDATE`/`DELETE` [CQN](/cds/cqn) objects. For example:

```js
INSERT.into('Books')
```

... always returns spec-compliant CQN objects now:

```js
{ INSERT: { into: { ref: ['Books']}}}
```

... instead of 'quirked' ones like that:

```js
{ INSERT: { into: 'Books' }}
```

With this, all framework components and generic handlers can expect all CQN objects to be in spec-compliant, non-quirked shape.

### New Protocol Adapters (GA)

The new protocol adapters comprise completely re-implemented adapters for OData and REST. Main benefits are:

* Code base of `@sap/cds` is reduced by a factor of 2
* Model-related memory consumption reduced by more than a factor of 2
* Per-request overhead reduced drastically
* Requests / sec throughput expected to improve drastically

::: tip APIs and behavior relevant for CAP-based applications stay the same.

:::

::: warning Former adapter implementations are deprecated...

While they are still supported with *cds8*. And you can keep using them instead of the new ones by setting config option

```js
cds.features.odata_new_adapter = false
```

Note though, that the old implementations will not receive new features anymore. Also expect them to be **less tested** over time, and be removed with *cds9* latest. → We strongly recommend to **use the new adapters as soon as possible.**

:::

#### Noteworthy Changes❗️{#changes-in-noa}

* `@odata.context` in responses where optimized to only contain the mandatory minimum information required by the OData specification. For example it does not include which columns were selected.
* `$batch` requests are processed sequentially to avoid peak loads and thereby heating up all pool connections. We might introduce a configuration to allow some parallelization in future.
* `$search` arguments are captured as plain [`val`](/cds/cxn#literal-values) in CQN objects and optimized for SAP HANA features and syntax. OData grammar compliance is not validated anymore.
* HTTP `401 - Unauthorized` responses for basic authentication don't contain a JSON `{error}` body anymore.

#### New Input Validation

As part of the new protocol adapters we also provide a complete reimplementation of our generic input validation, which provides the following improvements and changes over the former one:

* **All input validation happen in one place now** — type checks and input validations are done by `cds.validate()` in the service layer now. Before type checks were done in the old OData library, while `@assert` checks were done in the service layer, and returned in different partial responses.
* **UUIDs are not checked for hyphens** by default. This allows to easily work data from ABAP, without any workarounds like `@odata.Type:'Edm.String'` required any longer.
* **Fixed `@mandatory` checks** — `undefined` as a value is rejected now; it passed before.

::: warning Note: `not null`  is a database constraint!

As before the CDS  `not null` declaration is a database constraint, not an application-level one. It is ***not*** checked in `cds.validate()` but only on the database, with database-specific errors. Use [`@mandatory`](/guides/providing-services#mandatory) if you want application-level checks instead. Reason for that is that quite frequently applications want to fill in missing values in custom code before an INSERT or UPDATE, which would not be possible, if `cds.validate()` would reject such input before.

:::

#### Improved Error Responses

The new protocol adapters come with new error middlewares which improve error analysis in development or in tests. This comprises better error messages, more error details, and included error stacks.

::: warning May break tests

If you tested error responses using `.to.equal({...})`  these tests may break and have to be adjusted.

:::

::: tip More to come... → adhere to the principle of minimal assumptions

Please expect more of such improvements of error details in upcoming minor releases. To avoid these to break your tests again and again, Please adhere to the recommended in the [Best Practices section of the `cds.test()` guide](/node.js/cds-test#minimal-assumptions), to always test only a minimal set of significant properties.

:::

### Fiori Drafts

#### Lean Draft as the Sole Implementation {#lean-draft}

Lean draft is now the only draft implementation, the old draft implementation, which was deprecated since cds7, is removed in cds8.

::: warning Deprecated `cds.fiori.draft_compat`

Compatibility for old-style handler registrations through the [`cds.fiori.draft_compat`](/node.js/fiori#draft-support) flag is still available in cds8, but will be removed in upcoming releases.

:::

#### Automatic Draft Garbage Collection

Outdated drafts are automatically deleted now after a no-touch period of **30 days**, which can be overridden thru the  `cds.fiori.draft_deletion_timeout` config option like that:

::: code-group

```json [package.json]
{"cds":{
  "fiori": {
    "draft_deletion_timeout": "15d"
  }
}}
```

:::

> Values can be strings as in the example above, with suffixes `w`, `d`, `h`, `hrs`, `min`, or numbers specifying milliseconds.

### ESLint v9

[ESLint 9](https://eslint.org/blog/2024/04/eslint-v9.0.0-released/) was released recently and introduced the new [flat config system](https://eslint.org/blog/2022/08/new-config-system-part-2/), which is incompatible to the former one. With cds8 we migrated to eslint9, which also allows us to simplify eslint configurations for all CAP-based projects as follows.

Simply add a file named `eslint.config.mjs` to the root of your project with the following content:

::: code-group

```js [eslint.config.mjs]
import cds from '@sap/cds/eslint.config.mjs'
export default [ ...cds.recommended ]
```

:::

This enables the recommended rules for CAP-based projects and also includes recommended rules and settings for Node.js, and browsers. The browser settings are particularly useful for UI5 content enclosed in your CAP project. You can also add additional rules or override existing ones in this file as needed, of course, following standard eslint9 ways.

::: tip `cds init` does that by default

When starting new projects using `cds init`, this file will be created for you automatically. The additional package dependency to `@sap/eslint-plugin-cds` that was required in the past for this purpose is no longer needed.

:::

### TypeScript

Following are changes in cds8 in our ongoing endeavor to enhance and improve support for CAP-based TypeScript projects...

#### Standalone `@cap-js/cds-types` Package {#cds-types-dependency}

In December 2023 we introduced the [open-source `@cap-js/cds-types` package](../2023/dec23#type-definitions-are-open-source), which contains all TypeScript declarations for `@sap/cds` APIs. While so far, we still had a hard package dependency from `@sap/cds` to `@cap-js/cds-types` — which also created unwanted overhead for pure JavaScript projects — we found a better loosely-coupled way now to achieve the same without that hard dependency.

All you have to do is to add an explicit dev dependency to your TypeScript project now:

```sh
npm add -D @cap-js/cds-types
```

With that in place, both the TypeScript compiler, as well as VS Code editors will find the type declarations for the `@sap/cds` APIs.

::: warning Imports from `@sap/cds/apis/...` are no longer supported!

As a consequence of the above, always only import `@sap/cds` APIs, while imports from `@sap/cds/apis/...` were always wrong and don't work any longer with cds8:

```ts
import { Service } from '@sap/cds'
import { Service } from '@sap/cds/apis/services' // WRONG! // [!code --]
```

::: details Deprecated since December 23... {}

As already rolled out in [December 23](../2023/dec23#type-definitions-are-open-source), imports references to undocumented `.d.ts` files, as in line 2 above, was never documented, hence always wrong. While we still supported them for a grace period since then, this grace period ends with *cds8*.

:::

::: tip Contributions welcome!

The main reason we open-sourced `@cap-js/cds-types` was to allow you to easily contribute to that together with us and improve the TypeScript declarations. So, please be invited again to use all opportunities in that regard.

:::

### Fixed `req.user/tenant`

We detected and fixed several erroneous usages of `express.Request.user` and `.tenant` in  express middlewares. Please note: There's only one public and documented way to access user and tenant information through instances of `cds.EventContext`, which in turn includes all subclasses of which like `cds.Request` instances passed to event handlers, as well as `cds.context`.

For example, try this in `cds repl`:

```js
srv = (new cds.Service).on('*', req => req.user)
srv.read(Foo) //> Anonymous {}
cds.context = {user:'me'}
srv.read(Foo) //> User { id: 'me' }
```

Alternatively, this would work as well, of course:

```js
srv = (new cds.Service).on('*', req => cds.context.user)
```

::: warning NEVER use `express.req.user/tenant`!
Note that in contrast to the above, `.user` or `.tenant` properties you might detect in your debugger on instances of [`express.Request`](https://expressjs.com/de/api.html#req) are *internal* properties of some authentication strategy implementations. These are not documented and not public and should **NEVER** be used anywhere!
:::

::: tip `cds.User.default` is now an *instance* of `cds.User`, not a class anymore.
It is thus of same nature as `cds.User.anonymous` and `cds.User.privileged` singleton instances, by default it is an alias to the former. Note that this was always only used in (our own) tests to skip all access control checks, and should never be used in production code.
:::

### Deprecated Features

As the new database services, the new protocol adapters, the new input validation are the default in *cds8*, the former implementation variants are officially deprecated from now on, and will be removed in upcoming releases. Yet for a grace period until removal, you can re-enable them through these configuration flags:

| Config Flag                          | Description                                                  |
| ------------------------------------ | ------------------------------------------------------------ |
| `cds.features.odata_new_adapter`     | Set to `false` to keep using the former, deprecated OData adapter |
| `cds.features.cds_validate`          | Set to `false` to keep using the former, deprecated input validation |
| `cds.fiori.draft_compat`             | Set to `true` to keep using legacy style draft handlers      |
| `cds.sql.transitive_localized_views` | Set to `true` to keep creating transitive localized views    |




::: tip New `attic` profile

A new  `cds.env` profile `attic`  has been added, which allows to easily switch on all deprecated features as listed above, in single server starts or test runs. For example, you can use that like that:

```sh
CDS_ENV=attic cds watch
CDS_ENV=attic jest
```

:::

::: danger Requires `@sap/cds-attic`

Whenever using these deprecated options, make sure to [install `@sap/cds-attic` as explained below](#cds-attic).

:::

#### Introducing  `@sap/cds-attic` {#cds-attic}

To optimize package sizes, we will gradually move outdated and deprecated features out of our main code base into the new package `@sap/cds-attic`. This means, whenever you use deprecated features, you need to install this package:

```sh
npm add @sap/cds-attic
```

Note that while in the beginning this package is actually empty, and deprecated features might still work without it being present, that'll change over time, as we gradually cleanup our code base and move outdated code in there.

#### Old Database Services

Also deprecated are the old database services. If you need to switch back to them, you can do so by ***not*** having the new ones in the package dependencies, and have old ones installed instead:

```json
  "dependencies": {
    "@sap/cds": "^8",
    "@sap/cds-hana": "^2"
  },
```

Note that in contrast to the new database services, the old ones don't come with plug & play defaults for the configuration, so you would add these as before, for example:

```json
  "cds": {
    "requires": {
      "db": {
        "kind": "sql",
        "[production]": {
          "kind": "hana"
        }
      }
    }
  }
```

In the transition phase to `cds8`, you may want to install both, variants, and switch between them using process env variables like that:

```json
  "dependencies": {
    "@sap/cds": "^8",
    "@sap/cds-hana": "^2",
    "@cap-js/hana": "^1"
  },
  "devDependencies": {
    "@cap-js/sqlite": "^1",
    "sqlite3": "^5"
  },
```

<span id="odataold" />
<Fragment target="#odataold">

#### OData `x4` and `w4` Flavours <Internal /> {#x4}

The [OData protocol flavours `x4` and `w4`](/advanced/odata#api-flavors) which were added in late 2020 as a beta feature, and stayed beta ever since, are officially deprecated with *cds8*, and not supported with [new database services](#new-database-services-ga), nor the [new protocol adapters](#new-protocol-adapters-ga). There will be a better replacement for that in upcoming minor releases, but that is not available yet. Projects which used this beta feature should stay on *cds7* for the time being.

</Fragment>

### Removed Features

The following features were deprecated since *cds7*, or longer, and have been removed in *cds8*:

* CSN proxy objects `<entity>_texts` → use `<entity>.texts` instead
* Legacy API `srv.stream` → use `SELECT` with a single `LargeBinary` column instead
* Legacy API `req.user.locale` → use [`req.locale`](/node.js/events#locale) instead.
* Legacy API `req.user.tenant` → use [`req.tenant`](/node.js/events#tenant) instead.
* Annotation `@assert.enum` → use [`@assert.range`](/guides/providing-services#assert-range) instead.
* Annotations `@Common.FieldControl.Mandatory` and `@FieldControl.Mandatory`
  → use [`@mandatory`](/guides/providing-services#mandatory) instead.
* Annotations `@Common.FieldControl.Readonly` and `@FieldControl.Readonly`
  → use [`@readonly`](/guides/providing-services#readonly) instead.
* Undocumented properties of `cds.Request`:
  * `.tokenInfo`
  * `._.shared`
  * `.attr`
  * `._query`
  * `._path`
* Undocumented header `x-correlationid` → use `x-correlation-id` instead
* Old middlewares, hence config option `cds.requires.middlewares = false`.
* Old draft implementation, hence config option `cds.fiori.lean_draft = false`.
* Config option `cds.features.serve_on_root = true` → use the new path scheme, or use an absolute [`@path`](/node.js/cds-serve#path) annotation as announced in the [release notes of cds 7](../2023/jun23.md#new-protocol-specific-service-endpoints).
* Config option `cds.drafts.cancellationTimeout` → use [`cds.fiori.draft_lock_timeout`](/node.js/fiori#draft-locks) instead.

### Miscellaneous

#### VCAP Filters are *AND*-ed Now {#vcap}

For example, given a configuration like that:

```jsonc
{"cds":{
  "requires": {
    "whatever": {
      "vcap": { "label": "foo", "tag": "bar" }
    }
  }
}}
```

In the past, this matched the first `VCAP_SERVICES` entry, with *either* a property `label` matching the value `"foo"` ***or*** property `tag` matching the value `"bar"` , which lead to unexpected, hard-to-resolve behaviors. This has been fixed in *cds8* by always only matching entries that match **all** specified filters.

#### No Generated `index.html` in Production {#index-html}

The default `index.html` page generated by the CAP runtime was always meant for development only. We added a specific check to *cds8* to avoid accidental shipment of an application to production with this page still served, by just not doing so if `NODE_ENV` is set to `production`.  For demonstration purposes, you can set `cds.server.index = true` to enable this feature explicitly.

#### Destination Cache Turned On by Default

On the outbound protocol adapters side, we now switch on the destination cache by default.

## Java

### Important Changes❗️

This release brings the new major version CAP Java `3.0`.
In addition to advanced security features and latest dependency versions, there are also some incompatible changes that optimize runtime behavior.
Most of the changes can be consumed in the previous version `2.10.x` already which guarantees a smooth transition.

[Learn more in migration guide.](/java/migration#two-to-three){.learn-more}

The following changes are particularly worth mentioning:

New **minimum versions** apply:

| Dependency | Minimum Version |
|------------|-----------------|
| Cloud SDK  | `5.9.0`         |
| cds-dk     | `^7` and `^8`   |
| Maven      | `3.6.3`         |

Removed some **deprecated features**:

| Feature | Replacement |
| --- | --- |
| MTX Classic | [Streamlined MTX](/java/multitenancy) |
| [`MtSubscriptionService`](https://www.javadoc.io/doc/com.sap.cds/cds-feature-mt/latest/com/sap/cds/services/mt/MtSubscriptionService.html) | [`DeploymentService`](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/DeploymentService.html) |
| `cds-feature-xsuaa`                                                                                                                        | [`cds-feature-identity`](/java/security#xsuaa-ias)                                                                                 |

Some **default behavior** has changed, most notably:

* The production profile is `cloud` matching Java buildpack behavior\
    (<Config java>cds.environment.production.profile: cloud</Config>).
* EDMX V4 is localized on the fly for all applications\
    (<Config java>cds.odataV4.lazyI18n.enabled: true</Config>).
* SQL is optimized for SAP HANA HEX engine\
    (<Config java>cds.sql.hana.optimizationMode: hex</Config>).
* Remote service calls have no activated CSRF protection\
    (<Config java>cds.remote.services.\<key\>.http.csrf.enabled: false</Config>).

**New features** are active by default:

* Actions and functions have [support for instance-based authorization](#actions-functions-iba).

Stay up to date and benefit from latest and greatest features by migrating to `3.0`! Find a step-by-step instruction to upgrade in the [migration guide](/java/migration#two-to-three).

:::warning

* cds-services `2.10.x` is now in [maintenance](../../schedule#maintenance-status) mode and **only receives critical bugfixes**.
* All versions < `2.10.x` have reached [end of live](../../schedule#end-of-life-status) and **won't be patched anymore**.

:::

### IAS Service Consumption

CAP Java now supports consumption of [SAP Cloud Identity Services Identity Authentication (IAS)](https://help.sap.com/docs/cloud-identity-services)-based services of various kinds:

* Services bound to the IAS application.
* IAS BTP reuse services consumed via service binding.
* External IAS applications [consumed via destination](#app-to-app).

Regardless the kind of service, CAP provides a unified integration as Remote Service as described in the [documentation](/java/cqn-services/remote-services#remote-odata-services).
Basic communication setup and user propagation is done under the hood, for example, an mTLS handshake is performed in case of service-2-service communication.

![The TAM graphic is explained in the accompanying text.](./assets/jun24/java-ias.png){ }

:::tip
CAP Java now requires AppRouter to be configured with mTLS in case of IAS authentication (`forwardAuthCertificates: true`).
:::

By default, mTLS protection is activated for IAS endpoints.
You can deactivate with property `sap.spring.security.identity.prooftoken: false`.

[Learn more about IAS authentication in CAP Java](/java/security#xsuaa-ias){.learn-more}

#### IAS Reuse Service With CAP {#ias-reuse}

You now can also easily create an IAS-based BTP reuse service on basis of CAP Java.

The CAP reuse service (server) needs to:

1. Configure [IAS authentication](/java/security#xsuaa-ias).
2. Bind an IAS instance that exposes services and service plans.

    ::: details Sample configuration

    ```yaml
    - name: server-identity
        type: org.cloudfoundry.managed-service
        parameters:
          service: identity
          service-plan: application
          config:
            multi-tenant: true
            catalog:
              services:
                - id: "1d5c23ee-1ce6-6130-4af4-26461bc6ef79"
                  name: "review-service"
                  plans:
                    - id: "2d5c23ee-1ce6-6130-4af4-26461bc6ef78"
                      name: "standard"
    ```

    :::

The CAP consumer application (client) needs to:

1. Create and bind the provided service from the marketplace.
2. Create an IAS instance that consumes the required service.

    ::: details Sample SAP Cloud Identity Services Identity Authentication (IAS) instance for client

    ```yaml
      - name: client-identity
        type: org.cloudfoundry.managed-service
        parameters:
          service: identity
          service-plan: application
          config:
            multi-tenant: true
            "consumed-services": [ {
              "service-instance-name": "review-service-instance"
            } ]
    ```

    :::

3. Create a Remote Service based on the binding (optional).

    ::: details Sample Remote Service configuration

    ```yaml
    cds:
      remote.services:
        Reviews:
          binding:
            name: review-service-binding
            onBehalfOf: currentUser
    ```

    :::

4. Use CQN queries to consume the reuse service (optional)

[Learn more about simplified Remote Service configuration with bindings](/java/cqn-services/remote-services#service-binding-based-scenarios) {.learn-more}

#### App to App Communication With IAS {#app-to-app}

CAP Java now also supports streamlined [communication with applications](https://help.sap.com/docs/cloud-identity-services/cloud-identity-services/consume-apis-from-other-applications),
that are not necessarily deployed to SAP BTP, leveraging SAP Cloud Identity Services Identity Authentication (IAS) communication.

The IAS server application needs to

1. Configure [IAS authentication](/java/security#xsuaa-ias).
2. Expose an API in the IAS service instance.

    ::: details Sample IAS instance of server

    ```yaml
    - name: server-identity
        type: org.cloudfoundry.managed-service
        parameters:
          service: identity
          service-plan: application
          config:
            multi-tenant: true
            provided-apis:
              - name: "review-api"
    ```

    :::

3. Prepare a CDS service endpoint for the exposed API.

    ::: details Sample CDS Service for the API

    ```cds
    service ReviewService @(requires: 'review-api') {
      [...]
    }
    ```

    :::

To setup a connection to such a system, the client requires to do:

1. Create an IAS instance that consumes the required API.

    ::: details Sample IAS instance for client

    ```yaml
    - name: client-identity
        type: org.cloudfoundry.managed-service
        parameters:
          service: identity
          service-plan: application
          config:
            multi-tenant: true
            oauth2-configuration:
              token-policy:
                grant_types:
                  - "urn:ietf:params:oauth:grant-type:jwt-bearer"
    ```

    :::

2. Create a Remote Service based on the destination (optional).
    ::: details Sample Remote Service configuration

    ```yaml
    cds:
      remote.services:
        Reviews:
          destination:
            name: review-service-destination
    ```

    :::

To activate the app-2-app connection as subscriber, you need to

1. Create an IAS application dependency in the IAS tenant pointing to the server's exposed API (Cloud Identity Service UI: [Application APIs / Dependencies](https://help.sap.com/docs/cloud-identity-services/cloud-identity-services/communicate-between-applications)).

2. Create a dedicated [destination](https://help.sap.com/docs/connectivity/sap-btp-connectivity-cf/access-destinations-editor) provided by the subscriber that points to the application.
   The prepared destination needs to have
    * The URL pointing to the IAS-endpoint of the application.
    * Authentication type `NoAuthentication`.
    * Attribute `cloudsdk.ias-dependency-name` with the name of the created IAS application dependency.

[Learn more about how to consume external application APIs with IAS](https://help.sap.com/docs/cloud-identity-services/cloud-identity-services/consume-apis-from-other-applications) {.learn-more}

[Learn more about simplified Remote Service configuration with destinations](/java/cqn-services/remote-services#destination-based-scenarios) {.learn-more}

### Auth Filters for Actions and Functions {#actions-functions-iba}

`CqnSelect` statements propagated with the context of bound actions and functions now respect filter conditions of [restrictions](/guides/security/authorization#instance-based-auth):

```cds
service CustomerService @(requires: 'authenticated-user') {
  entity Orders @(restrict: [
    { grant: 'cancel', to: 'Customer', where: ($user.limit > invoiceAmount)}
  ]) {
    invoiceAmount: Integer;
  }
  actions {
     action cancel ();
  }
}
```

The custom handler code uses the query to locate the entities that the action or function is authorized for. In other words, it includes an extra filter: `$user.limit > invoiceAmount`:

```java
@On(service = CustomerService_.CDS_NAME, entity = Orders_.CDS_NAME)
public void onCancelOder(OrdersCancelContext context) {
    CqnSelect restrictedOrders = context.getCqn(); // selects authorized entities only
    Result orders = persistenceService.run(restrictedOrders);
    /* process filteredOrders here */
}
```

:::tip
Note that the **runtime does not reject the action or function** in case entities are excluded from the query due to an authorization condition.
:::

Filters for actions and functions can be deactivated by setting <Config java>cds.security.authorization.instance-based.custom-events.enabled: false</Config>.

<span id="java-deep-authorizations" />
<Fragment target="#java-deep-authorizations">

### Deep Authorizations <Beta /> <Internal />

In previous versions, only the target entities of CQN `READ` queries get authorization. However, navigated entities can also contribute to the results. They do this through expands or paths in filter conditions.

The generic authorization handler now analyses the entire query statement, whereby path expressions and extensions with `expand` or `inline` are inspected and authorized.

Imagine a scenario where `Managers` should have full access to `Contracts` but `Employees` may only read their own contracts:

```cds
entity Employees @(restrict: [
    { grant:'READ', to:'Employee' },
    { grant:'*', to:'Manager' } ]) {
  name: String;
  contract: Association to one Contracts;
}

entity Contracts @(restrict: [
    { grant:'READ', to:'Employee', where:($user = userId) },
    { grant:'*', to:'Manager' } ]) {
  userId  : User;
  salary  : Integer;
}
```

While checking the restriction on `Employees` was possible in previous versions, CAP Java 3.0 now also authorizes **associated** entity `Contracts` in

- Expands
- Inlines
- Paths in filter conditions.

For example, the responses to requests by an `Employee` user with id 1 (and salary > 100.000) would be:

| Query                                              | CAP Java < 3.0                                    | CAP Java 3.0               |
|----------------------------------------------------|---------------------------------------------------|----------------------------|
| `READ /Employees/contract`                         | `Contracts(1)`                                    | `Contracts(1)`             |
| `READ /Employees?$expand=contract`                 | all `Contracts`<sup>1</sup>                       | only `Contracts(1)`        |
| `READ /Employees?$select=name,contract/salary`     | all `Contracts.salary`<sup>1</sup>                | only `Contracts(1).salary` |
| `READ /Employees?where(contract/salary > 100.000)` | All `Employees` with salary > 100.000<sup>1</sup> | only `Employees(1)`        |

> <sup>1</sup> You either have to redesign the model (for example, use a function to retrieve contracts) or add custom code!

:::tip

**Deep authorizations apply to entities that are navigable via associations only**.
Entities of composition trees (documents) are authorized by the root entity.

:::

Deep authorizations are off by default and can be enabled by setting <Config java>cds.security.authorization.deep.enabled: true</Config>.

</Fragment>

### Outbox Observability

The persistent Outbox now periodically sends statistic data to [Open Telemetry](/java/operating-applications/observability#open-telemetry) and [CDS actuator](/java/operating-applications/observability#cds-actuator):

* `coldEntries`: Number of entries that reached the maximum number of retries.
* `remainingEntries`: Number of entries stored in the Outbox.
* `{min|max}StorageTimeSeconds`: Minimum and maximum time an entry is stored in the Outbox.

The data sent is labeled with the Outbox instance and tenant.

### Miscellaneous

* Java projects can now be generated without configured persistency: `cds init --add java --java:mvn persistence=false,archetypeVersion=3.0.0`.
* `cds add audit-logging` is supported now.
* mTLS support for connections to PostgreSQL.

## MTX

::: warning Adapt health check endpoint

As the generic *index.html* is [not served any more](#index-html) in cds8 you might have to change the health check endpoint in your deployment descriptor from `/` to `/health`.

:::

### SAP HANA Driver Required

With `@sap/hdi-deploy` version 5 used by `@sap/cds-mtxs` 2 , you now need to have a dependency to an SAP HANA driver in your MTX sidecar project.

If not already done, install package [`@cap-js/hana`](https://www.npmjs.com/package/@cap-js/hana) for this.
In `mtx/sidecar`, run:

```sh
npm add @cap-js/hana
npm rm hdb @sap/hana-client @sap/cds-hana  # removes explicit and legacy adapters
```

::: details `@cap-js/hana` installs the `hdb` driver for SAP HANA.
The `hdb` driver is recommended by CAP for example because of its small install size.
Check the [feature comparison chart](https://www.npmjs.com/package/hdb) for `hdb` and `@sap/hana-client` to make sure that your app doesn't use features not supported by the `hdb` driver.
:::

### Simplified SaaS Dependency Management

Instead of overwriting the `dependencies` handler in the MTX sidecar you can specify SaaS registry dependencies using the `subscriptionDependency` property. It points to the relevant key path in the service credentials (usually `xsappname`).

::: code-group

```json{5} [mtx/sidecar/package.json]
"cds": {
 "requires": {
    "my-service": {
      "vcap": { "label": "my-label" },
      "subscriptionDependency": "xsappname"
    }
  }
}
```

:::

[See the detailed section on SaaS registry dependencies](/guides/multitenancy/#saas-dependencies){.learn-more}

For convenience, `@sap/cds-mtxs` provides defaults for commonly used dependent services out of the box, such as for the SAP BTP Audit Logging, SAP BTP Connectivity, SAP BTP Destination, and SAP BTP Portal services. Simply setting to `true` is enough:

::: code-group

```jsonc [mtx/sidecar/package.json]
"cds": {
  "requires": {
    "audit-log": true,
    "connectivity": true,
    "destinations": true,
    "html5-repo": true,
    "portal": true
  }
}
```

:::

### New Extension Project Structure

`cds pull` now updates the structure of extension projects to a structure using `npm workspaces`. It downloads the base model into an NPM workspace folder `.base` as a package. To make the downloaded base model ready for use in your extension project, install it as a package:

```sh
npm install
```

This will link the base model in the workspace folder to the subdirectory `node_modules/<base app>`.

For existing projects, you might need to adapt the references (`using from '...'`).

::: details New project structure for extension projects
So far, extension project had the following structure.

```zsh
extension
├── db
│   ├── ext.cds
├── node_modules
│   └── _base
│       └── index.csn
├── package.json
└── srv
```

When running `cds pull`, the base model was stored inside the `node_modules` folder. In case `npm install` was called, the base model was deleted by npm again.

With the new structure, this is fixed by using the [npm workspaces](https://docs.npmjs.com/cli/v10/using-npm/workspaces). This will link the base model in the workspace folder to the subdirectory node_modules/<base app> but at the same time removes the risk of loosing the base model through npm actions.

```zsh
extension
├── .base
│   ├── index.csn
│   └── package.json
├── db
│   └── ext.cds
├── node_modules
│   ├── ...
│   ├── bookshop -> ../.base
│   ├── ...
├── package.json
└── srv
```

The `package.json` now contains the section

```json
"cds": {
  "extends": "bookshop"
},
"workspaces": [
    ".base"
  ]
```

Since the folder for base model has changed, your extension sources might have to be adapted like

`using sap.capire.bookshop from '_base';`

to

`using sap.capire.bookshop from 'bookshop';`

The name of the reference is derived from the label specified by `extends` in the `package.json` file.
:::

### More Extension Linter Restrictions

The extension linter that checks extensions before they can be activated now always checks critical annotations, even if no [extension linter configuration](/guides/multitenancy/mtxs#extensibility-config) exists.

::: details The following annotations are blocked:

Security annotations as extensions

```cds
@requires
@restrict
```

Persistence annotations as extensions

```cds
@cds.persistence.exists
@cds.persistence.skip
@cds.autoexpose
@cds.external
@cds.persistence.journal
@sql.append
@sql.prepend
```

Validation annotations as extensions

```cds
@readonly
@mandatory        // allowed if default is specified
@assert.unique
@assert.integrity
@assert.target
@assert.format
@assert.range    // allowed if default is specified
@assert.notNull  // allowed if default is specified
```

Service annotations as extensions

```cds
@path
@impl
@cds.autoexpose
@cds.api.ignore
@odata.etag
@cds.query.limit
@cds.localized
@cds.valid.from
@cds.valid.to
@cds.search
```

Annotations on new entities

```cds
@cds.persistence.journal
@cds.persistence.exists
@sql.append
@sql.prepend
```

:::

### Miscellaneous

#### Removed UIFlex Support From Extensibility API

The undocumented API for UIFlex extensions has been removed.

#### Removed cds.Subscriber Role From Build-in Mock Users

As non-technical users usually cannot trigger subscriptions and unsubscriptions, role `cds.Subscriber` has been removed from the [build-in mock users](/node.js/authentication#mock-users).

#### Classic Multitenancy Package has Reached End of Life

Package `@sap/cds-mtx` has reached [end of life](../../schedule#end-of-life-status) and is no longer supported.<br>
If you still use it, [migrate to `@sap/cds-mtxs`](/guides/multitenancy/old-mtx-migration) now.

## CAP Plugins

### Attachments w/ Malware Scans

The Attachments plugin [@cap-js/attachments](https://www.npmjs.com/package/@cap-js/attachments/) now supports automatic malware scanning for uploaded files, using [SAP Malware Scanning Service](https://discovery-center.cloud.sap/serviceCatalog/malware-scanning-service). This addition provides an extra layer of security, ensuring that all uploads are checked for malicious content seamlessly in the background.

* A new status feature shows the current state of each scan, including `Unscanned`, `Scanning`, `Infected`, `Clean`, and `Failed`.
* Scanning is enabled by default but is disabled in the development profile to streamline the testing process. You can disable malware scanning by setting <Config>cds.requires.attachments.scan: false</Config>.

<video src="./assets/jun24/malware_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

### New SAP Document Management Service Plugin <Beta />

The new CDS plugin [@cap-js/sdm](https://www.npmjs.com/package/@cap-js/sdm/) is now available as [open source on GitHub](https://github.com/cap-js/sdm). You can easily add the package to your application's dependencies and use the `Attachments` type in your model.

```sh
npm add @cap-js/sdm
```

![Screenshot showing the attachments table in an SAP Fiori UI.](assets/jun24/sdm-table.png)

[Find more details about the SAP Document Management Service Plugin.](https://github.com/cap-js/sdm#readme){.learn-more}

### New Open Resource Discovery Plugin

A new CDS plugin package for [Open Resource Discovery (ORD)](https://sap.github.io/open-resource-discovery/) is now available and [open source](https://github.com/cap-js/ord). Simply add package `@cap-js/ord` to your application's dependencies to generate an ORD document for your CAP Application.

![Screenshot showing the ORD Document generated](../../../@external/plugins/assets/index/ordCLI.png){ .mute-dark}

[Find more details about the ORD Plugin.](/plugins/#ord-open-resource-discovery){.learn-more}

## CAP on Kyma/K8s

### Interactive Helm Chart Prompts

`cds add helm` will now ask prompts at the first execution to fill data in *values.yaml*.

```log
[…]
Adding feature 'helm'...
domain: (abc.com)
imagePullSecret: (docker-registry)
registry: (registry-name)

Successfully added features to your project.
```

You can use `--y` flag with `cds add helm` command if you want to use defaults.

### Changes in the Helm Chart

With this release, the structure of the *values.yaml*, added by [`cds add helm`](/guides/deployment/to-kyma#deploy-to-kyma), has changed:

::: code-group

```yaml [values.yaml]
global:
  domain: <your-domain>
  imagePullSecret:
    name: <your-imagepull-secret>
  image: # [!code ++]
    registry: <your-container-registry> # [!code ++]
    tag: latest # [!code ++]
srv:
  ...
  image:
    repository: <your-container-registry>/bookshop-srv # [!code --]
    tag: latest # [!code --]
    repository: bookshop-srv # [!code ++]
...
approuter:
  ...
  image:
    repository: <your-container-registry>/bookshop-approuter # [!code --]
    tag: latest # [!code --]
    repository: bookshop-approuter # [!code ++]
...
hana-deployer:
  ...
  image:
    repository: <your-container-registry>/bookshop-hana-deployer # [!code --]
    tag: latest # [!code --]
    repository: bookshop-hana-deployer # [!code ++]
...
```

:::

You no longer have to specify registry name and tag with all the images. You can just specify it once in the global property. You can still specify tags at workload level if your tags are different.

#### Removal of mtxs-configmap

Earlier `configmaps` were used to provide environment variables required in multitenant application. Now, env variables are directly added to *values.yaml*.

Node application with App Router:

::: code-group

```yaml [values.yaml]
sidecar:
  ...
  env: # [!code ++]
    SUBSCRIPTION_URL: https://${tenant_subdomain}-{{ .Release.Name }}-approuter-{{ .Release.Namespace }}.{{ .Values.global.domain }} # [!code ++]
  envFrom: # [!code --]
  - configMapRef: # [!code --]
      name: "{{ .Release.Name }}-mtxs-configmap" # [!code --]
  ...
```

:::

Java application with App Router:

::: code-group

```yaml [values.yaml]
srv:
  ...
  env:
      CDS_MULTITENANCY_APPUI_TENANTSEPARATOR: "-" # [!code ++]
      CDS_MULTITENANCY_APPUI_URL: https://{{ .Release.Name }}-approuter-{{ .Release.Namespace }}.{{ .Values.global.domain }} # [!code ++]
      CDS_MULTITENANCY_SIDECAR_URL: http://{{ .Release.Name }}-sidecar.{{ .Release.Namespace }}.svc.cluster.local:8080 # [!code ++]
  envFrom: # [!code --]
  - configMapRef: # [!code --]
      name: "{{ .Release.Name }}-mtxs-configmap" # [!code --]
  ...
```

:::

> In the *values.yaml*, these environment variables may be overwritten by `cds add` commands. If you want to provide your own value and don't want `cds add` commands to overwrite the value of any particular variable, add `#cds.noOverwrite` comment next to that value.

#### Removal of saasRegistryParameters Key

Previously, a separate key `saasRegistryParameters` was used to specify parameters of `saas-registry` service. Now, this key is removed and the parameters are mentioned in the `saas-registry` key directly.

::: code-group

```yaml [values.yaml]
saas-registry:
  serviceOfferingName: saas-registry
  servicePlanName: application
  parameters: # [!code ++]
    displayName: bookshop # [!code ++]
    description: A simple CAP project. # [!code ++]
    category: "CAP Application" # [!code ++]
    appUrls: # [!code ++]
      onSubscriptionAsync: true # [!code ++]
      onUnSubscriptionAsync: true # [!code ++]
      onUpdateDependenciesAsync: true # [!code ++]
      callbackTimeoutMillis: 300000 # [!code ++]
      getDependencies: https://{{ .Release.Name }}-approuter-{{ .Release.Namespace }}.{{ .Values.global.domain }}/-/cds/saas-provisioning/dependencies # [!code ++]
      onSubscription: https://{{ .Release.Name }}-approuter-{{ .Release.Namespace }}.{{ .Values.global.domain }}/-/cds/saas-provisioning/tenant/{tenantId} # [!code ++]
    xsappname: bookshop-{{ .Release.Namespace }} # [!code ++]
    appName: bookshop-{{ .Release.Namespace }} # [!code ++]
  parametersFrom: # [!code --]
    - secretKeyRef: # [!code --]
        name: "RELEASE-NAME-saas-registry-secret" # [!code --]
        key: parameters # [!code --]
saasRegistryParameters: # [!code --]
  xsappname: bookshop # [!code --]
  appName: bookshop # [!code --]
  displayName: bookshop # [!code --]
  description: A simple self-contained bookshop service. # [!code --]
  category: "CAP Application" # [!code --]
  appUrls: # [!code --]
    getDependencies: "/-/cds/saas-provisioning/dependencies" # [!code --]
    onSubscription: "/-/cds/saas-provisioning/tenant/{tenantId}" # [!code --]
    onSubscriptionAsync: true # [!code --]
    onUnSubscriptionAsync: true # [!code --]
    onUpdateDependenciesAsync: true # [!code --]
    callbackTimeoutMillis: 300000 # [!code --]
```

:::

#### Support for External Destinations

The `backendDestinations` key now supports adding external destinations.

```yaml
...
backendDestinations:
  srv-api:
    service: srv
  ui5: # [!code ++]
    external: true # [!code ++]
    name: ui5 # [!code ++]
    Type: HTTP # [!code ++]
    proxyType: Internet # [!code ++]
    url: https://ui5.sap.com # [!code ++]
    Authentication: NoAuthentication # [!code ++]
```

### Generated Chart

`cds add helm` command won't generate static files (subcharts and templates) when `cds add helm` is executed. Instead, `cds build` generates the `chart` folder containing all the static data in the `gen` folder.

<div id="secondary-file">releases/archive/2024/jun24.fragment.md</div>


# May Release


_The May 2024 release only contains updates for the CAP Service SDK for Java._
{}

## Java {#cds-java}

### Diff Processor

In business logic, there might be the need to compare two states of an entity, for example, before and after an operation. Usually, you want to react on changed values, for instance, to track changes accordingly. For this purpose you can now use the new `CdsDiffProcessor` API. It traverses through two states of the entity and reports differences to a `CdsDiffVisitor`, which can react on the changes according to the use case's needs:

```java
CdsDiffProcessor diff = CdsDiffProcessor.create();
diff.add(new DiffVisitor() {
  @Override
  public void changed(Path newPath, Path oldPath, CdsElement element, Object newValue, Object oldValue) {
      // for example, log changes
  }

  @Override
  public void added(Path newPath, Path oldPath, CdsElement association, Map<String, Object> newValue) {
      // for example, send out event
  }

  @Override
  public void removed(Path newPath, Path oldPath, CdsElement association, Map<String, Object> oldValue) {
      // for example, delete related resources
  }
});

Result newImage = service.run(Select.from(...));
Result oldImage = service.run(Select.from(...));

diff.process(newImage, oldImage, newImage.rowType());
```

[Learn more about the Diff Processor.](/java/cds-data#diff-processor){.learn-more}

### Change Tracking - Human-Readable Identifiers for Associations

You can now use the `@changelog` annotation to specify a human-readable identifier for an associated entity:

```cds
annotate Orders {
  customer @changelog: [ customer.name ]
}
```

With this annotation, the change log will not log the (technical) customer ID if an associated customer changes but instead the customer's name is logged.

[Learn more about Identifiers for Associated Entities.](/java/change-tracking#human-readable-values-for-associations){.learn-more}

### Fuzzy Search on SAP HANA Cloud <Beta />

If you run CAP Java in [`HEX` optimization mode](/java/cqn-services/persistence-services#sql-optimization-mode) on SAP HANA Cloud, you can now enable [fuzzy search](/guides/providing-services#fuzzy-search) in your _application.yaml_ and configure the default fuzziness (range [0.0, 1.0], 1.0 is exact).

```yml
cds.sql.hana.search
   fuzzy: true
   fuzzinessThreshold: 0.9
```

Override the fuzziness for elements, using the `@Search.fuzzinessThreshold` annotation:

```cds
entity Books {
  @Search.fuzzinessThreshold: 0.7
  title : String;
}
```

### Exact Wildcard Search

The wildcards '*' matching zero or more characters and '?' matching a single character are now supported in search terms. Using wildcards in [fuzzy search](/guides/providing-services#fuzzy-search) mode triggers a fallback to _exact pattern search_. You can escape wildcards using '\\'.

### Control Max Age of HTTP Responses

Use the `@http.CacheControl: {maxAge: <seconds>}` and CAP Java will set a corresponding `Cache-Control: max-age=<seconds>` header in the response. The header allows to control the behavior of client-side caches, the `max-age` (in seconds) specifies the maximum age of the content before it becomes stale:

```cds
entity Book : uuid {
  title : String;
  @http.CacheControl: { maxAge: 86400 }
  @Core.MediaType: 'image/png'
  cover : LargeBinary;
  price : Decimal(10,2);
}
```

The client may cache the cover image for 86400 s (1 day).

### OData v4 - Key-as-Segment Convention

For OData v4, CAP Java now supports the Key-as-Segment Convention in the URL.

You can now send:

```http
GET https://host/service/OrderItems/1/2
```

Which is equivalent to:

```http
GET https://host/service/OrderItems(OrderID=1,ItemNo=2)
```

[Learn more about the Key-as-Segment Convention](https://docs.oasis-open.org/odata/odata/v4.02/csd01/part2-url-conventions/odata-v4.02-csd01-part2-url-conventions.html#KeyasSegmentConvention){.learn-more}

### CAP Developer Dashboard <Alpha />

![Screenshot of the CAP developer dashboard UI.](assets/may24/dashboard.jpg)

The CAP Developer Dashboard simplifies development by providing a centralized point where developers can efficiently manage and monitor their CAP applications. It offers tools and functions to support the development process and helps developers to quickly identify and resolve problems. Additionally, the dashboard facilitates better integration of CAP components, such as messaging, resilience and multitenancy, ensuring seamless functionality throughout CAP applications.

Add the `cds-feature-dev-dashboard` feature to your maven dependencies:

```xml
<dependency>
    <groupId>com.sap.cds</groupId>
    <artifactId>cds-feature-dev-dashboard</artifactId>
</dependency>
```

Navigate to the dashboard using the "Dashboard UI" navigation link on the index page:

![screenshot of the index page](assets/may24/index.jpg)

::: warning Only to be used in development
The dashboard is only intended for use in the development environment. It is strictly forbidden to use the dashboard in a production environment, as it allows access to sensitive data and presents a security risk.
:::

<div id="secondary-file">releases/archive/2024/may24.fragment.md</div>




# April Release




## Fewer Views in Database <Beta />

New option `cds.sql.transitive_localized_views: false` allows to skip generating _transitive_ localized views. For example, use it like that in your _package.json_ or in your _.cdsrc.json_:

::: code-group

```json [package.json]
{ "cds": {
  "sql": {                              // [!code focus]
    "transitive_localized_views": false // [!code focus]
  }                                     // [!code focus]
}}
```

:::

::: tip Java: `false` as default
In CAP Java, transitive localized views are never used. Hence the default value is `false` and you automatically benefit from fewer views.
:::

::: warning Node.js: Only with new database services
In CAP Node.js, transitive localized views can only be disabled when using _new_ database services. For compatibility with old database services the default value is still `true`, but will be changed to `false` in the future.
:::

::: details What are transitive localized views?

As explained in the [_Localized Data_ guide](/guides/localized-data#localized-helper-views), localized views are created for entities with localized data, recursively. This also includes entities which don't have localized elements on its own, but only associations to such. For example:

```cds
entity Books { ...
  title : localized String; // has own localized data
}
entity Authors { ...
  books : Association to many Books;
}
```

Without `cds.sql.transitive_localized_views: false`, a localized view is created for `Authors` as well, because it has an association to `Books` which has localized data. This is what we call a _transitive_ localized view.

:::

::: details Dry-run in your project...

For example when running this in _cap/sflight_:

::: code-group

```sh [Mac/Linux]
cds_sql_transitive__localized__views=true  cds \* -2 sql | grep -c VIEW
cds_sql_transitive__localized__views=false cds \* -2 sql | grep -c VIEW
```

```cmd [Windows]
set cds_sql_transitive__localized__views=true
cds * -2 sql | find /C "VIEW"
set cds_sql_transitive__localized__views=false
cds * -2 sql | find /C "VIEW"
```

This should print out some numbers, showing that the number of views created in the database is reduced from 80 to 55, like this:

```txt
80
55
```

:::

::: tip Speeds up database upgrades
This option can significantly reduce the number of views in your database, which can speed up database upgrades significantly, especially using SAP HANA.
:::

## Expressions as Annotation Values <Beta /> { #expression-annotations }

The handling of [expressions as annotation values](/cds/cdl#expressions-as-annotation-values)
has been significantly enhanced.

### Propagation

When annotations are propagated in views/projections or along type references,
the compiler now automatically adapts references in expression-like annotation values, if necessary.

Example:

```cds
entity E {
  @Common.Text: (text) // [!code highlight]
  code : Integer;
  text : String;
}
entity P as projection on E {
  code,
  text as descr // [!code highlight]
}
```

When propagated to element `code` of projection `P`, the annotation is automatically
rewritten to `@Common.Text: (descr)` due to the renaming of `text` to `descr`.

::: tip Note the syntax

Expression-like annotation values need to be enclosed in parentheses.
It's still possible to provide a reference as an annotation value without parentheses,
but such references are not adapted.

:::

### References in OData Annotations

When the CDS model is flattened for OData generation, references in expression-like annotation
values are automatically adapted.

Example:

```cds
type Price {
  @Measures.ISOCurrency: (currency) // [!code highlight]
  amount : Decimal; // [!code highlight]
  currency : String(3);
}
service S {
  entity Product {
    key id : Integer;
    name : String;
    price : Price; // [!code highlight]
  }
}
```

The resulting annotation in EDMX correctly references the flattened element:

```xml
<Annotations Target="S.Product/price_amount">
  <Annotation Term="Measures.ISOCurrency" Path="price_currency"/>
</Annotations>
```

::: warning Restrictions concerning the foreign key elements of managed associations

1. Usually an annotation assigned to a managed association is copied to the foreign key elements of the association.
This is _not_ done for annotations with expression values. That means, it's currently not possible
to use expression-valued annotations for annotating foreign keys of a managed association.

2. In an expression-valued annotation, it's not possible to reference the foreign key element
of a managed association.

:::

### Expressions in OData Annotations

Expressions in OData annotations are automatically translated to the corresponding EDMX syntax. You can now simply write the following:

```cds
service S {
  @UI.LineItem : [{
    Value: (status),
    Criticality: ( status = 'O' ? 2 : ( status = 'A' ? 3 : 0 ) )  // [!code highlight]
  }]
  entity Order {
    key id : Integer;
    status : String;
  }
}
```

Previously, you'd have needed to write the following expression:

```cds
Criticality : { $edmJson: { $If: [{$Eq: [{ $Path: 'status'}, 'O']}, 2,
                          { $If: [{$Eq: [{ $Path: 'status'}, 'A']}, 3, 0] }] } }
```

<div id="relnote-embedded-analytics" />
<Fragment target="#relnote-embedded-analytics" type="internal">

## Embedded Analytics

With Embedded Analytics you can evaluate and analyze real-time business data directly in your
SAP HANA-based CAP application, without having to replicate data to an external data warehouse.

Using CDS, you define a multidimensional analytical model on top of the entities of your application's domain model.
The necessary runtime objects and metadata for SAP HANA's built-in analytical query engine
are automatically created upon deployment.
Analytical clients like SAP Analytics Cloud (SAC) can connect directly to the CAP application,
which have a built-in endpoint for handling analytical queries using the InA (Information Access) protocol.

[Learn more about Embedded Analytics.](/advanced/embedded-analytics) {.learn-more}

</Fragment>

## Node.js {#cds-js}

### INSERT w/ Streams and Subselects

With new database services (SAP HANA, PostgreSQL and SQLite) you can now specify streams and subselect queries as arguments to `INSERT.entries()`, for example:

Using a **stream** instead of reading and parsing full JSONs or alike into memory:

```js
let streamed = fs.createReadStream('books.json')
await INSERT.into(Books) .entries (streamed)
```

Using a **subselect** query to copy _within_ the database:

```js
await INSERT.into(Books) .entries (SELECT.from(Products))
```

[Learn more about `INSERT.entries()`](/node.js/cds-ql#insert-entries) {.learn-more}

::: tip Recommendation

Prefer using streams and subselects whenever possible. Streams significantly reduce memory consumption and increase scalability. Subselects delegate all read/writes to the database.

:::

## Java {#cds-java}

<span id="java-attachments-plugin" />
<Fragment target="#java-attachments-plugin">

### Attachments Plugin <Beta />

The new CAP Java [Attachments Plugin](https://github.com/cap-java/cds-feature-attachments) provides out-of-the box support for attachments by offering CDS aspect `Attachments`.

The plugin offers:

- Managed metadata such as MIME type or creator and creation timestamp
- Proper Draft handling
- An API to plug in custom storage for attachment content
- Malware scanning as background service
- A simple UI integration

Add the plugin `cds-feature-attachments` as Maven dependency to the service's `pom.xml`:

```xml
<dependency>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-feature-attachments</artifactId>
  <version>${latest-version}</version>
</dependency>
```

Make also sure to call goal `resolve` of `cds-maven-plugin` during CDS build as explained in Java plugin [documentation](/java/building-plugins#reference-the-new-cds-model-in-an-existing-cap-java-project).

This allows to define attachments in your domain model as composition of aspects:

```cds
using { com.sap.attachments.Attachments } from 'com.sap.cds/cds-feature-attachments';

entity PhotoReviews : cuid {
  photos : Composition of many Attachments;
  ...
}
```

You can interact with attachments as common [media stream resources](/guides/providing-services#creating-a-media-resource).

By default, the attachment's content is stored as `LargeBinary` in the standard `PersistenceService`.

</Fragment>

### Enhanced Index Page

The [Index Page](/get-started/in-a-nutshell#generic-index-html) has been enhanced in this release. It now lists links to all web applications contained in the `app` folder, which are now served automatically as well.
In addition it comes with SAP Fiori preview links for entities with UI annotations and has a renewed stylesheet:

![The screenshot is explained in the accompanying text.](./assets/apr24/java-indexpage-light.png){ .mute-dark}

### Secure by Default

A bunch of CAP Java features are available for development scenarios only:

- Index Page
- Mock user authentication
- ...

To make sure these features are deactivated automatically in production mode, you can now tell the CAP runtime which Spring profile should be interpreted as productive:

```yaml
cds.environment.production.profile: cloud
```

Note that the Java buildpack chooses the `cloud` profile by default.

<span id="java-ias-mtxs" />
<Fragment target="#java-ias-mtxs">

### Enhanced IAS Support  <Internal />

CAP Java now supports multitenant applications with MTXS sidecar setup that run with a single identity instance for IAS:

![The TAM graphic shows how Approuter, CAP Java runtime, and MTX Sidecar use the same IAS service instance. ](./assets/apr24/java-ias-mtxs.svg){ }

::: tip
Enhanced IAS support requires Cloud SDK 5
:::

[Learn more about IAS configuration](/java/security#xsuaa-ias){.learn-more}
[Learn more about SMS configuration](/guides/multitenancy/#subscription-manager){.learn-more}

</Fragment>

### SAP Java Buildpack 2

You can now choose to deploy CAP Java by means of SAP Java Buildpack version 2 (`sap_java_buildpack_jakarta`) which brings sapmachine 17 and 21 in offline mode:

```yaml
parameters:
  buildpack: sap_java_buildpack_jakarta
properties:
  JBP_CONFIG_COMPONENTS: "jres: ['com.sap.xs.java.buildpack.jre.SAPMachineJRE']"
  JBP_CONFIG_SAP_MACHINE_JRE: '{ version: 21.+ }'
```

[Learn more about SAP Java buildpack usage](/java/developing-applications/configuring#buildpack){.learn-more}

### Full-Fledged Sample Project

`cds add sample` now generates a full-fledged  CAP Java application with bookshop entities that can be modified by mock users in a UI.
In contrast, the result of `cds add tiny-sample` exposes the bookshop only as OData API.

## Tools { #tools}

### Shell Completion for CDS Commands <Beta />

You can now easily enable shell completion in your shell for all `cds` commands like `build`, `compile`, and for `cds` itself.

Simply run the following command to install it once:

```sh
cds add completion
```

After that, you have to source or restart your shell and you're good to go to use `tab` key for completion:

<Asciinema :href='cds_completion' poster="npt:14" :autoPlay=true :loop=true :startAt="2" :speed="2"/>

Currently, _bash_, _zsh_, _Git Bash_ and _PowerShell_ are supported.

### Test Data Generation  <Beta />

In VS Code, test data for your application model is now available at your fingertips:

<video src="./assets/apr24/generate-data-json_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

With the new commands _Generate Model Data as JSON / CSV_, select a CDS entity in the pick list, and then test data is inserted at the cursor position in the active text editor.  This may include:

- plain `.csv` and `.json` files used for initial data deployment
- test `.js`/`.ts` files
- `.http` files used for manual tests with the [REST Client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client)

You can then modify the data as you wish potentially using AI tools.

Under the hood, this feature uses the `cds add data` CLI like this:

```sh
cds add data --records 2 --content-type csv --filter Books
```

Which will create 2 CSV records with test data for all entities matching _Books_ and store it in `db/data` by default.
Run `cds add data --help` to see all options.

[Learn more about test data generation](/tools/cds-cli#data){.learn-more}

### HTTP Requests Generation  <Beta />

The new _Generate HTTP Requests_ command in VS Code allows you to quickly generate sample HTTP requests for your services and entities, including sample data, authentication and endpoint information. You can execute the created request data with the [REST Client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client) in `.http` files.

<video src="./assets/apr24/generate-http-requests_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

Under the hood, the extension uses the `cds add http` CLI command as follows:

```sh
cds add http --filter Authors
```

This creates `.http` files with sample read and write requests for all services that include the `Authors` entity.

To add authentication and a CloudFoundry endpoint, use the `--for-app <app name>` option.

[Learn more about request generation](/tools/cds-cli#http){.learn-more}

### CDS Syntax Highlighting in VS Code Markdown Editor

The CDS language is now highlighted in `cds` code fences in the markdown editor of VS Code:

![syntax highlighting in markdown editor](assets/apr24/cds-in-md-editor.png){}

This is useful for all you authors that write about CAP and the CDS language.


The [markdown _preview_](https://code.visualstudio.com/docs/languages/markdown#_markdown-preview) in VS Code does not highlight CDS though.
This remains to be tackled in a future release.


[Learn more about highlighting code in markdown](https://www.markdownguide.org/extended-syntax/#fenced-code-blocks) {.learn-more}

### Playground for CDS ESLint Rules

You can now try each of the available [ESLint rules for CDS](/tools/cds-lint/rules/) in a playground environment.
This can help you better understand what the rule is supposed to do.

See this example from the [auth-valid-restrict-where](/tools/cds-lint/rules/auth-valid-restrict-where) rule with the _Open in Playground_ link:

::: code-group

```cds [srv/cat-service.cds]
service CatalogService {
  // invalid `where` expression, the equality operator is `=`
  @(restrict: [{ grant: 'READ', to: 'Viewer', where: 'CreatedBy === $user' }])
  entity ListOfBooks as projection on Books; // [!code warning]
  ...
}
```

:::
<PlaygroundBadge
  name="auth-valid-restrict-where"
  kind="incorrect"
  :rules="{'@sap/cds/auth-valid-restrict-where': ['warn', 'show']}"
  :files="['db/schema.cds', 'srv/cat-service.cds']"
/>

### ESLint 9 Support

CAP's ESLint plugin `@sap/eslint-plugin-cds` has reached a new major version 3 which is now compatible with the new ESLint major version 9.

This means that you can do the following:

- Adjust your `@sap/eslint-plugin-cds` dependencies from `^2` to `^3`.
- Consult the [ESLint 9 migration guide](https://eslint.org/docs/latest/use/migrate-to-9.0.0) for more information. Especially the notes about the new ['flat' configuration format](https://eslint.org/docs/latest/use/migrate-to-9.0.0#flat-config) are helpful to migrate your ESLint config files.
- Use both, `cds lint` and `eslint`, clients for your project as before.

The [`cds add lint`](/tools/cds-lint/#cds-add-lint) facet now creates ESLint 9 configuration for new projects.

In the upcoming major release of CAP Node.js, the [`cds lint`](/tools/cds-lint/#usage-lint-cli) client will use ESLint 9 by default.

### Binding Shared Service Instances on Cloud Foundry

You can now bind to a shared service instance on Cloud Foundry just like any other service instance.
For example, if you have access to a shared `redis-cache` service instance:

```sh
cds bind messaging --to redis-cache
```

[Learn more about binding shared service instances](/advanced/hybrid-testing#binding-shared-service-instances){.learn-more}

### Overwrite Cloud Service Credentials

You can easily overwrite service credential values with local binding information.
For example, you might need extra information to connect to a Cloud Foundry service via an SSH tunnel:

```sh
cds bind service --to my-service --credentials '{ "proxy_host": "localhost" }'
```

Before, you had to use a `default-env.json` file with the _entire_ credential details locally.

[Learn more about overwriting cloud service credentials](/advanced/hybrid-testing#overwriting-service-credentials){.learn-more}

## CAP Operator Plugin

The [CAP Operator](https://sap.github.io/cap-operator/) manages and automates the lifecycle operations involved in running multitenant CAP applications on Kubernetes (K8s) clusters. If you deploy an application using the CAP Operator, you must manually define the custom resources for the application in a helm chart, which needs time and deep knowledge of helm concepts.

This is where the CAP Operator **plugin** is very useful, as it provides an easy way to generate such a helm chart, which can be easily modified.

[Learn more about how to add and consume the CAP Operator plugin in our documentation](https://github.com/cap-js/cap-operator-plugin#readme). {.learn-more}

<div id="secondary-file">releases/archive/2024/apr24.fragment.md</div>


# March Release




## Capire Documentation

### Consolidated Cookbooks

![screenshot of the cookbooks overview page](assets/mar24/image-20240313154242007.png)

We merged the guides from the former *Advanced* section into the *[Cookbook](/guides/)* section. In detail, these guides have moved:

| From                               | To                                                                               |
|------------------------------------|----------------------------------------------------------------------------------|
| Advanced / Serving Fiori UIs       | [Cookbook / Serving UIs](/advanced/fiori)                                      |
| Advanced / OData API               | [Cookbook / Protocols](/advanced/odata)                                        |
| Advanced / Publish APIs / OpenAPI  | [Cookbook / Protocols](/advanced/publishing-apis/openapi)                      |
| Advanced / Publish APIs / AsyncAPI | [Cookbook / Protocols](/advanced/publishing-apis/asyncapi)                     |
| Advanced / Analytics               | [Cookbook / Analytics](/advanced/analytics)                                    |
| Advanced / Performance             | [Cookbook / Performance](/advanced/performance-modeling)                       |
| Cookbook / Media Data              | [Cookbook / Providing Services](/guides/providing-services#serving-media-data) |
| Cookbook / Authorization           | [Cookbook / Security / Authorization](/guides/security/authorization)                   |

### Restructured Java Docs

The Java documentation grew over the years and needed a cleanup. So, we gave the documentation more structure, which is an improvement over the old long and flat list. All the content is still available but URLs might have changed. We do have redirects in place but update your bookmark if you encounter any redirects.

These guides have moved:

| From                               | To                                                                               |
|------------------------------------|----------------------------------------------------------------------------------|
| Services                     | [CQN Services](/java/cqn-services/)                                                     |
| Application Services         | [CQN Services / Application Services](/java/cqn-services/application-services)         |
| Persistence Services         | [CQN Services / Persistence Services](/java/cqn-services/persistence-services)         |
| Remote Services              | [CQN Services / Remote Services](/java/cqn-services/remote-services)                   |
| Modular Architecture         | [Developing Applications / Building](/java/developing-applications/building)           |
| Development / CDS Properties | [Developing Applications / CDS Properties](/java/developing-applications/properties)   |
| Observability                | [Operating Applications](/java/operating-applications/)                                |

### Toggle Node.js/Java on All Pages

The toggle to select Node.js or Java content is now visible on every page in the title bar near the logo:

![Toggle for Node.js/Java in capire title area](assets/mar24/capire-toggle.png){}

This makes it easily accessible and allows you to see which content is shown at all times.

Note that not every page has deviating content that can be toggled.  If so, it is announced at the top of the page:

<ImplVariantsHint />

The toggle has no influence on the *side bar* and the [Node](/node.js/) and [Java](/java/) sections there. They stay visible so that you can explore content for both languages.

:::tip Try it out now, click the toggle in the title bar, or press <kbd>v</kbd>

<div class="impl node">

You have switched to **Node.js** content. This is now honored in other toggled pages like the [getting started](/get-started/in-a-nutshell) guide.

</div>

<div class="impl java">

You have switched to **Java** content. This is now honored in other toggled pages like the [getting started](/get-started/in-a-nutshell) guide.

</div>
:::

## SAP HANA Cloud Vector Engine <Beta />

We introduced the type `cds.Vector` to facilitate tasks like similarity search, anomaly detection, recommendations, and classification of unstructured data using [vector embeddings](/guides/databases-hana#vector-embeddings).

Vector embeddings of unstructured data like text and images are typically computed using embedding models. These models are specifically designed to capture important features and semantics of the input data. Similar data is represented by vectors with high similarity (low distance) to each other.

In CDS, such vector embeddings are stored in elements of type `cds.Vector`, which are mapped to `REAL_VECTOR` on the [SAP HANA Cloud Vector Engine](https://community.sap.com/t5/technology-blogs-by-sap/sap-hana-cloud-s-vector-engine-announcement/ba-p/13577010):

```cds
entity Books : cuid { // [!code focus]
  title         : String(111);
  description   : LargeString;  // [!code focus]
  embedding     : Vector(1536); // vector space w/ 1536 dimensions // [!code focus]
} // [!code focus]
```

In CAP Java you can compute the similarity and distance of vectors in the SAP HANA vector store using the `CQL.cosineSimilarity` and `CQL.l2Distance` (Euclidean distance) functions in queries:

```Java
//  Compute vector embedding of Book description, for example, via LangChain4j
float[] embedding = embeddingModel.embed(bookDescription).content().vector();

Result similarBooks = service.run(Select.from(BOOKS).where(b ->
  CQL.cosineSimilarity(b.embedding(), CQL.vector(embedding)).gt(0.9)));
```

[Learn more about Vector Embeddings in CAP Java](/java/cds-data#vector-embeddings) {.learn-more}

In CAP Node.js:

```js
let embedding; // vector embedding as string '[0.3,0.7,0.1,...]';

let similarBooks = await SELECT.from('Books')
  .where`cosine_similarity(embedding, to_real_vector(${embedding})) > 0.9`
```

::: warning
The `cds.Vector` type is only supported on SAP HANA Cloud (QRC 1/2024 or later).

Elements of type `cds.Vector` cannot be exposed via OData services.
:::



## Node.js {#cds-js}

### Improved `cds.linked`

All accesses to CSN definitions are now consistently done through instances of [`LinkedDefinitions`](/node.js/cds-reflect#iterable). It allows both, object-style access, as well as *array-like* access. For example:

```js
let linked = cds.linked (model)
let { Books, Authors } = linked.entities // object-like
let [ Entity1, Entity2 ] = linked.entities // array-like, assumes a certain order
```

The array-like nature also supports `for..of` loops, as well as common *Array* methods:

```js
for (let each of linked.definitions) console.log (each.name)
```

```js
linked.definitions .forEach (d => console.log(d.name))
linked.definitions .filter (d => d.is_entity)
linked.definitions .find (d => d.name === 'Foo')
linked.definitions .some (d => d.name === 'Foo')
linked.definitions .map (d => d.name)
```

[Learn more about `LinkedDefinitions`](/node.js/cds-reflect#iterable) {.learn-more}

### Enhanced `cds.service`

Class  `cds.service`  is enhanced with convenience shortcuts to access `entities`, `events`, and `actions` — which is the same as with instances of `cds.Service`:

```js
let { CatalogService } = linked.definitions
let { Books, Authors } = CatalogService.entities // object-like
let [ Books, Authors ] = CatalogService.entities // array-like
```

[Learn more about the new convenience shortcuts offered by `cds.service`](/node.js/cds-reflect#cds-service) {.learn-more}

<div id="kafka-node" />
<Fragment target="#kafka-node">

### Kafka Messaging <Alpha />

![](./assets/mar24/kafka-logo.svg){align="left" style="padding-right:20px;padding-top:10px}

[Apache Kafka](https://kafka.apache.org/) is now integrated as an additional message broker into CAP Messaging. The integration provides out-of-the-box messaging with CDS-defined events using Apache Kafka as the message broker. It also leverages Apache Kafka's advanced features for high horizontal scalability and reliability.

Simply use CAP project facet `cds add kafka --for production` to add Kafka as your message broker.

[Learn more about Messaging in general.](/guides/messaging/) {.learn-more}

[Learn more about Messaging APIs in Node.js.](/node.js/messaging) {.learn-more}

[Learn more about Kafka setup on SAP BTP.](/guides/messaging/apache-kafka) {.learn-more}

</Fragment>

<div id="new-odatav4-adapter-node" />
<Fragment target="#new-odatav4-adapter-node">

### New OData V4 Adapter <Alpha />

![](./assets/mar24/odata-logo.png){align="left" style="padding-right:20px;padding-top:10px}

The new OData protocol adapter is released as an alpha version. It already has support for common CRUD requests, $metadata and $batch. The performance and throughput are up to ~40 % better (More details will follow). In addition, the install size is dramatically smaller (~300 kB vs ~2.1 MB).
Simply enable it with `cds.features.odata_new_adapter=true`.

[Learn more about OData in general.](/advanced/odata) {.learn-more}

</Fragment>

### New SAP HANA Database Service <Beta />

![](./assets/mar24/sap-logo.png){align="left" class="mute-dark"}


The new database service for SAP HANA [`@cap-js/hana`](https://www.npmjs.com/package/@cap-js/hana) is released as a beta version. It is based on the same architecture as the previously released database services for PostgreSQL and SQLite.
All services are developed as open source packages. Be aware that the same recommendations as for [SQLite migration](/guides/databases-sqlite#migration) apply.
<br/><br/>

[Learn more about databases in general.](/guides/databases) {.learn-more}

[Learn more about SAP HANA Cloud.](/guides/databases-hana) {.learn-more}

::: warning
`@cap-js/hana` is still in the beta phase and not yet ready for productive usage.
:::

## Java {#cds-java}

### Outbox Enhancements

#### Optimized Processing

So far, messages sent via any [OutboxService](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/outbox/OutboxService.html) were processed in the order they were submitted.
While it is necessary for some cases such as Messaging, it imposes a performance penalty on services that allow messages to be processed in an arbitrary order.
CAP Java now allows you to configure custom Outbox instances that don't enforce strict ordering and thus allow optimized processing:

```yaml
cds:
  outbox:
    services:
      UnorderedOutbox:
        maxAttempts: 10
        ordered: false
```

Multiple application instances can work in parallel on the same unordered outbox instance and therefore increase the throughput of processed messages.

#### Type-Safe Service Access

[Generic Outbox API for services](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/outbox/OutboxService.html#outboxed(S)) now takes an interface type as an optional `Class` argument.
This interface can be used to wrap the outboxed service with an API that explicitly reflects the asynchronous nature of the service consumption:

```java
OutboxService outboxService = ...;
CqnService remoteS4Service = ...;
AsyncCqnService outboxedS4 = outboxService.outboxed(remoteS4Service, AsyncCqnService.class);
```

Note that the interface [`AsyncCqnService`](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/cds/AsyncCqnService.html) is provided as an asynchronous variant of `CqnService`, suitable for remote OData services.
In contrast to `CqnService`, there are no methods for `READ` operations and all methods have the return type `void`.

#### Custom Exception Handlers

You can now write custom exception handlers that react to errors when processing outboxed messages.
This gives you fine-grained control over the exception handling.
Depending on the cause of the error you could, for example, retry the processing, execute some compensation logic, or mark the message as undeliverable.

Find an example handler in [Wrapping On-Handlers](#wrapping-on-handlers) or in the detailed [documentation](/java/outbox#handling-outbox-errors).

### Wrapping On-Handlers { #wrapping-on-handlers }

In some situations, you may want to customize a service implementation to add pre-processing and post-processing logic rather than replacing it entirely (that is, by defining a custom [On-handler](/java/event-handlers/#on)).
The [EventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/EventContext.html) API now provides a new method called `proceed`, which executes the subsequent On-handlers.
This allows you to wrap the execution of the existing On-handlers with additional Java code:

```java
@On(service = OutboxService.PERSISTENT_ORDERED_NAME, event = "*")
void handleOutboxErrors(OutboxMessageEventContext context) {
    try {
        context.proceed();  // call standard event handlers
    } catch (Exception e) {
        if (isUnrecoverable(e)) {
            executeCompensationLogic(context); // don't retry
        } else {
            throw e; // trigger standard retry logic
        }
    }
}
```

This example wraps the standard Outbox processing with exception handling to control the error handling of failed events if any.

Read more about this feature in [Event Handlers](/java/event-handlers/#proceed-on).

### Simplified Remote Service Consumption

[Remote OData Services](/java/cqn-services/remote-services) can be easily configured with destinations to connect to external services such as an S/4 system.

CAP Java now provides another convenient integration with remote OData services. These can be services either offered as SAP BTP reuse services or are local to the application (i.e. bound to the same XSUAA or IAS service instance). In both cases, the application has a service binding to establish the connection accordingly.
This is an example configuration to define a remote BTP reuse service `MeteringService` called on behalf of the platform user:

```yaml
cds:
  remote.services:
  - name: "MeteringService"
    binding:
      name: metering-service
      onBehalfOf: systemUserProvider
```

Read more about remote service consumption capabilities in the renewed [Remote Service](/java/cqn-services/remote-services) documentation.

### ETag in Remote OData Services

CAP [Remote Services](/java/cqn-services/remote-services) can now work with [ETag-enabled](/guides/providing-services#etag) entities from remote OData APIs. If the `where` clause of an `Update` or `Delete` statement contains an [`ETagPredicate`](/java/working-with-cql/query-execution#etag-predicate), an `If-Match` header will be added to the remote request:

```java
RemoteService remoteS4 = ...;
remoteS4.run(Update.entity("BusinessPartner")
  .entry(Map.of("lastname", "Doe"))
  .where(b -> b.get("ID").eq(4711).and(b.eTag("<eTag Value>"))));
```

When reading an ETag-enabled entity from a remote OData API, the ETag is automatically stored in the metadata container of the entity data.
If an Update statement is triggered with modified data that contains the ETag in the metadata container, no explicit `ETagPredicate` is required:

```java
RemoteService remoteS4 = ...;
CdsData partner = remoteS4.run(Select.from("BusinessPartner").byId(4711)).single();

partner.put("lastname", "Doe");
// If-Match automatically set to previously read ETag value
partner = remoteS4.run(Update.entity("BusinessPartner").entry(partner)).single();

// ETag header value
Object etag = partner.getMetadata("etag");
```

### Change Tracking Localized

The UI of the [Change Tracking](/java/change-tracking) plugin now includes translations for all CAP languages out of the box.
The language bundles are automatically added to the `i18n.json` file by the CDS build.

## Tools { #tools}

<div id="ws-pack" />
<Fragment target="#ws-pack">

### Important Changes ❗️ { #changes-in-tools .important }

#### Changed Parameter for Workspace Support in `cds build` <Beta />

The experimental CLI option, formerly `--ws` is changed to `--ws-pack`. It lets you deploy npm workspace dependencies of Node.js apps as tarballs.

[Learn more about npm Workspace Support.](/guides/deployment/custom-builds#build-ws){.learn-more}

</Fragment>

### IntelliJ Plugin Available on GitHub

The [CAP CDS Language Support](https://github.com/cap-js/cds-intellij) plugin for IntelliJ is now available as Open Source on GitHub.

![Screenshot showing an example of code completion in IntelliJ](https://raw.githubusercontent.com/cap-js/cds-intellij/9dab0d1984e79b74074a820fe97ee6f9fb53cab7/.assets/code_completion.png){ .ignore-dark}

It adds features like syntax highlighting, code completion, formatting, diagnostics, and more.
See the [detailed feature list](https://github.com/cap-js/cds-intellij/blob/main/FEATURES.md) and the [installation instructions](https://github.com/cap-js/cds-intellij#requirements) for how to get started.
Note that only commercial IntelliJ products including IntelliJ IDEA Ultimate and WebStorm are supported.

### CDS Previews From Editor Title Bars

The commands to preview CDS models in different formats in VS Code are now available in the CDS editor's title area:

![Expanded CDS preview commands in editor title area.](assets/mar24/preview-in-editor-title.png)

You can also access these commands through the command palette (<kbd>F1</kbd> → *CDS...*) as well as through the editor's context menu.

<div id="tools-kafka" />
<Fragment target="#tools-kafka">

### Setup of Kafka Support <Alpha />

For Java and Node.js, the [Kafka support](#kafka-messaging) can be easily set up with the new facet:

```sh
cds add kafka --for production
```

</Fragment>

## CAP Plugins

### New Attachments Plugin <Beta />

The new CDS plugin [@cap-js/attachments](https://www.npmjs.com/package/@cap-js/attachments/) is now available as [open source on GitHub](https://github.com/cap-js/attachments). You can easily add the package to your application's dependencies and use the `Attachments` type in your model.

```sh
npm add @cap-js/attachments
```

![Screenshot showing the attachments table in an SAP Fiori UI.](assets/mar24/attachments-table.png)

::: warning Single tenant only

Please note that `@cap-js/attachments` currently supports single tenant application scenarios.

:::

[Find more details about the Attachments Plugin.](https://github.com/cap-js/attachments#readme){.learn-more}

<div id="secondary-file">releases/archive/2024/mar24.fragment.md</div>


# February Release




## Support and Feature Requests for CAP Plugins

For Node.js plugins, to open issues and also add contributions, use the open source repositories. This is the place where all relevant content comes together.

For Java plugins we're using the SAP Community for all kinds of issues and requests.

![The screenshot is explained in the accompanying text.](assets/feb24/plugin-support.png)
{}

[Learn more about support for Plugins](/plugins/#support-for-plugins){.learn-more}

## `Timezone` Definition and Data

There is now a [common CDS definition for time zones](/cds/common#entity-timezones), useful as a code list:

```cds
entity sap.common.Timezones : CodeList {
  key code : String; //> for example, Europe/Berlin
}
```

Package [`@sap/cds-common-content` 1.4.0](https://www.npmjs.com/package/@sap/cds-common-content) provides a list of commonly used time zones.
Translations aren't covered yet, but are planned.

## Audit Logging Plugin (GA)

The open source CDS plugin [@cap-js/audit-logging](https://www.npmjs.com/package/@cap-js/audit-logging) is generally available. Simply add the package to your application's dependencies and get automatic audit logging, for personal data in a plug and play fashion:

```sh
npm add @cap-js/audit-logging
```

[Learn more about setting up and using audit logging in the Data Privacy guide.](/guides/data-privacy/){.learn-more}

## Java {#cds-java}

### Optimistic Locking API

So far, CAP Java supported optimistic locking only via the OData protocol. This release now introduces an API to use optimistic locking programmatically from custom code.

#### ETag Predicate

The new ETag predicate allows to specify expected ETag values for conflict detection in update or delete statements. Use the `CQL.eTag()` and `StructuredType.eTag()` methods to create an ETag predicate:

```java
Instant expectedLastModification = ...;
Update.entity(ORDER)
      .entry(newData)
      .where(o -> o.id().eq(85).and(o.eTag(expectedLastModification)));
```

#### Runtime Managed Versions <Beta />

Use the new `@cds.java.version` annotation to advise the runtime to manage a *version* value that is used for optimistic conflict detection:

```cds
entity Order : cuid {
  @odata.etag
  @cds.java.version
  version : Int32;
  product : Association to Product;
}
```

If a version element is additionally annotated with `@odata.etag` it's also used as [ETag by OData](/guides/providing-services#etag).

A version element can have the `Timestamp` and `UUID`, or any integral type like `Uint8`, ... `Int64`.

If the update data contains a value for a version element this value is used as the *expected* value for the version. This enables the very convenient use of version elements in the program flow:

```java
PersistenceService db = ...
CqnSelect select = Select.from(ORDER).byId(85);
Order order = db.run(select).single(Order.class);
order.setAmount(5000);
CqnUpdate update = Update.entity(ORDER).entry(order);
Result rs = db.execute(update);
if (rs.rowCount() == 0) {
  // order 85 does not exist or was modified concurrently
}
```

[Learn more about **Optimistic Concurrency Control in CAP Java**.](/java/working-with-cql/query-execution#optimistic){ .learn-more}

### Change Tracking <Beta />

CAP Java now provides out-of-the box support for automatic tracking of of changes in the business domain.
The Node.js equivalent is offered as [@cap-js/change-tracking](https://github.com/cap-js/change-tracking) plugin.

To enhance your application with change tracking, add `cds-feature-change-tracking` as runtime dependency in the `pom.xml` of the service:

```xml
<dependency>
 <groupId>com.sap.cds</groupId>
 <artifactId>cds-feature-change-tracking</artifactId>
 <scope>runtime</scope>
</dependency>
```

In the CDS model, you can specify which parts of the model should be subject to change tracking:

- The domain level entity needs to be extended with the `changeTracked` aspect to provide basic support.
- On service level, the annotation `@changelog` defines a human-readable identifier for an entity.
- On field level of a service entity, elements subject to change tracking are annotated with `@changelog`.

In the UI, the change history view can be added as a facet.

The following example shows how to track changes of `Orders.total` (human readable identifier containing`orderNo` and `buyer`):

```cds
using {sap.changelog as changelog} from 'com.sap.cds/change-tracking';

// domain entity level (basic support):
extend my.Orders with changelog.changeTracked;

// service entity level (identifier):
annotate AdminService.Orders with @changelog: [
  orderNo,
  buyer
];

// service entity field level (tracked values):
annotate AdminService.Orders {
  total @changelog;
};
```

Configure the UI to present a change history view:

```cds
// UI level:
annotate AdminService.Orders with @(
  UI : { ...
    Facets : [ ...
       {
          $Type               : 'UI.ReferenceFacet',
          ID                  : 'ChangeHistoryFacet',
          Label               : '{i18n>ChangeHistory}',
          Target              : 'changes/@UI.PresentationVariant',
          ![@UI.PartOfPreview]: false
        } ...
   ] ...
  } ...);
```

Resulting change history view:

![Change history view](./assets/feb24/changetracking-java.png){}

[Learn more about change tracking](/java/change-tracking) {.learn-more}

### Generic Outbox

CAP Java now allows to configure custom instances of type [OutboxService](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/outbox/OutboxService.html):

```yaml
cds:
  outbox:
    services:
      MyCustomOutbox:
        maxAttempts: 10
        storeLastError: true
```

They can be used to emit an event of an *arbitrary* service `MyService`:

```java
@Autowired
@Qualifier("MyService")
MyService myService;

@Autowired
@Qualifier("MyCustomOutbox")
OutboxService myCustomOutbox;

Service myServiceOutboxed = myCustomOutbox.outboxed(myService);
myServiceOutboxed.send(...);
```

The messages stored in `MyCustomOutbox` are processed independently from messages in other outbox instances.

[Learn more about **Custom Outbox Instances for Generic Service Usage**.](/java/outbox#persistent){ .learn-more}

## Tools { #tools}

### New Snippet for `annotate` Statements

The new `elements…` snippet for `annotate` statements inserts all possible elements of the annotated artifact.

![Elements Snippet](assets/feb24/annotate-elements-snippet.png){ .ignore-dark}

For example, if you want to annotate an entity, the snippet inserts all elements of the entity:

![Elements Snippet](assets/feb24/annotate-elements-completed.png){.ignore-dark}

You can now add annotations to the elements as required and remove the ones you don't need:

```cds
annotate Publisher with {
  name    @title;
  address @assert.unique;
}
```

### `cds add html5-repo` for Cloud Foundry (Beta)

We support a Beta version for a new command in the `cds add` toolchain:

```sh
cds add html5-repo
```

This sets up the [HTML5 Application Repository](https://help.sap.com/docs/btp/sap-business-technology-platform/html5-application-repository) service. Under the hood, this command also runs `cds add destination` to fulfil all prerequisites.

::: details See what this adds to your project...



1. In `cds.requires`, entries for `destinations` and `html5-repo` are set to `true`:

   ```js
   "cds": {
    "requires": {
      "destinations": true,
      "html5-repo": true
    }
   }
   ```

2. In your `mta.yaml`...

    ...the required services are created:

      ```yaml
      resources:
      - name: bookshop-destination
        type: org.cloudfoundry.managed-service
        parameters:
          service: destination
          service-plan: lite
          config:
            HTML5Runtime_enabled: true
            init_data:
              instance:
                existing_destinations_policy: update
                destinations:
                  - Name: bookshop-srv
                    URL: ~{srv-api/srv-url}
                    Authentication: NoAuthentication
                    Type: HTTP
                    ProxyType: Internet
                    HTML5.ForwardAuthToken: true
                    HTML5.DynamicDestination: true
        requires:
          - name: srv-api
            group: destinations
            properties:
              name: srv-api # must be used in xs-app.json as well
              url: ~{srv-url}
              forwardAuthToken: true
      - name: bookshop-html5-repo-host
        type: org.cloudfoundry.managed-service
        parameters:
          service: html5-apps-repo
          service-plan: app-host
      - name: bookshop-html5-runtime
        type: org.cloudfoundry.managed-service
        parameters:
          service: html5-apps-repo
          service-plan: app-runtime
      ```

    ...a module is created for hosting the application content:

    ```yaml
    - name: bookshop-app-content
      type: com.sap.application.content
      path: app/
      requires:
        - name: bookshop-destination
        - name: bookshop-html5-repo-host
          parameters:
            content-target: true
      build-parameters:
        build-result: resources
        requires:
          - name: bookshop-app-admin-books
            artifacts:
              - admin-books.zip
            target-path: resources/
          - ...
    ```

    ...modules are created for each `html5` application:

    ```yaml
      - name: bookshop-app-admin-books
        type: html5
        path: app/admin-books
        build-parameters:
          build-result: dist
          builder: custom
          commands:
            - npm ci
            - npm run build

      - name: bookshop-app-browse
        type: html5
        path: app/browse
        build-parameters:
          build-result: dist
          builder: custom
          commands:
            - npm ci
            - npm run build
    - ...
    ```

3. If the App Router was set up via `cds add approuter`, we create an `xs-app.json` in each submodule.

    ```json
    {
      "welcomeFile": "/index.html",
      "authenticationMethod": "route",
      "routes": [{
        "source": "^/{{app}}/(.*)$",
        "target": "/{{app}}/$1",
        "destination": "srv-api",
        "authenticationType": "xsuaa",
        "csrfProtection": false
      }, {
        "source": "^(.*)$",
        "target": "$1",
        "service": "html5-apps-repo-rt",
        "authenticationType": "xsuaa"
      }]
    }
    ```

:::

### Convenience Options for `cds bind`

`cds bind -2 <srv>` brings additional convenience in Cloud Foundry. If there isn't a service key, such a **service key is automatically created** with the name `<srv>-key`. Custom settings are still possible by creating the service key manually beforehand with the `-c` option.

In addition, `cds bind` comes with a new `--to-app-services` option that **binds to all services of a given CF application**.

Taken together, this reduces the flow to create, build, deploy, and bind a multitenant application with multiple platform services like this:

```sh:line-numbers
cds init bookshop --add tiny-sample && cd bookshop
cds add xsuaa,hana,mtx,mta --for production
npm install
mbt build -t gen/mta.tar
cf deploy gen/mta.tar
cds bind --to-app-services bookshop-srv # [!code ++]
cf create-service-key bookshop-auth bookshop-auth-key # [!code --]
cds bind -2 bookshop-auth # [!code --]
cf create-service-key bookshop-db bookshop-db-key # [!code --]
cds bind -2 bookshop-db # [!code --]
cf create-service-key bookshop-registry bookshop-registry-key # [!code --]
cds bind -2 bookshop-registry # [!code --]
```

### Upgrade all tenants via the `cds-mtx` CLI

In addition to upgrading individual tenants, `cds-mtx upgrade *` now allows batch upgrading of all tenants.

[Learn more about tools and CLI support.](/about/features#cli-tools-support){.learn-more}

### Configuration Schema Contributions by CAP Plugins <Beta />

Starting with `@sap/cds` and `@sap/cds-dk` version `7.6.0`, CAP plugins can now contribute a schema for their configuration.  This allows VS Code to offer code completion in files like `package.json` or `.cdsrc.json`.

As an example, plugin [`cds-swagger-ui-express`](https://github.com/chgeo/cds-swagger-ui-express/blob/6b96e0f3fb105deab1a5613c81912604cc872424/package.json#L60-L93) contributes such a schema, so that you get assisted when adding configuration:
![Configuration file in VS Code with code completion](assets/jan24/schema-contrib.png){.ignore-dark}

[Learn more about schema contributions here.](/node.js/cds-plugins#configuration-schema){.learn-more}

### Implementing Your own Build Plugins <Beta />

CDS build now allows the implementation of custom build plugins.

[Learn more about Implementing Build Plugins.](/guides/deployment/custom-builds#custom-build-plugins){.learn-more}



# January Release




## Open Telemetry Plugin

The Telemetry plugin [@cap-js/telemetry](https://www.npmjs.com/package/@cap-js/telemetry) provides observability features such as tracing and metrics, including [automatic OpenTelemetry instrumentation](https://opentelemetry.io/docs/concepts/instrumentation/automatic).
Simply add the plugin to your project and you will find telemetry output written to the console as follows:

```txt
[odata] - GET /odata/v4/processor/Incidents
[telemetry] - elapsed times:
  0.00 → 2.85 = 2.85 ms  GET /odata/v4/processor/Incidents
  0.47 → 1.24 = 0.76 ms    ProcessorService - READ ProcessorService.Incidents
  0.78 → 1.17 = 0.38 ms      db - READ ProcessorService.Incidents
  0.97 → 1.06 = 0.09 ms        @cap-js/sqlite - prepare SELECT json_object('ID',ID,'createdAt',createdAt,'creat…
  1.10 → 1.13 = 0.03 ms        @cap-js/sqlite - stmt.all SELECT json_object('ID',ID,'createdAt',createdAt,'crea…
  1.27 → 1.88 = 0.61 ms    ProcessorService - READ ProcessorService.Incidents.drafts
  1.54 → 1.86 = 0.32 ms      db - READ ProcessorService.Incidents.drafts
  1.74 → 1.78 = 0.04 ms        @cap-js/sqlite - prepare SELECT json_object('ID',ID,'DraftAdministrativeData_Dra…
  1.81 → 1.85 = 0.04 ms        @cap-js/sqlite - stmt.all SELECT json_object('ID',ID,'DraftAdministrativeData_Dr…
```

In addition to the default console output, there are predefined kinds for exporting telemetry data to [SAP Cloud Logging](https://help.sap.com/docs/cloud-logging), Dynatrace, and Jaeger.

[See the repository's `README` for more details.](https://github.com/cap-js/telemetry/blob/main/README.md){ .learn-more}
[Learn more about Java support.](/java/operating-applications/observability#open-telemetry){ .learn-more}

## CDS Language & Compiler {#cds}

### Define Event by Projection

You can now define an event as projection on an entity, type, or another event.
This is useful, for example, when importing services: it allows to define an event in CAP as projection on the "external" event.

Example:

```cds
event CustomerChanged : projection on ImportedService.BusinessPartner.ChangedEvent {
  BusinessPartner as ID,
  BusinessPartnerFullName as name,
  // ...
}
```

Only the effective signature of the projection is relevant.

[Learn more about **Events**.](/cds/cdl#events){ .learn-more}

## Node.js {#cds-js}

### Media Data and Large Binaries

Previously, the database services returned `cds.LargeBinary` without `@Core.MediaType` annotation as regular column with base64-encoded buffer as value which potentially causes problems in memory consumption.

As a consequence, from now on the database services will return large binaries only if requested explicitly and as a stream instead of the materialized buffer.

This has the following effect:

```js
SELECT.from(Attachments) //> [{ ID, title, image: Buffer }] [!code --]
SELECT(['image']).from(Attachments) //> [{ image: Buffer }] [!code --]

SELECT.from(Attachments) //> does not include "image" [!code ++]
SELECT(['image']).from(Attachments) //> [{ image: <media stream> }] [!code ++]
```

This also has an effect for OData APIs. Large binaries have to be annotated with `@Core.MediaType` in order to be reachable via the [streaming choreography](/guides/providing-services#serving-media-data). If not annotated, those properties are not reachable anymore, even if requested explicitely.

`cds.stream()` and `srv.stream()` are deprecated and will be removed with the next major release. `SELECT` with a single large binary column can be used instead as described above.

Compatibility to the previous behavior can be restored with

```json
"cds": {
  "features": {
    "stream_compat": true
  }
}
```

:::tip
It is strongly recommended to annotate all large binary properties with `@Core.MediaType` and use them according to streaming scenarios.
:::

[Learn more about streaming.](/guides/providing-services#serving-media-data){ .learn-more}
[Learn more about databases.](/guides/databases){ .learn-more}

### Programmatic Outboxing of Services

You can now use `cds.outboxed(srv)` to get the outboxed variant of a service: Each event first gets stored in an outbox before reaching the target service.
For immediate emits of outboxed services, there's also the counterpart `cds.unboxed(srv)`.

```js
const outboxed = cds.outboxed(srv)
await outboxed.emit('someEvent', { some: 'message' }) //> deferred emit via outbox
await cds.unboxed(outboxed).emit('someEvent', { some: 'message' }) //> immediate emit w/o outbox
```

[Learn more about the outbox in Node.js.](/node.js/queue){ .learn-more}

### Lean Draft Sorting on SAP Fiori List Report Floorplan

The sorting behavior for the lean draft has been aligned with the other runtimes in the SAP ecosystem, such as CAP Java and RAP for a consistent user experience.

Instead of positioning the drafts always on top of the list, they are now included at the respective position of the actual sorting order.

<video src="./assets/jan24/sorting-on-sap-fiori-list-report_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

### Garbage Collection of Stale Drafts

Stale drafts can be deleted automatically after a configurable timeout. Simply set the timeout to `true` (enables default timeout of `30d`) or a value like `14d`.

```json
{
  "cds": {
    "fiori": {
      "draft_deletion_timeout": "14d"
    }
  }
}
```

[Learn more about general draft handling in Node.js.](/node.js/fiori){ .learn-more}

## Java {#cds-java}

### Important ❗️ { #changes-in-java .important }

#### Support for Cloud SDK 5

CAP Java supports [Cloud SDK 5](https://sap.github.io/cloud-sdk/docs/java/release-notes) now.

In case your application uses Cloud SDK integration (`cds-integration-cloud-sdk`), the migration is a matter of adapting Maven dependencies only.

:::warning Migrate to Cloud SDK 5 as soon as possible
We highly recommend to migrate to Cloud SDK 5 as soon as possible as Cloud SDK 4 runs out of maintenance end of May 24 according to the [release policy](https://sap.github.io/cloud-sdk/docs/java/release-policy).
:::

[You can find detailed instructions in the dedicated migration guide.](/java/migration#cloudsdk5){.learn-more}

#### Comparing CDS Elements

When comparing `CdsElement` instances obtained from the `CdsModel` the `equals` method must now be used.

### Support for Spring Boot 3.2

CAP Java now supports latest [Spring Boot `3.2`](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.2-Release-Notes).

The most interesting feature is [virtual thread](https://dev.java/learn/new-features/virtual-threads/) support.
To use virtual threads, you need to run with JDK 21 and set the property `spring.threads.virtual.enabled` to `true`.

Note that HANA JDBC driver processes Input/Output in `synchronized` blocks which can reduce the effect of virtual threads.
Experiments are currently being carried out with an internal driver version optimized for virtual threads. Stay tuned!

### Enhanced Open Telemetry

When configured with a front end for Open Telemetry signals, CAP Java now additionally writes trace spans for the following:

- Individual OData V4 requests of a `$batch` request.
- CQN processing showing detailed statement information.

Moreover, Dynatrace as Open Telemetry front end is [integrated](/java/operating-applications/observability#open-telemetry-configuration-dynatrace) smoothly now.

![Dynatrace](./assets/jan24/Dynatrace-Java.png){}

[Learn more about Open Telemetry in CAP Java.](/java/operating-applications/observability#open-telemetry){.learn-more}

### Update with Expressions in Fluent Style

Use the model interfaces of the builder API to build update expressions in fluent style. The following statements converts a book's title to upper case and increases the stock by 1:

```java
CqnUpdate update = Update.entity(BOOK).where(b -> b.title().eq("CAP"))
    .set(b -> b.title(), title -> title.toUpper())
    .set(b -> b.stock(), stock -> stock.plus(1));
```

[Learn more about building update expressions.](/java/working-with-cql/query-api#update-expressions){.learn-more}

### Improvements in Search on SAP HANA Cloud HEX Engine { #search-hex }

On SAP HANA Cloud, in SQL optimization mode `hex`, CAP Java uses the `SCORE` function instead of the `CONTAINS` predicate to execute a search.

Compared to `CONTAINS`, `SCORE` has more capabilities, listed in the following:

- can be executed by the SAP HANA HEX engine
- can search expressions
- can search subqueries

This allows to significantly simplify the generated SQL in `hex` mode, which brings performance improvements in many situations.

Annotate an entity with `@cds.sql.search.mode` to specify how an entity should be searched. Ths following list contains possible values:

- `generic` - search using `LIKE`
- `localized-associations` - for localized elements, the translation *and* the fallback text are searched
- `localized-view` - for localized elements, the translation is searched *or* the fallback text if no translation is available

[Learn more about SQL optimization mode.](/java/cqn-services/persistence-services#sql-optimization-mode) {.learn-more}

<span id="cqn-transformations" />
<Fragment target="#cqn-transformations">

### CQN Transformations <Beta />

In OData v4, the CAP Java runtime can now _optionally_ represent `$apply` transformations in the `CqnSelect` statement as a list of `CqnTransformation`s.
This allows the application to handle transformations in custom code.
This feature needs to be explicitly enabled using the configuration `odatav4.apply.in-cqn.enabled: true`.

In the following example, sales data is stored in memory as a `List<Sales>`.

The custom code should handle the request `GET Sales?$apply=groupby((country), aggregate(amount with sum as sum))`:

```java
List<Sales> sales = ...
CqnSelect select = ...;
List<CqnTransformation> trafos = select.transformation();
if (trafos.size() == 1 && trafos.get(0) instanceof CqnGroupByTransformation groupBy) {
    String dim = groupBy.dimensions().get(0).path();
    Map<String, Double> salesByDim
         = sales.stream().collect(groupingBy(s -> s.get(dim)),
                                  summingDouble(s -> s.getAmount()));
    List<Map<String, Object>> result = new ArrayList<>();
    salesByDim.forEach((d, s) -> result.add(Map.of(dim, d, "sum", s)));

    return result;
}
```

:::warning

Handling `CqnTransformation`s in custom code requires detailed understanding of the [OData Extension for Data Aggregation](https://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/odata-data-aggregation-ext-v4.0.html).

:::

</Fragment>

<span id="node-ias-subscriptions" />
<Fragment target="#node-ias-subscriptions">

## Multitenancy <Internal /> { #cds-mtx}

### Support for Subscription Manager Service

`@sap/cds-mtxs` now supports subscription of [IAS](https://help.sap.com/docs/identity-authentication?locale=en-US) tenants by providing an integration with Subscription Manager Service (SMS) also for Node.js applications.
The necessary endpoints are provided via the new service `cds.xt.SmsProvisioningService`.

The service offers:

* Synchronous as well as asynchronous (un)subscription flows.
* Hybrid setup with SaaS-binding for migration scenarios.

[Learn more about configuration options in Subscribing IAS tenants.](/guides/multitenancy/?impl-variant=node#subscription-manager){.learn-more}

</Fragment>

<span id="tools" />
<Fragment target="#tools">

## Tools <Beta /> { #tools}

### Convenience options for `cds bind`

`cds bind -2 <srv>` brings additional convenience in Cloud Foundry. If there isn't a service key, such a **service key is automatically created** with the name `<srv>-key`. Custom settings are still possible by creating the service key manually beforehand with the `-c` option.

In addition, `cds bind` comes with a new `--to-app-services` option that **binds to all services of a given CF application**.

Taken together, this reduces the flow to create, build, deploy, and bind a multitenant application with multiple platform services like this:

```sh:line-numbers
cds init bookshop --add tiny-sample && cd bookshop
cds add xsuaa,hana,mtx,mta --for production
npm install
mbt build -t gen/mta.tar
cf deploy gen/mta.tar
cds bind --to-app-services bookshop-srv # [!code ++]
cf create-service-key bookshop-auth bookshop-auth-key # [!code --]
cds bind -2 bookshop-auth # [!code --]
cf create-service-key bookshop-db bookshop-db-key # [!code --]
cds bind -2 bookshop-db # [!code --]
cf create-service-key bookshop-registry bookshop-registry-key # [!code --]
cds bind -2 bookshop-registry # [!code --]
```

### Configuration Schema Contributions by CAP Plugins

Starting with `@sap/cds` and `@sap/cds-dk` version `7.6.0`, CAP plugins can now contribute a schema for their configuration.  This allows VS Code to offer code completion in files like `package.json` or `.cdsrc.json`.

As an example, plugin [`cds-swagger-ui-express`](https://github.com/chgeo/cds-swagger-ui-express/blob/6b96e0f3fb105deab1a5613c81912604cc872424/package.json#L60-L93) contributes such a schema, so that you get assisted when adding configuration:
![Configuration file in VS Code with code completion](assets/jan24/schema-contrib.png){.ignore-dark}

[Learn more about schema contributions here.](/node.js/cds-plugins#configuration-schema){.learn-more}

</Fragment>

<div id="secondary-file">releases/archive/2024/jan24.fragment.md</div>


# All of 2023



<br>
<IndexList :pages='pages' />



# December Release




## Lazy Loading in Change Tracking Plugin

The CDS plugin for change tracking now comes with lazy loading of the *Change History* table:

<video src="./assets/dec23/change-history_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

## CDS Language & Compiler {#cds}

### Association-Valued Calculated Elements <Beta />

You can now define a calculated element where the expression is an association with a filter
("association-like calculated element").
The calculated element effectively is an association, where the ON condition is the ON condition
of the original association plus the filter condition, combined with `and`.
The behavior is similar to [publishing an association with a filter](./sep23#publish-association-with-filter-beta).

Example:

```cds
entity Authors : managed {
  key ID       : Integer;
  name         : String;
  books        : Association to many Books on books.author = $self;
  availableBooks = books[stock > 0];
}
```

[Learn more about **Calculated Elements**.](/cds/cdl#calculated-elements){ .learn-more}

### Expressions in Annotations <Beta /> { #expressions-in-annotations-beta }

We're working on a set of features with the goal to provide full support
for [expressions](/cds/cxn#expressions) as "first class" annotation values.

As a first step, you now can provide an expression as annotation value.

Example:

```cds
entity Orders @(restrict: [
    { grant: 'READ', to: 'Auditor', where: (AuditBy = $user.id) }
  ]) {/*...*/}
```

The expression must be enclosed in parentheses. Supported expressions are the same as in
calculated elements. You get code completion, and the compiler checks the syntax and the
paths in the expression.

:::warning
Runtime support in CAP is today only available for the `where` property of the `@restrict`
annotation. Expressions are not supported in other [standard annotations](/cds/annotations#common-annotations).
The support will be extended in future releases.
:::

Currently, paths are not rewritten in propagated annotations. In a projection, for example,
all elements used in the expression must be propagated without renaming.
Thus, for the time being we recommend using the feature mainly in top-level projections.
Expressions in OData annotations are not yet handled properly, either.

In later releases we plan to extend the support for expressions in annotation values:

* Properly rewrite paths in propagated annotations.
* Support expressions in OData annotations with improved path handling.

This feature can of course also be used for your custom annotations:

```cds
@MyCustomAnnotation : (a + b)
entity Foo {
  a : Integer;
  @MyCustomAnnotation : (a + b)
  b : Integer;
}
```

::: warning
Expressions as annotation values are released as beta feature.
We provide an early preview for the functionality to allow you to experiment with it and provide feedback.
The behavior and the CSN representation of paths in propagated annotations will change.
The behavior of expressions in OData annotations will change.
:::

[Learn more about **Expressions as Annotation Values**.](/cds/cdl#expressions-as-annotation-values){ .learn-more}
[Learn more about support in **CAP Java**](#support-for-expressions-in-annotations){ .learn-more}

## Node.js {#cds-js}

### Important Changes ❗️ { #changes-in-node-js .important }

* In rare cases, it was required to oversteer the default VCAP lookup, for example, when multiple instances of the same service are bound to your application.

  From now on, it's required to explicitly deactivate the default lookup if a different mechanism should be used.
  Previously, `name` and the default `label` were used individually as lookup in sequential order, which led to erratic behavior.

  ```json
  "cds": {
    "requires": {
      "messaging": {
        "kind": "enterprise-messaging-shared",
        "vcap": {
          "name": "<my-em-instance-name>",
          "label": false
        }
      }
    }
  }
  ```

### Type Definitions Are Open Source

The [type definitions of the `@sap/cds` APIs](/node.js/typescript#typescript-apis-in-sap-cds) are now maintained on github.com as package [`@cap-js/cds-types`](https://github.com/cap-js/cds-types).  The new package allows us to provide fixes faster and in better quality with the help of the CAP community.

::: tip No additional dependency needed
You don't need to do anything to get the new package.  It's shipped with `@sap/cds`.
:::

However, please make sure to **import types through the [`cds` facade class](/node.js/cds-facade) only**:

::: code-group

```ts [Typescript]
import { Request } from '@sap/cds'  // [!code ++]
import { Request } from '@sap/cds/apis/events'  // [!code --]

function myHandler(req: Request) { }
```

```js [JavaScript]
/** @param { import('@sap/cds').Request } req */ // [!code ++]
/** @param { import('@sap/cds/apis/events').Request } req */ // [!code --]

function myHandler(req) { }
```

:::

In this release, we've also fixed a number of type export issues that have forced you to reference the internal files from above.

<div id="gh-releases" />
<Fragment target="#gh-releases">

### GitHub Releases for Node.js Packages <Internal />

Most CAP Node.js packages like [`@sap/cds`](https://github.tools.sap/cap/cds/releases) now publish proper GitHub releases for each CAP release.
This allows you to subscribe and get notified whenever a new release is available.

![This screenshot is explained in the accompanying text.](assets/dec23/gh-releases.png)

</Fragment>

### Log Formatting in Production

We reworked log formatting, especially with regards to naming and defaults. `cds.log` now exports two log formatters, namely `plain` and `json`. The JSON log formatter is the default log formatter in production. Hence, it's no longer necessary to set feature flag `kibana_formatter: true`. You can opt-out of this new default behavior via config `cds.log.format: 'plain'`.

Consequently, `cds add kibana-logging` was deprecated. Please use `cds add application-logging` going forward. Further, this initializer now adds an instance of SAP Application Logging Service with plan `standard` instead of `lite` to your *mty.yaml*. The *lite* service plan isn't meant for production as the quota is not sufficient to avoid dropped logs.

Additionally, we reworked the support for SAP Application Logging Service's custom fields and introduced configurable header value masking.

[For more details, see revised Logging in Production.](/node.js/cds-log#logging-in-production){.learn-more}

### SAPUI5 Mass Edit

The ["Mass Edit" feature of SAPUI5](https://sapui5.hana.ondemand.com/sdk/#/topic/965ef5b2895641bc9b6cd44f1bd0eb4d.html) is now supported. It allows modifying multiple rows of a table at the same time without needing to create drafts for each row. The feature must be activated by setting `cds.fiori.bypass_draft = true`.

<video src="./assets/dec23/fiori-direct-mod_compressed.mp4" autoplay loop muted webkit-playsinline playsinline />

::: warning
Be aware that this feature creates an additional entry point to your application. Custom handlers might require adaptations because the handlers are triggered with partial payloads instead of the complete business object.
:::

### CSRF Token Configuration

Fetching CSRF tokens of remote services is configurable at a more fine granular level. If `method` and/or `url` are provided, those are used for fetching the token.

```jsonc
"cds": {
  "requires": {
    "API_BUSINESS_PARTNER": {
      "kind": "odata-v2",
      "csrf": { // this configuration implies `csrf: true`
        "method": "get",
        "url": "..."
      }
    }
  }
}
```

[Learn more about the fetching CSRF tokens.](/node.js/remote-services#csrf-token-handling){.learn-more}

### Eliminated `passport` Dependency

The generic authentication implementation doesn't rely on the 3rd party dependency `passport` anymore.

You can remove it running `npm uninstall passport` or delete it from the dependencies in the *package.json* by hand.

## Java {#cds-java}

### Important Changes ❗️ { #changes-in-java .important }

* The free [OSS support](https://spring.io/projects/spring-boot#support) for Spring Boot `2.7.x` has ended in November. Accordingly, the support for maintenance version CAP Java `1.34.x`, which is based on Spring Boot `2.7`, will be discontinued in May 2024. We **strongly recommend** [migrating](/java/migration#one-to-two) to CAP Java 2 as soon as possible. See also CAP Java [release schedule](/releases/schedule#cap-java).

* The execution order of the system query option `$apply`, with regards to other system query options, has been fixed. In accordance with [the specification](https://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs03/odata-data-aggregation-ext-v4.0-cs03.html#SystemQueryOptionapply), the system query option `$apply` is now always evaluated first, then the other system query options are evaluated *on the result of `$apply`*. Before, it was possible that, for example, `$filter` or `$search` were evaluated before `$apply`.

### Support for Expressions in Annotations

With this release, the CDS compiler introduces [expressions in annotations](#expressions-in-annotations-beta).

Custom code can use the [reflection API](/java/reflection-api#get-and-inspect-an-association-element-of-an-entity) to obtain the expression value from an annotation. This allows to use expressions as annotation values in *custom annotations* that are handled by custom code. This example defines a custom annotation `@my.check` to perform a consistency check after an update:

```cds
annotate Authors with @my.check: (yearOfDeath is null or
                                  yearOfBirth <  yearOfDeath);
annotate Books with @my.check: (year > author.yearOfBirth);
```

Evaluate the annotation's expression value in a generic handler:

```java
@After
public void checkAfterWrite(CdsUpdateEventContext ctx) {
   CdsEntity target = ctx.getTarget();

   CqnExpression xpr = target.getAnnotationValue("my.check", CQL.TRUE);
   ctx.getResult().stream().forEach(row -> {
      CqnSelect query = Select.from(row.ref()).where(xpr.asPredicate()).limit(1);
      if (db.run(query).first().isEmpty()) {
        throw new ServiceException(BAD_REQUEST, "check failed");
      }
   });
}
```

:::warning
Besides in `@restrict`, CAP Java doesn't support using expressions in standard annotations.
:::

[Learn more about expressions in annotations.](/cds/cdl#expressions-as-annotation-values){.learn-more}

### Update with Expressions

The `Update` now supports expressions using the new `set` method, for example, to decrease the stock of Book 101 by 1:

```java
Update.entity(BOOKS).byId(101).set("stock", CQL.get("stock").minus(1));
```

[Learn more about Update with Expressions.](/java/working-with-cql/query-api#update-expressions){.learn-more}

### On-the-fly Localization of EDMX

Internationalization of an SAP Fiori elements UI requires that the server provides translated EDMX metadata documents. So far, localized EDMX files were created by `cds build` or retrieved from the MTX model provider API and served by the runtime as is.

This approach resulted in EDMX versions for multiple languages being cached by the runtime, which consumed significant memory.

Now, the `cds build` and MTX model provider API provide a nonlocalized EDMX template as well as a text bundle with the translated texts of each locale. If an OData `$metadata` request is served, the runtime mixes the translations into the EDMX on the fly and streams the response. For now, you need to enable this feature in the *application.yaml* with the configuration `cds.odata-v4.lazy-i18n.enabled: true`. It requires `@sap/cds-dk` >= `7.4.0` and `@sap/cds-mtxs` >= `1.12.0`.

The `cds build` currently creates localized and nonlocalized EDMX files as static resources by default.
To save disk space, the creation of translated EDMX files can be disabled with the `cds build` option `--opts contentLocalizedEdmx=false`

:::tip
On-the-fly localization of EDMX is only available with OData V4.
:::

### RegEx Pattern Matching

Use the new `matchesPattern` predicate to test if a string value matches a given regular expression.
The following query returns books with a title that starts with the letter "C" and ends with the letter "e":

```java
Select.from(BOOKS).where(t -> t.title().matchesPattern("^C\\w*e$"));
```

You can also use `matchesPattern` with `CQL` in [tree-style](/java/working-with-cql/query-api#cql-helper-interface):

```java
Select.from("bookshop.Books").where(CQL.matchesPattern(CQL.get("title"), "^C\\w*e$"));
```

Furthermore, you can now use the `matchesPattern` function [in OData v4](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc23836468):

```txt
GET Books?$filter=matchesPattern(title, '^C\\w*e$')
```

:::warning Possible performance penalty
Pattern matching with regular expressions can result in significant performance degradation, if applied on large entity sets.
:::

[Learn more about the matchesPattern predicate.](/java/working-with-cql/query-api#matches-pattern){.learn-more}

### Auditlog Premium Plan

Feature `cds-feature-auditlog-v2` now supports public service plan `premium` of the Audit Log Service.
External customers can consume it by binding the CAP application to the service instance of Audit Log and adding the following dependency to the service *pom.xml*:

```xml
<dependency>
 <groupId>com.sap.cds</groupId>
 <artifactId>cds-feature-auditlog-v2</artifactId>
</dependency>
```

[Learn more in the Audit Log documentation](/java/auditlog#handler-v2){.learn-more}

### Open Telemetry Support

CAP Java now provides end-to-end observability based on [Open Telemetry](https://opentelemetry.io/) format.
Collected metrics, traces, and logs can be exported to [SAP Cloud Logging service](https://discovery-center.cloud.sap/index.html#/serviceCatalog/cloud-logging) and/or Dynatrace.

On SAP BTP, Cloud Foundry environment, configuration is simplified as shown as follows.
Bind the application to a cloud logging service instance with Open Telemetry ingestion activated:

```sh
cf create-service cloud-logging standard cls -c '{"ingest_otlp": {"enabled": "true"}}'
```

Don't forget to add the logging extension library for Open Telemetry in your service *pom.xml*:

```xml
<dependency>
  <groupId>com.sap.hcp.cf.logging</groupId>
  <artifactId>cf-java-logging-support-opentelemetry-agent-extension</artifactId>
  <version>${logging.support.version}</version>
</dependency>
```

Finally, configure the Open Telemetry Java agent from the buildpack as well as the logging extension library in the environment of the CAP application:

```yaml
JBP_CONFIG_JAVA_OPTS:
  from_environment: false
  java_opts: >
    -javaagent:META-INF/.sap_java_buildpack/otel_agent/opentelemetry-javaagent.jar
    -Dotel.javaagent.extensions=BOOT-INF/lib/cf-java-logging-support-opentelemetry-agent-extension-<logging.support.version>.jar
```

Beside automatic instrumentations given by the Java agent, CAP Java additionally does the following:

* Adds nested spans for [Request](/java/event-handlers/request-contexts) and [ChangeSet](/java/event-handlers/changeset-contexts) contexts.
* Handles thread propagation of spans out of the box.

[Learn more about observability with Open Telemetry.](/java/operating-applications/observability#open-telemetry){.learn-more}

### Miscellaneous

* The code generator supports annotating services with `@cds.java.name` to customize the name of the corresponding generated service interface.

* Draft garbage collector  and outbox collector introduced model loading bursts in MTX sidecar as all subscriber tenants have been processed periodically.
This has been improved so that such CPU overload situations are avoided.

<span id="custom-build-plugins" />
<Fragment target="#custom-build-plugins">

## Tools <Beta /> { #tools}

### npm Workspace Support in CDS Build

Use CLI option `--ws` to enable support for [npm workspaces](https://docs.npmjs.com/cli/using-npm/workspaces).  As an effect, your workspace dependencies can be deployed to SAP BTP without them being published to an npm registry before.

[Learn more about npm Workspace Support.](/guides/deployment/custom-builds#build-ws){.learn-more}

</Fragment>
<span id="intellij-cds" />
<Fragment target="#intellij-cds">

### CDS Language Support for IntelliJ <Internal />

Our recent update of [CDS Language Support for IntelliJ](https://github.tools.sap/cap/intellij-cds) addresses the previous version's shortcomings, particularly its lack of product readiness and issues arising from incompatibilities with the IntelliJ Platform and Plugins API 2023.

Moreover, the switch to the new IntelliJ LSP API helps the plugin maintain compatibility with updated IntelliJ versions and ensures up-to-date CDS language support. This change is a step forward in improving the stability and responsiveness of CAP CDS language support in IntelliJ IDEs.

![Screenshot showing code completion in IntelliJ IDE.](assets/dec23/code_completion.png)

This plugin is designed for developers working in commercial JetBrains IDEs including IDEA Ultimate and WebStorm, offering an array of essential features to streamline your workflow. Highlights include:

- Syntax Highlighting
- Code Completion
- Diagnostics
- Quick Fixes
- Goto Definition

CDS Language Support for IntelliJ 7.0.1 is compatible with IntelliJ 2023.2.4 and later versions. The plugin utilizes Java 17, the IntelliJ LSP API, and a TextMate bundle. It is also based on the latest @sap/cds-lsp version 7.4.0.

Note that due to restrictions of the IntelliJ LSP API, the plugin is incompatible with IDEA Community edition.

The plugin is currently published in the internal GitHub [Releases section](https://github.tools.sap/cap/intellij-cds/releases).

</Fragment>

<div id="secondary-file">releases/archive/2023/dec23.fragment.md</div>


# November Release




## New Learning Sources Page

We created a new page that collects selected learning resources for you. We aim to maintain and curate the best learning content for you here, so please feel free to nominate blog posts, tutorials, etc in our [cap-js/docs](https://github.com/cap-js/docs/issues/new) repository, which helped you and should get more attention.

[![A screenshot of capire showing the new page.](assets/nov23/image-20231117161748715.png){.ignore-dark}](/get-started/learning-sources)

[Find here the new _Learning Sources_ page.](/get-started/learning-sources){.learn-more}

## CAP Plugins

### New Overview Page in capire

There's a new page showing you a curated list of plugins that are available for the SAP Cloud Application Programming Model (CAP) which provide integration with BTP services and technologies, or other SAP products. For example, you'll find there the well known GraphQL adapter or the OData V2 proxy.

[![A screenshot of capire showing the new page.](assets/nov23/image-20231117162248693.png){.ignore-dark}](/plugins/)

::: tip Maintained by CAP and SAP
These plugins are created and maintained in close collaboration and shared ownership of CAP development teams and other SAP and BTP development teams.
:::

[Have a look at the new CAP plugins page.](/plugins/){.learn-more}

### New Change Tracking Plugin

A new CDS plugin package [@cap-js/change-tracking](https://www.npmjs.com/package/@cap-js/change-tracking) is now available and [open source](https://github.com/cap-js/change-tracking). Simply add the package to your application's dependencies and get out-of-the box support for automatic capturing, storing, and viewing of the change records of modeled entities:

```sh
npm add @cap-js/change-tracking
```

![The change tracking table in an application using the change tracking plugin.](./assets/nov23/change-tracking.png){}

::: warning

Please note that `@cap-js/change-tracking` is currently released as an early adopter version and, hence, minor breaking changes are possible in the general availability version.

:::

[Find more details about the Change Tracking Plugin.](https://github.com/cap-js/change-tracking){.learn-more}

### Notifications Plugin for Business Notifications

A new CDS plugin package [@cap-js/notifications](https://www.npmjs.com/package/@cap-js/notifications/) is now available and [open source](https://github.com/cap-js/notifications). Simply add the package to your application's dependencies and publish the business notifications:

```sh
npm add @cap-js/notifications
```

::: warning

Please note that `@cap-js/notifications` currently supports single tenant application scenarios with notification types lifecycle management.

:::

[Find more details about the Notifications Plugin.](https://github.com/cap-js/notifications){.learn-more}

[Find here more CAP plugins with a short description and all relevant links.](/plugins/){.learn-more}

## CDS Language & Compiler {#cds}

### Annotating Draft Entities

If an entity is draft related, additional entities and elements are generated
for the database model or for the OData API, respectively. These additional entities and
elements can now be annotated.

Example:

```cds
annotate AdminService.Books.drafts with @cds.persistence.journal;
annotate AdminService.Books:DraftAdministrativeData with @UI.Hidden: false;
```

## Node.js {#cds-js}

### Inferring Query Elements

A new API  `req.query.elements` has been added to conveniently infer and reflect a query's result set. For example:

```js
let q = SELECT.from(Books, b=>{ b.ID, b.title })
q.elements //> will return a CSN struct object like that:
{
  ID: { key: true, type: 'cds.Integer' },
  title: { type: 'cds.String', length: 111, localized: true }
}
```

The returned object contains the selected column names as key and the CSN definitions as value. This comes in very handy if custom implementation must be triggered on selection of certain elements, for example, _virtuals_.

```js
if ('foo' in req.query.elements) doSomething()
```

[Find more details about the new API.](/node.js/cds-ql#elements){.learn-more}

### Persistent Outbox by Default

The default [outbox](/node.js/queue) configuration has been changed to `persistent-outbox`. As a result, once `cds.requires.outbox` is set to `true`, all messaging services and the audit-logging service now first store outgoing messages in a database table before sending them to the respective platform service.

Configuration to use the default, that is, persistent outbox:

```json
{
  "cds": {
    "requires": {
      "outbox": true
    }
  }
}
```

To use the former default, the behavior can be restored with:

```json
{
  "cds": {
    "requires": {
      "outbox": "in-memory-outbox"
    }
  }
}
```

[Learn more about the Transactional Outbox.](/node.js/queue){.learn-more}

### Miscellaneous

- In order to comply with the specific error format of SAP Fiori Elements, we've implemented a feature flag `cds.fiori.wrap_multiple_errors = false`. With this, the first error is used as top level error instead of a generic wrapper error. This will become the default in the next major version.
- On SAP BTP Cloud Foundry Runtime, the default keep alive timeout of the server is set to 91s in order to exceed the 90s of Cloud Foundry gorouter. This was frequently the reason for intermittently failing requests with status code 502.

## Java {#cds-java}

### JDK 21 Support

CAP Java 2 now officially supports [JDK 21](https://openjdk.org/projects/jdk/21/) which has been released as new LTS version recently.

We recommend configuring [SapMachine](https://sap.github.io/SapMachine/) 21 JDK (respective JRE) with the [SAP Java buildpack](https://help.sap.com/docs/btp/sap-business-technology-platform/developing-java-in-cloud-foundry-environment) as shown in the example (`mta.yaml`):

```yaml
modules:
  - name: MyCAPJavaApp
    type: java
    path: srv
    parameters:
      ...
      buildpack: sap_java_buildpack
    properties:
      JBP_CONFIG_COMPONENTS: "jres: ['com.sap.xs.java.buildpack.jre.SAPMachineJRE']"
      JBP_CONFIG_SAP_MACHINE_JRE: '{ use_offline_repository: false, version: 21.+ }'
      JBP_CONFIG_JAVA_OPTS: '[from_environment: false, java_opts: ''-XX:+IgnoreUnrecognizedVMOptions'']'
```

Current `sap_java_buildpack` does not yet officially support JDK 21 and therefore has some limitations:

- Public Internet access is required to download the JDK (no offline mode).
- Only Java Main deliveries are supported (no restriction for Spring Boot apps).

::: warning
The default parameter [`UseContainerCpuShares`](https://bugs.openjdk.org/browse/JDK-8281571), set by the SAP Java buildpack, is now removed. The sizing of JVM with respect to fork join pool, number of GC and compiler threads might change with JDK 21 in contrast to older JVM releases.
If required, apply appropriate JVM sizing parameters according to your needs.
:::

### Reading Drafts

#### New Draft Read Events

Upon [read of draft-enabled entities](/java/fiori-drafts#reading-drafts), the standard `READ` event of a `CqnService` now spawns new `ACTIVE_READ` and `DRAFT_READ` events. These events allow to register event handlers to selectively handle the read of active entity data and draft data.

#### Split Persistence

Active entity data and draft data is usually co-located in the same database schema. By default, query execution of draft-enabled entities is optimized for performance and may leverage the option to join data of active entities and drafts.

However, it's now also possible to enforce a _split_ persistence, which strictly separates active entity data and draft data. This allows, for example, to enable remote entities or entities stored in a different persistence for drafts. In that case set the property `cds.drafts.persistence` to `split`. You can then delegate reading of active entities to a remote system:

```java
@On(entity = MyRemoteDraftEnabledEntity_.CDS_NAME)
public Result delegateToS4(ActiveReadEventContext context) {
    return remoteS4.run(context.getCqn());
}
```

[Learn more about Reading Drafts.](/java/fiori-drafts#reading-drafts){.learn-more}

### Typed Service Interfaces

Besides the [model & data accessor interfaces](/java/cqn-services/persistence-services#staticmodel) for CDS entities and CDS service metadata, the CDS code generator ([cds:generate](/java/assets/cds-maven-plugin-site/generate-mojo.html){target="_blank"}) now creates Java interfaces that reflect the API of the CDS service itself.
In particular, the interfaces contain type-safe methods for bound and unbound actions and functions, as alternative to the generic `emit` method:

Given the CDS service definition:

```cds
service CatalogService {
    entity Books as projection on db.Books {
    } actions {
        action addReview(rating : Integer, title : String, text : String)
          returns Reviews;
    };
    action submitOrder(book : String, quantity : Integer) returns {
        stock : Integer
    };
}
```

The following Java interface is generated:

```java
@Generated(...)
public interface CatalogService extends CqnService {
  Reviews addReview(Books_ ref, Integer rating, String title, String text);

  SubmitOrderContext.ReturnType submitOrder(String book, Integer quantity);
}
```

The interface allows a simplified handler code:

```java
@Autowired
CatalogService catalogService;

int stock = catalogService.submitOrder(bookID, 5).getStock();
```

To turn off the generation of typed service interfaces, use the flag `cqnService` of the `generate` goal:

```xml
<execution>
 <id>cds.gen</id>
 <goals>
  <goal>generate</goal>
 </goals>
 <configuration>
  <cqnService>false</cqnService>
 </configuration>
</execution>
```

### Technical User Switch

Processing business requests frequently requires switching to the technical user of the tenant or technical user of the provider.
One example is calling a platform or sidecar service on a technical level. To cover most common scenarios, the `RequestContextRunner` now allows to explicitly switch to a technical user:

- `systemUserProvider()`: Execute code as technical user on behalf of a _provider tenant_.
- `systemUser()`: Execute code as technical user on behalf of the _current tenant_.
- `systemUser(tenantId)`: Execute code as technical user on behalf of a _specific tenant_.

To execute code on behalf of the provider tenant, open a Request Context as follows:

```java
@Autowired
CdsRuntime runtime;

runtime.requestContext().systemUserProvider().run(reqContext -> {
    ...  // running as provider user (tenant == null)
});
```

The user context is prepared appropriately.

[Learn more about _Defining New Request Contexts_.](/java/event-handlers/request-contexts#defining-requestcontext){ .learn-more}

### Custom EDMX Provider

Now, the OData V4 adapter makes use of the new `EdmxV4Provider` interface, which you can use to customize or even override the EDMX metadata being requested:

```java
@Component
public class CustomEdmxV4Provider implements EdmxV4Provider {

    private EdmxV4Provider standardProvider;

    @Override
 public InputStream getEdmx(String serviceName) {
  return wrapped(standardProvider.getEdmx(serviceName));
 }

 private InputStream wrapped(InputStream edmxStream) {
  ... // adapt stream
 }

    @Override
    public void setPrevious(EdmxV4Provider prev) {
        this.standardProvider = prev;
    }
 ...
}
```

The default provider generates an EDMX stream according to the underlying CDS model of the current tenant.
Don't miss to adjust the Etag of the customized EDMX data as well as clients. For example, SAP Fiori relies on it to implement a proper caching.

### SQL Optimization Mode for SAP HANA Cloud

The SAP HANA adapter in CAP Java now can generate SQL that is optimized for the new [HEX engine](https://help.sap.com/docs/SAP_HANA_PLATFORM/9de0171a6027400bb3b9bee385222eff/3861d0908ef14e8bbec1d76ea871ac0f.html#sap-hana-execution-engine-(hex)) in SAP HANA Cloud.

[Learn more about the SAP HANA Cloud Mode](/java/cqn-services/persistence-services#sql-optimization-mode){.learn-more}

### Runtime Views <Beta />

When you define a projection on an entity that is mapped to a database table, the CDS compiler creates a corresponding view definition for the database schema. To activate the view definition, a database deployment is required. To avoid _unwanted_ schema changes, you can now define a projection as a _runtime view_ by annotating it with `@cds.persistence.skip`:

```cds
entity Books {
  key id    : UUID;
      title : String;
      year  : Int16;
}

@cds.persistence.skip // [!code focus]
entity BooksFromYear2000 as projection on Books { // [!code focus]
   id, title as name // [!code focus]
} where year = 2000; // [!code focus]
```

At runtime, CAP Java dynamically resolves queries against this projection without requiring a corresponding view on the database.

[Learn more about Runtime Views.](/java/working-with-cql/query-execution#runtimeviews){.learn-more}

::: warning
**IMPORTANT:** This is a beta feature, which is available already now to get early feedback from you.  All the [Important Disclaimers and Legal Information](https://help.sap.com/viewer/disclaimer) apply!
:::

### Typed Entity References

Use the new `CQL.entity(Class<StructuredType>)` method to create _typed_ [entity refs](/java/working-with-cql/query-api#entity-refs), which can be used as source in `CqnStatement`s or when calling actions or functions via [service interfaces](#typed-service-interfaces):

```java
Book_ books = CQL.entity(Book_.class);
Book_ booksFromYear2000 = books.filter(b -> b.year().eq(2000));

// get author names of books from year 2000
Select.from(booksFromYear2000.author()).columns(a -> a.name());

// delete all books from year 2000
Delete.from(booksFromYear2000);
```

[Learn more about Entity References.](/java/working-with-cql/query-api#entity-refs){.learn-more}

### Use CDS Watch with Test Containers

The `watch` goal of the `cds-maven-plugin` supports starting applications with test containers.
Therefore it uses the [`test-run`](https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#run.test-run-goal) goal of the `spring-boot-maven-plugin`.
To enable this feature, add the `-DtestRun` property to the Maven command line: `mvn cds:watch -DtestRun`.
In the test environment the Spring Boot application can provide a setup for test-containers as explained in this [guide](https://spring.io/blog/2023/06/23/improved-testcontainers-support-in-spring-boot-3-1).

### Add PostgreSQL and Liquibase support

The [`add`](/java/assets/cds-maven-plugin-site/add-mojo.html){target="_blank"} goal of the `cds-maven-plugin` supports adding PostgreSQL and Liquibase features to a CAP Java project.

To add the PostgreSQL feature use the CDS client:

```bash
cds add postgresql --for postgresql
```

To add the Liquibase feature use the `add` goal of the `cds-maven-plugin`:

```bash
mvn com.sap.cds:cds-maven-plugin:add -Dfeature=LIQUIBASE -Dprofile=postgresql
```

## Multitenancy { #cds-mtx}

### Job Queuing for Subscribe/Unsubscribe/Upgrade

The built-in job orchestrator now has an in-memory queuing mechanism. It can be configured using `cds.requires.multitenancy.jobs.queueSize`.

For non-scaled sidecar instances, this avoids tasks being run for the same tenant at the same time.

[Learn more about configuring the SaaSProvisioningService.](/guides/multitenancy/mtxs#saasprovisioningservice){.learn-more}

### Timestamps for Tenant Metadata

[Tenant metadata](/guides/multitenancy/mtxs#example-get-tenant-metadata) will now contain the `createdAt` and `modifiedAt` properties. Note, that the `createdAt` field is only filled for newly onboarded tenants.

[Learn more about getting tenant-specific metadata.](/guides/multitenancy/mtxs#get-tenant){.learn-more}



# September Release




## Share Your Ideas for CAP

![This screenshot shows the UI of the CAP customer influence session.](assets/sep23/influenceSession.png){.ignore-dark}

We run a continuous influence session as an official channel for your feature requests.
Get engaged and share your ideas.

[Find here the continuous influence session for CAP.](https://influence.sap.com/sap/ino/#/campaign/2280){.learn-more}

## PostgreSQL

### Native `cds build` Support

If your app is using `@cap-js/postgres`, `cds build` now auto-pulls a `postgres` build task generating deployment artifacts for PostgreSQL. This results in a folder structure like this in your `gen` folder:

```zsh
bookshop/
├─ db/
├─ gen/
│ └─ pg/
│   ├─ package.json
│   └─ db/
│     ├─ csn.json
│     └─ data/
│       ├─ my.bookshop-Authors.csv
│       ├─ my.bookshop-Books.csv
│       └─ ...
└─ ...
```

::: warning Remove custom build scripts
As `cds build` is now doing all the work for you, build scripts shouldn't be required any more. If your scenario requires custom build scripts, make sure they do not interfere with the `cds build`-generated `gen` folder structure.
:::

[Learn more about deployment with a deployer app.](../../../guides/databases-postgres#with-a-deployer-app){.learn-more}

### Using `cds add`

For Node.js projects on Cloud Foundry, you can now easily add PostgreSQL configuration to your CAP project – simply run `cds add postgres`.

## CDS Language & Compiler {#cds}

### Calculated Elements

In previous releases we have introduced
[Calculated Elements On-read](./march23#calculated-elements-beta)
with support in the [Node Runtime](./aug23#calculated-elements-in-node-js)
and in the [Java Runtime](./jun23#java-support-for-calculated-elements-on-read),
and [Calculated Elements On-write](./jun23#calculated-elements-on-write)
as beta features.
They are now generally available without restriction.

[Learn more about Calculated Elements.](../../../cds/cdl#calculated-elements){.learn-more}

### Publish Association With Filter <Beta /> { #publish-association-with-filter-beta }

In views or projections, you can now publish an association with a filter. The ON condition of
the resulting association is the ON condition of the original association plus the filter
condition, combined with `and`.

In this example, in addition to `books` projection `P_Authors` has a new association `availableBooks`
that points only to those books where `stock > 0`:

```cds
entity P_Authors as projection on Authors {
  *,
  books[stock > 0] as availableBooks
};
```

[Learn more about Publishing Associations.](../../../cds/cdl#publish-associations){.learn-more}

### Defaults for Managed Associations

If the association target has a single primary key, a default value can be provided for a managed association.

```cds
entity Booking {
  // ...
  bookingStatus : Association to one BookingStatus default 'N';
}
```

This default applies to the generated foreign key element:

```sql
CREATE TABLE Booking (
  ...
  bookingStatus_code NVARCHAR(1) DEFAULT 'N',
);
```

[Learn more about Managed Associations.](../../../cds/cdl#managed-associations){.learn-more}

## Security

### Internal Users

Microservices of an application usually need to send requests on the technical provider level.
For instance, multitenant CAP services fetch tenant-specific CDS models from their MTX sidecar.
Obviously endpoints for intra-application communication need to be authorized properly, to exclude external clients.

Use the new pseudo-role `internal-user` to conveniently protect internal endpoints:

```cds
@requires: 'internal-user'
service InternalService {
  // only open for the technical PaaS provider
  // ...
}
```

Defining custom CAP roles for this use case is no longer necessary and could lead to very dangerous privilege escalations.

Behind the scenes, a JWT token created on behalf of the technical user for the application's shared XSUAA or IAS instance
results in granted pseudo-role `internal-user` in the receiving CAP service that is bound to the **same instance**.

[Find more details about internal communication in Pseudo Roles.](../../../guides/security/authorization#pseudo-roles){.learn-more}

## Node.js {#cds-js}

### Important Changes ❗️ { #changes-in-node-js .important }

- Node 16 is EOL (see [Node.js announcement](https://nodejs.org/en/blog/announcements/nodejs16-eol)). Please upgrade to Node.js 18 or higher as the Node.js buildpack might drop the support soon.

  [For more information, please see _What's New for SAP BTP._](https://help.sap.com/whats-new/cf0cb2cb149647329b5d02aa96303f56?Component=Node.js%20System%20Buildpack&Software_Lifecycle=Deprecated%3Bunscheduled&locale=en-US&version=Cloud&Valid_as_Of=2023-06-01%3A2024-01-31%3Aunscheduled){.learn-more}

### Optimized `cds.test`

To work properly, [_cds.test_](../../../node.js/cds-test) requires to be started from the application directory, to ensure that the correct [_cds.env_](../../../node.js/cds-env) configuration is applied. If it's started from an incorrect directory, rather cryptic error messages appear or it even tests the application with an invalid configuration.
To simplify the detection of these errors, we have implemented the flag [_CDS_TEST_ENV_CHECK_](../../../node.js/cds-test#cds-test-env-check) that throws an error and explains the root cause:

```sh
Detected cds.env loaded before running cds.test in different folder:
1. cds.env loaded from:  ./
2. cds.test running in:  cds/tests/bookshop

    at Test.in (node_modules/@sap/cds/lib/utils/cds-test.js:65:17)
    at test/cds.test.test.js:9:41
    at Object.describe (test/cds.test.test.js:5:1)

   5 | describe('cds.test', ()=>{
>  6 |   cds.env.fiori.lean_draft = true
     |       ^
   7 |   cds.test(__dirname)

  at env (test/cds.test.test.js:7:7)
  at Object.describe (test/cds.test.test.js:5:1)
```

To mitigate such issues, use [`cds.test.in(...)`](../../../node.js/cds-test#test-in-folder) in the beginning of the file, which ensures that [_cds.env_](../../../node.js/cds-env) is loaded correctly.

[Learn more about **cds.test**.](../../../node.js/cds-test){.learn-more}

> We plan to enable the flag by default in the next major release. Please prepare for it by enabling the flag already today.

## Java {#cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

- Cloud SDK `4.24.0` is the new minimum required version for CAP Java. Use [dependency management](https://sap.github.io/cloud-sdk/docs/java/guides/manage-dependencies) to ensure your project consistently uses this or a later Cloud SDK version.
- For event brokers that don't provide an explicit unique message ID the ID is now determined from the cloudevents ID property, if available. Message IDs are no longer generated when receiving an event without any ID.
- Active instances of draft-enabled entities are now locked for deletion, if a locked draft exists, that is owned by a different user. The user owning the draft can always delete the active instance and with that also delete the corresponding draft.

### JDK21 Compliance

CAP Java can now be run on latest [SapMachine 21](https://sap.github.io/SapMachine/) (LTS) and [GraalVM 21](https://www.graalvm.org/).
Integration tests covering transitive dependencies introduced by CAP Java extensions have been executed successfully.

We have started to investigate cool new JDK21 features such as [Virtual Threads](https://openjdk.org/jeps/444).

Stay tuned!

<span id="java-kafka-support" />
<Fragment target="#java-kafka-support">

### Apache Kafka Support <Internal />

[Apache Kafka](https://kafka.apache.org/) is now fully integrated as CAP messaging broker for asynchronous intra-application communication.

You can benefit from Kafka's high-performant and high-scale intra-application event processing infrastructure and still run your code on basis of CAP's intrinsic and easy-consumable messaging APIs.

[Learn more about the CAP Kafka integration.](/guides/messaging/apache-kafka){.learn-more}

</Fragment>

### Collating on SAP HANA

When using locale-specific comparison on SAP HANA, we replaced a _statement-wide_ collation setting, which had negative impact on the performance in some situations. Now, only if locale-specific sorting is required, the `ORDER BY ... COLLATE` clause is used, which affects only the selected sort specification.

By default, all string elements are sorted locale specific. To fine-tune this, the new annotation [@cds.collate](../../../java/cqn-services/persistence-services#sap-hana-cloud) allows to indicate that an element does not require locale-specific comparison:

```cds
entity Books : cuid {
    title        : localized String(111);
    descr        : localized String(1111);
    @cds.collate : false
    isbn         : String(40);  // does not require locale-specific sorting
}
```

::: warning
If string elements, which are not annotated with `@cds.collate:false`, are used in an ordering relation (`>`, `<`, ... , `between`), a statement-wide collation setting is unavoidable.
:::

[Learn more about support for SAP HANA Cloud.](../../../java/cqn-services/persistence-services#sap-hana-cloud){.learn-more}

### Use List Values with IN

You can now compare list values in an `IN` predicate, which allows to efficiently filter by multiple value sets:

```java
import static com.sap.cds.ql.CQL.*;

...

CqnListValue elements = list(get("AirlineID"), get("ConnectionID"));
CqnListValue lh454  = list(val("LH"), val(454));
CqnListValue ba119  = list(val("BA"), val(119));
List<CqnListValue> valueSets = List.of(lh454, ba119);

CqnSelect q = Select.from(FLIGHT_CONNECTION).where(in(elements, valueSets));
```

This is executed by this efficient SQL query:

```sql
SELECT * FROM FlightConnection
  WHERE (AirlineID, ConnectionID) IN ((?, ?), (?, ?))
```

[Learn more about List Values.](../../../java/working-with-cql/query-api#list-values){.learn-more}

### Optimized Expand

The expand strategy `parent-keys` is now executed as a bulk operation. Use the strategy `load-single` to expand the associated entity sets one by one.

```cds
entity Person {
  key id   : Int16;
  name     : String;
  parent   : Association to Person;
  @cds.java.expand: {using: 'parent-keys'}
  children : Composition of many Person on children.parent = $self;
}
```

Sample query:

```java
Select.from(PERSON)
  .where(p -> p.id().in(300, 400))
  .columns(p -> p.name(),
           p -> p.children().expand(c -> c.name()));
```

This query is executed as follows:

```sql
SELECT * FROM Person T0 WHERE T0.id in (?, ?)
SELECT * FROM Person T0 INNER JOIN Person T1 ON (T1.parent_id = T0.id) and (T0.id in ((?), (?)))
```

Use `@cds.java.expand: {using: 'load-single'}` to enforce expanding with individual selects.

[Learn more about Expand Optimization.](../../../java/working-with-cql/query-api#expand-optimization){.learn-more}

### Identity Management

<span id="java-ias-subscriptions" />
<Fragment target="#java-ias-subscriptions">

#### IAS Tenant Subscriptions <Internal />

CAP Java now supports subscription of [IAS](https://help.sap.com/docs/identity-authentication?locale=en-US) tenants by providing an integration with Subscription Manager Service (SMS).
Binding a service instance of type `subscription-manager` with service-plan `provider` to the application automatically activates an endpoint that serves tenant lifecycle requests issued by SMS.

The feature offers:

* Synchronous as well as asynchronous (un)subscription flows.
* Hybrid setup with SaaS-binding for migration scenarios.
* Full integration with [DeploymentService](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/DeploymentService.html).

[Learn more about configuration options in Subscribing IAS tenants.](/java/multitenancy#skipping-deletion-of-tenant-data){.learn-more}

</Fragment>

#### Enhanced Identity Feature

Previously, feature `cds-feature-xsuaa` was mandatory for XSUAA authentication.
Now feature `cds-feature-identity` is also supporting pure XSUAA-based scenarios and is positioned to fully replace `cds-feature-xsuaa` in a compatible way.

For compatibility reasons, the `cds-feature-xsuaa` feature still takes precedence over `cds-feature-identity` in the classpath.
Remove the Maven dependency to `cds-feature-xsuaa` explicitly in order to switch to `cds-feature-identity` in general.

::: warning
Note that `cds-feature-xsuaa` is based on [spring-xsuaa](https://github.com/SAP/cloud-security-services-integration-library/tree/main/spring-xsuaa) which is deprecated.
Consequently, `cds-feature-xsuaa` is now deprecated as well and will be removed in a future release.
:::

### Miscellaneous

- The `cds-feature-postgresql` adds support for SSL connections with host verification.
- Service Bindings from `default-env.json` are now provided through a plugin-in the Service Binding Library and are therefore visible to other libraries, for example Cloud SDK.

## Multitenancy { #cds-mtx}

### Download Migrated Projects

After migrating an application to `@sap/cds-mtxs`, customers might want to continue working with the extensions they made with `@sap/cds-mtx`.<br>
As long as the metadata containers (`TENANT-<id>-META`) created by `@sap/cds-mtx` still exist, the customer extension projects can be downloaded using the CDS client. The user running the download command needs to have the scope `cds.ExtensionDeveloper` assigned.

```sh
cds extend <url> --download-migrated-projects
```

The command downloads an archive named `migrated_projects.tgz` that contains the existing extensions that are ready to be used with `@sap/cds-mtxs`.<br>

[Learn more about MTX migration and the download of migrated projects.](../../../guides/multitenancy/old-mtx-migration#download-of-migrated-extension-projects){.learn-more}

## Miscellaneous

- CSV files with multiline values, that is line breaks, are supported with `cds deploy`.

<div id="secondary-file">releases/archive/2023/sep23.fragment.md</div>


# August 2023




## CDS Language & Compiler {#cds}

### Constraints for `.texts` Entities

If you have enabled foreign key constraints on the database, you will now
also get a constraint on the generated `.texts` entity for localized elements.

Example:

```cds
entity Books {
  key ID : Integer;
  title : localized String;
}
```

A constraint is added to the `texts` table:

```sql
ALTER TABLE Books_texts
  ADD CONSTRAINT Books_texts_texts
  FOREIGN KEY(ID) REFERENCES Books(ID)
  ON UPDATE RESTRICT
  ON DELETE CASCADE
  VALIDATED ENFORCED INITIALLY DEFERRED
```

[Learn more about **Database Constraints**.](../../../guides/databases#database-constraints){.learn-more}
[Learn more about **Localized Data**.](../../../guides/localized-data#localized-data){.learn-more}

## Node.js {#cds-js}

### ‼️ Important Security Change ‼️

For reasons of security by default, the startup of the application is now stopped if `jwt` or `ias` is configured but no service binding is found. Previously, only a warning was emitted and the startup continued without any authentication.

As a consequence, the authentication configuration for test deployments or deployments of demo applications needs to be adapted. For example, by configuring `dummy` or `mocked` authentication for production profile like that:

```json
{
  "cds": {
    "requires": { "auth": "[production]": { "kind": "dummy" }}
  }
}
```

::: danger

Only use that for demo purposes, not in real productive scenarios!

:::

[Learn more about **Authentication Strategies**.](../../../node.js/authentication#strategies){  .learn-more}

### Calculated Elements in Node.js

In recent releases we already introduced [calculated elements with support in views](./march23#calculated-elements-beta), followed by [on-write support](jun23#calculated-elements-on-write), and [support in Java runtime](jun23#java-support-for-calculated-elements-on-read). With this release, Node.js support is added by the new database services.

For example given this definition:

```cds
service Register {
  entity People : cuid {
    lastName  : String(30);
    firstName : String(30);
    fullName  : String = firstName || ' ' || lastName;
    upperName : String = upper(fullName);
  }
}
```

Although the values of calculated elements aren't persisted, they can be used
in ad-hoc queries at runtime in Node.js just like ordinary elements:

```js
SELECT.from(People).columns('fullName', 'upperName');
```

The database service substitutes them with their defining expression:

```sql
SELECT firstName || ' ' || lastName as fullName,
       upper(firstName || ' ' || lastName) as upperName FROM People
```

[Learn more about **Calculated Elements on Read**.](../../../cds/cdl#on-read){  .learn-more}

### Consistent Timestamps in SQLite

The support for `DateTime` and `Timestamp` values has been greatly improved in the new SQLite service, also to maximize feature parity with SAP HANA and PostgreSQL. All timestamp values are converted and stored in normalized values now, so they can be safely compared. For example, you can now safely insert any valid ISO string:

```js
await INSERT.into(Books).entries([
  { createdAt: new Date },                       //> stored .toISOString()
  { createdAt: '2022-11-11T11:11:11Z' },         //> padded with .000Z
  { createdAt: '2022-11-11T11:11:11.123Z' },     //> stored as is
  { createdAt: '2022-11-11T11:11:11.1234563Z' }, //> truncated to .123Z
  { createdAt: '2022-11-11T11:11:11+02:00' },    //> converted to zulu time
])
```

[Learn more in the Database Guide for SQLite](../../../guides/databases-sqlite?impl-variant=node#consistent-timestamps){.learn-more}

### PostgreSQL Step-by-Step Guide

The PostgreSQL database guide was enhanced with [step-by-step instructions](../../../guides/databases-postgres#with-a-deployer-app) describing how to add PostgreSQL to CAP projects. This greatly enhances the existing documentation which required advanced CAP expertise to succeed.

![Screenshot showing the enhanced PostgreSQL guide.](assets/aug23/image-20230906141747850.png)

> This is a community contribution to <https://github.com/cap-js/docs>. <br>
> Thanks so much for that!

### Fixed Typescript APIs

Our Typescript API declarations, that is `@sap/cds/apis/cds.d.ts`, had several bugs and flaws that broke usage in real Typescript projects. Usage for IntelliSense in JavaScript projects was not affected. In a first iteration we now fixed many of these flaws and filled in missing declarations so that usage of `@sap/cds` in true Typescript projects shouldn't run into showstoppers anymore.

Noteworthy in that context:

1. You can use default import as well as individual imports now:

   ```ts
   import cds from '@sap/cds';               // default import
   import { Session, User } from '@sap/cds'; // individual imports

   console.log (cds.Session === Session) //> true
   console.log (cds.User === User) //> true
   ```

   Note that functions like `cds.parse()` o`r cds.linked()` are not available through individual imports. Always access these functions using the `cds` facade object obtained via default import:

   ```ts
   let csn = cds.parse(`entity Foo {}`)
   let m = cds.linked(csn)
   ```

2. Many missing exports have been added now, for example:

   ```ts
   import {

     Service,
     ApplicationService,
     MessagingService,
     DatabaseService,
     RemoteService,

     EventContext,
     Request,
     Event,
     User,

     Association,
     Composition,
     entity,
     event,
     type,
     array,
     struct,
     service,

   } from '@sap/cds'
   ```

   ```ts
   import cds from '@sap/cds'

   cds.env
   cds.requires
   cds.version
   cds.home
   cds.root

   cds.compile
   cds.resolve
   cds.load
   cds.get
   cds.parse
   cds.reflect
   cds.linked

   cds.builtin
   cds.Association
   cds.Composition
   cds.entity
   cds.event
   cds.type
   cds.array
   cds.struct
   cds.service
   cds.services
   cds.server
   cds.serve
   cds.connect

   cds.Service
   cds.ApplicationService
   cds.MessagingService
   cds.DatabaseService
   cds.RemoteService

   cds.EventContext
   cds.Request
   cds.Event
   cds.User

   cds.debug
   cds.log
   cds.test
   cds.utils
   cds.lazify
   cds.lazified
   cds.exit

   cds.ql
   cds.entities
   cds.context
   cds.spawn
   cds.tx
   cds.run
   cds.foreach
   cds.stream
   cds.read
   cds.create
   cds.insert
   cds.update
   cds.delete
   ```

3. You are not required to use the *`esModuleInterop`* tsc compiler option anymore. You can use `@sap/cds` with or without that option now.

Going forward, we will add more improvements and also fix/add links to capire docs.

## Java {#cds-java}

### CDS reuse models in Jars

CDS models and other content can now be shared through Maven dependencies in addition to npm packages. This means you can now provide CDS models, CSV files, i18n files and Java code (for example, event handlers) in a single Maven dependency.

Models are placed in the `resources/cds` folder of the reuse package under a unique module directory (for example, leveraging group ID and artifact ID): `src/main/resources/cds/com.sap.capire/bookshop/`.

Projects wanting to import the content simply add a Maven dependency to the reuse package to their `pom.xml`.

```xml

<dependency>
  <groupId>com.sap.capire</groupId>
  <artifactId>bookshop</artifactId>
  <version>1.0.0</version>
</dependency>
```

Additionally the new `resolve` goal from the CDS Maven Plugin needs to be added, to extract the models into the `target/cds/` folder of the Maven project, in order to make them available to the CDS Compiler.

```xml
<plugin>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-maven-plugin</artifactId>
  <version>${cds.services.version}</version>
  <executions>
    ...
    <execution>
      <id>cds.resolve</id>
      <goals>
        <goal>resolve</goal> // [!code focus]
      </goals>
    </execution>
    ...
  </executions>
</plugin>
```

In CDS files the reuse models can then be referred to using the standard `using` directive:

```cds
using { CatalogService } from 'com.sap.capire/bookshop';
```

> Note that [CDS editor](../../../tools/cds-editors) does not yet support this new location and hence shows an error marker for this line. This will be fixed soon.

[Learn more about providing and using reuse packages.](../../../guides/extensibility/composition){.learn-more}

<span id="enhanced-audit-log" />
<Fragment target="#enhanced-audit-log">

### Enhanced Auditlog <Internal />

So far, [AuditLog V2](../../../java/auditlog#handler-v2) handler has had a strong restriction: SAP Audit Log service couldn't be used  with recommended _oauth2_ plan in combination with [transactional outbox](../../../java/outbox) and hence only synchronous audit log event processing was possible.
Moreover, usage of SAP Audit Log service introduced an expensive JWT token exchange for each business request.

CAP Java now leverages an optimized SAP Audit Log API that brings following benefits when using _oauth2_ plan:
- Asynchronous audit logging with _oauth2_ plan by means of transactional Outbox.
- Significantly reduce audit log event processing times.
- Significantly reduce calls for JWT token exchanges to central XSUAA service.

</Fragment>

### Miscellaneous

- Platform starter bundles `cds-starter-cloudfoundry` and `cds-starter-k8s` now also comprise maven dependencies that are required to run with [IAS](../../../guides/security/authorization#prerequisite-authentication)-based authentication. In particular,
  - `cds-feature-identity`
  - Spring boot starter bundle for security ([cloud-security-services-integration-library
  ](https://github.com/SAP/cloud-security-services-integration-library/tree/main/spring-security-starter))
  are included.

- Performance of accessor interfaces (generated POJOs) has been improved significantly.

- Public [Java Bookshop sample](https://github.com/SAP-samples/cloud-cap-samples-java/tree/postgres) now demonstrates how to consume [Postgre SQL](../../../guides/databases-postgres?impl-variant=java#using-postgresql).

## New Audit Logging Plugin <Beta />

Last but not least, the new, open source CDS plugin [@cap-js/audit-logging](https://www.npmjs.com/package/@cap-js/audit-logging) is available for early adoption now. Simply add the package to your applications's dependencies and get automatic audit logging, for personal data in a plug and play fashion:

```sh
npm add @cap-js/audit-logging
```

*Learn more about setting up and using audit logging in the [Data Privacy guide](../../../guides/data-privacy/), which got greatly revamped and rebased on the new [Incident Management](https://github.com/cap-js/incidents-app) reference sample*.{.learn-more}

#### Migration from former implementation

If you were using the former audit logging support implemented in `@sap/cds@6,` here are your migration steps:

- Remove obsolete dependency `@sap/audit-logging`
- Remove obsolete configuration `cds.requires.audit-log`
- Remove obsolete feature flag `cds.env.features.audit_personal_data = true`.
- Remove obsolete `@AuditLog.Operation` annotations from your CDS models.
- Add the new plugin package, i.e.: `npm add @cap-js/audit-logging`.

`@cap-js/audit-logging` supports all plans of the SAP Audit Log Service.

::: warning

Please note that `@cap-js/audit-logging` is currently released as an early adopter version and, hence, minor breaking changes are possible in the general availability version.

:::

## VS Code Standard Theme in CDS Editor

The [*SAP CDS Language Support* extension for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=SAPSE.vscode-cds) now uses the standard theme instead of a custom built-in theme.  This allows you to use one of the many excellent [themes](https://code.visualstudio.com/docs/getstarted/themes) included in Visual Studio Code by default, as well as in the extension marketplace.

Previously, a custom theme called *Vanilla* was used which in today's standard was quite outdated.  For example it did not provide colors for all token classes. A similar, but more competent, theme is for example *Light Modern* included in Visual Studio Code as default light theme.  In case you have specifically used *Vanilla*, you don't need to take action.  Visual Studio Code will automatically switch to *Light Modern* after an update of the extension.

<div id="secondary-file">releases/archive/2023/aug23.fragment.md</div>


# July 2023




## Better Documentation Search

The search function in Capire got several improvements that lead to **more accurate results**.

- **Java or Node.js pages get prioritized** in the result list depending on the language toggle.
  For example, results for _Fiori draft_ now show _either_ Java or Node.js pages, but not a mixture of both.
  ::: tip
  If you haven't set the toggle to _Node.js_ or _Java_, you can do so now at the top of this page. This toggle applies to all pages, so you only need to set it once.
  ![Toggle for languages](./assets/jul23/variants-toggle.png){}
  :::
- You can use **more search terms** to refine your search. They're now combined with _AND_ to allow this. Note that exact searches (with terms in quotes for example) aren't possible at the moment.
- **Ambiguity got reduced**. For example, _cds watch_ doesn't find _patch_ or _batch_ anymore.

## CDS Language & Compiler {#cds}

### Calculated Elements

We closed a gap in the implementation of calculated elements:
a calculated element "on-read" can now refer to a localized element.

Example:

```cds
entity Product {
  // ...
  description : localized String;
  descr_len : Integer = length(description);
}
```

[Learn more about Calculated Elements.](../../../cds/cdl#calculated-elements){.learn-more}

### Aspects Without Elements

If you define an aspect solely for the purpose of carrying annotations and you don't intend to add elements to it, you can now define it without an elements list, that is, without curly braces.

Example:

```cds
@restrict: [ /*...*/ ]
aspect AuthorizationAnnotations;
```

We plan to enable applying such aspects to services and other objects without elements in the coming releases.

### Simplified Subqueries

Until now, each select item needed to have a name, even if it was inside a subquery and the name was never used. You can now omit these unnecessary aliases in most cases.

Before:

```cds
select from Products {
  // …
} where price < (select from Orders { 0.7 * amount as foo} )
```

After:

```cds
select from Products {
  // …
} where price < (select from Orders { 0.7 * amount } )
```

## Node.js {#cds-js}

After the major release in June, we have a smaller maintenance release in July.
However, there are the two following noteworthy additions.

### `cds.Service.endpoints` (Beta)

The new property `.endpoints` of a served [cds.Service](../../../node.js/core-services#cds-service) instance is an array containing the information for all endpoints.

Consider the service definition:

```cds
@protocol: ['odata-v4', 'rest']
@path: 'browse'
service CatalogService { ... }
```

This exposes services via OData and REST with the schema `<prefix>/<path>` and therefore the following value for `CatalogService.endpoints`:

```js
[
  { kind: 'odata-v4', path: '/odata/v4/browse' },
  { kind: 'rest', path: '/rest/browse' }
]
```

See [cds.protocols](../../../node.js/cds-serve#cds-protocols) for more details on how to configure exposures.

### `@restrict` for Services

The Node.js runtime now supports `@restrict` annotations on service level.
As described in the [authorization guide](../../../guides/security/authorization#restrict-annotation), the properties `grant` and `where` aren't applicable to services so it's ignored.
[Learn more about `@restrict`.](../../../guides/security/authorization#supported-combinations-with-cds-resources){.learn-more}

## Java {#cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

#### Changed Search Behaviour

To achieve stable search performance, the default search behaviour has been changed. Now, only elements of the type String that _aren't computed_ are searched. This can lead to observable differences in the search results. Example:

```cds
entity Persons : cuid {
  firstName : String;
  lastName : String;
  fullName : String = firstName || ' ' || lastName; // not searched by default
}
```

Here, only elements `firstName` and `lastName` will be in the scope of a search by default, but the element `fullName` will not be included anymore.

::: tip
If required, use the [@cds.search](../../../guides/providing-services#cds-search) annotation to include computed String elements.
:::

#### Localized Data

CAP Java by default now leverages session context variables for localized and temporal data on all databases [including H2](#h2-session-context-vars). Consequently, the property `cds.sql.supportedLocales` now defaults to an empty list indicating that session variables should be used.

::: warning

- H2 needs to be updated to v2.2.220 or later
- SQLite requires the compiler configuration `{"cdsc": { "betterSqliteSessionVariables": true }}` in **.cdsrc.json**
:::

### Spring Boot 3.1

CAP Java now supports [Spring Boot 3.1](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-3.1-Release-Notes).

### Better PostgreSQL Config

To facilitate running CAP Java with PostgreSQL on BTP a new feature `cds-feature-postgresql` is available. The feature auto-configures the service bindings for PostgreSQL on BTP. Find detailed information in the [documentation](../../../guides/databases-postgres?impl-variant=java#using-postgresql).

### Order by Alias

You may now use an alias of a select list item in [Order By](../../../java/working-with-cql/query-api#order-by) to sort by the corresponding items. This is useful if you need to sort by a complex expression:

```java
Select.from("bookshop.Person")
    .columns(p -> p.get("name").toUpper().as("aliasForName"))
    .orderBy(p -> p.get("aliasForName").asc());
```

### H2 Session Context Vars

The H2 dialect now uses session context variables for localized and temporal data. These features can now be used without restrictions.

::: warning
This feature requires cds-dk 7.1 (cds-compiler 4.1) and H2 v2.2.220 or later
:::

### Improved Maven Plugin

This release brings some improvements for the [CDS Maven Plugin](../../../java/developing-applications/building#cds-maven-plugin):

- The `watch` goal of the CDS Maven Plugin can now be executed from the root directory of the CAP Java application.
- The new `add` goal allows you to add different features to the CAP Java project. Supported features are `SQLITE`, `H2`, and `MTXS`.

#### Fine-Tuned @Generated Annotation

The `generate` goal of the [CDS Maven Plugin](../../../java/developing-applications/building#cds-maven-plugin) allows you to fine-tune the verbosity of the `@Generated` annotation the generated java sources with the parameter `annotationDetailLevel`. You can choose to include full information (`FULL`), omit the generation timestamp (`MINIMAL`), or suppress the `@Generated` annotation (`NONE`).

### Native Executables <Beta />

CAP Java now supports GraalVM Native Image, which enables you to compile a CAP Java application to a native executable.
Native Image applications have faster startup times and require less memory.

[Learn more about using GraalVM Native Image with CAP Java.](../../../java/operating-applications/optimizing#graalvm-native-image-support-beta){ .learn-more}

## cds-typer: Enums, Arrays

We've added [documentation for `cds-typer`](../../../tools/cds-typer) to Capire. It features a [quick start guide](../../../tools/cds-typer#cds-typer-vscode) and has detailed explanations on how to use the generated types.

The package has also gone open source and is available on [npm](https://www.npmjs.com/package/@cap-js/cds-typer) and [GitHub](https://github.com/cap-js/cds-typer).<br>
**Feedback, bug reports, and contributions are welcome!**

Now `cds-typer` also supports the [`array of` / `many` syntax](../../../cds/cdl#arrayed-types), as well as [enums](../../../cds/cdl#enums).
For your convenience, the Enum values are available at runtime .

For Example, if this is your source:
::: code-group

```cds [schema.cds]
namespace issuetracker;

type Priority: String enum {
  LOW = 'Low';
  MED = 'Medium';
  HIGH = 'High';
}

entity Issues {
  priority: Priority;
  tags: array of String;
  categories: many String;
}
```

:::

The cds-typer will generate:
::: code-group

```ts [@cds-models/issuetracker/index.ts (generated by cds-typer)]
const Priority = {
  LOW: "Low",
  MED: "Medium",
  HIGH: "High",
}

class Issue {
  priority: Priority
  tags: Array<string>
  categories: Array<string>
}
```

:::

Finally, this is how it can be used:
::: code-group

```js [srv/service.js]
const { Priority, Issue } = require('#cds-models/issuetracker')

service.before('CREATE', Issue, ({data}) => {
  data.priority = Priority.LOW
})
```

:::



# June 2023


## Mandatory Prerequisites ❗️ {.important}

::: warning Major Release

The June 2023 release comprises **major release** updates of [CAP Java 2](#java),  as well as [CAP Node.js 7](#node-js). While we kept breaking changes to a minimum as much as possible, please pay attention to the information in the subsections below, as well as to the *Important Changes* sections in the subsequent chapters!

:::

#### Upgrade to Node.js 18

Node.js 14 is out of maintenance and cds 7 requires Node.js 16 minimum. So, ensure to upgrade your Node.js installation. Recommended is Node.js 18, which is the latest LTS version currently. Node.js 16 is not recommended as it reaches end of life already in September 2023.

[Download Node.js LTS version](https://nodejs.org){.learn-more }
[See also: CAP Release Schedule](../../schedule){.learn-more }

#### Upgrade to Java 17

For Java projects using the new [CAP Java SDK 2](#java2), an update to Java 17 is mandatory.

Note: In SAP Business Application Studio, this needs to be triggered explicitly using the command *Java: Set Default JDK* (press <kbd>F1</kbd> to find it).

#### Upgrade to cds-dk 7

`@sap/cds` 7 requires `@sap/cds-dk` 7, so make sure to update it with

```sh
npm i -g @sap/cds-dk
```

#### Use `cds-serve` as Start Script

Prior to cds 7 there was a conflict with the `cds` executables from `@sap/cds` and `@sap/cds-dk`. To resolve this, we renamed the executable provided by `@sap/cds`, which is mainly used in npm start scripts, into `cds-serve`. So, make sure to change `cds-serve` in your start scripts instead of `cds run` from now on, for example:

```json
"scripts": {
  "start": "cds run" // [!code --]
  "start": "cds-serve" // [!code ++]
}
```

> Note: with `@sap/cds-dk` installed, you'd continue to use `cds run` or `cds serve` on your command line as the preferred way.

#### Upgrade VS Code plugins

Ensure your VS Code plugins are upgrade. In particular the [SAP CDS Language Support extension](../../../tools/cds-editors#vscode) has to be on latest version. Usually that happens automatically, and you only need to confirm to restart.

#### Migrate to `@sap/cds-mtxs`

The old MTX package `@sap/cds-mtx` was deprecated with cds 6, and is no longer supported with cds 7. So, in order to use cds 7,  you need to use the new MTX services package `@sap/cds-mtxs` for multitenant applications.

[Learn more about migrating to `@sap/cds-mtxs`.](../../../guides/multitenancy/old-mtx-migration){.learn-more}

## Revamped Guides

#### New Database Guides

We thoroughly overhauled and updated our [database guide](../../../guides/databases), adding content that was missing so far. Moreover, we added dedicated guides for SAP HANA Cloud, as well as the new SQLite Service and PostgreSQL Service.

![image-20230614092040581](assets/jun23/image-20230614092040581.png)

#### Renovated Node.js Reference Docs

Several Node.js reference documentations have been renovated and complemented, such as:

- [The cds Facade](../../../node.js/cds-facade)
- [Class cds. Service](../../../node.js/core-services)
- [Class cds. ApplicationService](../../../node.js/app-services)

## CDS Language

### Important Changes {.important}

Here we list only the most prominent changes. The full list can be found
in the changelog.

#### Default String Length

The default length for type `cds.String` has been changed from `5000` to `255` for all database dialects except for `hana`.

Omitting the string length is meant for rapid prototyping. For production, the length should always be specified.
The default of `5000` is the largest possible length for NVARCHAR fields in SAP HANA. On other (row-based) databases,
this length might have detrimental effects on performance.

The default string length can be controlled with a configuration option:
::: code-group

```json [package.json]
{
  "cds": {
    "cdsc": {
      "defaultStringLength": 5000
    }
  }
}
```

```json [.cdsrc.json]
{
  "cdsc": {
    "defaultStringLength": 5000
  }
}
```

:::

#### Table Aliases in Extends

When extending a view or projection with new select items, it's no longer
possible to use the table alias of the base entity.

Example:

```cds
entity Base { key id: Integer; }
entity P as select from Base as b { id };
```

The table alias `b` is no longer visible in an extension:

```cds
extend P with columns { b.id as bid }  // error
```

Prefixing elements with the table alias isn't necessary, just remove it:

```cds
extend P with columns { id as bid }
```

This change was necessary as a table alias should be an implementation detail of
the basic view definition and shouldn't be visible anywhere else. In addition, the change
avoids potential name resolution ambiguities if `Base` is extended with a structured element `b`.

#### Identifiers with `$`

Your identifiers should not start with `$`.
This is now enforced for table aliases and mixin names. For them,
you can simply choose a different name, as they're local to the respective view/projection definition.
The reason for this change is to avoid unexpected name resolution effects in combination with built-in `$`-variables.

#### `type of` with Association Path

Element type references can no longer follow  associations. For example,
it is no longer possible to write the following:

```cds
entity Books {
  // ...
  authorName : type of author.name; // [!code focus]
}
```

You have to refer directly to the element in the target entity:

```cds
entity Books {
  // ...
  authorName : Authors:name; // [!code focus]
}
```

### Calculated Elements

::: warning
Calculated elements are released as **beta** feature.
They're brand new, and we want to keep the possibility to gather feedback
and do some adjustments, if necessary.
We don't expect major changes in the functionality, though,
and plan to remove the beta tag in one of the next releases.
:::

Calculated elements "on-read" were already introduced in the [March Release](./march23#calculated-elements-beta),
so far to be used only in views or projections. With the current release, we add the following functionalities:

- usage in ad-hoc queries in the Java runtime
- "on write" variant of calculated elements (also called "stored" calculated elements)

#### Java Support for Calculated Elements (On-Read)

The Java runtime now supports using calculated elements in ad-hoc queries.

```cds
service Register {
  entity People : cuid {
    lastName  : String(30);
    firstName : String(30);
    fullName  : String = firstName || ' ' || lastName;
    upperName : String = upper(fullName);
  }
}
```

Although the values of calculated elements aren't persisted, they can be used
in ad-hoc queries at runtime in Java just like ordinary elements:

```java
Select.from(PEOPLE).columns("fullName", "upperName");
```

The Java runtime substitutes them with their defining expression:

```sql
SELECT firstName || ' ' || lastName as fullName,
       upper(firstName || ' ' || lastName) as upperName FROM People
```

Support in the Node.js runtime is on the roadmap.

::: tip
Always specify the type of a calculated element as the type is not computed automatically.
:::

#### Calculated Elements On-Write

In addition to the calculated elements "on-read" introduced in the March release,
CDS now also supports calculated elements "on-write", so called "stored" calculated elements.
The computed values are stored in the database and thus can improve performance, in
particular when used for sorting or filtering.

Define a calculated element "on-write" with the keyword `stored`.
Parentheses around the expression are optional, a type specification is mandatory:

```cds
entity People {
  lastName : String;
  firstName : String;
  fullName : String = (firstName || ' ' || lastName) stored;
}
```

Calculated elements "on-write" are implemented by using the respective
database feature. For SAP HANA, the following table is created:

```sql
-- SAP HANA syntax --
CREATE TABLE Register_People (
  lastName NVARCHAR,
  firstName NVARCHAR,
  fullName NVARCHAR GENERATED ALWAYS AS (firstName || ' ' || lastName)
);
```

Using calculated elements "on write" in ad-hoc queries is possible
both in the Java and in the Node.js runtime.

[Learn more about Calculated Elements.](../../../cds/cdl#calculated-elements){.learn-more}

### Annotated Return Types

It's now possible to annotate the `returns` of an (bound or unbound)
action or function. The annotation can be provided directly in the action/function definition:

```cds
service SomeService {
  entity SomeEntity {
    key id: Integer;
  } actions {
    action boundAction() returns @Core.MediaType: 'application/json' LargeBinary;
  };
  action unboundAction() returns @Core.MediaType: 'application/json' LargeBinary;
};
```

Or it can be assigned via the `annotate` statement:

```cds
annotate SomeService.SomeEntity actions {
  boundAction returns @Core.MediaType: 'application/json';
};
annotate SomeService.unboundAction with returns @Core.MediaType: 'application/json';
```

[Learn more about Annotations.](../../../cds/cdl#annotations){.learn-more}

## Node.js

### Important Changes {.important}

Following are potentially breaking changes you should take notice of...

### Changed Default Service Path

By default, each service is served at an endpoint including a protocol prefix. The `AdminService` is now served at `/odata/v4/admin` instead of `admin`.
Consumers of endpoints, like SAP Fiori Elements applications, might need to be adjusted.

[Learn more about the reason of this change.](#protocols){.learn-more}

#### **Removed Service-Level Checks for Referential Integrity**

This effects `cds.features.assert_integrity` = **`app`** . This feature had been [deprecated since cds6](../2022/jun22#db-constraints), and announced to be removed with cds 7 → please use [database constraints](../../../guides/databases#database-constraints) and/or [`@assert.target`](../../../guides/providing-services#assert-target) instead.

#### Removed Audit Logging

In the course of modularization, the audit logging implementation of `@sap/cds` has been factored out into a separate package `@sap/cds-audit-logging` (to be released soon).

#### **Deprecated OData Flavor x4**

This affects usages of config settings `cds.odata.flavor` and `cds.odata.structs`. Don't use these anymore, and we'll likely remove them with the next major release. Reason: This feature is used very rarely, if at all, while creating lots of efforts and runtime overhead.

#### Removed *Unofficial* Features

- Method **`req.run()`** → use [`cds/srv.run()`](../../../node.js/core-services#srv-run-query) instead.
- Methods `req.getUriInfo()` and `req.getUrlObject()`
- Config option `cds.env.features.bigjs`
- Config option `cds.env.features.parameterized_numbers`
- Config option `cds.env.features.cds_tx_protection`

#### See Also

- [Serving Multiple Protocols](#protocols)
- [Simplified Handlers](#simplified-handlers)

### New Database Services

With cds 7, new database services for SQLite and PostgreSQL are released (new SAP HANA Service will follow soon), which are based on an entirely new database service architecture. The new services are implemented in new open source packages as follows:

| Database                                                     | Implemented In                                               | Learn More                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------ |
|![SQLite logo](https://www.sqlite.org/images/sqlite370_banner.gif){} | [`@cap-js/sqlite`](https://npmjs.com/package/@cap-js/sqlite) | [New SQLite Service](/guides/databases-sqlite)       |
| ![PostgreSQL Elephant Logo](https://www.postgresql.org/media/img/about/press/elephant.png){} | [`@cap-js/postgres`](https://npmjs.com/package/@cap-js/postgres) | [New PostgreSQL Service](/guides/databases-postgres) |

::: tip Maximized Portability

A main advantage of the new database architecture and the new services is  maximized feature parity and portability. For example, we've extensive and equal support for [**path expressions**](../../../guides/databases-sqlite#path-expressions-filters) with or without infix filters, for all databases. Similarly a set of standardized functions is now supported in a portable way.

This gives you enhanced test coverage with SQLite, as well as allowing to switch to other databases, for example from PostgreSQL to SAP HANA, when your project grows.

:::

::: warning

We strongly encourage you to start migrating to and using the new database services as soon as possible. We were able to keep breaking changes to a minimum, mostly affecting undocumented behaviour. We tested them thoroughly, also with customers' test suites. Nevertheless, they're in their very first release, of course... **carefully read the [migration guides](../../../guides/databases-sqlite#migration)** for that reason.

:::

### New Packages

To further modularize `@sap/cds`, as well as simplifying dependencies, new packages have been introduced:

- `@sap/cds-fiori` contains SAP Fiori-related code like the [Fiori preview](../../../advanced/fiori#sap-fiori-preview).
- `@sap/cds-hana` contains SAP HANA-related code, with dependency to the `hdb` driver.

::: tip Recommendation

While you don't need to act immediately, we strongly recommend adding both packages to your package dependencies and remove direct dependencies to the `hdb` driver, if you use SAP HANA or SAP Fiori. This likely will become mandatory in future versions.

:::

### Lean Draft

With cds 7, draft handling for SAP Fiori Elements was reimplemented thoroughly.

The following improvements simplify the handling of draft entities drastically:

- All draft sibling entities are now fully compliant CSN entities. Previously, they were only an overlay of the original entity. This allows a clear separation of logic for drafts and active instances. If you used `req.query` or implemented against `$filter` patterns of SAP Fiori Elements to find out the targeted entity, using lean draft simplifies this drastically.

    ```js
    // As an example, you can differentiate now which handlers are run for active and draft instances
    srv.after("READ", MyEntity, () => {});
    srv.after("READ", MyEntity.drafts, () => {});
    ```

- It also provides better performance as the new implementation doesn't generate expensive `UNION` SQL statements, which are hard to optimize by the databases.

For easier adoption, we also provide a compatibility mode `cds.fiori.draft_compat = true` that reduces adoption effort to a minimum. Be aware, that this is a compatibility mode that will be dropped in the next major release.

[Learn more about the new lean draft implementation.](../../../node.js/fiori#draft-support){.learn-more}

::: tip Lean Draft is enabled by default...

If that creates problems, you can still disable it via `cds.fiori.lean_draft = false`, though. Yet, as the [New Database Services](#new-database-services) are cleaned up of any draft-related code, they require Lean Draft, or not using Draft at all.
:::

### Plugins

The [new plugins technique](../../../node.js/cds-plugins) allows to provide plugin packages, that automatically plug in to cds including auto-wiring required configurations. For example, the new database services auto-wire themselves, when you install them:

```sh
npm add @cap-js/sqlite
```

[Blog post about reusable components for CAP with cds-plugin.](https://blogs.sap.com/2023/04/30/reusable-components-for-cap-with-cds-plugin/){.learn-more}
[Blog post about reusable plugin components for CAP Java applications.](https://blogs.sap.com/2023/05/16/how-to-build-reusable-plugin-components-for-cap-java-applications/){.learn-more}

### Protocols

#### Serving Multiple Protocols

Prior to cds7 you already were able to specify the protocol, but each service was served through a *single* protocol only, at a *single* service endpoint mounted at `/`:

```cds
@protocol: 'rest'
service AdminService { ... }
```

> AdminService is served at `/admin`

With cds7, services can be served via multiple protocols, as follows:

```cds
@protocol: ['odata-v4', 'rest']
service AdminService { ... }
```

> AdminService is served at `/odata/v4/admin` as well as at `/rest/admin`.

#### New Protocol-Specific Service Endpoints

Serving services via multiple protocols, requires separate endpoints with protocol prefixes, for example, `/odata/v4/admin` and `/rest/admin` in the example above. Other advantages of that include avoiding conflicts with static resources served at `/` or `/admin/webapp/...`.

::: warning Breaking Change

The new service endpoints may pose a breaking change to your applications. For example this is the case if:

- When using OData v2 proxy version `< 1.11`
- When using relative service paths, for example, `@path:'admin'`
- When using automatically determined service paths (that is, no `@path` specified at all)

In these cases you can turn on the compat flag `cds.features.serve_on_root = true` , or specify absolute paths with the `@path` annotation, for example, `@path:'/admin'`.
:::

::: tip Prefer the new path scheme

While we provide the compat options as indicated above, you should prefer switching to the new endpoint scheme as soon as possible, as the old one should be regarded as **deprecated**, and will likely be removed in future.

:::

#### Configuring Protocols

With the new major version, the framework does not need to bring the configuration for each protocol.
Protocol adapters like [`@cap-js/graphql`](https://github.com/cap-js/graphql/blob/main/cds-plugin.js) register themselves using the [`cds-plugin` mechanism](../../../node.js/cds-plugins).

::: code-group

```js [cds-plugin.js]
const cds = require('@sap/cds')
const protocols = cds.env.protocols ??= {}
if (!protocols.graphql) protocols.graphql = {
  path: "/graphql", impl: "@cap-js/graphql"
}
```

:::

Additional custom protocols can use the same mechanism to make the framework aware of itself. Applications can simply refer to these protocols using the `@protocol` annotation.

[Learn more about the new protocol configuration.](../../../node.js/cds-serve#cds-protocols){.learn-more}

### Simplified Handlers

From now on, the `result` argument of after handlers is always an array.

**Before**, you always had to handle these three cases: no result, single object, and array of rows, frequently leading to code like that:

```js
srv.after('READ', Books, result => {
  if (!result) return
  if (!Array) result = [result]
  for (let each of result) // ... do something with each
})
```

**Now**, as `result` is always an array, this reduces to:

```js
srv.after('READ', Books, books => {
  for (let each of books) // ... do something with each
})
```

That change is mostly nonbreaking, as most anyways had to support all three cases.

In the very rare cases you may need to differentiate whether the incoming request was addressing a single entry or a collection. Use `req.query.SELECT.one` to do so.

### Miscellaneous

- With the major version, **SAP Cloud SDK version 3** is required. Version 2 is out of maintenance.
  Be aware, that this requires adding an additional dependency `@sap-cloud-sdk/resilience`.
- By default, only primitive strings are searched when using `$search` query option. If columns using expressions should be searched, use the annotation [`@cds.search`](../../../guides/providing-services#searching-data).
- If a custom handler implements `$search` itself, `req.query.SELECT.search = undefined` must be set to undefined instead of using the `delete` keyword.
- All requests for handling of stream metadata (data type, filename, etc.) is handled on application service level instead of protocol adapter level, as streaming is a generic application service feature.

## Java

### Important Changes {.important}

#### New Major 2.x {#java2}

This release brings the new *major* version CAP Java 2.0. Find a step-by-step instruction to upgrade in the [migration guide](../../../java/migration#one-to-two). Stay up to date and benefit from latest and greatest features by migrating to `2.0.x`.

The following changes are especially noteworthy:

- CAP Java 2.0 requires minimal [Java 17](../../../java/migration#java-17)
- [API Cleanup](../../../java/migration#api-cleanup): Some interfaces, methods, configuration properties and annotations, which had already been deprecated in 1.x, are now removed in version 2.0.
- In some areas the [behavior has changed](../../../java/migration#changed-behavior), which might be observable. For example refs are now immutable, and the handling of `NULL` values in results has changed.
- It's no longer possible to navigate from one [draft](../../../java/migration#lean-draft) document to a different draft document in inactive state.

::: warning
Be aware that cds-services `1.34.x` and cds4j `1.38.x` are now in [maintenance](../../schedule#maintenance-status) mode and only receive critical bugfixes. All cds-services versions below `1.34.x` won't be fixed anymore.
:::

### Spring Boot 3

```txt
. .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.0.7)
```

CAP Java now runs with Spring Boot 3, which brings a number of great benefits:

- Leveraging JDK 17 (baseline) and JDK 19 language features.
- Latest Spring Framework 6, Jakarta EE 9 and Tomcat 10.1 capabilities.
- New [Observability](https://spring.io/blog/2022/10/12/observability-with-spring-boot-3) API to provide metrics and traces for [OpenTelemetry](https://opentelemetry.io/).
- [GraalVM](https://www.graalvm.org/) Native Image support that allows compiling applications to native executables.
- Experiment with [virtual threads](https://spring.io/blog/2022/10/11/embracing-virtual-threads) and gain initial experience.

::: warning
Spring Boot 2.7 runs out of OSS support in November 2023.
:::

### OData: `$count` in `$expand`

The OData V4 adapter now supports the [$count](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358955) system query option in `$expand`.

```http
GET http://host/service/Authors?$expand=Books($count=true;$top=3)
```

The `$count` query option ignores the `$top` and `$skip` options, and returns the total count of results across all pages including only those results matching any specified `$filter` and `$search`.

The count is added to the response under the name of the navigation property suffixed with [@count](https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_ExpandedNavigationProperty):

```json
{
  "Name": "Victor Hugo",
  "Books@count": 42,
  "Books": [ ... ],
  ...
}
```

Use `Authors?$expand=Books/$count` to count without expanding the entity.

### Simplified `@After`-Handlers

The result of `CRUD` events now can be easily injected as POJO argument in `@After`-handlers:

```java
@After(event = CqnService.EVENT_READ)
public void afterReadResult(Result result) {
 Stream<Row> rows = result.stream();
 // ...
}
```

<span id="java-calc-elements" />

### Structured Event Messages

Added a new configuration property `structured` to the messaging service configuration. The default is set to `false`. If set to `true`, it enforces that plain strings are transformed into a structured representation.

::: tip
**Note:** Setting `structured` to `true` might have an effect on the representation of the message in the broker.
:::

Configuration example:

```yaml
cds:
  messaging.services:
    - name: "messaging"
      kind: "enterprise-messaging"
      structured: true
```

The interface `MessagingService` provides a new method for emitting events with a data map and a headers map:

```java
void emit(String topic, Map<String, Object> data, Map<String, Object> headers);
```

Example:

```java
String topic;
MessagingService messagingService;

messagingService.emit(topic, Map.of("firstname", "John", "lastname", "Doe"), Map.of("timestamp", Instant.now()));
```

[Learn more about **Enhanced Message Representation**.](../../../java/messaging#enhanced-messages-representation){.learn-more}

## MTX Services

### Renovated Guide for Multitenancy

The [guide for multitenancy](../../../guides/multitenancy/) has bean greatly improved.

![image-20230627073250391](assets/jun23/mt-guide.png)

### Simplified Configuration

Multitenancy and Extensibility can now easily be added using `cds add multitenancy` and `cds add extensibility`.

Example:

```sh
cds add multitenancy
```

::: details Adds package `@sap/cds-mtxs` to your project:

   ```jsonc
   {
      "dependencies": {
         "@sap/cds-mtxs": "^1"
      },
   }
   ```

:::

::: details Adds these lines to *package.json* to enable multitenancy with sidecar:

   ```jsonc
   {
     "cds": {
       "profile": "with-mtx-sidecar",
       "requires": {
         "multitenancy": true
       }
     }
   }
   ```

:::

::: details Adds a sidecar subproject at `mtx/sidecar`:

```json
{
  "name": "<your app name>-mtx",
  "dependencies": {
    "@sap/cds": "^7",
    "@sap/cds-hana": "^2",
    "@sap/cds-mtxs": "^1.9",
    "@sap/xssec": "^3",
    "express": "^4",
    "passport": ">=0.6.0"
  },
  "devDependencies": {
    "@cap-js/sqlite": ">=0"
  },
  "scripts": {
    "start": "cds-serve"
  },
  "cds": {
    "profile": "mtx-sidecar"
  }
}
```

:::

[Learn more about these facets.](../../../guides/multitenancy/#enable-multitenancy) {.learn-more}

The configuration for multitenancy uses static profiles `mtx-sidecar` and `with-mtx-sidecar`. This keeps the **configuration compact**.

::: details For example, profile `mtx-sidecar` contributes the following configuration:

```jsonc
"[mtx-sidecar]": {
    requires: {
      db: {
        "[development]": { ...sqlite_mt, credentials: { url: "../../db.sqlite" }},
        "[production]": hana_mt,
      },
      "cds.xt.ModelProviderService": {
        "[development]": { root: "../.." }, // sidecar is expected to reside in ./mtx/sidecar
        "[production]": { root: "_main" },
        "[prod]": { root: "_main" }, // for simulating production in local tests
        _in_sidecar: true,
      },
      "cds.xt.SaasProvisioningService": true,
      "cds.xt.DeploymentService": true,
      "cds.xt.ExtensibilityService": true,
    },
    "[development]": {
      // requires: { auth: "dummy" }, -> We need authentication for push and pull requests
      server: { port: 4005 }
    }
  }
```

:::

### Sidecar Also Default for Node.js

If a project is switched to multitenancy using `cds add multitenancy`, cds now always creates a sidecar module in folder `mtx/sidecar`, also for Node.js based projects.

[Learn more about the sidecar setup.](../../../guides/multitenancy/#about-sidecar-setups) {.learn-more}

### Improved Local Tests

The tenant upgrade can now also be triggered using the CLI:

```sh
cds upgrade t1 --at http://localhost:4005 -u alice:
```

### Migration from Old MTX

For multitenant applications using `@sap/cds-mtx`, a migration to `@sap/cds-mtxs` is mandatory. Package `@sap/cds-mtx` is no longer supported with cds 7.

[See our migration guide](../../../guides/multitenancy/old-mtx-migration) {.learn-more}

## Toolkit / CLI

### Important Changes {.important}

- `cds deploy --to sqlite` no longer modifies `package.json`. The `--no-save` argument is no longer needed.
- `cds build/all` is no longer available. Use `cds build` instead.
- `cds build --for java` no longer supports the CAP Java Classic runtime. [Migrate to the current CAP Java runtime](../../../java/migration#cap-java-classic-to-cap-java-1-x) version.

### Deploy Format  `hdbtable`

In cds 7, we say goodbye to `hdbcds` as default deploy format for SAP HANA and use `hdbtable` instead. `cds build` now creates `hdbtable` and `hdbview` files by default.

```jsonc
"cds": {
  "requires": {
    "db": "hana"
  },
  "hana": { // [!code --]
    "deploy-format": "hdbtable" // [!code --]
  } // [!code --]
}
```

::: details In case you still need `hdbcds`

... configure it like that:

```json [package.json]
"cds": {
  "requires": {
    "db": {
      "kind": "hana",
      "deploy-format": "hdbcds"
    }
  }
}
```

:::

### Improved `cds env`

- `cds env <key>` allows for a simpler querying of Node.js configuration options. The additional `get` subcommand isn't required anymore.

- The new `--keys` option of `cds env` lists the configuration keys only. For example, this shows all required services of a Node.js app:

  ```sh
  cds env requires --keys
  ```



# April 2023




## All-new Documentation

The **CAP documentation pages (aka _CAPire_) got an all-new look and feel** with major improvements like dark-mode support, better accessibility and responsiveness on smaller devices.  Here are some of the noteworthy features:

- The button on the upper right corner allows **toggling dark or light mode**.  By default, it uses your operating system's preference.
- The **sidebar** on the left side now supports **nested levels**.  Because it expands automatically to the current page, you now know exactly where that page is located.
- With the **_On this page_ outline** on the right side, you now get an overview of the current page's content.  It is available on smaller screen sizes as well
- The [CDS language](../../../cds/cdl) is now supported in code blocks, providing **more accurate syntax highlighting**.
- **Code blocks with focused lines** give more guidance in larger code snippets on which lines are relevant.  See an [example](../../../get-started/in-a-nutshell#capture-domain-models).

<div id="capire-author-news" />
<Fragment target="#capire-author-news">

- Documentation _authors and contributors_ get **much faster turnarounds** running the local version of CAPire. Checkout our [getting started guide for authors](https://github.tools.sap/cap/docs/blob/main/README.md). <Internal />

</Fragment>

<div id="capire-opensource" />
<Fragment target="#capire-opensource">

We have also split the pages into internal and public content to prepare for **open-sourcing CAPire**.  Stay tuned for news in one of the next releases! <Internal />

</Fragment>

## Unrestricted XSUAA Attributes

`$user` attributes can be compared with _null_ in `@restrict` annotations.

- `$user.<attr> is null` matches _null_ and an empty array
- `$user.<attr> is not null` matches arrays _!= null_ and an array with at least one entry

Note that XSUAA attributes with `valueRequired:false` might need model adaption such as `$user.code = code or $user.code is null` to support unrestricted access. There is no effect on default XSUAA attributes with `valueRequired:true`.

[Learn more about unrestricted XSUAA attributes.](../../../guides/security/authorization#unrestricted-xsuaa-attributes){.learn-more}

## Reliable Pagination

For [Server Side Paging](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ServerDrivenPaging) CAP so far uses a numeric skip token that uses `$skip` and `$top` for pagination. This can result in duplicate or missing rows if the data is concurrently created or deleted.
Alternatively, you can now use [reliable pagination](../../../guides/providing-services#reliable-pagination), which generates a skip token based on the values of the last row of a page and is therefore more robust.

You can enable _reliable paging_ with the following configuration options:

- Java: `cds.query.limit.reliablePaging.enabled: true`
- Node.js: `cds.query.limit.reliablePaging: true`

[Learn more about reliable pagination.](../../../guides/providing-services#reliable-pagination){.learn-more}

## Enhanced _Show All References_ in VS Code

_Show All References_ for service elements such as entities, properties and actions now also shows the references to these elements in annotation values. You can use it before modifying a service element to understand if annotations will be affected by the change and avoid the related errors or easily fix them.

<video src="./assets/apr23/FindAllReferences_compressed.mp4" alt="Animated gif showing the new show all references function." autoplay loop muted webkit-playsinline playsinline />

## CDS Language & Compiler {#cds}

### Additional OData Annotation Vocabularies

By default, the compiler only generates the OData metadata for annotations listed in one of the OData vocabularies known to the compiler. Assuming you have a vocabulary `com.MyCompany.vocabularies.MyVocabulary.v1`, you can set the following configuration option:

::: code-group

```json [package.json]
{
  "cds": {
    "cdsc": {
      "odataVocabularies": {
        "MyVocabulary": {
          "Alias": "MyVocabulary",
          "Namespace": "com.MyCompany.vocabularies.MyVocabulary.v1",
          "Uri": "<link to vocabulary document>"
        }
      }
    }
  }
}
```

```json [.cdsrc.json]
{
  "cdsc": {
    "odataVocabularies": {
      "MyVocabulary": {
        "Alias": "MyVocabulary",
        "Namespace": "com.MyCompany.vocabularies.MyVocabulary.v1",
        "Uri": "<link to vocabulary document>"
      }
    }
  }
}
```

:::

Assume you use the annotation assignments prefixed with `Alias`:

```cds
service S {
  @MyVocabulary.MyAnno: 'My new Annotation'
  entity E { /*...*/ };
};
```

This is added to the OData API, including the mandatory reference to the vocabulary definition:

```xml
<edmx:Reference Uri="link to vocabulary document">
  <edmx:Include Alias="MyVocabulary" Namespace="com.MyCompany.vocabularies.MyVocabulary.v1"/>
</edmx:Reference>
...
<Annotations Target="S.E">
  <Annotation Term="MyVocabulary.MyAnno" String="My new Annotation"/>
</Annotations>
```

The compiler neither evaluates the annotation values nor the URI. The values are translated generically and it's your responsibility to make the URI accessible if required.

[Learn more about **OData Annotation Vocabularies**.](../../../advanced/odata#vocabularies){ .learn-more}

## Node.js {#cds-js}

### Important Changes ❗️ { #changes-in-node-js .important }

- A new `minorUnit` element in [sap.common.Currencies](../../../cds/common#entity-currencies) holds the number of fractions that the minor unit takes (for example, 0 or 2). See [@sap/cds-common-content](https://www.npmjs.com/package/@sap/cds-common-content) for matching content.
- Texts for [sap.common.Countries](../../../cds/common#entity-countries) are changed from _Country_ to _Country/Region_.
<span id="country-change" />
<Fragment target="#country-change">

> This is to comply with SAP Product Standard [GLOB-192](https://wiki.one.int.sap/wiki/display/PSGLOB/GLOB-192). <Internal />

</Fragment>

### Miscellaneous

- If custom authentication is enabled, it's now also used for the protection of enterprise-messaging webhooks.
- You can now limit the maximum number of requests that are accepted within a single OData $batch request. `cds.odata.batch_limit` specifies the corresponding limit. By default, no limit applies.
<span id="audit-log-oauth2" />
<Fragment target="#audit-log-oauth2">

- The audit logging service now supports the _OAuth2_ plan. Be aware that this involves a token exchange and therefore cannot be used in conjunction with our outbox. <Internal />

</Fragment>

## Java {#cds-java}

### Important Changes ❗️ { #important-changes-in-java}

#### Optimized OData V4 Adapter

The optimized serializer is now enabled by default. It can be disabled by setting `cds.odatav4.serializer.enabled: false`.

#### XSUAA Attributes Restricted by Default

By default, undefined or empty attributes **restrict** expressions in where-conditions of instance-based authorization now.
For instance, `$user.code = code` evaluates to `false` if the user attribute `code` is not defined or has no value.

#### Immutable References

In CDS QL, a [reference](../../../cds/cxn#references) (_ref_) identifies an entity set or element of a structured type. References can have multiple segments and ref segments can have filter conditions.

The default implementations of references (`ElementRef` and `StructuredTypeRef`), as well as ref segments (`RefSegment`) are now immutable. This makes [copying & modifying CQL statements](../../../java/working-with-cql/query-api#copying-modifying-cql-statements) much cheaper, which significantly improves the [performance](#performance).

:::tip
Only code that modifies existing refs is affected by this change.
:::

##### - Set alias or type

`CQL:entity:asRef`, `CQL:to:asRef` and `CQL:get` create immutable refs. Modifying the ref is not supported. Methods `as(alias)` and `type(cdsType)` now return a _new_ (immutable) ref:

```java
ElementRef<?> authorName = CQL.get("name").as("Author");
ElementRef<?> nombre = authorName.as("nombre");           // authorName is unchanged
ElementRef<?> string = authorName.type("cds.String");     // authorName is unchanged
```

##### - Modify ref segments

Also the segments of an immutable ref can't be modified in-place any longer. To create an immutable ref segment with filter, use

```java
Segment seg = CQL.refSegment("title", predicate);
```

The deprecated `RefSegment:id` and `RefSegment:filter` methods now throw an `UnsupportedOperationException`. For in-place modification of ref segments use the new [RefBuilder](#ref-builder).

<div id="java-event-mesh-upgrade" />
<Fragment target="#java-event-mesh-upgrade">

#### Event Mesh tenant upgrade via Deploy main method <Internal />

The [Deploy main method](/java/multitenancy#deploy-main-method), which is the recommended approach for tenant upgrades, now includes the tenant upgrade of multitenancy-enabled SAP Event Mesh messaging services.
The formerly used [HTTP-based tenant upgrade REST API for Event Mesh](/guides/messaging/event-mesh#upgrading-tenants) has been deprecated and is only available, if the [multitenancy compatibility mode](/java/multitenancy#custom-logic) is enabled.

</Fragment>

### Modification of Ref Segments {#ref-builder}

Use `CQL.copy(ref)` to create a `RefBuilder`, which is a modifiable copy of the original ref. The `RefBuilder` allows to modify the segments in-place to change the segment id or set a filter. Finally call the `build` method to create an immutable ref.

To manipulate a ref in a `Modifier`, implementations should override the new `ref(CqnStructuredTypeRef ref)` and `ref(CqnElementRef ref)` methods. Only use `CQL.copy(ref)` if necessary.

```java
Modifier modifier = new Modifier() {
 @Override
 public CqnStructuredTypeRef ref(CqnStructuredTypeRef ref) {
  RefBuilder<StructuredTypeRef> copy = CQL.copy(ref); // try to avoid copy
  copy.targetSegment().filter(newFilter);
  return copy.build();
 }

 @Override
 public CqnValue ref(CqnElementRef ref) {
  List<Segment> segments = new ArrayList<>(ref.segments());
  segments.add(0, CQL.refSegment(segments.get(0).id(), filter));
  return CQL.get(segments).as(alias);
 }
};
CqnStatement copy = CQL.copy(statement, modifier);
```

For compatibility, the legacy methods `ref(ElementRef<?> ref)` and `ref(StructuredTypeRef ref)` are still supported. The runtime automatically creates _mutable_ copies of refs as input for these methods during CQN modification.

::: warning
The `Modifier` methods `ref(ElementRef<?> ref)` and `ref(StructuredTypeRef ref)` are _deprecated_ and will be removed with CAP Java 2.0.
:::

### Performance Improvements {#performance}

[Immutable references](#immutable-references) improve the performance of copy operations, resulting in a significant reduction in CPU usage, in particular for GET requests on single entities.

According to measurements of basic OData requests in the [SFlight](https://github.com/SAP-samples/cap-sflight) demo application, the average response time of requests on single entities is reduced by 20-30% compared to cds-services version `1.33.1`.

### Compare Row Values

The Query Builder API now allows to build queries that use row values in comparisons.

For example, to get all sales after Q2/2012 you may compose the following query:

```java
import static com.sap.cds.ql.CQL.*;

...

CqnListValue props = list(get("year"), get("quarter"));
CqnListValue vals  = list(val(2012), val(2));
CqnSelect q = Select.from(SALES).where(comparison(props, GT, vals));
```

On databases that support comparing row value (SQLite, H2, Postgres) this feature is leveraged when converting to SQL:

```sql
Select * from Sales where (year, quarter) > (2012, 2)
```

On SAP HANA, the comparison is unfolded as follows:

```sql
Select * from Sales where year > 2012 or year = 2012 and quarter > 2
```

### Open Types in OData v4

You may now annotate an entity or a structured type with [@open](../../../advanced/odata#open-types) to indicate that it is _open_ and hence allows clients to add properties dynamically by specifying uniquely named property values in the payload. Likewise, the server may return additional properties:

```cds
@open
entity Products {
    key productId : Int32;
}
```

The CDS build for OData v4 will render the entity type `Products` in `edmx` with the [`OpenType` attribute](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_OpenEntityType) set to `true`.

Now the client may pass additional properties:

```js
POST /CatalogService/Products
Content-Type: application/json

{
    "productId": 17,
    "description": "box",
    "details": {
        "length" : 17,
        "width"  : 4,
        "height" : 23
    }
}
```

::: warning
Like virtual elements, additional properties are not automatically persisted by the runtime. They must be handled completely by custom code.
:::

<span id="session-context" />
<Fragment target="#session-context">

### Localized and Temporal Data on SQLite <Beta />

Before this release there were functional restrictions when using SQLite:

- localization was supported for only a predefined set of locales
- only as-of-now queries with temporal data were supported

Now, you can advise the CDS Compiler to generate DDL that uses _session context variables_. This allows to use localized and temporal data without restrictions on SQLite.

First, enable compiler support for session context variables:

::: code-group

```json [.cdsrc.json]
{"cdsc": { "betterSqliteSessionVariables": true }}
```

```json [package.json]
{"cds": {"cdsc": { "betterSqliteSessionVariables": true }}}
```

:::

In addition, in the _application.yaml_, set `cds.sql.supportedLocales: "*"` to advise the runtime to use session context variables.

::: tip
The configuration will be simplified in a future release.
:::

</Fragment>

### Improved Kyma Support

A new starter module `cds-starter-k8s` has been introduced which bundles useful CAP dependencies for the Kubernetes/Kyma environment.
The CDS Maven archetype now supports the `kubernetes` and `k8s` values as additional option in the `targetPlatform` parameter.

## Tools {#tools}

### Important Changes ❗️ { #important-changes-in-tools}

`cds-ts watch` now considers configuration from `tsconfig.json` files in Typescript projects.  This might expose compilation errors that were ignored before.  Note that `cds-ts run` has always used `tsconfig.json`, so that these 'error' cases should be rare.

### mTLS (X.509) Authentication

You can now configure `@sap/cds-mtxs` to authenticate with X.509 (mTLS) against XSUAA when fetching a token for multitenancy and/or extensibility. In particular, `cds login -m <clientid>[:<key>]` can be run against an X.509-enabled application, supplying as `<key>` the private key of its X.509 client certificate.
This [configuration](https://help.sap.com/docs/btp/sap-business-technology-platform/enable-mtls-authentication-to-sap-authorization-and-trust-management-service-for-your-application) is usually made in the config parameters of the XSUAA resource in `mta.yaml`.

### EDMX Import

You can now import OData V4 EDMX files containing multiple `Schemas` with single `EntityContainer`.

### AsyncAPI Import

The `cds import` command can now import AsyncAPI documents. It translates events listed in an AsyncAPI document to CDS services and events in a CSN file.

To import an AsyncAPI document, use:

```sh
cds import ~/Downloads/AsyncAPI_sample.json
```

> You can specify the `--from` option to import from AsyncAPI sources explicitly.

![](./assets/apr23/AsyncAPI_Import.png){}

To import AsyncAPI documents programmatically, use the [APIs](../../../tools/apis/cds-import#cds-import-from-asyncapi).

<div id="secondary-file">releases/archive/2023/apr23.fragment.md</div>


# March 2023


## Calculated Elements <Beta /> { #calculated-elements-beta }

Elements can be specified with a calculation expression, in which you can refer to other elements of the same entity.
There are different flavors of calculated elements, which are provided as a series of features in the next releases.
As a first part, this release includes calculated elements with a value expression with "on-read" semantics.

```cds
entity Employees {
  key ID : UUID;
  firstName : String;
  lastName : String;
  name : String = firstName || ' ' || lastName;
}
```

These calculated elements essentially are a convenience feature.
They serve as a "predefined" calculation expressions that can be used in views or projections
on top of the entity instead of writing the expressions there.

```cds
service Srv {
  entity EmployeesWithName as projection on Employees { ID, name };
}
```

A request to read `name` of `EmployeesWithName` returns the concatenated name.

Using such a calculated element in a view/projection is equivalent to writing the expression
directly into the select list, both with respect to semantics and to performance.
The definition above is equivalent to

```cds
service Srv {
  entity EmployeesWithName as projection on Employees {
    ID,
    firstName || ' ' || lastName as name : String
  }
}
```

::: warning
Currently, a calculated element in an entity can't be accessed directly in an OData request
or in custom code. It must always be accessed via a view/projection, as shown in the example.
:::

[Learn more about **Calculated Elements**.](/cds/cdl#calculated-elements){ .learn-more}

## New `cds-plugin` technique

Both `@sap/cds` and `@sap/cds-dk` now provide a simple way for plugins:
It searches in the projects dependencies for packages with a module `cds-plugin.js`.
If that exists it will be loaded. Here's an example usage of that concept in our [GraphQL adapter](https://github.com/cap-js/graphql/blob/main/cds-plugin.js) implementation:

 ```js
 // cds-plugin.js
 const cds = require('@sap/cds')
 const protocols = cds.env.protocols ??= {}
 if (!protocols.graphql) protocols.graphql = {
   path: "/graphql", impl: "@cap-js/graphql"
 }
 ```

> Within that module you can basically plug in to everything, similar to what projects can do in local `server.js` files.

**Main benefit** of that is that adding a feature, like graphql in this case, to a project just requires a simple `npm add`, with no additional configuration required:

```sh
npm add @cap-js/graphql
```

## New SQLite Service <Beta /> {#new-sqlite-service}

We have completely rebuilt our SQLite Database Service with a streamlined design based on a new database services architecture and the [better-sqlite3](https://www.npmjs.com/package/better-sqlite3) driver. The most noteworthy improvements from users' perspective are:

* **Full support for [path expressions](../../../cds/cql#path-expressions)**, including [infix filters](../../../cds/cql#with-infix-filters), and [exists predicates](../../../cds/cql#exists-predicate). For example, queries like that are possible now:

  ```js
  SELECT.from (Books, b => { b.ID, b.title, b.author.name }) .where ('genre.name=','Drama')
  ```

  ```sql
  SELECT `from ${Authors} {
     ID, name, books[where title like '%a%']{ title }
  }`
  ```

* **Standard functions** like `contains`, `concat`, `startswith`, ... are now supported in database-agnostic ways.

* **Common SAP HANA functions**  like `days_between`, `months_between`, `years_between` are supported to enhance testing for SAP HANA-based production scopes.

* **Deep Read queries** with expands are executed as *single* native database queries  using `json_object` functions.

So overall, feature scope has been greatly enhanced, as well as quite some performance improvements. For example, in combination with lean draft we saw this for displaying the initial list page of Travels in [cap/sflight](https://github.com/SAP-samples/cap-sflight):

**Old:** >250ms

![image-20230402140522007](assets/march23/image-20230402140522007.png)

**New:** ~15ms

![image-20230402140543488](assets/march23/image-20230402140543488.png)

::: warning
**IMPORTANT:** This is a beta feature, which is available already now to get early feedback from you.  All the [Important Disclaimers and Legal Information](https://help.sap.com/viewer/disclaimer) apply!
:::

The new service will become the default for SQLite in the upcoming major release.

Find more information, in particular instructions about how to use it in the [README of the `@cap-js/sqlite` package *npmjs.com*](https://www.npmjs.com/package/@cap-js/sqlite).

## Lean Draft <Beta />

We have revamped our implementation for draft-enabled entities. While the old implementation was spread all over our code base, the new one is implemented in a modular, non-intrusive fashion.

**Benefits** for draft usages are more intuitive handler registrations and clear distinction of the request target (active or draft instances) within the custom handlers, as illustrated in this sample:

* `List status: All` triggers `READ` requests to the active and draft entities.

  ```js
  srv.on('READ', '<entity>', /* handle only active instances */)
  srv.on('READ', '<entity>.drafts', /* handle only draft instances */)
  ```

* `EDIT` triggers a `READ` on the active instance followed by a `CREATE` on the draft instance.

**Non-intrusive** means there's no support for draft in the new database services anymore, hence, **[New SQLite Service](#new-sqlite-service) requires lean draft**. So it's automatically switched on when using new SQLite service, you can also switch it on for old db services with:

```jsonc
{ ...,
  "cds": {
    "fiori": {
      "lean_draft": true
    }
  }
}
```

**As a reference**, we've created a [branch in SFlight](https://github.com/SAP-samples/cap-sflight/tree/support-for-lean-draft), that shows some of the changes.
Simply start `cds watch --profile lean-draft` to see it in action or `cds watch --profile lean-draft,better-sqlite` to also use the new SQLite Database Service.

We've also implemented a compatibility mode which mitigates most of the changes. It can be enabled via compatibility flag `cds.fiori.draft_compat = true`.
The SFlight main branch works without any changes when started with `cds watch --profile lean-draft,draft-compat`.
::: warning
**IMPORTANT:** This is a beta feature, which available already now to get early feedback from you.  All the [Important Disclaimers and Legal Information](https://help.sap.com/viewer/disclaimer) apply!
:::

More details will follow soon.

## CAP Security Guide

*"How can we develop and run a CAP application in a secure manner?"*

*"What has CAP in store to protect against typical attack patterns?"*

*"What is expected to meet production-level security requirements?"*

*"How are platform security services involved?"*

These are typical questions asked by developers, operators, and security experts.
The new [CAP Security Guide](../../../guides/security/) addresses all of these questions and helps you to find your way around the challenging topic of security.

![image-20230404174932619](./assets/march23/image-20230404174932619.png){}

<span id="aftersecurityguide" />
<Fragment target="#aftersecurityguide">

## Customer-Managed Keys <Internal />

CAP now supports [SAP HANA Cloud Multitenancy](https://help.sap.com/docs/HANA_CLOUD_DATABASE/5db69f41f207422a98669500adc0181f/172f93968dfe45f09bf8c14b2ca9582d.html?state=DRAFT), a cross-product capability integrating several BTP services.

Most notably, CAP SaaS applications can be natively integrated with [SAP Data Custodian KMS Central Key Management](https://help.sap.com/docs/SAP_DATA_CUSTODIAN) in order to offer a customer-specific key management.

Find details about this feature in [Encryption of Tenant Data](../../../guides/security/aspects#storage-encryption) in the CAP Security Guide.

</Fragment>

## CDS Language and Compiler { #cds}

### Ternary Conditional Operator

Use the new ternary conditional operator `<cond> ? <expr> : <expr>` to improve
the readability of your sources.

This operator is only available as syntactical variant on CDL level. In CSN,
it is represented by the same token stream as the corresponding `CASE` expression.

Example:

```cds
SELECT FROM Books {
  (stock>100 ? 0.3 : 0.1) as discount_ternary,
  CASE WHEN stock>100 THEN 0.3 ELSE 0.1 END as discount_case
}
```

A ternary conditional operator must always be enclosed in parentheses.

## Node.js {#cds-js}

### Important Changes ❗️ {#changes-in-node-js .important }

#### Changed Behavior for Plain SQL Queries

Plain SQL queries now have `req.event === undefined`, formerly this had nondeterministic values. If you require to intercept plain SQL queries, you can register a custom handler using event `*`.
This change also affects the return of plain SQL INSERT queries that formerly returned an [`InsertResult`](../../../node.js/databases#insertresult-beta). From now on, they return the database driver result.

#### Change your start script to `cds-serve`

With the next major version, the `cds` executable of `@sap/cds` will be removed.
This is to avoid further conflicts with the same executable in `@sap/cds-dk`.

If you used `cds run` or `cds serve` commands in your `package.json`, make sure to update it and use the successor `cds-serve`:

```sh
npm pkg set scripts.start="cds-serve"
```

This results in the following configuration:

::: code-group

```jsonc [package.json]
"scripts": {
  "start": "cds-serve"
}
```

:::

### Access Targeted Instances with req.subject

This API simplifies the access of the targeted instances within custom implementation. It's handy for custom actions but is also available for the other events.

Example of [SFlight application](https://github.com/SAP-samples/cap-sflight/blob/0700e9223b14fe7865fcd179158dc176524d7741/srv/travel-service.js#L171):

```js
this.on ('acceptTravel', req => {
  return UPDATE (req.subject) .with ({TravelStatus_code:'A'})
})
```

It can also be used for operating on draft enabled entities as showcased in SFlight.

[For more details, see Node.js > cds.Requests > req.subject](../../../node.js/events#subject){.learn-more}

## Java {#cds-java}

### Important Changes ❗️ {.important #important-changes-in-java}

[Minimum CloudSDK version](/java/versions#minimum-versions) is now `4.10`.

### Retrieving SAP HANA Database ID

The [TenantProviderService](/java/multitenancy#working-with-tenants) now provides, as part of the `TenantInfo` class, the id of the database on which a specific tenant has been onboarded. If the information is not available `null` is returned:

```java
@Autowired ServiceCatalog serviceCatalog;

TenantProviderService tenantProvider =
    serviceCatalog.getService(TenantProviderService.class, TenantProviderService.DEFAULT_NAME);

tenantProvider.readTenantsInfo().forEach(tenantInfo -> {
  String tenantId = tenantInfo.getTenant();
  String dbId = tenantInfo.get("database_id");
});
```

### Auditlog with IAS

Audit Log integration now supports writing entries on behalf of a named user when the CAP application is using IAS instead of XSUAA.

<span id="beforepropcorr" />
<Fragment target="#beforepropcorr">

### CAP Java 2.0 Migration Guide <Beta />

A preliminary version of a migration guide is available, which summarizes changes upcoming with CAP Java 2.0 so that applications can prepare before-hand for the upgrade.

[Learn more in the CAP Java 2.0 Migration Guide.](../../../java/migration#one-to-two){.learn-more}

</Fragment>

### Propagation of Correlation ID

If the execution of a `RequestContext` is dispatched to a different thread, the correlation id of the parent thread is now always propagated to the new thread. If the receiving thread already had a correlation id it will be restored once the execution of the `RequestContext` is completed.

### Deployment Service

The [DeploymentService](/java/multitenancy#custom-logic) API no longer validates the subscription and deployment scope. The scopes are now only validated on incoming HTTP requests (for example, SaaS Registry subscription), that trigger the `DeploymentService` API internally. In case the `MtSubscriptionService` compatibility mode is used, the scopes are still enforced when using the API.

Two new main methods `com.sap.cds.framework.spring.utils.Subscribe` and `com.sap.cds.framework.spring.utils.Unsubscribe` allow triggering subscriptions or unsubscriptions as tasks.

### Simplified Configuration Properties

* Some new CDS [properties](/java/developing-applications/properties) are introduced. The previous properties are still supported for backwards compatibility.
* The [properties](/java/developing-applications/properties) `cds.dataSource.csv*` are moved into a new `cds.dataSource.csv.*` sub-section.
* The new property `cds.multiTenancy.healthcheck.interval` allows to specify the health check interval as a [duration](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config.typesafe-configuration-properties.conversion.durations). Use it in favor of the deprecated property `cds.multiTenancy.healthcheck.intervalMillis`, which specifies the health check interval in ms: `cds.multiTenancy.healthcheck.interval: 5m`


## Tools {#tools}

### Update to Cloud Foundry CLI **8** ❗️ { #update-to-cf8 .important }

The usage of Cloud Foundry CLI versions < 8 is deprecated and will be removed in the near future. Please [update your local installations](https://github.com/cloudfoundry/cli#downloads) accordingly.

For now, you'll get a warning when using an older version of the `cf` CLI in `cds deploy`:

```log
[Warning] You are using Cloud Foundry client version 7.8.9.
We recommend version 8 or higher. Deployment will stop in the near future
for Cloud Foundry client versions < 8.
```

[Learn more about upgrading to cf CLI v8.](https://docs.cloudfoundry.org/cf-cli/v8.html){.learn-more}

### Extension Point Validation by cds build

`cds build` now validates the extension point restrictions defined by the SaaS application provider. If any restriction is violated, the extension build aborts and the errors are logged.

### Improved Code Completion in VS Code for `using` Paths with Support for Mono Repos

Code completion for paths of `using` statements now accounts for the `(dev)dependencies` of the corresponding *package.json* file.

![using_code_completion.gif](assets/march23/using.gif)

### Improved Visualization of Model File Dependencies

*Visualize CDS file dependencies* command now highlights sub modules of mono repos.

![visualize_file_dependencies.png](assets/march23/dependencies.png)

<div id="secondary-file">releases/archive/2023/march23.fragment.md</div>


# February 2023


::: tip
We're focussing already on our [upcoming major release](../../schedule#yearly-major-releases) and therefore have fewer announcements than usual for you. Nevertheless we hope you enjoy the additions and fixes to our framework.
:::

## CDS Language & Compiler {#cds}

### Method-Style Syntax for Spatial Functions

CDS now supports the instance method call syntax and instantiation syntax
for geospatial functions.

```cds
entity Geo as select from Foo {
  geoColumn.ST_Area() as area : Decimal,
  new ST_Point(2.25, 3.41).ST_X() as x : Decimal
};
```

[Learn more about **Native Database Functions**.](../../../guides/databases#native-db-functions){ .learn-more} [Learn more about expression notation of function calls.](../../../cds/cxn#function-calls){ .learn-more} [Learn more about the geospatial functions supported by SAP HANA.](https://help.sap.com/docs/HANA_CLOUD_DATABASE/bc9e455fe75541b8a248b4c09b086cf5/7a2d11d7787c1014ac3a8663250814c2.html){.learn-more}

## Java { #cds-java}

<span id="beforestreamdeploy" />
<Fragment target="#beforestreamdeploy">

### Mass Data Upload in OData v4 <Beta />

In OData v4, you now can upload mass data in a more efficient way, using [PATCH on Entity Collections](../../../advanced/odata#odata-patch-collection) with [delta payloads](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_DeltaPayloads):

```js
PATCH /CatalogService/Books
Content-Type: application/json

{
    "@context": "#$delta",
    "value": [
        {
            "ID": 17,
            "title": "CAP - what's new in 2023",
            "price": 29.99,
            "author_ID": 999
        },
        {
            "ID": 85,
            "price": 9.99
        },
        {
            "ID": 42,
            "@removed": { "reason": "deleted" }
        }
    ]
}
```

Delta patch requests are executed using bulk delete and [upsert](../../../java/working-with-cql/query-api#bulk-upsert) statements, and are more efficient than OData [batch requests](https://docs.oasis-open.org/odata/odata/v4.01/csprd02/part1-protocol/odata-v4.01-csprd02-part1-protocol.html#sec_BatchRequests).

</Fragment>

### Streamlined Deployment Service

The former [MtSubscriptionService](https://www.javadoc.io/doc/com.sap.cds/cds-feature-mt/latest/com/sap/cds/services/mt/MtSubscriptionService.html) has been deprecated in favour of the new [DeploymentService](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/DeploymentService.html).
It covers all tenant lifecycle events such as subscriptions or upgrades in a lean way:

| Event Name       | Event Context                                                                  | Use Case        |
| -----------------| -------------------------------------------------------------------------------| --------------- |
| `DEPENDENCIES`   | [DependenciesEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/DependenciesEventContext.html)   | MT Dependencies |
| `SUBSCRIBE`      | [SubscribeEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/SubscribeEventContext.html)         | Add a tenant    |
| `UNSUBSCRIBE`    | [UnsubscribeEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/UnsubscribeEventContext.html)     | Remove a tenant |
| `UPGRADE`        | [UpgradeEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/UpgradeEventContext.html)             | Upgrade tenant(s)|

By default, tenant-specific resources such as database containers are deleted during removal.
Migration to the [new API](/java/multitenancy#custom-logic) is recommended.
::: tip
Event handlers on the `MtSubscriptionService` API are continued to be triggered in a compatibility mode `cds.multitenancy.compatibility.enabled` (activated by default).
:::

### Miscellaneous

- The [Maven archetype](../../../java/developing-applications/building#the-maven-archetype) now has a new property `jdkVersion`, which can be used to determine the JDK version of the generated CAP Java project. Supported values are `11` and `17` (default).

- The built-in [CDS actuator](../../../java/operating-applications/observability#cds-actuator) now contains a new section `dbpools` that shows database pool statistics (requires `registerMbeans: true` in [Hikari pool configuration](/java/cqn-services/persistence-services#datasource-configuration)).

- The new OData V4 serializer now supports a mode in which it buffers the response before streaming it to the client. This can be enabled in case serialization errors after streaming to the client has already started must be avoided. To enable it set `cds.odataV4.serializer.buffered` to `true`.

## Tools { #tools}

### CAP Notebooks From The Docs

[CAP Notebooks](../../../tools/cds-editors#cap-vscode-notebook) are now available directly through our documentation.

A new *notebook button* on the right-hand-side of the screen directly opens a CAP Notebook in a new [workspace](https://code.visualstudio.com/docs/editor/workspaces) in the user's local [VS Code application](https://code.visualstudio.com/docs).
> For this feature, the [*SAP CDS Language Support*](https://marketplace.visualstudio.com/items?itemName=SAPSE.vscode-cds) Visual Studio Code Extension version 6.6.0 or higher is required.

![](./assets/feb23/cap-notebook-button.png){}

### New CAP Notebook Samples

As CAP Notebooks are now available through our documentation, we make a different kind of CAP Notebook available to you from the [CAP Notebooks Welcome page](../../../tools/cds-editors#cap-notebooks-page).

These are shorter notebooks which serve to describe and demonstrate the different code/language cell types (*Native Shell*, *Native Terminal*, *CDS*, etc.) as well as different commands available within a CAP Notebook providing you simple examples to help you get started.

### AsyncAPI Export Tooling

[AsyncAPI Export](/advanced/publishing-apis/asyncapi) tooling is now available to document events in the CAP project in AsyncAPI format.
You can provide additional configuration for AsyncAPI exports with [presets](/advanced/publishing-apis/asyncapi#presets) and [annotations](/advanced/publishing-apis/asyncapi#annotations).

```sh
cds compile srv --service all -o docs --to asyncapi
```

[![A screenshot showing the corresponding documentation.](assets/feb23/asyncapi.png){}](/advanced/publishing-apis/asyncapi)

## CAP on Kyma/K8s { #cap-on-kymak8s}

### Connectivity Service

Connectivity Service Instance is no longer created by `cds add helm`. Only volumes are added to the `srv` deployment. You need to create the service and bind it before deployment.

[Learn more about Connectivity service.](../../../guides/deployment/to-kyma#arbitrary-btp-services){ .learn-more}

### Changes in the Helm Chart

- Renamed keys
- New way to specify parameters as JSON for service instances
- Two keys for `saas-registry`

With this release the following keys have been renamed/moved:

| Old | New |
|-|-|
| `html5_apps_repo_host` | `html5-apps-repo-host` |
| `service_manager` | `service-manager` |
| `saas_registry` | `saas-registry` |
| `event_mesh` | `event-mesh` |

[Learn more about configuring SAP BTP services.](../../../guides/deployment/to-kyma#sap-btp-services){ .learn-more}

The `config` property of service instances is no longer supported. If you want to specify parameters using a JSON file then you need to use `--set-file` flag during installation.

[Learn more about configuration options for SAP BTP services.](../../../guides/deployment/to-kyma#configuration-options-for-services){ .learn-more}

The `saas-registry` key has been split into 2 different keys.
Key 1: `saas-registry` is dedicated for the service instance properties.
Key 2: `saasRegistryParameters` is dedicated for the parameters and these parameters can be modified by the user if required.

Earlier the *values.yaml* content for `saas-registry` was:

```yaml
saas_registry:
  serviceOfferingName: saas-registry
  servicePlanName: application
  parameters:
    getDependencies: "/-/cds/saas-provisioning/dependencies"
    onSubscription: "/-/cds/saas-provisioning/tenant/{tenantId}"
  ...
```

Now it's changed to:

```yaml
...
saas-registry:
  serviceOfferingName: saas-registry
  servicePlanName: application
  parametersFrom:
    - secretKeyRef:
        name: "RELEASE-NAME-saas-registry-secret"
        key: parameters
saasRegistryParameters:
  xsappname: bookshop
  appName: bookshop
  displayName: bookshop
  description: A simple self-contained bookshop service.
  category: "CAP Application"
  appUrls:
    getDependencies: "/-/cds/saas-provisioning/dependencies"
    onSubscription: "/-/cds/saas-provisioning/tenant/{tenantId}"
    onSubscriptionAsync: true
    onUnSubscriptionAsync: true
    onUpdateDependenciesAsync: true
    callbackTimeoutMillis: 300000
```


<div id="secondary-file">releases/archive/2023/feb23.fragment.md</div>

# January 2023


## CDS Language & Compiler { #cds}

### Simplified Syntax for Binding Parameters

Bound actions or function have a so-called
[binding parameter](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_BindinganOperationtoaResource)
pointing to their bound entity — similar to `this` for Java or JavaScript methods — which usually
is implicitly defined. In the following example, the bound action `CatalogService.Products.addReview`
implicitly has a binding parameter `in` with type `Products`:

```cds
service CatalogService {
  entity Products { ... }
    actions { // bound actions or functions
      action addReview (stars: Integer, comment: String);
    }
}
```

Sometimes however, you need to change the name or the type of this parameter, for example to bind
the action or function to a _collection_ of instances of the base entity rather than to a single instance.
This is now possible by explicitly modelling the binding parameter:
the _first_ parameter of a bound action or function is treated as binding parameter,
if it's typed by `[many] $self`. Use Explicit Binding to control the naming of the binding parameter.
Use the keyword `many` to indicate that the action or function is bound to a collection of instances.

```cds
service CatalogService {
  entity Products { ... }
    actions { // bound actions or functions
      action addReview (in: $self, stars: Integer, comment: String);
      action archiveOutOfStock (products: many $self, since: Date);
    }
}
```

> Action `addReview` shows the equivalent of the action in the first example above but with an explicit binding parameter.
Action `archiveOutOfStock` is bound to a collection of `Products` via a binding parameter called `products`.

::: tip
> In the past you had to use annotations `@cds.odata.bindingparameter.name` and
`@cds.odata.bindingparameter.collection` to achieve the same, which are not required anymore, and deprecated from now on.
:::

Explicit binding parameters are ignored in OData V2.

[Learn more about **Bound Actions and Functions**.](../../../cds/cdl#bound-actions){  .learn-more}

### Extending the Generated _.texts_ Entities

If you have [_localized data_](../../../guides/localized-data),
you can now collectively extend all generated _.texts_ entities by extending
the aspect [`sap.common.TextsAspect`](../../../cds/common#texts-aspects),
which is defined in file _common.cds_.

Use this to add an association targeting the `Languages` code list entity,
or for adding flags that help you to control the translation process.

Example:

```cds
extend sap.common.TextsAspect with {
  language : Association to sap.common.Languages on language.code = locale;
}
```

In the bookshop sample, this would result in the following _Books.texts_ entity:

```cds
entity Books.texts {
  key locale: sap.common.Locale;
  language : Association to sap.common.Languages on language.code = locale;
  key ID : UUID;
  title : String;
  descr : String;
}
```

[Learn more about **Extending generated .texts entities**.](../../../guides/localized-data#extending-texts-entities){  .learn-more}

## Node.js { #cds-js}

### Fixed Semantics of `.where` Function in Query API

In previous versions of the query API, the `where` method didn't consistently wrap the existing where clause in an `xpr`, resulting in situations where the provided expression wasn't always correctly evaluated.

Example:

```js
const query = SELECT.from('Entity')
query.SELECT.where = [{ ref: [ 'a' ] }, '=', { val: 1 }, 'or', { ref: [ 'b' ] }, '=', { val: 2 }]
query.where({ c: 3 })
```

The generated SQL where clause would be `a = 1 or b = 2 and c = 3`, where the second expression might not be evaluated. This is now corrected and the expressions are correctly grouped, in SQL terms `(a = 1 or b = 2) and c = 3`.

### Continued Improvement of `cds.d.ts` Typings

Together with our community, we've done various improvements in our [TypeScript typings](../../../node.js/typescript#typescript-apis-in-sap-cds):

- Typings for [cds.test](../../../node.js/cds-test#test-run) to allow additional arguments
- Typings for [srv.send](../../../node.js/core-services#srv-send-request) to support unbound actions
- Typings for [cds.ql](../../../node.js/cds-ql) to return the correct CQN

If you observe gaps in any of the typings, we appreciate your help.

### Improved Implementation for `search` on SAP HANA

When searching on localized properties, it's now searched in the translation and the fallback for an entry matching the search term. Considering the [bookshop sample](https://github.com/SAP-samples/cloud-cap-samples/blob/main/bookshop) and a German user using the search terms **Wuthering** or **Sturmhöhe**, both would return a match.

## Java { #cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

#### Removed Support for Associations Between Unrelated Draft Entities

Associations from draft entities pointing outside the draft document no longer include entities in inactive state, that is, queries only return associated _active_ data.
In contrast, a corresponding composition from a draft entity always refers to an inactive entity as part of the hierarchical draft document.

In the following example

```cds
service Bookshop {
  @odata.draft.enabled
  entity Books {
    author: Association to Authors;
    ...
  }

  @odata.draft.enabled
  entity Authors {
    ...
  }
}
```

the query `GET /Bookshop/Book(ID=<id>,IsActiveEntity=false)/author` returns an associated entity (type `Authors`) with `IsActiveEntity=true` (or `null` if not existing), even if there's a draft version.

To restore the previous behaviour, you can configure `cds.drafts.associationsToInactiveEntities.enabled: true`.
::: warning
This switch is deprecated and will be removed in future.
:::

#### Changed HTTP Error Code on Missing Authentication

Unauthenticated requests are now rejected with HTTP error code 401 if they fail _authorization_ (error code 403 previously).
This can only happen in a misconfigured application where no authentication is active (for example, no Spring security added) but still authorization is performed by generic CAP handler.
Productive usage shouldn't be affected but you might have to adjust test code.

### JDK 17 Support

JDK 17 is now fully supported and also the _recommended_ runtime JDK. Until now, only JDK 8 and JDK 11 were supported. Due to the [Spring Boot support schedule](https://spring.io/projects/spring-boot#support), Spring Boot version 2.7 that is currently used will reach end of OSS support in November 23.
The latest Spring Boot version 3 has minimum JDK version 17. Therefore, **we recommend a migration to JDK 17 in the near future** as preparation for the upcoming Spring Boot 3 migration.

We also recommend configuring [SapMachine](https://sap.github.io/SapMachine/) 17 JDK (respective JRE) with the [SAP Java buildpack](https://help.sap.com/docs/btp/sap-business-technology-platform/developing-java-in-cloud-foundry-environment) as shown in the example (`mta.yaml`):

```yaml
modules:
  - name: MyCAPJavaApp
    type: java
    path: srv
    parameters:
      ...
      disk-quota: 512M
      buildpack: sap_java_buildpack
    properties:
      JBP_CONFIG_COMPONENTS: "jres: ['com.sap.xs.java.buildpack.jre.SAPMachineJRE']"
      JBP_CONFIG_SAP_MACHINE_JRE: '{ use_offline_repository: false, version: 17.+ }'
```

Current `sap_java_buildpack` has some limitations for JDK 17:

- Public Internet access is required to download the JDK (no offline mode).
- Only Java Main deliveries are supported (no restriction for Spring Boot apps).

<span id="beforereserveddbkey" />
<Fragment target="#beforereserveddbkey">

### Reliable Pagination <Beta />

For [Server Side Paging](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ServerDrivenPaging) CAP so far uses a numeric skip token that uses `$skip` and `$top` for pagination. This can result in duplicate or missing rows if the data is concurrently created or deleted.
[Learn more about **Bound Actions and Functions**.](../../../cds/cdl#bound-actions){  .learn-more}

Alternatively, you can now use [reliable pagination](../../../guides/providing-services#reliable-pagination), which generates a skip token based on the values of the last row of a page and is therefore more robust.

You can enable _reliable paging_ with the configuration option `cds.query.limit.reliablePaging.enabled: true`.

</Fragment>

### Reserved Database Keywords

You can now use identifier names in your CDS Models, which are [reserved words and keywords](/guides/databases#reserved-words) on the target database. The runtime now uses delimited identifiers in the database's default case to avoid a clash with the keyword.

### Memory Consumption of CDS Models

The CAP Java runtime serves business requests on basis of CDS models that are cached in-memory for fastest possible processing. Especially for multi-tenancy, when different tenant-specific models are required, the CDS model cache can consume a substantial amount of memory.

CAP Java now stores CDS models in a more compact representation. Since 1.30, the model reader [strips UI annotations](../2022/dec22#miscellaneous) from the in-memory representation.

With the model of the CAP SFlight [sample application](https://github.com/SAP-samples/cap-sflight), we observe the following improvements:

| CAP Java Version | file size | memory size | reduction |
| --- | --- | --- | --- |
| 1.29 | 222 kB | 1.30 MB |  |
| 1.30 w/ UI annotations | 222 kB | 735 kB | 43 % |
| 1.30 w/o UI annotations | 222 kB | 573 kB | 56 % |
| 1.31 w/o UI annotations | 222 kB | 171 kB | 87 % |

Moreover, some model artifacts, which are common to multiple tenants are now shared in memory. With _three_ variants of the same Fiori Elements sample application model, which have only small differences, we observe:

| CAP Java Version | file size | memory size | reduction |
| --- | --- | --- | --- |
| 1.29 | 667 kB | 3.95 MB |  |
| 1.30 w/ UI annotations | 667 kB | 2.09 MB | 47 % |
| 1.30 w/o UI annotations | 667 kB | 1.69 MB | 57 % |
| 1.31 w/o UI annotations | 667 kB | 505 kB | 87 % |

### Security

- You can now limit the maximum number of requests that are accepted within a single OData `$batch` request.
Settings `cds.odataV4.batch.maxRequests` resp. `cds.odataV2.batch.maxRequests` specify the corresponding limits. By default, no limit applies.

- Added a generic [UserInfoProvider](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/runtime/UserInfoProvider.html) that recognizes requests on behalf of the _provider tenant_ and normalizes the request tenant to `null`(that is, `UserInfo.getTenant() == null`).
This helps to distinguish provider requests from subscriber requests, for instance when fetching the tenant-specific CDS model or when dispatching to the corresponding [PersistenceService](../../../java/cqn-services/persistence-services#additional-persistence-services).
Set `cds.security.authentication.normalizeProviderTenant` to `true` to activate the normalization.

### Modification of CQN Statements

Use the new `Modifier` methods `skip` and `top` to [modify](../../../java/working-with-cql/query-api#copying-modifying-cql-statements) the pagination settings of a `CqnQuery`.
::: warning
The subinterface `CqnModifier`, which does an expensive copy of values, is now deprecated and will be removed in a future release.
:::

### OData: Update Related Entities Using Delta Payload

For OData PATCH requests that [update related entities](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UpdateRelatedEntitiesWhenUpdatinganE) (deep updates) and specify the related entities as a nested [delta payload](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_DeltaPayloads), the key values of entities to be removed can now be given as properties instead of `@id` control information. The "reason" property of `@removed` is optional now.

```json
{
    "ID": "o101",
    "Items@delta": [
        {
            "ID": "i01",
            "amount": 101
        },
        {
            "ID": "i02",
            "@removed": { }
        },
        {
            "@id": "OrderItems(i03)",
            "@removed": { "reason": "deleted" }
        }
    ]
}
```

The example update payload for `Order(o101)` contains a nested delta payload for the associated order items. Upon executing  the PATCH request, order item `i01` is upserted (inserted or updated as needed), and items `i02` and `i03` are deleted. All other items of `Order(o101)` remain untouched.

## Tools {#tools}



<span id="beforecfuserhybrid" />
<Fragment target="#beforecfuserhybrid">

### Auto-generated Type Definitions for CDS Models <Beta /> <Internal /> {#auto-cds-typer}

Remember the tool to generate [`.ts` type definitions for your CDS models](../2022/oct22#js-type-defs)?  You can now have it **run automatically** within VS Code.

To do so, install the _cds typer_ tool:

```sh
npm i -g @sap/cds-dts-generator --@sap:registry=https://int.repositories.cloud.sap/artifactory/api/npm/build-releases-npm
```

And enable it in VS Code's settings:

![A screenshot showing the configuration in VS Code. Type "type generator" to filter down the options and enable 'Cds > Type Generator'](assets/jan23/cds-typer-config-vscode.png){ .adapt}

The type generator is in beta state, and we like to hear what you think about it. Give it a try!

[Learn more about the type generator.](https://github.tools.sap/cap/cds-typer){ .learn-more}

</Fragment>

### Cloud Foundry User-Provided Services in Hybrid Testing

User-provided services can now be used for [hybrid testing](../../../advanced/hybrid-testing). The handling is fully transparent to users, e.g `cds bind --to my-user-provided-service` is sufficient.

`cds watch --profile hybrid` will automatically resolve bindings to user-provided service instances using the same technique as for any other managed services.

## Multitenancy { #cds-mtx}

### Minimum Runtime Version Required

`@sap/cds-mtxs` version `>= 1.5.0` requires at least `@sap/cds@6.5.0`.

<span id="beforehdbmigrationtable" />

### Support of `hdbmigrationtable` in Extensible Projects

SaaS applications using extensibility can now use `@cds.persistence.journal` for base model entities to get `.hdbmigrationtable` support. Important: Extending migration table artifacts isn't supported.

### Cache Database Credentials from SAP Service Manager

The credentials fetched from the `service-manager` are now cached. This reduces the number of requests to the `service-manager`, mitigating errors caused by rate-limiting. Disable caching by setting `cds.requires.multitenancy.cacheBindings = false`.

### Simpler Deployment Service Configuration

You can now configure the deployment service in a simpler way:

```jsonc
"hdi": {
  "create": {
    "database_id": "<ID>"
  },
  "bind": {
    "key": "value"
  }
}
```

Instead of:

```jsonc
"hdi": {
  "create": {
    "provisioning_parameters": {
      "database_id": "<ID>"
    },
    "binding_parameters": {
      "key": "value"
    }
  }
}
```

The old configuration is still supported, but you're advised to migrate to the new configuration for improved readability.

### Improved Job Status Response

`/-/cds/jobs/pollJob` now also returns a `tenants` field, so tenant-specific tasks don't have to be polled individually. An example response format looks like this:

```json
{
  "status": "FAILED",
  "op": "upgrade",
  "tenants": {
      "non-existing-tenant": {
         "status": "FAILED",
         "error": "Tenant 'non-existing-tenant' does not exist"
      },
      "existing-tenant": {
         "status": "FINISHED"
      }
   }
}
```

## CAP on Kyma/K8s { #cap-on-kymak8s}

### SAP HANA Cloud HDI Containers on Kyma Runtime

With the December 2022 release of the SAP HANA Cloud tools, we can now create HANA HDI shared containers on the Kyma runtime. The CAP on Kyma tooling creates HANA HDI shared containers on the Kyma runtime itself.

![An architecture diagram showing the old and new ways to access SAP Hana from Kyma. It highlights that Cloud Foundry isn't required to access the containers anymore.](assets/jan23/hana-on-kyma.png){ .adapt}

### Support for Multitenancy and App Router

![Command 'cds add hana,xsuaa,approuter,multitenancy --for production' and output to show the new way to  add multitenancy to your Kyma apps.](assets/jan23/kyma-multitenacy-command.png){}

CAP on Kyma tooling now supports the deployment of Multitenant SaaS applications on Kyma along with App Router. The [Deploy to Kyma guide](../../../guides/deployment/to-kyma) is updated with the multitenancy deployment instructions.

![A part of a sample helm chart with configuration for Service Manager and SaaS Registry.](assets/jan23/kyma-multitenancy-chart.png){}

### Changes in the Helm Chart

With this release, the [Helm charts](../../../guides/deployment/to-kyma#deploy-to-kyma) (`cds add helm`), the following keys have been renamed/moved:

| Old | New |
|-|-|
| `hana_deployer` | `hana-deployer` |
| `html5_apps_deployer` | `html5-apps-deployer` |
| &rarr; `bindings` &rarr; `html5_apps_repo` | &rarr; `bindings` &rarr; `html5-apps-repo` |
| &rarr; `cloudService` | &rarr; `env` &rarr; `SAP_CLOUD_SERVICE` |

In addition to these properties, `backendDestinations` is now moved from `html5_apps_deployer.backendDestinations` to root of `values.yaml`.

Earlier the `values.yaml` content for `HTML5 Apps Deployer` was:

```yaml
html5_apps_deployer:
  cloudService: null
  backendDestinations: {}
  ...
```

Now, it's changed to:

```yaml
backendDestinations: {}
html5-apps-deployer:
  env:
    SAP_CLOUD_SERVICE: null
  ...
```

<div id="secondary-file">releases/archive/2023/jan23.fragment.md</div>


# All of 2022



<br>
<IndexList :pages='pages' />



# December 2022


## Common Content Package Available on npm { #common-content }

Package [@sap/cds-common-content](https://www.npmjs.com/package/@sap/cds-common-content) is now available on npm. It provides prebuilt data for the common entities `Countries`, `Currencies`, and `Languages`.

Add it like so:

```sh
npm add @sap/cds-common-content --save
```

Add this to your `cds` files:

```cds
using from '@sap/cds-common-content';
```

[Learn more about types and aspects from @sap/cds/common](../../../cds/common){ .learn-more}
[Learn more about integrating reuse packages](../../../guides/extensibility/composition){ .learn-more}

<span id="beforegraphql" />
<Fragment target="#beforegraphql">

The package is another great example of inner-source contributions by our [internal SAP community](../../../resources/community-sap). <Internal />

</Fragment>

## Open Source GraphQL Adapter

We have released our first module `@cap-js/graphql` to public GitHub. It's the successor of `@sap/cds-graphql`. Use this from now on instead.

Also note the new plugin mechanism.
It requires the [middlewares feature](/node.js/cds-serve#customization-of-req-user) and, by default, mounts the protocol adapter behind the authentication middleware.

```json
{
  "cds": {
    "requires": {
      "middlewares": true
    },
    "protocols": {
      "graphql": { "path": "/graphql", "impl": "@cap-js/graphql" }
    }
  }
}
```

[Learn more about the new GraphQL Adapter at our public repository.](https://github.com/cap-js/cds-adapter-graphql){ .learn-more}

## Multitenant CAP Sample Application

Based on a recent [partner collaboration](https://blogs.sap.com/2022/11/07/circelligence-by-bcg-innovate-in-the-circular-economy-on-sap-btp/) we are pleased to feature another comprehensive CAP sample application. Besides demonstrating various Multitenancy aspects, the solution touches on a lot of other essential topics like SAP BTP Automation, User-Management, or a push-based API Integration. Even a lot of Day-2 Operations are covered in the so-called Expert Scope. Start by reading the recently published [blog post series](https://blogs.sap.com/2022/10/19/multitenant-saas-applications-on-sap-btp-using-cap-tried-and-true/) and deep dive into the related SAP-samples [GitHub repository](https://github.com/SAP-samples/btp-cf-cap-multitenant-susaas) to learn more.

![A screenshot showing multiple screens of the sample application.](assets/dec22/AppOverview.png){ .adapt}

[Blog Series](https://blogs.sap.com/2022/10/19/multitenant-saas-applications-on-sap-btp-using-cap-tried-and-true/){ .learn-more}
[Sample Application incl. documentation](https://github.com/SAP-samples/btp-cf-cap-multitenant-susaas){ .learn-more}

## New Performance Modeling Guide

The new [Performance Modeling](../../../advanced/performance-modeling) guide is the start of a series of performance-related documents. We'll promote additions to this series in our release notes.

![Screenshot of the Performance Modeling guide.](assets/dec22/performance-modeling-guide.png){ }

[Read the new Performance Modeling guide.](../../../advanced/performance-modeling){ .learn-more}

## Initial Data for Extensions

Besides local test data, extensions can now contain initial data as CSV files.

[Learn more about initial data in Extensions.](../../../guides/extensibility/customization#push-extension){ .learn-more}

## Migration Helper for MTX <Beta />

In order to migrate your application from using `@sap/mtx` to `@sap/mtxs`, you can now run a script to convert the subscription metadata and the extensions to the persistence used by `@sap/cds-mtxs`.

[Learn more about the script in the Migration Guide.](../../../guides/multitenancy/old-mtx-migration){ .learn-more}

## Automatic Schema Migration for SQLite <Beta />

::: warning
This is a beta feature. Its configuration and how it works may change in future releases.
:::

Compatible model changes can now be deployed by evolving the database schema instead of applying `DROP/CREATE`.
Switch on automatic schema evolution in the database configuration:

::: code-group

```json [package.json: cds > requires]
"db": {
    "kind": "sqlite",
    "schema_evolution": "auto"
}
```

:::

## CDS Language & Compiler { #cds}

### OData Annotation `@Validation.AllowedValues` for all enums

The values of an `enum` type are now always rendered in the generated EDMX as `@Validation.AllowedValues`,
irrespective of `@assert.range`.

<span id="beforenode" />

## Node.js { #cds-js}

### Important Changes ❗️ { #changes-in-node-js .important }

- Errors thrown by the Database Service do not have a status code anymore. Eventually, they end up in an internal server error (status code 500). Previously, the runtime differentiated between actual SQL errors and input validation. As the origin of the query is unknown to the Database Service, it must not always be treated as user input.
- Data provided for associations (except primary keys in managed associations) within a deep insert/update is from now on ignored by the Database Service. Previously, it was erroneously rejected as a Bad Request assuming that it always serves an HTTP endpoint.

### UPSERT

Flat UPSERT queries are now supported. It updates existing data or inserts new data if not yet existing and is primarily intended for efficient data replication scenarios.
It eventually unfolds to an [UPSERT SQL statement](https://help.sap.com/docs/HANA_CLOUD_DATABASE/c1d3f60099654ecfb3fe36ac93c121bb/ea8b6773be584203bcd99da76844c5ed.html) on SAP HANA and to an [INSERT ON CONFLICT SQL statement](https://www.sqlite.org/lang_upsert.html) on SQLite.

`UPSERT` is only available for database services. It can be used in custom handlers but the generic handlers of the runtime do not make use of it.

You can use it like:

```js
UPSERT.into('db.Books')
  .entries({ ID: 4711, title: 'Wuthering Heights', stock: 100 })
```

[Learn more about UPSERT.](../../../node.js/databases#databaseservice-upsert){ .learn-more}

### CSRF Token Handling for Remote Services

The [automatic fetch of CSRF tokens](../../../node.js/remote-services#csrf-token-handling) of consumed services is now controllable for each service individually.

```jsonc
"cds": {
    "requires": {
        "API_BUSINESS_PARTNER": {
            "kind": "odata-v2",
            "model": "srv/external/API_BUSINESS_PARTNER",
            "csrf": true
        }
    }
}
```

::: warning
The global configuration `cds.features.fetch_csrf` is deprecated and will be removed in the next major version 7.
:::

[Learn more about Consuming Remote Services in general.](../../../guides/using-services){ .learn-more}

## Java { #cds-java}

### Deep Update / Upsert with nested Deltas

CAP Java now supports [delta lists](../../../java/working-with-cql/query-api#deep-update-delta) with related entities in deep updates and upserts, which allow a more efficient execution.

#### OData: Update Related Entities using Delta Payload

So far OData PATCH requests that [update related entities](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UpdateRelatedEntitiesWhenUpdatinganE) (deep updates) have to provide data for related entities using a _full set_ payload. Related entities that are not in the update data are deleted.

As an alternative it is possible now to specify the related entities as nested [delta payload](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_DeltaPayloads). In this case, only the entities contained in the delta payload are processed. Related entities that are not in the delta remain untouched.

```json
{
    "ID": "o1",
    "Items@delta": [
        {
            "ID": "oi1",
            "amount": 101
        },
        {
            "@id": "OrderItems(oi2)",
            "@removed": { "reason": "deleted" }
        }
    ]
}
```

The example update payload for `Order(o1)` contains a nested delta payload for the associated order items. Upon executing  the PATCH request, order item `oi1` is upserted (inserted or updated as needed), and item `oi2` is deleted. All other items of `Order(o1)` remain untouched.

#### Using Deltas in CDS QL

When executing [deep update](../../../java/working-with-cql/query-api#deep-update) or [deep upsert](../../../java/working-with-cql/query-api#deep-upsert) statements, associated entities can now also be represented as a delta.

To use the delta representation, create a `CdsList` that is marked as `delta` and explicitly mark entities to be deleted via the `CdsData:forRemoval` method.

```java
OrderItems item1 = OrderItems.create("oi1");
item1.setAmount(101);
OrderItems item2 = OrderItems.create("oi2");
Orders order = Orders.create("o1");
order.setItems(delta(item1, item2.forRemoval()));

Update.entity(ORDERS).data(order);
```

This update data for `Order(o1)` contains a nested delta list (`CdsList` marked as `delta`) for `Items`. The delta contains data for item `oi1` and item `oi2` is marked for removal.
During execution item `oi1` is upserted and item `oi2` is deleted, all other items of `Order(o1)` remain untouched.

### Optimized OData V4 Adapter

Creating a JSON-response on basis of the OData query's result is a pretty CPU-intensive task in the OData protocol adapters.
The previous implementation of the V4 adapter is based on [Apache Olingo](https://olingo.apache.org/doc/odata2/tutorials/basicread.html) APIs that require the _full_ query result set to be transferred into an intermediate data representation before it is serialized to the servlet stream in JSON format.

With this version, an optimized implementation of OData V4 serializer is introduced which directly writes the result data to the response stream.
This significantly reduces memory and CPU consumption helping to scale the number of requests to a higher degree. To cope with errors during streaming, it makes use of [OData in-stream error handling](https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_InStreamError).

The measurements of basic OData requests in [SFlight](https://github.com/SAP-samples/cap-sflight) application has been redone with the current version (optimized OData serializer mode activated):

| OData Request<sup>1</sup> | CAP Java 1.26.0 | CAP Java 1.29.0 | CAP Java 1.30.0
| --- | --- | --- | ---
| `GET /Travel?$top=1000` | 100%  | 31% | **13%**
| `GET /Travel?$expand=to_Agency`  | 100% | 39% | **16%**
| `GET /Travel?$expand=to_Booking($expand=to_Carrier)` | 100% | 21% | **11%**
| `GET /Travel?$search=Japan` | 100% | 46% | **29%**
| `GET /Travel(TravelUUID=<uuid>,IsActive=true)` | 100% | 130% | **50%**

> <sup>1</sup> No authorization and in-memory DB H2

The optimized serializer is optional and can be switched on with `cds.odatav4.serializer.enabled: true`.
If enabled, only OData requests with system option `$apply` still make use of the classic serializer.

### Exception Handler for Messaging

To ensure successful delivery of messages, some messaging brokers such as [Event Mesh](../../../java/messaging#configuring-sap-event-mesh-support) and [Message Queuing](../../../java/messaging#configuring-sap-event-mesh-support) rely on the acknowledgement of sent messages.
These brokers redeliver messages that are not acknowledged by the receiver. By default, CAP acknowledges messages _only if they have been successfully handled_ by the application. Hence, repeatedly failing messages are redelivered again and again, regardless of the root cause.

To avoid this situation and to introduce an application-specific error handling, you can now register an error handler for messaging services in order to explicitly control message acknowledgement in case an exception has occurred:

```java
@On(service = "messaging")
private void handleError(MessagingErrorEventContext context) {
  // access the event context of the raised exception
  context.getException().getEventContexts().stream().findFirst().ifPresent(expContext -> {
    TopicMessageEventContext messageEventContext = expContext.as(TopicMessageEventContext.class);
    String event = messageEventContext.getEvent();
    String data = messageEventContext.getData();
    // handle the message according to event and data
    // ...
  });
  context.setResult(true); // finally acknowledge the message
}
```

[Learn more about Error Handling.](../../../java/messaging#error-handling){ .learn-more}

<span id="beforeadditional" />
<Fragment target="beforenode">

### CDS Syntax Highlighting on github.tools.sap <Internal />

_CAP CDS_ is now a publicly known language on [github.tools.sap](https://github.tools.sap), which means you get syntax highlighting for [_CAP CDS_ files](https://github.tools.sap/cap/cds/blob/6110905af17f9a70e1bbac82143932b2643901b1/common.cds).

You can also write `cds` markdown code fences in all GitHub issues like so:

<pre><code>```cds
entity Foo {
  key bar: String;
}
```
</code></pre>

[Learn more about writing code blocks on GitHub](https://docs.github.com/en/get-started/writing-on-github/working-with-advanced-formatting/creating-and-highlighting-code-blocks){ .learn-more}

[github.wdf.sap.corp](https://github.wdf.sap.corp) will display CDS code in the same way after the next update.

</Fragment>

<Fragment target="#beforeadditional">

### Kafka Messaging <Beta />

Added integration of [Apache Kafka](https://kafka.apache.org/) as additional offering into CAP Messaging:

- It provides out-of-the-box messaging with CDS-defined events using Apache Kafka as a message broker.
- Leverage Apache Kafka's advanced features for high horizontal scalability and reliability.

To integrate with a Kafka message broker, bind your CAP application to an appropriate platform service, for example of type `kafka`, and add the following feature in your pom.xml:

```xml
<dependency>
  <groupId>com.sap.cds</groupId>
  <artifactId>cds-feature-kafka</artifactId>
  <scope>runtime</scope>
</dependency>
```

Configure the corresponding Kafka messaging service in your `application.yaml`:

```yaml
cds:
  messaging:
    services:
      my-kafka-messaging:
        kind: kafka-channel-messaging
```

Per default, all CAP events are sent to predefined topic `cds.default`.

To define a specific Kafka partition and object keys of an event, make use of [KafkaEventContext](https://www.javadoc.io/doc/com.sap.cds/cds-feature-kafka/latest/com/sap/cds/feature/messaging/kafka/KafkaEventContext.html).

[Java Messaging](../../../java/messaging#supported-message-brokers) shows how to work with messaging in CAP Java in general.

</Fragment>

### Additional Persistence Services

The CAP Java SDK now automatically configures additional Persistence Services for each non-primary database service binding. This enables simple CQN-based access to an additional tenant-independent HDI container in multitenant applications. Simply bind an additional HDI container to your application and a Persistence Service with the name of the service binding is automatically configured by CAP. Any usage of an additional Persistence Service needs to happen in custom handlers.

Note that all Persistence Service instances reflect on the same CDS model. It is the responsibility of the developer to decide which artifacts are deployed into which database at deploy time and to access these artifacts with the respective Persistence Service at runtime.

You can also now configure additional Persistence Services for non-primary datasources that are explicitly created as beans in Spring Boot.
All details about Persistence Services can now be found in the new [Java > Persistence Services](../../../java/cqn-services/persistence-services) guide.

### Type Propagation

For the functions `min`, `max`, `count*`, `tolower`, `toupper` and `substring` the result type is now determined considering the input type.

Sample entity:

```cds
entity Orders {
    ID : UUID;
    created : Timestamp;
}
```

Query:

```java
Select.from(ORDERS).columns(o -> o.created().max().as("mx"));
```

Returns data with an element `mx` with Java type `java.time.Instant`.

### Miscellaneous

- The [expand](../../../java/working-with-cql/query-api#expand) execution now also [optimizes](../../../java/working-with-cql/query-api#expand-optimization) the `to-one` expands that have nested `to-many` expands, resulting in less queries against the data store.

- In [CSV initialization](../../../java/developing-applications/properties#cds-dataSource-csv-initializationMode) mode `always`, CAP Java creates now CSV data with UPSERT so that the initialization can be used with a persistent database.

- Generated [accessor](../../../java/cds-data#generated-accessor-interfaces) and [builder](../../../java/cqn-services/persistence-services#model-interfaces) interfaces are now annotated with `@Generated` so that they can be identified by static code analysis as such.

- CAP Java now reduces the size of CDS models. As UI Annotations aren't needed in the backend, it strips the UI annotations from the CDS model and preserves them only in EDMX.

- The `DataSource` beans created by CAP Java based on service bindings are now named `ds-<binding>` instead of `<binding>`. Now a Persistence Service bean is auto-configured with name `<binding>`.

- The query parameter `sap-language` is based on SAP's proprietary language tags. CAP Java however supports [BCP47 language tags](https://en.wikipedia.org/wiki/IETF_language_tag) only. Therefore `sap-language` was replaced by `sap-locale` which is based on BCP47 language tags.

## Tools { #tools}

### New CAP Sample Notebook

The [Extending SaaS Applications](../../../guides/extensibility/customization) guide is now available as a [CAP Notebook](/tools/cds-editors#cap-vscode-notebook).

### Add Variables to CAP Notebooks

[CAP Notebooks](/tools/cds-editors#cap-vscode-notebook) now support variable declarations in a cell which can be used later in `shell` cells, `terminal` cells or any `magic command`. This offers the possibility to declare values once, like host names or ports, and reuse them across the notebook.

![This screenshot is explained in the accompanying text.](assets/dec22/capnb_variables.png){}

### Support for Specific CDS Compiler Versions in VS Code

This release of our VS Code extension introduces a special handling for projects using older (version < 3) compilers.
If your workspace contains exclusively projects using CDS compiler version 2 or lower, a specialized CDS language support will be started.
This enhancements comes with a change, which doesn't allow mixing CDS compiler versions in one workspace anymore. In such cases, our extension shows a warning message and informs you to separate your projects into workspaces, one workspace for each compiler version.

![Warning when mixing CDS compiler versions](assets/dec22/mixing_compiler_warning.png){}

### Improved Migration Table Support in `cds build`

With this version, only model entities annotated with `@cds.persistence.journal` are saved as `last-dev` version in the file system. This ensures that changes are reduced to the minimum.
::: warning
You will observe unexpectedly big diffs after the first execution of `cds build`.
:::

<span id="beforemtx" />
<Fragment target="#beforemtx">

### Simplified xMake Configuration for SQLite <Internal />

If you have maintained a `sqlite3` configuration in `.xmake.cfg`, you can now simplify it and use a stable URL:

```properties
[env_all]
npm_config_sqlite3_binary_host_mirror=https://int.repositories.cloud.sap/artifactory/build-releases/com/sap/cds/node-sqlite3-binary/{version}/node-sqlite3-binary-{version}.zip!
```

The `{version}` string is automatically replaced by npm, which means you no longer need to adjust the URL for future versions of `sqlite3`.

> Note the mandatory `!/` at the end of the URL.

</Fragment>

## Multitenancy { #cds-mtx}

### Minimum runtime version required

`@sap/cds-mtxs` version `>= 1.4.0` requires at least `@sap/cds@6.4.0` or CAP Java `1.30.1`.

### Enhanced job status response for asynchronous APIs

With the `@sap/cds-mtxs` library, you can now poll the status of the individual tenants for the asynchronous upgrade call.

### Persistence of onboarding metadata

The metadata that is sent to the application by the **SAP BTP SaaS Provisioning service** with the subscription is now persisted. It can be read using

```http
GET /-/cds/saas-provisioning/tenant/<tenant id>
```

You can omit the tenant id to get the metadata of all tenants.

<div id="secondary-file">releases/archive/2022/dec22.fragment.md</div>


# October 2022


## CAP Sessions at SAP TechEd { #teched}

![](../../../resources/assets/sap-teched.svg){}

**Date**: November 15/16, 2022<br>
[**Register** now!](https://www.sap.com/about/events/teched.html)<br>

We are about to pack our bags for this year's SAP TechEd. Here is what we have planned as sessions around CAP:

- [Discover the Latest Innovations in CAP](https://go3.events.sap.com/sapteched/hybrid/2022/reg/flow/sap/saptech2022/sapteched2022catalog/page/catalog/session/1661202714774001CAb1): New and noteworthy things in CAP
- [Boost Verticalization, Customization, and Composition](https://go3.events.sap.com/sapteched/hybrid/2022/reg/flow/sap/saptech2022/sapteched2022catalog/page/catalog/session/1661198449398001XLB7): Learn about multitenancy, extensibility, and feature toggles
- [Bringing Service Integration to Your Fingertips](https://go3.events.sap.com/sapteched/hybrid/2022/reg/flow/sap/saptech2022/sapteched2022catalog/page/catalog/session/1661198449436001XsjT): See service integration with integration packages in action
- [Compose Full-Stack Apps in Business Application Studio](https://go3.events.sap.com/sapteched/hybrid/2022/reg/flow/sap/saptech2022/sapteched2022catalog/page/catalog/session/1661198449362001Xt1w): Build and deploy CAP applications in minutes using only visual editors

## Localization Support in Extensions

Within an extension, it's now possible to include i18n files, using the same approach as for standard applications

::: code-group

```properties [i18n/i18n.properties]
SalesRegion_name_col = Sales Region
Orders_priority_col = Priority
...
```

:::

[Learn more about localized extensions.](../../../guides/extensibility/customization#localizable-texts){ .learn-more}

<span id="beforealpsflight" />
<Fragment target="#beforealpsflight">

## JavaScript Type Definitions from CDS Models <Beta /> {#js-type-defs}

You can now generate `.ts` type definitions from your CDS model.
In JavaScript projects, this allows for better code completion and type checks in VS Code.

In the following example, because of the generated type definitions, the elements of `Books` are available inside a `SELECT` query. An element that does not exist got an error mark:

![Code completion for CDS model](assets/oct22/cds-typer.png){ }

The type generator is in beta state, and we like to hear what you think about it. Give it a try!

[Learn how to use the type generator.](https://github.tools.sap/cap/cds-typer){ .learn-more}

</Fragment>

## SAP Fiori Analytical List Page for SFlight { #alp-sflight }

We have added an SAP Fiori [Analytical List Page](https://ui5.sap.com/#/topic/3d33684b08ca4490b26a844b6ce19b83) (ALP) to our [CAP SFlight](https://github.com/SAP-samples/cap-sflight) sample.

![A screenshot of an analytical list page based on SFlight.](assets/oct22/alp_sflight.png){ .adapt}

The ALP runs with the Node.js and the Java version of CAP SFlight.
Both runtimes support the relevant queries out of the box.
That means, you just have to set the required annotations without the need of custom handler implementations.

::: warning
Within the SFlight repository, to enable all features for the ALP in the Node.js runtime, we've switched on the new OData parser (`odata_new_parser: true`), which is still **experimental**. If you use the ALP with the standard OData parser, some features like grouping in the analytical table are not available.
:::

## CDS Language & Compiler { #cds}

### Reusing Annotations

Now, it is possible to extend a view or a projection with an aspect that only contains annotations.
Use this to write lengthy annotations like for instance-based authorization only once and
reuse them for several entities:

```cds
@restrict: [{ grant: ['READ', 'WRITE'], where: 'CreatedBy = $user' }]
aspect RestrictToOwner {};

extend Orders with RestrictToOwner;
extend Vendors with RestrictToOwner;
```

Extending an entity with an aspect is the same as including the aspect. Thus, applying
an annotation directly to the entity overwrites the same annotation coming from an aspect.

[Learn more about Named Aspects.](../../../cds/cdl#named-aspects){ .learn-more}

## Node.js { #cds-js}

### Consumption of Dead Letter Queue

In messaging, to receive all messages without creating subscriptions, you can register on `*`.

### Simplified Usage of Correlated Sub-Queries

In the fluent query API, we have eased the construction of where exists clauses.

```js
SELECT.from(Authors).where({exists:'books'})
SELECT.from(Authors).where({'not exists':'books'})
SELECT.from(Authors).alias('a').where({ exists:
  SELECT.from(Books).where({author_ID:{ref:['a','ID']}})
})
```

To support those clauses, we've introduced a dedicated method `.alias()` to choose table aliases.

```js
SELECT.from(Authors).alias(a)
```

[Learn more about Constructing Queries.](../../../node.js/cds-ql#constructing-queries){ .learn-more}

### SAP-Specific EDMX Annotations Respected in Service Consumption

SAP-specific properties like `sap:display-format="Date"` are respected in EDMX importer and runtime.

```js
service.insert({ name: 'Edgar Allan Poe', birthdate: '1809-01-19' }).into(Authors)
```

The payload of this query will be automatically transformed to match the expected EDM format of the remote system, in this case `1809-01-19T00:00:00`.

## Java { #cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

Starting with this release, property `cds.install-cdsdk.version` of goal `install-cdsdk` in the `cds-maven-plugin` is **mandatory and needs to be explicitly maintained by the application**. This property specifies the `@sap/cds-dk` version used for CDS build. Previously it was optional and had the default value `^4`.
Note that the build stops if this property is missing. If your configuration is not prepared yet, find a detailed description how to set this property in [Using a specific cds-dk Version](../../../java/developing-applications/building#cds-maven-plugin).

### Significant Performance Optimizations

Recently, there has been a focus on eliminating performance hotspots in the CAP Java runtime.
According to measurements of basic OData requests such as fetching a full entity set (`GET /Travel`) in [SFlight](https://github.com/SAP-samples/cap-sflight) application, CPU usage has been significantly reduced. The following table shows some examples (CPU consumption compared to version 1.26.0):

| OData Request<sup>1</sup> | CAP Java 1.29.0 |
| --- | --- |
| `GET /Travel?$top=1000`  | down to 31% |
| `GET /Travel?$expand=to_Agency`  | down to 39% |
| `GET /Travel?$expand=to_Booking($expand=to_Carrier)` | down to 21% |
| `GET /Travel?$search=Japan` | down to 46% |

> <sup>1</sup> No authorization and in-memory DB H2

Performance optimizations are still ongoing, so stay tuned for more improvements.

### H2 2.x as Default Database

CAP Java now supports H2 version 2.x. In Spring, H2 is automatically initialized as in-memory database when the H2 JDBC driver is present on the classpath.

For H2, you need to configure the CDS Compiler to use the new SQL [dialect `h2`](../../../java/cqn-services/persistence-services#h2), which is specific for H2 2.x.

```sh
cds deploy --to h2 --dry
```

The `cds-services-archetype` now generates a new CAP Java project with H2 2.x as in-memory database.

### Support for Download Repositories with Authentication

The goal `install-node` of the `cds-maven-plugin` triggers the download of a Node.js contribution from a remote repository.
To support repositories that require authentication (for example, internet facing location), the goal has been enhanced with a new optional property `cds.install-node.serverId`, which refers to a server configuration in maven's `settings.xml` file. When setting up a connection to the remote repository to download Node.js, `install-node` now uses provided credentials from this server configuration.

### Create CDS QL Statements from Results

[Entity References](../../../java/working-with-cql/query-execution#entity-refs) can now also be obtained from the result rows of insert and update operations. The references address the entity via the key values from the result row and can be used in CDS QL statements:

```java
CqnUpdate update = Update.entity(AUTHOR).data("name", "James Joyce").byId(101);
Author joyce = service.run(update).single(Author.class);

CqnSelect q = Select.from(joyce.ref().books());
```

<div id="secondary-file">releases/archive/2022/oct22.fragment.md</div>

# September 2022


## Streamlined MTX { #cds-mtx}

### New Extensibility Guide {  #new-ext-guide }

Following the streamlined [multitenancy guide](../../../guides/multitenancy/), there is now a [new guide for extending SaaS apps](../../../guides/extensibility/customization). It features

- Easier setup of extension projects
- Local development roundtrips with SQLite
- More examples for extending CDS models

<span id="afterextguide" />
<Fragment target="#afterextguide">

### Improved Subscription <Internal />

When subscribing via the `SaasProvisioningService`, tenant metadata is now saved and can be accessed as follows:

```http
###
# Return all tenants metadata

GET /-/cds/saas-provisioning/tenant

###
# Return the metadata for a single tenant

GET /-/cds/saas-provisioning/tenant/<tenantID>
```


</Fragment>

## CDS Language & Compiler { #cds}

### Reuse Type `sap.common.Locale`

[The reuse types `@sap/cds/common`](../../../cds/common) now contain a new type definition for `Locale`:

```cds
type sap.common.Locale : String(14) @title : '{i18n>LanguageCode}';
```

> This type is used for the `locale` field of generated text entities.

### Extending Scalar Types

The `extend` directive has been enhanced to allow for enlarging the `length`
property of strings and the properties `precision` and `scale` of decimals.

Example:

```cds
using { User, Locale } from '@sap/cds/common';
extend Locale with (length:16);
extend User with (length:200);
```

[Learn more about Extend.](../../../cds/cdl#extend){ .learn-more}

### New Integer Types

We have introduced the built-in types `UInt8` and `Int16`.
They are supported by both, the Node.js and the Java runtime.

| CDS Type | Example Value | SQL         | EDMX        |
| ---      | ---           | ---         | ---         |
| `UInt8`  | `133`         | _TINYINT_   | _Edm.Byte_  |
| `Int16`  | `1337`        | _SMALLINT_  | _Edm.Int16_ |

Example:

```cds
type Rating : UInt8;
type Stock : Int16;
```

[Learn more about Built-in Types.](../../../cds/types){ .learn-more}

<span id="afterintergertypes" />
<Fragment target="#afterintergertypes">

### Nested Projections <Beta />

The CDS Compiler now supports *Nested Expands*, which are postfix projections following
a struct element or an association. They are used to read deeply structured
documents and produce structured result sets.

Example:

```cds
SELECT from Authors {
   name, address { street, town { name, country }}
}
```

This feature is only relevant if you need structured result sets or want to describe structured APIs.
You won't use it for SAP Fiori UI services where everything is flattened. As the CAP Runtimes have up to now
only restricted support for structured result sets, the feature *Nested Expands* is most interesting
for modeling structured APIs.


In contrast to nested expands, *Nested Inlines* don't affect the structure of the result.
They are a convenience syntax to avoid writing the same path repeatedly.

Example:

```cds
SELECT from Authors {
  name, address.{ street, town.{ name, country }}
}
```

Note the <kbd>.</kbd> before the opening brace, which distinguishes a nested inline from a nested expand.

The previous example is equivalent to the following query:

```cds
SELECT from Authors {
  name,
  address.street,
  address.town.name,
  address.town.country
}
```

::: warning
Currently you can use nested projections only for modeling, with
generic runtime support being restricted to GET requests.
:::

[Learn more about nested projections in CDS Query Language.](../../../cds/cql#postfix-projections){ .learn-more} [Learn more about nested projections in Node.js](../../../guides/querying#nested-projections){ .learn-more} [Learn more about nested projections in Java](../../../java/working-with-cql/query-api#select){ .learn-more}


</Fragment>

## Node.js { #cds-js}

### Important Changes ❗️ { #changes-in-node-js .important }

- All MTX related services have been moved to `@sap/cds-mtxs`. Make sure that you update both modules, `@sap/cds` and `@sap/cds-mtxs`, together.
- The Node.js runtime doesn't interpret the SAP-specific query option `sap-language`. Fiori Elements always sends a _BCP47_ compliant `accept-language` header that is interpreted correctly. If you have used the query option in your tests, please use the header instead.
- If you use the new [1.0.0 version of `axios`](https://github.com/axios/axios/releases/tag/v1.0.0), this might raise errors with missing response headers. In this case, stay with `axios 0.x` for the time being.
- 14.18 is now the minimum required Node.js version. Previously, this was 14.15.  Check your version with `node -v`.

<span id="afterimportant" />
<Fragment target="#afterimportant">

### Streamlined Express Middlewares <Beta />

To get more control over HTTP request handling, we have streamlined the usage and the implementation of our own express middlewares.

As a consequence, the authentication middlewares have been refactored and are now aligned with common passport modules.
Other functionality has been converged into express middlewares as well.

You can activate this feature either by using the `middlewares` profile when starting the application or by setting `cds.middlewares = true` within your cds configuration.

To plug in own express middlewares, you can either manipulate the `cds.middlewares.before` array or reassign a new array containing all required middlewares.

```js
cds.middlewares.before.push(function x (req,res,next) { next() })
```

Be aware, that some of the middlewares are required for the runtime to work properly.

To serve the same service with multiple protocols, you can use the following configuration:

```js
cds.env.protocols = {
  'odata-v4': { path: '/' },
  rest: { path: '/rest' }
}
```


</Fragment>

### Default Suffix for SQLite Files is now `.sqlite`

The default file endings of SQLite databases has been changed to `.sqlite` in order to integrate seamlessly with VS Code plugins.
Make sure to adapt your _.gitignore_ file.

<video src="./assets/sep22/sqlite_compressed.mp4" alt="A gif showing VS Code and the execution of the `cds deploy --to sqlite` command and as a result the _db.sqlite_ file." autoplay loop muted webkit-playsinline playsinline />

If you are using `.db` as file ending within your project, it will work as before.

### Messaging via Redis <Beta />

::: warning
This is a beta feature. Beta features aren't part of the officially delivered scope that SAP guarantees for future releases.
:::

There's a new `Messaging Service` based on Redis PubSub, which is suitable for asynchronous communication between tightly-coupled microservices. To configure this messaging service, bind your CAP application to an appropriate platform service, for example of type `redis-cache` and install the latest version of npm package `redis`.

In the `package.json`, you can configure a Redis messaging service explicitly:

```json
{
  "requires": {
    "messaging": {
      "kind": "redis-messaging"
    }
  }
}
```

### Improved `cds.log()`

- Added out-of-the-box support for **winston** loggers. For example, creation and usage of winston loggers is as simple as that now:

  ```js
  cds.log.Logger = cds.log.winstonLogger()
  ```

  [Learn more in the documentation of `cds.log()`.](../../../node.js/cds-log#winston){ .learn-more}

- Improved loading custom `server.js` files during bootstrapping so that setting custom loggers via `cds.log.Loggers = ...` has immediate effect on all subsequent log output.

- Finally, [documentation for `cds.log()`](../../../node.js/cds-log) received a major overhaul, including additional, formerly missing information as well as some formerly undocumented features.

![A screenshot of the documentation for the cds.log method showing the table of content.](./assets/sep22/cds-log-docs.png){}


### Improved `cds.d.ts` Typings

Together with our community, we have done various improvements in our [TypeScript typings](../../../node.js/typescript#typescript-apis-in-sap-cds):

- Typings for using [tagged template variants of several CQL constructs](../../../node.js/cds-ql#constructing-queries)
- Typings for calling shortcut versions of CQL constructs (`SELECT(...)` in addition to `SELECT.from(...)`, etc.)
- Typings for [wildcard expansion `*` of properties in CQL](../../../cds/cql#smart-selector)
- Typings for [cds.log](../../../node.js/cds-log), [cds.test](../../../node.js/cds-test), [cds.utils](../../../node.js/cds-utils), [req.entity](../../../node.js/events#target)
- More specific signatures for CQL operations

![Screenshot showing intellisense for cds.log](assets/sep22/ts-cds-log.png){ .adapt}

<div id="beforecdsjava" />
<Fragment target="#beforecdsjava">

See the [list of the closed issues](https://github.tools.sap/cap/issues/issues?q=is%3Aissue+label%3A%22in+Typescript%22+is%3Aclosed+closed%3A%3C2022-10-04). <Internal />

</Fragment>

If you observe gaps in any of the typings, we appreciate your help.

## Java { #cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

#### New Behavior for Upsert

The semantics, behavior and implementation of [Upsert](#upsert) has been redesigned. This might [affect your application](../../../java/migration#legacy-upsert) if you use the Upsert statement in custom code.

#### Parameters of Actions and Functions

Values for parameters of actions and functions are now validated as described [here](#validation-function).

### Native `UPSERT` {   #upsert}

The semantics, behavior and implementation of [upsert](../../../java/working-with-cql/query-api#upsert) has been redesigned and aligned with the stakeholders' expectations.
Upsert now leverages UPSERT (UPdate or inSERT) operations on the database where possible.

#### Behavior

- The Upsert statement is primarily intended for efficient data replication scenarios.
- The Upsert statement updates existing data or inserts new data if not yet existing.
- It is now possible to supply partial data ("PATCH semantics").
- The entities that are upserted are identified by the key values given in the data.
- Generic handlers are not executed upon upsert, and no ID generation happens.

#### Usage

The following code performs a [bulk upsert](../../../java/working-with-cql/query-api#bulk-upsert) that upserts two books in a batch leveraging UPSERT on the DB:

```java
Books b1 = Books.create(101);
b1.setTitle("Odyssey");

Books b2 = Books.create(103);
b2.put("title", "Ulysses");

CqnUpsert upsert = Upsert.into(BOOKS).entries(asList(b1, b2));
```

You can also upsert [deeply structured data](../../../java/working-with-cql/query-api#deep-upsert). Here, we upsert an order with an associated order item:

```java
Orders order = Orders.create(1000);

OrderItems item = OrderItems.create(1);
item.setBookId(101);
item.setQuantity(2);
order.setItems(asList(item));

CqnUpsert upsert = Upsert.into(ORDERS).entry(order);
```

#### Implications on Custom Code

Up to cds-services 1.27, upsert always completely _replaced_ pre-existing data with the given data: it was implemented as
cascading delete followed by a deep _insert_. Since this release the upsert is implemented as a deep _update_ that creates
data if not existing.

While generic code is not affected by this change application developers that use upsert in custom code need to be aware of
the [implications](../../../java/migration#legacy-upsert) and might have to adapt their code.

If an application can't immediately adjust to the new upsert behavior when upgrading to this version of cds-services, _it's possible to switch back_ to the old upsert behavior: set the configuration parameter `cds.sql.upsert.strategy` to `replace`.

[Learn more about Upsert.](../../../java/working-with-cql/query-api#upsert){ .learn-more}

### Input Validation for Actions { #validation-function  }

[Input validation](../../../guides/providing-services#input-validation) is now performed for action and function parameters. The annotations `@mandatory` as well as `@assert.format`, `@assert.range` and `not null` are evaluated to verify the parameter values:

```cds
type Contact {
    @assert.format: '^\p{Lu}.*' name : String(30);
    @assert.range: [1, 10] priority: Integer;
    address: Address not null;
}
action addContact(contact: Contact not null);
function hasContact(@mandatory name: String) returns Boolean;
```

The validation is applied deeply to nested input data. Note that annotated parameters in your model are effectively validated when updating to this version.
To switch off parameter validation temporarily, set `cds.query.validation.parameters.enabled` to `false`.

### Local Support for Streamlined MTX

You can now run and test your application locally with the [Streamlined MTX](../../../guides/multitenancy/) sidecar (`@sap/cds-mtxs`) and a [file-based SQLite](../../../java/cqn-services/persistence-services#file-based-storage) database in multitenant mode.
In addition to the common [MTX configuration](../../../guides/multitenancy/#enable-multitenancy) you need to set the following configuration in your `application.yaml`:

```yaml
cds:
  multi-tenancy:
    mtxs:
      enabled: true
    sidecar:
      url: http://localhost:4004
```

Then start the sidecar locally (default port 4004) as described [in the multitenancy guide](../../../guides/multitenancy/#test-locally).
[Mock users with tenants](../../../java/security#mock-tenants) can be used to run your tests.
[Local Development and Testing](../../../guides/multitenancy/#test-locally) explains the steps in detail.

### Improvements for PostgreSQL

You can now use the new SQL [dialect `postgres`](../../../java/cqn-services/persistence-services#postgresql) of the CDS Compiler to generate DDL, which is specific for PostgreSQL.
Before this release you had to manually adapt the DDL generated for the dialect `plain`.

```sh
cds deploy --to postgres --dry
```

On [PostgreSQL](../../../java/cqn-services/persistence-services#postgresql-1), localized and temporal data can now be used without restrictions.

### Miscellaneous

- CSV file import now also supports string values that contain escaped characters, delimiter tabs or are quoted with ".

- CloudSDK 4 is now supported. The integration automatically propagates CDS request contexts to CloudSDK's async callables (`ThreadContextExecutorService`).

<div id="secondary-file">releases/archive/2022/sep22.fragment.md</div>


# August 2022


## CAP on Kyma/K8s { #tools}

### Important Changes ❗️ { #changes-in-kyma .important }

#### New Component Minimum Version

The latest version of the [CAP Helm chart](../../../guides/deployment/to-kyma#deploy-to-kyma) (`cds add helm`) introduces new minimum version requirements for the following components:

| Component | Minimum Version |
|-|-|
| `cds` (Java) | 1.27.0 |
| `@sap/hdi-deploy` (SAP HANA Deployer) | 4.4.1 |
| `@sap/html5-app-deployer` ([HTML5 application deployer](../../../guides/deployment/to-kyma#html5-applications)) | 4.1.2 |

#### Don't Use `CDS_ENVIRONMENT_K8S_SERVICEBINDINGS_*` Environment Variables

Make sure that no environment variables starting with `CDS_ENVIRONMENT_K8S_SERVICEBINDINGS_` are in your `chart/values.yaml` file of your Helm chart, as they conflict with the [new service bindings](#cap-java-support-for-servicebinding-io-service-bindings).

These variables were previously added by the `cds add helm:connectivity` command.

### CAP Java Support for `servicebinding.io` Service Bindings

CAP Java now makes use of the new open source [Service Binding Access library](https://github.com/SAP/btp-environment-variable-access) as default source to obtain service bindings. On K8s/Kyma it integrates better with the SAP BTP Service Operator, which uses a [servicebinding.io based format](https://blogs.sap.com/2022/07/12/the-new-way-to-consume-service-bindings-on-kyma-runtime/). This allows reading service bindings with the same set of metadata as in Cloud Foundry, which makes it fully transparent to the CAP application if the service bindings are read in the K8s/Kyma or Cloud Foundry environment.

### Configure Resources for Content Deployment Jobs

You can now configure the Kubernetes resources for [HTML5 application](../../../guides/deployment/to-kyma#html5-applications) and HANA deployment jobs.

The default configuration is added by running `cds add helm`.

### Add Environment Variables for Content Deployment Jobs

[HTML5 application](../../../guides/deployment/to-kyma#html5-applications) and SAP HANA deployment jobs allow adding environment variables.

For example, the following snippet from the Helm chart adds an environment variable `DEBUG` with value `*` to the HTML5 applications deployer job:

```yaml
html5_apps_deployer:
  env:
    DEBUG: '*'
```

### Schema Validation

The Helm chart now contains a JSON schema that `helm` uses to validate the `values.yaml` file. Development tools, such as Visual Studio Code, can use the schema to show validation errors, descriptions and suggestions.

<span id="beforeimprovedvscsupport" />
<Fragment target="#beforeimprovedvscsupport">

## Streamlined Extensibility (for Early Adopters) <Beta /> { #extensibility }

Following the streamlined [multitenancy guide](../../../guides/multitenancy/), there is now a [new guide for extending SaaS apps](../../../guides/extensibility/customization). It features
- Easier setup of extension projects
- Local development roundtrips with SQLite
- More examples for extending CDS models

It is available internally for early adopters.  We are curious about your feedback!

</Fragment>

## Improved VS Code Support for CDS Configuration { #tools-config-schema }

Code completion and validation for the `cds` configuration has been improved in VS Code.  In both `package.json` and `.cdsrc.json`, you get hints on the possible values plus warnings for invalid values based on the installed `@sap/cds` version.  Especially filling out the `cds.requires` section is now much easier.

![A gif showing the code completion for CDS configuration in VS Code.](assets/aug22/json_code_completion.gif)

## CDS Language & Compiler { #cds}

### SAP HANA Regex Functions

CDS natively supports the [SAP HANA Regex functions](https://help.sap.com/docs/HANA_CLOUD_DATABASE/c1d3f60099654ecfb3fe36ac93c121bb/20a24d4b75191014afc5ac3b997d3ce2.html?locale=en-US) `locate_regexpr`, `occurrences_regexpr`, `replace_regexpr`, and `substring_regexpr`:

```cds
entity Foo as select from Bar {
  /* ... */
  substring_regexpr(pattern in name from 5) as sub
};
```

[Learn more about Native Database Functions.](../../../guides/databases#native-db-functions){ .learn-more}

### Actions and Functions in Aspects

Aspects now can have bound actions and functions:

```cds
aspect TravelActions { }
  actions {
    action rejectTravel();
    action acceptTravel();
    function isValid() returns Boolean;
  }
```

Reuse these aspects for example in services:

```cds
service TravelService {
  entity Travel as projection on my.Travel;
  extend Travel with TravelActions;
}
```

[Learn more about Aspects.](../../../cds/cdl#aspects){ .learn-more}

## Java SDK { #cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

#### Minimum Spring Boot Version 2.7.x

- CAP Java SDK now requires Spring Boot version `2.7.x` or later. Most notably the deprecated `WebSecurityConfigurerAdapter` has been migrated to `SecurityFilterChain` in CAP Java. As both can't coexist, custom security configurations in applications **need to be migrated** to `SecurityFilterChain` as well. See an [example](../../../java/security#custom-spring-security-config) in our documentation. In addition, Spring Boot `2.7.x` defaults to H2 version `2.x`, which is not fully compatible with DDL artifacts generated by CDS compiler. If you use H2, make sure to pin your application to H2 version `1.x` as shown in the bookshop [example](https://github.com/SAP-samples/cloud-cap-samples-java/blob/709b095df53d39dc675a78ac7dc930829f04b5d1/pom.xml#L70).
In addition, read the Spring Boot [upgrade instructions](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.7-Release-Notes#upgrading-from-spring-boot-26).

- The deprecated path access via `CdsData::get` has been removed. Instead use `data.getPath("deeply.nested.key")` to access values in deeply nested maps.

### Error Response Handler

Exceptions thrown during event handler processing, are caught by OData V2 and V4 protocol adapters and are turned into corresponding OData error responses. So far, it wasn't possible to change error responses as exceptions were thrown by the framework. Now, you can customize these responses by handling the `ERROR_RESPONSE` event of the [Application Lifecycle Service](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/application/ApplicationLifecycleService.html) emitted by the protocol adapter. You can control the error message text, code and the list of [messages](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/messages/Messages.html) collected during request processing for specific or general error situations.
The following example demonstrates how to change the error text of authorization errors:

```java
@Component
@ServiceName(ApplicationLifecycleService.DEFAULT_NAME)
public class SimpleExceptionHandler implements EventHandler {

  @After
  public void overrideMissingAuthMessage(ErrorResponseEventContext context) {
    if (context.getException().getErrorStatus().equals(CdsErrorStatuses.EVENT_FORBIDDEN)) {
        context.getResult().getMessages().set(0,
            Message.create(Severity.ERROR, "You cannot execute this action"));
    }
  }
}
```

Find the details in our [documentation](../../../java/event-handlers/indicating-errors#errorhandler).

### Messaging via Redis PubSub <Beta />

::: warning
This is a beta feature. Beta features are not part of the officially delivered scope that SAP guarantees for future releases.
:::

There's a new `MessagingService` based on Redis PubSub, which is suitable for asynchronous communication between tightly-coupled microservices.
To configure this messaging service, bind your CAP application to an appropriate platform service, for example of type `redis-cache`, and add the following feature in your _pom.xml_:

```xml
<dependency>
    <groupId>com.sap.cds</groupId>
    <artifactId>cds-feature-redis</artifactId>
</dependency>
```

In the _application.yaml_ you can configure a Redis messaging service explicitly:

```yaml
cds:
  messaging.services:
    my-redis-service:
      kind: redis-pubsub
```

### Enhanced TenantProviderService

The [TenantProviderService](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/mt/TenantProviderService.html) now offers a new `readProviderTenant()` method, which provides the tenant ID of the provider. This method tries to retrieve the information from an existing XSUAA, Identity (IAS) or SaaS Registry service binding.

### Character-based Media Streams

Besides media types based on binary data (`LargeBinary`), CAP Java now also supports character-based media streams (`LargeString`):

```cds
entity Books : cuid {
  title   : String;
  content : LargeString @Core.MediaType: 'text/plain';
}
```

Programmatically you consume `content` in custom handlers using `java.io.Reader`. Refer to the [media type](../../../java/cds-data#mediatypeprocessing) documentation for details.

### Simplified Authentication Configuration

We introduced a new property `cds.security.authentication.mode`, which controls the _authentication_ strategy for CAP endpoints:

- `model-strict` authenticates endpoints based on `@requires/@restrict`. Paths to model elements without annotation are _authenticated_.
- `model-relaxed` authenticates endpoints based on `@requires/@restrict`. Paths to model elements without annotation are _public_.
- `never` disables authentication of _all_ CAP endpoints (use in local development scenario only!).
- `always` authenticates _all_ CAP endpoints.

Mode `model-strict` is set by default. Note that the authentication mode has no impact on the _authorization_ behaviour.

### Miscellaneous

- The generated data [accessor interfaces](../../../java/cds-data#generated-accessor-interfaces) for entities with a single key element now come with a `create` method that takes the key value.

```java
Books book = Books.create(201);
Integer bookId = book.getId(); // 201
```

- The [CqnAnalyzer](../../../java/working-with-cql/query-introspection#cqnanalyzer) now can extract (key) values from  more complex predicates.

- The `cds-services-archetype` now provides the new parameter `inMemoryDatabase` to choose the in-memory database configuration for local testing in the newly created CAP Java project. Supported values are `h2` (default) and `sqlite`.

- Annotations `@Capabilities.Readable` and `@Capabilities.ReadRestrictions.Readable` are now handled.

- Authentication-related settings in section `cds.security` have been moved to new subsection `cds.security.authentication`:
  - `authenticateUnknownEndpoints` is replaced by `authentication.authenticateUnknownEndpoints`.
  - `openMetadataEndpoints` is replaced by `authentication.authenticateMetadataEndpoints` (mind the negation!).
  - `openUnrestrictedEndpoints` and `defaultRestrictionLevel` are subsumed under the new property `authentication.mode`.

  All previous properties are deprecated and can still be used for compatibility.

## Node.js Runtime { #cds-js}

### Important Changes ❗️ { #changes-in-node-js .important }

You can now use `cds.ql` fluent API to query tables not in the model, but in the database.
For example, within `cap/samples/bookshop` this works now:

```js
await SELECT.from('sqlite_master')
await cds.read('sqlite_master')
```

Caveat: the following undocumented usage of unqualified names happened to work in the past.
But this was very fragile and caused lots of issues, and therefore was removed:

```js
await SELECT.from('Books')
await cds.read('Books')
```

Always use qualified names, or reflected definitions instead:

```js
const Books = 'sap.capire.bookshop.Books'
await SELECT.from(Books)
await cds.read(Books)
```

```js
const {Books} = cds.entities ('sap.capire.bookshop')
await SELECT.from(Books)
await cds.read(Books)
```

### Improved REST Adapter

- Aliased parameters in requests like `/submitOrder(ID=@p)?@p=1` are now supported.
- `in` operator in requests like `/Books?$filter=ID in (1,2,3)` are now converted to the correct CQN syntax.

### Improved Consumption of Remote OData V2 Services

- `cds.Time` is now converted to the correct format `PT<hh>H<mm>M<ss>S`.
- The CQN property `search` is now converted into a SAP-specific custom query option:

```js
{
  SELECT: {
    from: [{ ref: ['Books'] }],
    search: [{ val: 'wut' }]
  }
}
```

This query is translated into the URL `/Books?search=wut`.

<div id="secondary-file">releases/archive/2022/aug22.fragment.md</div>

# June 2022


## Important Changes &#10071; {}

### Authentication Enforced in Production { #auth-by-default}

In a productive scenario with an authentication strategy configured, for example XSUAA, _all CAP service endpoints are now authenticated by default regardless of the authorization model_.

In Node.js this can be disabled via feature flag `cds.env.requires.auth.restrict_all_services: false` or by using mock authentication explicitly in production.

[For Java find details below](#security-java).

### Database-Level Constraints & `@assert.target` { #db-constraints}

With general availability of [database-level integrity constraints](../../../guides/databases#database-constraints), service-level integrity checks as provided in the Node.js stack, are now deprecated and planned to be removed with the next major release. In essence, take notice of these changes:
::: tip
**DB-level constraints** are the recommended way to ensure referential integrity. <br>Yet they are **not enabled by default** → do that explicitly by setting `cds.env.features.assert_integrity = 'db'`.
:::

::: warning
**Service-level referential integrity** checks are deprecated from now on, and [**not enabled by default anymore**](#changes-in-node-js). They will likely be removed with next major.
:::

::: warning
**Integrity Checks are not for end users** — Always keep in mind: Referential integrity checks are designed and meant for avoiding corruption of your database's integrity. The error messages that they produce are not suitable for end users of your apps. → [use `@assert.target` for that](#input-validation-for-associations-assert-target).
:::

#### Input Validation for Associations — `@assert.target` {#input-validation-for-associations-assert-target}

To address input validation on references suitable for end users, we introduced new annotation [`@assert.target`](../../../guides/providing-services#assert-target), which ensures, that the target of a managed to-one association exists.

```cds
entity Books {
  ...
  author : Association to Authors @assert.target;
}
```

[Learn more about `@assert.target`](../../../guides/providing-services#assert-target){ .learn-more}

### Improved Read After Write {  #read-after-write }

OData `CREATE` and `UPDATE` requests, as well as draft-related `EDIT` and `SAVE` actions, are now followed by an additional `READ` request to the application service, instead of mixing the handler result with the database state.

##### As a Consequence

+ It's only required to register `READ` handler to adjust the response, for example to handle virtual properties, instead of registering the same handler also for the above mentioned events.
+ A user only sees the full response if authorized.

  <div id="afterasaconsequence" />
<Fragment target="#afterasaconsequence">

+ Modification logs are now followed by corresponding access logs within the audit-log.

</Fragment>

+ If the subsequent `READ` results in an error, the response status is 204 without payload.

##### Formerly

```js
  // Apply a discount for over-stocked books
  this.after ('READ','Books', each  => {
    if (each.stock > 111) each.title += ' -- 20% off'
  })
```

```js
  // We additionally have to do that for responses after write
  this.on (['CREATE','UPDATE'], 'Books', async (_, next) => {
    const book = await next()
    // Results of write operations might be minimized
    if (!book.stock) {
      let {stock} = await SELECT `stock` .from (Books,book.ID)
      book.stock = stock
    }
    if (book.stock > 111) book.title += ' -- 20% off'
    return book
  })
```

##### Now

```js
  // Apply a discount for over-stocked books
  this.after ('READ','Books', each  => {
    if (each.stock > 111) each.title += ' -- 20% off'
  })
```

### SAP Cloud SDK v2 (Node.js)

The usage of the SAP Cloud SDK dependency is now aligned with other dependencies. It is now an optional package that needs to be installed if required, similar to SAP HANA driver.
To have it working as before, make sure to install the required packages as described in section [Mock Remote Service as OData Service (Node.js)](../../../guides/using-services?impl-variant=node#mock-remote-service-as-odata-service-node-js).

### Dropped Support for Node.js v12

Following the plans laid out in the [Release Schedule](../../schedule), please take notice of these changes and transitions:

::: warning
**CAP cds 6 doesn't support Node v12** — Node.js v14.15 is now the minimum required Node.js version. You should better upgrade to Node.js v16 (current Active LTS version).
:::

::: warning
**CAP cds 5 goes into [Maintenance Status](../../schedule#maintenance-status)** — Essentially means that it will receive only emergency fixes from now on → plan to upgrade to cds 6 as soon as possible.
:::

::: danger
**CAP cds 4 reached [End of Life Status](../../schedule#end-of-life-status)** — Essentially means that you urgently should upgrade to cds 6 now, unless your project reached end-of-life as well.
:::

## Highlights

### Feature-Toggled Aspects

[Feature-Toggled Aspects](../../../guides/extensibility/feature-toggles) complement the range of [CAP's extensibility offerings](../../../guides/extensibility/) by one that allows SaaS providers to prepare prebuilt extensions, which can be toggled dynamically at runtime.

![Screenshot showing VS Code with two open feature files, reviews and isbn.](assets/jun22/image-20220628101642511.png)

[Learn more about Features-Toggled Aspects in the Cookbook.](../../../guides/extensibility/){ .learn-more}

### Streamlined MT(X)

We thoroughly redesigned and refactored our MTX Services. The new package `@sap/cds-mtxs` (note the trailing `s`) provides a modular set of standard CAP services, which implement _[multitenancy](../../../guides/multitenancy/)_, _[features toggles](../../../guides/extensibility/feature-toggles)_, and _[extensibility](../../../guides/extensibility/)_ (_'MTX'_ stands for these three functionalities).

![image-20220706115840909](./assets/jun22/image-20220706115840909.png){}

#### Key Benefits

+ **[Test-Drive Locally](../../../guides/multitenancy/#test-locally)** → While the 'old' MTX always required SAP HANA and an SAP BTP setup, you can now run fully MTX-enabled apps locally, with minimal complexity, using SQLite in-memory database, and so on.
+ **[Grow as you go...](../../../guides/multitenancy/mtxs#grow-as-you-go)** → This also allows you to enable MTX only when required, as well as to simplify and speed up your test pipelines significantly; in turn accelerating development.
+ **[MTX = CAP services](../../../guides/multitenancy/mtxs#introduction-overview)** → Being plain standard CAP services allows to benefit from all the flexibility CAP provides, such as [customizing service definitions](../../../guides/multitenancy/mtxs#customization) using CDS Aspects, [adding custom event handlers](../../../guides/multitenancy/mtxs#adding-custom-lifecycle-event-handlers), and so on. You can enhance and adapt MTX to your needs.
+ **Resource Consumption** → The minimized and refactored implementations are the basis for some optimizations already applied, and much more to follow going forward

[Learn more about **Streamlined MTX**.](../../../guides/multitenancy/mtxs){ .learn-more}

#### Limitations → to Come Soon

::: warning
**Extensibility** with streamlined MTX is not finalized and documented, hence not released yet → will follow soon with upcoming releases.
:::
::: warning
**Gaps in documentation** — there are still a few gaps in our documentation that we will fill in on the go, also between releases.
:::

#### Migration from 'Old' MTX

The old MTX is still available through `@sap/cds-mtx` (without suffixed `s`). Means that you don't have to adopt the new, streamlined MTX in a hurry.
::: tip
**Migration to New MTX** is very much straight forward. No content needs to be changed, configurations stay very much the same, only stored extensions need to be migrated, which we plan to support generically. We will document how to [migrate to new MTX](../../../guides/multitenancy/old-mtx-migration) soon.
:::
::: warning
**No need to hurry, yet...** — you should plan to adopt new MTX as soon as possible within the next 12 months, as the old MTX goes into [Maintenance Status](../../schedule#maintenance-status) now (that means, will only receive emergency bug fixes from now on), and will reach [End of Life Status](../../schedule#end-of-life-status) with the next major release.  :::

:::

### Experimental Support for ECMAScript Modules (ESM) { #esm }

You can now write CAP Node.js applications using ECMAScript Modules (ESM).
Let's use, for example, the following handler code:

```js
const cds = require('@sap/cds')
module.exports = function() { ... }
```

This is how you can turn it into an ES module:

```js
import cds from '@sap/cds'
export default function() { ... }
```

[Learn more about ES modules](https://nodejs.org/docs/latest-v16.x/api/esm.html#modules-ecmascript-modules){ .learn-more}

#### Enabling ESM support

The easiest to enable that, is to set type module in your package.json:

```jsonc
  ...
  "type": "module",
  ...
```

[Find more information on this in the Node.js docs](https://nodejs.org/docs/latest-v16.x/api/esm.html#esm_enabling){ .learn-more}

With ESM enabled, CAP will load all your JavaScript files (custom handlers, server.js) and asynchronously using [dynamic imports](https://javascript.info/modules-dynamic-imports).

#### Limitations

Some third party libraries still have issues with ESM modules. For example, [ESM support in Jest v28](https://jestjs.io/docs/28.0/ecmascript-modules) is still experimental, and we encountered lots of issues, so **we currently disable ESM support when running in Jest**.
::: warning
**Note** that this feature is rated **_experimental_** so far.
:::

### Import OpenAPI

The `cds import` command can now import OpenAPI documents into CSN file. It translates all operations into unbound actions and functions on service level.

To import OpenAPI documents, use:

```sh
cds import ~/Downloads/OpenAPI_sample.json
```

> Specify the `--from` option to import from EDMX, OpenAPI sources explicitly.

![](./assets/jun22/OpenAPI-Importer.gif){}

To import OpenAPI documents programmatically, use the [APIs](../../../tools/apis/cds-import#cds-import-from-openapi).

### GraphQL GA

As a first step to a better package structure, the implementation of [the GraphQL protocol adapter](/plugins/#graphql-adapter) has moved to a separate package `@sap/cds-graphql`.
The GraphQL adapter has reached an early general availability state and can be found on the [default _npm_ registry](https://www.npmjs.com/package/@sap/cds-graphql), including instructions on how to get started.

### Shared Locks

Use _shared_ locks in [pessimistic locking](../../../guides/providing-services#select-for-update) to prevent data from concurrent modification without blocking concurrent readers.

In CAP Java use [the `Select.lock()` method](../../../java/working-with-cql/query-execution#pessimistic-locking) to obtain a shared lock:

```java
import static com.sap.cds.ql.cqn.CqnLock.Mode.SHARED;
Select.from("bookshop.Books").byId(17).lock(SHARED);
```

In CAP Node.js use [the `forShareLock` method](../../../node.js/cds-ql#forsharelock):

```js
SELECT.from(Books,17).forShareLock()
```

### CAP on Kyma/K8s

You can now run CAP applications on SAP BTP, Kyma runtime.

You can add a [Helm chart](https://helm.sh/) containing the [Kubernetes deployment files](https://kubernetes.io/docs/reference/kubernetes-api/) to your CAP project with the [`cds add helm` command](../../../guides/deployment/to-kyma#deploy-to-kyma). There is a new guide in the section [Deployment](../../../guides/deployment/) that explains the [deployment to Kyma Runtime](../../../guides/deployment/to-kyma):

![image-20220706123629266](./assets/jun22/image-20220706123629266.png){}

Explore the many opportunities [Kyma](https://kyma-project.io/) and its underlying components, [Kubernetes](https://kubernetes.io/de/) and [Istio](https://istio.io/), gives you. For example, how to [easily secure communication between services](../../../guides/using-services#connect-to-an-application-in-your-kyma-cluster).

For the deployment to SAP BTP, Kyma runtime, CAP supports reading service bindings from volume mounts in Java and in [Node.js](../../../node.js/cds-connect#in-kubernetes-kyma).

[Learn more about the SAP BTP, Kyma Runtime](https://discovery-center.cloud.sap/serviceCatalog/kyma-runtime?region=all){ .learn-more}

### CAP Notebooks in VS Code

Since [November 2021](https://code.visualstudio.com/blogs/2021/11/08/custom-notebooks#_notebook-support-in-vs-code), Notebooks have become part of the core functionality of VS Code. This allows to build VS Code extensions that support custom notebook extensions for _any_ language or purpose, for example, [GitHub Issue Notebook](https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-github-issue-notebooks) or [REST Book](https://marketplace.visualstudio.com/items?itemName=tanhakabir.rest-book).

Thus, we have substituted the formerly known CAP _Jupyter_ Notebooks by the native [VS Code CAP Notebooks](../../../tools/cds-editors#cap-vscode-notebook) within the [CDS Editor](../../../tools/cds-editors). They are thus no longer isolated web views (Jupyter), but can actually interact with the rest of VS Code and any other extension enabling **syntax highlighting, indentation, code completion, and so on**.

Furthermore, we have **extended the number of CAP Notebooks** you can try out. These can be started using the command _CDS: Open CAP Notebooks Page_.

### CAP CDS on github.com

_CAP CDS_ is now a publicly known language on [github.com](https://github.com).

You get syntax highlighting for [_CAP CDS_ files](https://github.com/SAP-samples/cloud-cap-samples/blob/bcb6ffa20f96fc5d075153d9aa29494309053eb3/bookshop/db/schema.cds):
![Screenshot showing Syntax highlighting of CAP CDS files in the GitHub.com UI.](assets/jun22/Github-CDS-Highlighting.png){}

_CAP CDS_ files are considered in language overview statistics:
![The screenshot is explained in the accompanying text.](assets/jun22/Github-CDS-Language-Usage.png){}

<div id="beforecapsamplestreeview" />
<Fragment target="#beforecapsamplestreeview">

GitHub enterprise servers here at SAP will display CDS code in the same way after the next update. <Internal />

</Fragment>

### CAP Samples: Tree View

There is [new sample code](https://github.com/SAP-samples/cloud-cap-samples/pull/365) available that showcases hierarchical data using SAP UI5's `TreeTable`, the `@sap.hierarchy` annotations, OData V2, and the [CDS OData V2 adapter](https://www.npmjs.com/package/@sap/cds-odata-v2-adapter-proxy).

![Screenshot showing hierarchical data in treetable based on Genres.](assets/jun22/cap-samples-hierarchies.png){}

In addition, there is a [new, detailed blog post by Oliver Klemenz](https://blogs.sap.com/2022/07/01/display-of-hierarchical-data-in-sap-fiori-elements-using-sap-cloud-application-programming-model/) on this topic.

<span id="aftercapsamples" />
<Fragment target="#aftercapsamples">

### CAP Community @SAP <Internal />

For quite some time, there's an inner source community around CAP & CDS. The [CAP Community](https://github.wdf.sap.corp/cds-community) has created great contributions and useful modules for a variety of use cases. We've also linked it from our [Resources page](../../../resources/#internal-resources).

- [**CAP Community Link in capire**](../../../resources/#internal-resources) &rarr; Inner Source - CAP Community
- [**CAP Community Landing Page**](https://github.wdf.sap.corp/cds-community)

Here are some great examples of packages contributed by CDS Community:

- [OData V2 Adapter for OData V4 Services](https://github.wdf.sap.corp/cds-community/cds-odata-v2-adapter-proxy)
- [Diagnostic tools for MTX on SAP BTP](https://github.wdf.sap.corp/cds-community/btp-tools-mtx)
- [Cloud Business Application Best Practices for CAP Node.js](https://github.wdf.sap.corp/cds-community/cds-bootstrap)
- [Reusable Content for sap/cds/common](https://github.wdf.sap.corp/cds-community/cds-common-content) (alpha)
::: tip
**Get engaged** and become a part of the CAP & CDS Community!
:::


</Fragment>

## CDS Language & Compiler { #cds}

### Important Changes ❗️ { .important #important-changes-in-compiler}

#### Removed "Compatibility" Options

In the step from Compiler v1 to v2 there had been a few incompatible changes. We had introduced some "compatibility"
options to keep the old behavior for some time to ease the upgrade. These options have now been removed, using them
leads to an error: "Deprecated flag ... has been removed in CDS compiler v3".
If you see this error, you have to adapt your code to the v2 behavior.

[Learn more about Upgrade to Compiler v2.](../../../cds/compiler/v2){ .learn-more}

#### Remove Compiler v1 Options

Early versions of Compiler v1 used different options. Since Compiler v1.24, new options are available.
With Compiler v3, support for old option names was removed.  If you have a `"cdsc"` section in your `.cdsrc.json`
or `package.json`, please ensure that the following options are replaced:

+ `magicVars`: This option was replaced by `variableReplacements`.
+ `toSql` / `toOdata` / `toHana` / `toCdl` / `toCsn`:
  These command specific options were removed. Command specific options are now top-level.
+ `<command>.names`: Use `sqlMapping` instead.
+ `<command>.dialect`: Use `sqlDialect` instead.
+ `toOdata.version`: Use `odataVersion` instead.

Note that options such as `sqlMapping`, `sqlDialect`, as well as `odataVersion` are already set by
`@sap/cds` and `@sap/cds-dk`.  Usually you don't need these options in your `.cdsrc.json` at all.

#### Generated Objects and `@cds.persistence.exists/skip`

We made the behavior of the annotations `cds.persistence.skip` and `cds.persistence.exists` more consistent.

Now, no foreign key constraints on the database are generated for a managed association if the source entity
or the target entity are annotated with `@cds.persistence.skip` or `@cds.persistence.exists`.
With compiler v2, a foreign key constraint was generated even if the target entity is annotated with `@cds.persistence.exists`.

[Learn more about Database Constraints.](../../../guides/databases#database-constraints){ .learn-more}

If an entity with a localized element or a managed composition is annotated with `@cds.persistence.exists` or `@cds.persistence.skip`,
this annotation is now also applied to the generated text or child entities, respectively. Thus, no database tables
are generated for these text or child entities any more. With compiler v2, database tables were generated for the text or child entities.

If a different behavior is wanted, the generated text or child entities can be annotated explicitly with `@cds.persistence.exists/skip: false`.

[Learn more about unfolding text entities.](../../../guides/localized-data#behind-the-scenes){ .learn-more} [Learn more about Managed Compositions.](../../../cds/cdl#managed-compositions){ .learn-more}

_Localized helper views_ are no longer generated for entities annotated with `@cds.persistence.exists`,
so that now the behavior is the same as for `@cds.persistence.skip`.

[Learn more about Localized Helper Views.](../../../guides/localized-data#localized-helper-views){ .learn-more}

### Define Association in a Projection

An unmanaged association can now be defined directly in the select list of a view or projection:

```cds
entity BookReviews as projection on Reviews {
  ...,
  subject as bookID,
  book : Association to Books on book.ID = bookID
};
```

The new association becomes part of the projection signature, but cannot be used in the query itself.
In the ON condition you can, besides target elements, only reference fields of the select list. Elements of the query's data sources are not accessible.
In comparison to mixins, this syntax is simpler and also available in projections.

[Learn more about Defining Associations in a select list.](../../../cds/cql#select-list-associations){ .learn-more}

With this syntax, it's now possible to add new, unmanaged associations to a projection or view in an extension:

```cds
extend BookReviews with columns {
  subject as bookID,
  book : Association to Books on book.ID = bookID
};
```

[Learn more about Extending Views and Projections.](../../../cds/cdl#extend-view){ .learn-more}

### Annotating OData Annotations

Adding a nested annotation to a scalar or array valued OData annotation has been simplified:
add a parallel annotation that has the nested annotation name appended to the outer annotation name:

```cds
@UI.LineItem: [
    {Value: ApplicationName},
    {Value: Description}
]
@UI.LineItem.@UI.Criticality: #Positive
```

Generated EDMX:

```xml
<Annotation Term="UI.LineItem">
  <Collection>...</Collection>
  <Annotation Term="UI.Criticality" EnumMember="UI.CriticalityType/Positive"/>
</Annotation>
```

The old way of annotating a single value or a Collection by turning them into a structure with an artificial property `$value` is still possible, but deprecated.

Overwriting or extending annotated annotations via `annotate` now works as expected.

[Learn more about Annotating Annotations.](../../../advanced/odata#annotating-annotations){ .learn-more}

### Arguments for Simple Custom Types

It is now possible to provide arguments when _using_ a simple custom type.

```cds
type NumericString : String;

entity Address {
  ...,
  zipCode : NumericString(5);
}
```

### Load On Demand

Requiring an API function of the compiler will no longer load the whole compiler, but only the necessary parts.

### Overriding OData Type Mapping

Overriding the OData type mapping with annotation `@odata.Type` can now be done with any EDM type.

```cds
entity Foo {
  ...,
  @odata: { Type: 'Edm.GeometryPolygon', SRID: 0 }
  geoCollection : LargeBinary;
};
```

[Learn more about Overriding OData type mapping.](../../../advanced/odata#override-type-mapping){ .learn-more}

## Node.js { #cds-js}

### Important Changes &#10071; { #changes-in-node-js .important }

::: warning
The following are changes in behavior, which you should take notice of.
:::

+ [No referential integrity checks by default anymore.](#db-constraints)
+ [Non-Singleton `@sap/cds` anymore.](#singleton-cds)
+ [Mandatory Login in Production.](#auth-by-default)
+ [Improved Read after Write &rarr; triggers READ events which weren't there before](#read-after-write).

##### Removed Support for _Unofficial_ APIs

The following APIs were never documented or rolled out and therefore should never be used. As we remove those _unofficial_ APIs, we give you a heads-up in case you used them anyway.

+ Legacy CQN syntax for representation of values for `IN` operator
  + `where: [..., 'IN', { val: [1,2,3] }]` isn't supported anymore &rarr; use:
  + `where: [..., 'IN', { list: [{val:1},{val:2},{val:3}] }]` instead
+ Legacy CQN syntax for aliases within ref:
  + `{ ref: ['column as c'] }` isn't supported anymore &rarr; use:
  + `{ ref: ['column'], as: 'c' }` instead
+ Internal Feature Flags
  + `cds.env.features.implicit_sorting`
  + `cds.env.features.auto_fetch_expand_keys`
  + `cds.env.features.throw_diff_error`
  + `cds.env.features.delay_assert_deep_assoc`
  + `cds.env.features.update_managed_properties`
  + `cds.env.sql.spaced_columns`
  + `cds.env.features.extract_vals`
  + `cds.env.features.resolve_views`
+ Annotations
  + `@odata.contained` &rarr; use `cds.Composition` to use deep payloads instead
  + `@odata.on.insert/update` &rarr; use `cds.on.insert/update` instead
+ Sub-Selects in `@restrict` annotations &rarr; use the [exists predicate](../../../guides/security/authorization#exists-predicate) instead
+ As documented, `req.tenant` is `undefined` instead of `'anonymous'` for single tenant applications

<span id="beforeoptimiziedsearch" />
<Fragment target="#beforeoptimiziedsearch">

### Persistent Outbox Stores Error and Timestamp <Internal />

In case a message can't be emitted, the error and timestamp of the last failing attempt is captured in `cds.outbox.Messages`.

>  In case of problems, this can be disabled by setting `cds.requires.outbox.storeLastError: false`
::: warning
As a consequence of this, the schema of the [`cds.outbox.Messages` entity](../../../node.js/queue#persistent-queue) has changed. Be aware that this requires a database redeployment.
:::

</Fragment>

### Optimized Search on SAP HANA as Default

We now translate `$search` requests into the SAP HANA native `contains` function instead of generic `LIKE` expressions whenever possible. In the previous major version, this was hidden behind the feature flag `cds.features.optimized_search`. It still can be disabled by setting the feature flag to `false`.

### Optimized Server Startup Times

OData transformation and corresponding checks are no longer applied to the whole model, but only to the relevant services.
This reduces server start-up times and avoids OData related error messages for services which are not intended for OData exposure.

### New Rest Adapter as Default

The new REST adapter includes a more powerful request parser, that allows using associations and compositions as well. We already shipped this new implementation before, but hidden behind the feature flag `cds.features.rest_new_adapter`. With cds6, it completely replaces the old implementation.

### Added `<Entity>.data(...)` (experimental)

Linked definitions as obtained from `cds.linked()` models now provide proxy wrappers around raw data that provide canonic structured access to elements as defined in corresponding CDS models.

For example, raw data you get from Fiori clients, or from databases frequently contains flattened elements:

```js
this.on ('UPDATE','Books', req => {
  let {author_ID} = req.data //> author_ID = 111
  // ...
})
this.after ('READ','Books', each => {
  let {author_ID} = each //> author_ID = 111
  // ...
})
```

If you prefer to access these things in their canonical, structured shape you can now do so like this:

```js
let { Books } = this.entities
this.on ('UPDATE','Books', req => {
  let {author} = Books.data(req.data) //> author = {ID:111}
  // ...
})
this.after ('READ','Books', each => {
  let {author} = Books.data(each) //> author = {ID:111}
  // ...
})
```

::: warning
**Note** that this feature is rated **_experimental_** so far.
:::

### Added `cds.context.http`

It's now possible to reliably access the incoming Express.js request and response objects from anywhere within your implementation, if it was initiated by an HTTP request.
For other inbound channels like messaging, `cds.context.http` isn't defined.

```js
const { req, res } = cds.context.http
if (!req.headers.authentication)
  return res.status(403).send('Please login')
```

> Previously, it was required to use `req._.req` or `req.context._.req` depending on the invocation context, which was quite fragile.

### Improved `cds.tx()`

When using the [function block variant of `cds.tx()`](../../../node.js/cds-tx#srv-tx-fn), the new `tx` will be set as global root `tx` for the function body's continuation from now on.
All nested service or database operations will be executed within this transaction automatically. In effect, this works now as intuitively expected:

```js
cds.tx (()=>{
  // following are expected to run within the same transaction
  await INSERT.into (Authors). entries ({...})
  await INSERT.into (Books). entries ({...})
})
```

Before this improvement, this didn't work, but one of these was required:

```js
cds.tx (tx => {
  cds.context = tx // ensure all subsequent cds.db calls are in this tx
  await INSERT.into (Authors). entries ({...})
  await INSERT.into (Books). entries ({...})
})
```

```js
cds.tx (tx => {
  await tx.run( INSERT.into (Authors). entries ({...}) )
  await tx.run( INSERT.into (Books). entries ({...}) )
})
```

### Improved `req.error()`

To ease debugging, this release improves `req.error()` to always turn each recorded error in to an instance of `Error` with own stack trace.

For example:

```js
req.error (`Somethings's wrong with your $data`)
req.error (`Failed to update some related record`)
```

&rarr; These will now be reported with own stack traces, each.

Multiple errors are finally thrown as a wrapping Error object with `.message = 'MULTIPLE_ERRORS'`
and `.details = the array of collected errors.

### Non-Singleton `@sap/cds` {  #singleton-cds}

With this release `@sap/cds` behaves like a regular Node.js module, so that `require('@sap/cds')` returns different objects for  _different_ install locations in the same process.  Previously, `require('@sap/cds')` would return the _same_ object even for different install locations.

While such install scenarios are rather exotic, code might need to be adjusted if you use [`jest.resetModules()`](https://jestjs.io/docs/jest-object#jestresetmodules) to wipe the module cache.  You now really get a new `cds` object:

```js
let cds = require('@sap/cds')
cds.foo = {}
func ()
function func() {
  jest.resetModules()
  cds = require('@sap/cds')
  cds.foo.bar // fails, as cds.foo is not available because `cds` is a fresh object
}
```

The fix is either to cope with the new object or to share the same `cds` variable:

```js
let cds = require('@sap/cds')
cds.foo = {}
func (cds)
function func(cds) {
  jest.resetModules()
  cds.foo.bar // works because cds is passed on
}
```

### Further Changes

+ The `file` option for file-based messaging moved from `credentials` to top level
+ Remote Services now appended original errors as `reason` instead of `innererror`
+ Property `innererror` of OData error responses is now propagated to client
+ Boolean keys are properly parsed into JS boolean values

## Java { #cds-java}

### Important Changes &#10071; { .important #important-changes-in-java}

##### Security by Default { #security-java}

The Spring security (auto-)configuration now authenticates all CAP endpoints that are not explicitly annotated with `@restrict` or `@requires`. Note that `cds.security.openUnrestrictedEndpoints = true` will only open endpoints that are explicitly exposed to `any`. To model open endpoints, you can either adapt your model accordingly or reactivate the former behavior with `cds.security.defaultRestrictionLevel = any`.

##### UUIDs in CSV Import

Values imported from the CSV files for fields having type UUID and annotated with `@odata.Type: 'Edm.String'` are not longer be normalized.

### Feature Toggles Configuration for Mock Users

If mock users are used, a default [FeatureToggleProvider](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/runtime/FeatureTogglesInfoProvider.html) is registered, which assigns feature toggles to users based on the [mock user configuration](../../../java/security#mock-users).

#### Configuration per User

Feature toggles can be configured directly per mock _user_:

```yaml
cds:
  security:
    mock:
      users:
        - name: Bob
          tenant: CrazyCars
          features:
            - wobble
        - name: Alice
          tenant: SmartCars
          features:
            - cruise
            - parking
```

For mock user `Bob` the feature `wobble` is enabled while for `Alice` the features `cruise` and `parking` are enabled.

#### Configuration per Tenant

Alternatively, feature toggles can be configured on mock _tenant_ level:

```yaml
cds:
  security:
    mock:
      users:
        - name: Bob
          tenant: CrazyCars
        - name: Alice
          tenant: SmartCars
      tenants:
        - name CrazyCars
          features:
            - wobble
        - name: SmartCars
          features:
            - cruise
            - parking
```

For the mock tenant `CrazyCars` the feature `wobble` is enabled while for tenant `SmartCars` the features `cruise` and `parking` are enabled.

### Create Active Version of Draft-Enabled Entity

OData V2 now also supports [directly creating active versions](../../../java/fiori-drafts#bypassing-draft-flow) of draft-enabled entities through POST by passing `{"IsActiveEntity": true}` in the payload. In OData V4 this was already possible.

### Protocol Configuration

Use the new annotation `@protocol` as alias for `@protocols` to [configure](../../../java/cqn-services/application-services#configure-path-and-protocol) by which protocol a service is served. Both annotations allow single and arrayed values. You can use `@protocol: 'none'` to completely disable serving a service.

### Auto-Build

The `cds-maven-plugin` is enhanced with new goal `auto-build`, which eases use of Spring Developer Tools. Once started, it reacts to changes in the CDS model and starts CDS builds automatically. In contrast to the `watch` goal it does not start the Java application and hence is suitable to enable development with IDEs.

## Tools { #tools}

### Important Changes ❗️ { #changes-in-tools .important }

+ Note the [changes in the `cds build` area](#changes-to-cds-build) as they may affect the behaviour of your application in production environment

+ `cds deploy --to hana` now stores connection information _without_ credentials.<br>
  This is the same behavior as [cds bind](../../../advanced/hybrid-testing) and replaces the unsafe local _default-env.json_ file which contained credentials in clear text. If you still need the old behavior, you can add the option `--store-credentials`.

### New CDS Lint Rules for Authorization

A series of new lint rules (with names `auth-*`) has been added to ensure that restrictions on CDS models enforce proper access control. Any models containing the `@restrict` / `@requires` annotations are now checked to catch empty restrictions, misspelled privileges, redundant events, and so on.

### Changes to `cds build`

#### Improved Initial Data Handling for SAP HANA Deployments

CSV files containing initial data are now found in _reuse modules_ as well, which is the same bahavior as with SQLite.  More specifically, they can be located in any _csv_ or _data_ subfolder, including _db/data_ and _db/csv_, for which a CDS model file of your application exists. Previously, csv files would need to be manually copied from the reuse module into the application's deployment folder.

Use the following option to return to the former behaviour:

```json
{ "for": "hana", "options": { "csvFileDetection": false } }
```

[Learn more about providing initial data.](../../../guides/databases#providing-initial-data){ .learn-more}

#### More Configuration Files Available in Production

The files _.cdsrc.json_, _.npmrc_ located in _root_, _srv_ or _db_ folders of your project are now copied into the deployment folder (usually _gen/srv_, _gen/db_) by default. Files including _package.json_, _package-lock.json_ located in the _srv_ folder have precedence over the corresponding files located in the project root directory.
As these files are used in production environment, make sure that the folders do not contain one of these files by mistake. Consider using profiles `development` or `production` in order to distinguish environments. CDS configuration that should be kept locally can be defined in a file _.cdsrc-private.json_.

For security reasons the files _default-env.json_ and _.env_ are no longer copied into the deployment folder.

The contents of the _node_modules_ folder is no longer copied into the deployment folder.

[Learn more about cds build configuration](../../../guides/deployment/custom-builds#build-config){ .learn-more}

#### New CDS Build Task Aliases

The new build task names `nodejs` and `java` should be used instead of the deprecated aliases `node-cf` and `java-cf`, which are still supported for compatibility reasons.

#### Cloud Foundry Manifest Files No Longer Auto-Generated

Manifest files for the _srv_ and _db_ modules are no longer created as default by `cds build`. If you prefer `cf push`-based deployment in contrast to MTA-based deployment, you can create _manifest.yml_ and _services-manifest.yml_ using the command `cds add cf-manifest`.  Add them to your Git repo as regular source files.

[Learn more about Cloud Foundry native deployment.](../../../guides/deployment/to-cf){ .learn-more}

[Learn more about MTA deployment.](../../../guides/deployment/to-cf#add-mta-yaml){ .learn-more}

<div id="secondary-file">releases/archive/2022/jun22.fragment.md</div>


# March 2022


## Database Integrity Constraints

CDS can now automatically generate native database referential integrity constraints for managed to-one Associations and Compositions:

```cds
entity Books {
  ...
  author : Association to Authors;
}
entity Authors {
  key ID : Integer;
  ...
}
```

Association `author` triggers the generation of a constraint:

```sql
CONSTRAINT Books_author ON Books
  FOREIGN KEY(author_ID) REFERENCES Authors(ID)
  ON UPDATE RESTRICT
  ON DELETE RESTRICT
  VALIDATED
  ENFORCED
  INITIALLY DEFERRED
```

Database constraints are available for SQL dialects `hana` and `sqlite`.

Switch them on with the configuration `cds.env.features.assert_integrity`
that can have the values:

- `'db'`: Database constraints
- `'app'`: Runtime checks (default, only effective in Node.js runtime)
- `false`: No database constraints and no runtime checks

The Node.js runtime features integrity checks in the application. We intend to replace
these rather expensive checks in the application by database constraints with the next
major release in 2022. For the migration period until then you can choose what kind of
integrity checks are performed.

Generation of database constraints is of course also possible on the CAP Java stack,
where no runtime checks are available.

[Learn more about Database Constraints.](../../../guides/databases#database-constraints){ .learn-more}

## Native Database Clauses

Using the annotations `@sql.prepend` and `@sql.append`, you can add arbitrary SQL snippets to the
DDL statements that are generated by the compiler. This allows you to use database features that
are not natively supported by CDS.

Model:

```cds
@sql.append: ```sql
             GROUP TYPE foo
             GROUP SUBTYPE bar
             ```
entity E {
  ...,
  @sql.append: 'FUZZY SEARCH INDEX ON'
  text: String(100);
}
```

Result:

```sql
create table E (
  ...,
  text nvarchar(100) FUZZY SEARCH INDEX ON
) GROUP TYPE foo
GROUP SUBTYPE bar
```

If you use native database clauses in entities where schema evolution has been enabled using annotation `@cds.persistence.journal`, see [Schema Evolution Support of Native Database Clauses](../../../guides/databases-hana#schema-evolution-native-db-clauses).

::: warning _❗ Warning_ 
The compiler doesn't check or process the provided SQL snippets in any way. You are responsible to ensure that the resulting statement is valid and doesn't negatively impact your database or your application. We don't provide support for problems caused by using this feature.
:::

[Learn more about Native Database Clauses.](../../../guides/databases-hana#schema-evolution-native-db-clauses){ .learn-more}

## Native HANA Functions with non-standard syntax

CDS now supports SAP HANA aggregate functions with an additional `order by` clause in the argument list, like:

```sql
first_value(name order by price desc)
```

[Learn more about Native SAP HANA Functions.](../../../guides/databases#native-db-functions){ .learn-more}

## CDS Language { #cds}

### Simplified Syntax for Extending or Annotating Elements

Until now, for annotating or extending elements of an entity, you had to "repeat" the relevant part of the entity definition:

```cds
annotate Foo with {
  nestedStructField {
    existingField @title:'Nested Field';
  }
}

extend Foo with {
  extend nestedStructField {
    newField : String;
  }
}
```

This is a bit cumbersome if you only want to annotate or extend single elements.
You can **now directly address the element** you want to annotate or extend:

```cds
annotate Foo:nestedStructField.existingField with @title:'Nested Field';

extend Foo:nestedStructField with { newField : String; }
```

[Learn more about **annotate**.](../../../cds/cdl#annotate){ .learn-more} [Learn more about **extend**.](../../../cds/cdl#extend){ .learn-more}

### Default in Type Definitions

A default value can now be specified also in scalar custom type definitions:

```cds
type CreatedAt : Timestamp default $now;
```

[Learn more about Defaults.](../../../cds/cdl#default-values){ .learn-more}

## Node.js SDK { #cds-js}

### Important Changes ❗️ { #changes-in-node-js .important }

- **Fixed:** Keys of an entity were always fetched in addition. This does not happen anymore.
  Example:

  ```js
  let { CatalogService } = cds.services
  let books = await CatalogService.read('title').from('Books')
  ```

  &rarr; formerly this returned:

  ```js
  books = [{ ID:201, title:'Wuthering Heights' }, ...]
  ```

  &rarr; now it is:

  ```js
  books = [{ title:'Wuthering Heights' }, ...]
  ```

  If you need the keys in the result, make sure you request them explicitly in the query as well.

### Driver-Agnostic Results for Stored Procedures

We added a driver-agnostic way for SAP HANA procedure calls with table output data.

Example:

```js
// P1 -> table output, P2 -> primitive output, P3 -> input
> await cds.run(' CALL PROC(P1 => ?,P2 => ?,P3 => ?)', 42)
{
  P1: [...]
  P2: 4711
}
```

## Java SDK { #cds-java}

### Important Changes ❗️ { #important-changes-in-java .important }

Elements with type `UUID` that are annotated with `@odata.Type:'Edm.String'` are not normalized anymore. The comparison is case sensitive and arbitrary values can be stored ([example](#additional-values-for-managed-data)).

### Relaxed Deep Insert/Update

If the data of deep Insert or deep Update contains values of an associated entity but the (forward mapped) association does not cascade the Insert/Update operation, only the association itself is updated, but not the values of the associated entity.

Assumed you have the following model:

```cds
entity Orders {
  key id : UUID;
  book : Association to Books; // not cascading
}

entity Books {
  key id : Integer;
  title : String;
}
```

In addition, you run this code:

```java
Map<String, Object> order = Map.of("book",
    Map.of("id", 17, "title", "Capricorn"));
CqnInsert insert = Insert.into("Orders").entry(order);
db.run(insert);
```

This creates a new order and associates this order to the book with `id` 17. But it doesn't create the book.

### Collectors for AND and OR

New methods `CQL.withAnd()` and `CQL.withOr()` allow to use a `Collector` to connect a stream of CQN predicates with `AND` or `OR`:

```java
List<Map<String, Object>> values = ...
Stream<CqnPredicate> predicates = values.stream().map(CQL.matching);
CqnPredicate filter = predicates.collect(CQL.withOr());
```

[Learn more about Connecting Streams of Predicates](../../../java/working-with-cql/query-api#connecting-streams-of-predicates)

### Additional Values for Managed Data

The annotations `@cds.on.insert` and `@cds.on.update` now support additional values. The special references `$user.locale` and `$user.tenant` allow to automatically set respective tenant or locale from the user info.

The value `$uuid` can be used to automatically set a generated UUID value.

The following snippets are equivalent:

```cds
entity Orders {
  @cds.on.insert : '$uuid'
  id : String;
}
```

```cds
entity Orders {
  @odata.Type : 'Edm.String'
  id : UUID;
}
```

### Security & Compliance

<span id="beforedefaultmockuser" />

#### Default Mock Users to Ease Testing

In case mock user security configuration is active, default mock users reflecting [pseudo roles](../../../guides/security/authorization#pseudo-roles) are available by default now. They are named `authenticated`, `system`, and `privileged` and can be used with an empty password. For instance, requests sent during a Spring MVC unit test with annotation `@WithMockUser("authenticated")` will pass authorization checks that require `authenticated-user`.

[Learn more mock user authentication.](../../../java/security#mock-users){ .learn-more}

#### Improved Propagation of Authentication Information

The [AuthenticationInfo](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/authentication/AuthenticationInfo.html) (for example, storing a JWT) can now be accessed from the [RequestContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/request/RequestContext.html) and [EventContext](https://www.javadoc.io/doc/com.sap.cds/cds-services-api/latest/com/sap/cds/services/EventContext.html) and is provided as a Spring bean:

```java
@Autowired AuthenticationInfo authInfo;
...
JwtTokenAuthenticationInfo jwtTokenInfo = authInfo.as(JwtTokenAuthenticationInfo.class);
String jwtToken = jwtTokenInfo.getToken();
```

It is also propagated to child threads when propagating the `RequestContext`.

[Learn more in Reading Request Contexts.](../../../java/event-handlers/request-contexts#reading-requestcontext){ .learn-more}

#### Fine-Grained Control of Outbox Usage

Added properties `cds.auditlog.outbox` and `cds.messaging.services.<key>.outbox` that control the usage of the Outbox for Auditlog/Messaging events.

[Learn more about CDS Properties.](../../../java/developing-applications/properties){ .learn-more}

### Misc

- `@Core.ContentID` is now present on OData V4 error responses. For batch requests this allows to relate the error messages of an OData change set to the individual request that causes the error.

- When using SAP HANA Cloud, you can now enable a shared connection pool using property `cds.multiTenancy.dataSource.combinePools.enabled` without having to specify all database instances using property `cds.multiTenancy.dataSource.hanaDatabaseIds`.

- Added integration with Cloud SDK's RequestHeaderFacade ensuring HTTP headers are propagated to Cloud SDK.

- The goal install-cdsdk of the cds-maven-plugin provides the new parameter `arguments` to pass additional arguments to the command line.

## Preview on Save in VS Code { #preview-on-save}

The preview for a _.cds_ file is now automatically refreshed each time you save the corresponding _.cds_ file.

> You can disable this behavior with setting `Cds > Preview: Refresh On Save`.

## Simplified Deploy Guides { #deploy-guides}

We have reworked and simplified the [Deploy and Operate](../../../guides/deployment/) guides.  Most notably,  the [Deploy to Cloud Foundry](../../../guides/deployment/to-cf) and [Multitenancy](../../../guides/multitenancy/) cookbooks are much simpler to execute, as they make use of the [project facets](#cds-add-improved)
below.

## Improved `cds add <facets>` { #cds-add-improved}

We've enhanced the CAP project facets to ease application setup for various configurations and deployment scenarios:

- `cds add xsuaa` prepares for JWT authentication via XSUAA.
- `cds add mtx` configures your application for SaaS deployments.
- `cds add approuter` allows for serving your application's UI using [SAP App Router](https://www.npmjs.com/package/@sap/approuter).
- `cds add kibana-logging` sets up your application for the BTP logging service and the Kibana dashboard.
- `cds add mta` creates the _mta.yaml_ deployment descriptor as before, but in addition, the other templates update _mta.yaml_ if needed.

The `--for <profile>` parameter allows to specify the [Node.js configuration profile](../../../node.js/cds-env#profiles).  For example, `cds add mtx --for production` only adds multitenancy configuration to the `[production]` profile.

Take a look at the revised [deploy guides](../../../guides/deployment/) to see the facets in context.

## Names Check in `cds lint` { #check-reserved-names}

A [new lint rule](/tools/cds-lint/rules/no-dollar-prefixed-names) warns about entities and elements that start with `$`.<br>
Such names may conflict with reserved variables that also start with `$` (like `$self`).

[Learn more about CDS Lint.](../../../tools/cds-lint/){ .learn-more}

## Security in Multitenancy { #mtx}

Tokens downloaded to the command line client are now reduced in scope.
That means, they only contain those scopes necessary for client operation.
This follows the principle of least privileges and aims to reduce the risk of token misuse.

The optional `ExtendCDSdelete` scope is not part of the token unless the user is assigned that scope.
If the `ExtendCDSdelete` scope is not assigned when activating a new extension, requests to delete a previous version of an extension are rejected.

If the user's privileges change, for example, by assigning the `ExtendCDSdelete` scope via a role collection,
the user has to run `cds logout` and then `cds login`. This fetches a token containing the extended set of scopes.

<div id="secondary-file">releases/archive/2022/mar22.fragment.md</div>

# February 2022


## Capire Docs & Samples { #capire-samples}

### Keyboard Shortcuts in Capire { #shortcuts}

We now provide an overview of the available keyboard shortcuts in capire. Just try it out and hit <kbd>?</kbd> to see this list:

![SScreenshot from the available shortcuts in capire, invoked using ?](assets/feb22/capire-shortcuts-external.png){}

<div id="aftershortcuts" />
<Fragment target="#aftershortcuts"> <Internal />

::: info Shortcuts for the internal CAPire
![Screenshot from the available shortcuts in capire, invoked using ?](assets/feb22/capire-shortcuts-internal.png){}
:::

</Fragment>

### Revised Cookbook - Deploy & Operate

This cookbook is based on the deployment guide that was previously found in the _Advanced_ section of capire. We revised it and promoted the [guide to a cookbook](../../../guides/deployment/).

Assuming you have developed your application, it's tested and running, and ready for deployment. Before you start to automate, you want to do the necessary preparation and deploy ad-hoc, to see if everything works as before. This guide helps you.

![A screenshot of the cookbook in capire.](assets/feb22/deploy-guide.png){}

## Data Browser Sample { #data-browser}

We have added a simple generic data browser to the sample suite for Node.js, useful for troubleshooting purposes during application development:

![This screenshot is explained in the accompanying text.](assets/feb22/data-viewer.png){}

You can browse entities from all connected services of the application. Data is either fetched directly from the database or through the application's CDS services, which then includes projections, validations and so on.

The [sample code](https://github.com/SAP-samples/cloud-cap-samples/pull/310/files) also demonstrates the following:

- How to write a generic CAP service (see the _data-viewer_ package).
- How to include such a service and its UI in another application (the _bookstore_ app).

> Note that this code is meant for demonstration purposes and should not be used in production. Copy the code into your application as needed.

<span id="beforekux" />
<Fragment target="#beforekux">

## Migrate from Instance Manager to Service Manager <Internal />

It's now possible to switch from the `managed-hana` service to the `service-manager` service without (much) downtime. The switch requires only one redeployment of the application to prepare the migration. You need the latest versions of the modules `@sap/cds`, `@sap/cds-mtx`, and `@sap/instance-manager`.

See [Instance Manager wiki page](https://wiki.one.int.sap/wiki/pages/viewpage.action?pageId=2762460221) for more details.

</Fragment>

## Key-User Extensions with SAPUI5 Flexibility

We added a first **experimental** support for simple field extensibility in CAP.

::: warning ❗ _Warning_ 
This is only disclosed for testing purposes and for gathering feedback.
:::

Current limitations:

- Only works locally using `cds watch`
- Needs to be deployed to a **file-based** SQLite database
- Only available for the Node.js runtime

This is a first step to enable extensibility in CAP applications without depending on an MTX/HDI based deployment and an SAP HANA database.

## Multiline String Literals

Multiline string literals enclosed in single or triple backticks provide a convenient
way of writing long text snippets, for example in annotation values.
In addition, they support escape sequences. The variant with triple backticks
performs indentation stripping and allows tagging.

```cds
annotate Customer with @Cache.UpdateHandler:
{
  XMLHttpRequest : `PUT /patients`,
  XMLRequestBody : ```xml
                    <patient id="\${entity.PatientID}">
                        <name>\${entity.Name}</name>
                        <state>\u{1f197}</state>
                        <address>\${entity.Address}</address>
                        <dateOfBirth>\${entity.DOB}</dateOfBirth>
                    <patient>
                   ```
}
```

[Learn more about Multiline Literals.](../../../cds/cdl#multiline-literals){ .learn-more}

## Native Database Clauses <Beta />

Activate this feature in _.cdsrc.json_:

```JSON
"cdsc": {
  "beta": { "sqlSnippets": true }
}
```

Using the annotations `@sql.prepend` and `@sql.append`, you can add arbitrary SQL snippets to the
DDL statements that are generated by the compiler. This allows to use database features that
are not natively supported by CDS.

Model:

```cds
@sql.append: ```sql
             GROUP TYPE foo
             GROUP SUBTYPE bar
             ```
entity E {
  ...,
  @sql.append: 'FUZZY SEARCH INDEX ON'
  text: String(100);
}
```

Result:

```sql
create table E (
  ...,
  text nvarchar(100) FUZZY SEARCH INDEX ON
) GROUP TYPE foo
GROUP SUBTYPE bar
```

::: warning _❗ Warning_ 
The compiler doesn't check or process the provided SQL snippets in any way. You are responsible to ensure that the resulting statement is valid and doesn't negatively impact your database or your application. We don't provide support for problems caused by using this feature.
:::

[Learn more about Native Database Clauses.](../../../guides/databases-hana#schema-evolution-native-db-clauses){ .learn-more}

## Extend Array-Like Annotation Values - Insert

In addition to adding new entries at the beginning and at the end of an array-like annotation value,
you can now insert them at arbitrary positions. Provide a _comparator_ object to identify the entry
after which to insert.

For displaying the day of week after the respective fields for `BeginDate` and `EndDate`:

```cds
@UI.LineItem : [
    { Value : TravelID    },
    { Value : BeginDate   },
    { Value : EndDate     },
    { Value : TotalPrice  },
    { Value : Description }
  ]
entity TravelService.Travel { /* elements */ }
```

use the new `... up to` syntax:

```cds
annotate TravelService.Travel with @UI.LineItem: [
  ... up to { Value : BeginDate },
  { Value : BeginWeekday },  // inserted after BeginDate
  ... up to { Value : EndDate },
  { Value : EndWeekday },    // inserted after EndDate
  ...                        // remaining array values
];
```

[Learn more about `... up to`.](../../../cds/cdl#extend-array-annotations){ .learn-more}

## Node.js Runtime { #cds-js}

### Important Changes ❗️ { #changes-in-node-js .important }

- Draft entities can only be updated by the user that created the draft. From this release on, this rule includes bound actions and functions. See [Restrictions and Draft Mode](../../../guides/security/authorization#restrictions-and-draft-mode) for more details.
- In OData, binary data (whether as payload or part of query options) is consistently passed into the service as Base64 encoded strings.

### New Hook `req.before('commit')`

The new hook [req.before('commit')](../../../node.js/events#eve-before-commit) allows you to perform some final actions, such as validity checks, bookkeeping, and so on, before the respective transaction is committed. Throwing an error vetoes the commit.

Example:

```js
srv.before('CREATE', Order, function(req) {
  req.before('commit', async function() {
    const { creditscore } = await SELECT.one.from(Customers)
      .where({ ID: req.data.customer_ID })
    if (creditscore < 42) throw new Error("We shouldn't make this sale")
  })
})
```

### Media Data

The new OData annotation `@Core.ContentDisposition.Type` is now supported, with `attachment` as the default value.

Further, we added beta support for returning custom stream objects in custom handlers as described in [Custom Streaming](../../../node.js/best-practices#custom-streaming-beta).

## Java SDK { #cds-java}



### Synchronous In-Memory Messaging to Ease Testing

The new in-memory `MessagingService` can be easily consumed in [local testing scenarios](../../../java/messaging#local-testing) or JUnit tests. To create such a messaging service, choose  `local-messaging` as kind:

```yaml
cds:
  messaging.services:
  - name: "messaging"
    kind: "local-messaging"
```

The `MessagingService` provides the common messaging service API, but the event publishing is _synchronous_ to the event listeners. This frees test code from having to wait on the asynchronous execution of the listeners.

### Instance-Based Authorization with `IN` Predicates

`IN` predicates with user attributes are now supported in [instance-based authorization](../../../guides/security/authorization#instance-based-auth) conditions, for example, `country in $user.countries`. Logically, it has the same effect as the `=`-operator in predicates (for example: `country = $user.countries`), but the `$user`-attribute value (list) needs to be a right operand.

### Exclude Sensitive Data from Logging

Potentially, sensitive values are now excluded from CQN statements in application logging _by default_. To enable logging of sensitive values again you can set `cds.security.logPotentiallySensitive` to `true`.

### Analyze a CQN Expression Tree

Use a [CqnVisitor](../../../java/working-with-cql/query-introspection#cqnvisitor) for in-depth analysis of a CQN expression tree. Use cases:

- Transformation of CQN to some different query language
- In-memory evaluation of CQN
- Overcome limitations of the `CqnAnalyzer`

### ORDER BY ... NULLS FIRST | LAST

You may now specify if `null` values are to appear _first_ or _last_ in a sorted result of a read query. The following query sorts the authors by year of death with the live authors appearing last:

```java
Select.from(AUTHOR).orderyBy(a -> a.yearOfDeath().ascNullsLast());
```

### Misc

- The audit logging implementation now handles `@PersonalData.EntitySemantics: 'Other'` as defined in [Audit Logging](../../../guides/data-privacy/audit-logging).

- The OData V2 adapter now handles `@Aggregation.default: #COUNT`.

- To support deferred foreign key constraints in SQLite during the CSV data import, all CSV files can be imported in an atomic [change set](../../../java/event-handlers/changeset-contexts). This behavior can be enabled by setting the new property `cds.dataSource.csvSingleChangeset` to `true`.

- You may now write through a projection with calculated fields. The calculated fields will be [silently ignored](../../../guides/providing-services#readonly).

## Command Line Client for CDS Code Formatter <Beta /> { #cds-dk }

Up to now the CDS code formatter was only accessible in an IDE that uses the CDS language server, for example,
VS Code with the [SAP CDS Language Support](https://marketplace.visualstudio.com/items?itemName=SAPSE.vscode-cds)
extension.

The CDS code formatter now provides a command line interface. This is especially helpful to guarantee a consistent
formatting, for example, as a pre-commit hook or within your CI/CD pipeline.

[Learn how to use the code formatter CLI.](../../../tools/cds-editors#cds-formatter){ .learn-more}

## CDS Editor

### Workspace Symbols Query Supports Filters for Artifact Kinds

_Workspace Symbols_ can now be filtered by kinds, for example: `entity:...` or `service:...`.
The kind can be shortened, for example, `s:...` for _services_. A shortcut kind may match multiple kinds: `e:...`
matches _entities_, _enums_, and _elements_.

![Screenshot of workspace wymbols with filtering by kind in VS Code.](assets/feb22/ws_symbols_with_kinds.png){}

### Performance and Memory Improvements

The CDS language server is now bundled and minified to further reduce startup time.
The caching of indexes was optimized to reduce memory.

### Improved Code Completion

Code completion for _index.cds_ files now renders just the folder when selected.

## Archived Changelogs 2021

When you're looking for our changelog, you'll notice that we "archived" already our changelog for the past year. You can still search, navigate and find it. But we rearranged the content to keep the most recent content at the top.

<div id="secondary-file">releases/archive/2022/feb22.fragment.md</div>


# All of 2021



<br>
<IndexList :pages='pages' />


# December 2021


## Exists Predicates in CQL

This release adds thorough support for `exists` predicates with path expressions, to CDS compiler, as well as Node.js and Java runtimes. Exists path predicates allow to express complex relationships while hiding the complexity of nested subselects. For example:

```sql
SELECT FROM Authors WHERE exists books.pages[wordcount > 1000]
```

[Learn more about the Exists Predicates in CQL.](../../../cds/cql#exists-predicate){ .learn-more}

Exists predicates can also be nested. The previous example is equivalent to:

```sql
SELECT FROM Authors WHERE exists books [
  where exists pages [
    where wordcount > 1000
  ]
]
```

::: warning
Paths *inside* infix filters aren't yet supported.
:::

### Support in CDS Compiler

The CDS compiler translates this into plain SQL like that:

```sql
SELECT FROM sap_capire_bookshop_Authors a
WHERE EXISTS (
  SELECT 1 from sap_capire_bookshop_Books b
  WHERE b.author_ID = a.ID and EXISTS (
    SELECT 1 from sap_capire_bookshop_BookPages p
    WHERE p.book_ID = b.ID
  )
)
```

### Support in Runtimes

The `EXISTS` predicate is also supported by the CAP Node.js and CAP Java runtimes. In CAP Java `EXISTS` is expressed by the [`anyMatch` predicate](../../../java/working-with-cql/query-api#any-match).
In an OData request a [Lambda Operator](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31361024) is used.

### Instance-based Authorization

The `EXISTS` predicate is especially useful when enforcing instance-based access control:

```cds
@restrict: [{ grant: 'READ',
  where: 'exists teams.members [userId = $user and role = `Editor`]'
}]
entity Projects {
  // ...
  teams : Association to many Teams;
}

```

[Learn more about Exists Predicate in the Authorization guide.](../../../guides/security/authorization#exists-predicate){ .learn-more}

In the example, only those users may read projects' data, which are associated members with role *Editor*.

## Persistent Outbox <Beta /> {#persistent-outbox-beta}

The persistent outbox combines asynchronism with resilience. It allows to defer the emit of messages until the success of the current transaction, to avoid that recipients falsely receive messages in case of a rollback.

![Outbox (simplified)](assets/dec21/outbox_simplified.png){}

In addition, the persistent outbox safely stores the messages in the used persistence, so that they are not lost in case an application crashes. The deferred emits will then be done asynchronously. In case the emit is currently not possible, for example because of a temporary unavailability of the targeted service, it will be retried with an exponentially growing waiting time.

Currently, the persistent outbox can be enabled to be used with messaging and audit logging services.

See [Java - Persistent Outbox](../../../java/outbox#persistent) or [Node.js - Persistent Outbox](../../../node.js/queue#persistent-queue) for more details.

## Resilient Audit Logging via Outbox <Beta /> {#persistent-outbox}

The out-of-the-box audit logging makes use of the new persistent outbox, if enabled.
See [Persistent Outbox](#persistent-outbox) for more details.
That is, logs that shall be sent to the audit log sink are first written into the persistent outbox, which is transactionally safe, and only sent to the audit log sink once the original transaction was committed.
This ensures that there are no "ghost" logs (for example, modifications that eventually were not committed) or lost logs (for example, modifications that were committed but not logged because there was an issue in between).

## Declarative Audit Logging in Java

Audit logs of type "Personal data access" and "Personal data modification" are now automatically created in case the model is annotated with `@PersonalData` and `@AuditLog` as described in section [Audit Logging](../../../guides/data-privacy/audit-logging):

```cds
annotate Authors with
@PersonalData : { EntitySemantics : 'DataSubject'}
@AuditLog.Operation : { Read : true, Update : true }
{
  ID @PersonalData.FieldSemantics : 'DataSubjectID';
  name @PersonalData.IsPotentiallyPersonal;
}
```

In the example, modifying the field `Authors.name` generates a log event of type `DataModificationLog`.

For more information, see the respective section for [Java](../../../java/auditlog).

<div id="beforedatabaseconstraints" />
<Fragment target="#beforedatabaseconstraints">

::: info Internal Information <Internal />
For Node.js see [here](../../../guides/data-privacy/audit-logging).
:::
</Fragment>

## Database Constraints <Beta />

CDS can now automatically generate database constraints for managed to-one Associations and Compositions:

```cds
entity Books {
  ...
  author : Association to Authors;
}
entity Authors {
  key ID : Integer;
  ...
}
```

Association `author` triggers the generation of a constraint:

```sql
CONSTRAINT Books_author ON Books
  FOREIGN KEY(author_ID) REFERENCES Authors(ID)
  ON UPDATE RESTRICT
  ON DELETE RESTRICT
  VALIDATED
  ENFORCED
  INITIALLY DEFERRED
```

Database constraints are available for SQL dialects `hana` and `sqlite`.

Switch them on with the configuration `cds.env.features.assert_integrity`
that can have the values

- `'db'`: Database constraints
- `'app'`: Runtime checks (default, only effective in Node.js runtime)
- `false`: No database constraints and no runtime checks

The Node.js runtime features integrity checks in the application. We intend to replace
these rather expensive checks in the application by database constraints with the next
major release in 2022. For the migration period until then you can choose what kind of
integrity checks are performed.

Generation of database constraints is of course also possible on the CAP Java stack,
where no runtime checks are available.

[Learn more about Database Constraints.](../../../guides/databases#database-constraints){ .learn-more}

## SQL Window Functions

CQL now supports the syntax for SQL window functions:

```sql
select from Foo {
  ...,
  sum(x) over (partition by a order by b
                 rows between unbounded preceding and current row) as s
}
```

No semantic checks are performed for the window functions, they are simply translated to SQL.
Consult the documentation of your database for more information about the supported window functions.

[Learn more about representing SQL window functions in CXN.](../../../cds/cxn#function-calls){ .learn-more}

## GraphQL Schema Using CLI (experimental)

The GraphQL schema used in the experimental GraphQL Adapter can be generated stand-alone via `cds compile -2 gql`.

## Node.js Runtime { #cds-js}

### Important Changes ❗️ { #changes-in-node-js .important }

From this release on, debug logs of `cds.DatabaseService` and `cds.RemoteService` have sanitized values in production.
The sanitization can be deactivated:

```js
cds.env.log.sanitize_values = false
```

::: tip
In production, it's strongly recommended to use log level `info` or higher.
:::

### Generic Providers

The media type of a stream property is now updated based on the content type header of the `PUT .../<stream property>` request.
With this, only one request is needed to update both, the media data and the media type.

Further, the Node.js runtime now supports filtering based on the count of records in a collection.
For example, you can get all hard-working authors via `GET /Author?$filter=books/$count gt 10`.

### Developer Experience

For the December release, we added some improvements with regard to developer experience.

- Typically, running with mocks in production isn't sensible and, hence, the command line option `--with-mocks` was ignored.
However, there may be some scenarios during development that would benefit from this option.

  `cds.env.features.with_mocks = true` now allows `--with-mocks` in production.

- Authorization-related local development was tricky if the respective (mock) user had a tenant other than `anonymous`, as, by default, a new, empty SQLite database would have been created during `cds watch`. Now, in single tenant mode, the default SQLite database is used regardless of `context.tenant`.

- The npm module `passport` is no longer required for authentication strategies `dummy` and `mock`. See [Authentication Strategies](../../../node.js/authentication#strategies) for more details.

- Requests to remote services are logged (similar to the debug logs for executed SQL statements) if the log level for module `remote` is set to `debug`. See [Module Names Used by the Runtime](../../../node.js/cds-log#cds-log-modules) for more details.

## Java SDK { #cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

#### Use Double Star (`**`) to Exclude Paths

To `exclude` *complete* namespaces from code generation with the [CDS Maven Plugin](../../../java/developing-applications/building#cds-maven-plugin), now `**` placeholder must be used. Adjust the configuration in the `pom.xml` accordingly.

### Configure DB Connection Properties in MT Scenario

Pool configurations of multitenant database bindings now support map-based parameters. This enables additional connection properties to be specified. For Hikari connection pool, you can use `cds.datasource.<binding-name>.hikari.data-source-properties.<key>: <value>`.

For instance, to configure the packet size of connections created by SAP HANA JDBC driver, add following configuration to your *application.yaml* file:

```yaml
cds:
  datasource:
    <binding-name>:
      hikari:
        data-source-properties:
          packetSize: 300000
```

[Learn more about datasource configuration.](../../../java/cqn-services/persistence-services#datasource-configuration){ .learn-more}

### CSV Import of Array-Typed Elements

Values for elements with arrayed types can now be specified in CSV files for test data import. The values need to be presented as JSON arrays as shown in the following example:

```cds
entity Samples : cuid {
    records : array of {
        index: Integer;
        flag: Boolean
    }
}
```

A CSV file `Samples.csv` in folder `db/data` containing a single entity instance to be imported could look like this:

```csv
ID;records
08[...]15;[{"index": 1, "flag": true}, {"index": 2, "flag": false}]
```

[Learn more about providing initial data.](../../../guides/databases#providing-initial-data){ .learn-more}

### OData

#### Expose a Service with OData V2 and V4 in Parallel

In CAP Java, you can expose a service with OData versions [V2 and V4 in parallel](../../../java/migration#enabling-odata-v2-and-v4-in-parallel). Formerly this wasn't possible when using the MTX sidecar. This limitation has now been lifted.

### Remote Service Consumption

You can now configure Cloud SDK's [destination retrieval strategy](https://help.sap.com/doc/b579bf8578954412aea2b458e8452201/1.0/en-US/com/sap/cloud/sdk/cloudplatform/connectivity/ScpCfDestinationRetrievalStrategy.html) and the [token exchange strategy](https://help.sap.com/doc/b579bf8578954412aea2b458e8452201/1.0/en-US/com/sap/cloud/sdk/cloudplatform/connectivity/ScpCfDestinationTokenExchangeStrategy.html) for a Remote Service by setting `cds.remote.services.<key>.destination.retrievalStrategy` resp. `cds.remote.services.<key>.destination.tokenExchangeStrategy`.

### CQL Runtime

#### Null Values in Results

Clarification: The result row of a query execution [*may* contain `null` values](../../../java/working-with-cql/query-execution#null-values). Therefore, the `containsKey` method is not appropriate to check if a value is present in a result row and isn't equal to `null`.

#### Aliased Expands

[Expands](../../../java/working-with-cql/query-api#expand) in CQL `Select` statements can now have an alias:

```java
CqnSelect select = Select.from(BOOKS).columns(
     b -> b.author().as("writer").expand()).byId(101);
Row book = dataStore.execute(select).single();

Object writer = book.get("writer.name"); // path access
```

#### Associations on the Select List

Managed to-one associations and compositions can now be [added to the select list](../../../java/working-with-cql/query-api#managed-associations-on-the-select-list) of `Select` statements.

```java
CqnSelect select = Select.from(BOOKS).columns(
     b -> b.author()).byId(101);
Row book = dataStore.execute(select).single();

Object authorId = book.get("author.Id"); // path access
```

### Reflection API: get/find Elements by Path

When using the [Reflection API](../../../java/reflection-api), you can now specify a *path* to reflect on elements of a structured type or of an associated entity. Considering the following model:

```cds
entity People {
     key id : UUID;
     name : { first : String; last : String; };
     car : Composition of one { brand : String; color : String; };
}
```

The following snippets are equivalent.

Long version:

```java
@Autowired
CdsModel model;

CdsEntity people = model.getEntity("People");

CdsElement name = people.getElement("name");
CdsStructuredType nameType = name.getType().as(CdsStructuredType.class);
CdsElement firstName = nameType.getElement("first");

CdsElement car = people.getElement("car");
CdsStructuredType carType = car.getType(CdsAssociationType.class).getTarget();
Optional<CdsElement> colorOfCar = carType.findElement("color");
```

New short version:

```java
@Autowired
CdsModel model;

CdsEntity people = model.getEntity("People");
CdsElement firstName = people.getElement("name.first");
Optional<CdsElement> colorOfCar = people.findElement("car.color");
```

### CDS Maven Plugin: Include/Exclude Definitions

The [CDS Maven Plugin](../../../java/developing-applications/building#cds-maven-plugin) now allows to selectively *include* and *exclude* definitions during [code generation](../../../java/cqn-services/persistence-services#staticmodel). With the following configuration of the `generate` goal, Java artifacts are generated for the definitions of the `CatalogService` but not for definitions of the namespace `localized`:

```xml
<plugin>
    <groupId>com.sap.cds</groupId>
    <artifactId>cds-maven-plugin</artifactId>
    <version>${cds.services.version}</version>
    <executions>
        <execution>
            <goals>
                <goal>generate</goal>
            </goals>
            <configuration>
                <includes>
                    <include>CatalogService.**</include>
                </includes>
                <excludes>
                    <exclude>localized.**</exclude>
                </excludes>
            </configuration>
        </execution>
    </executions>
</plugin>
```

## New Lint Rule for CSV Files {  #cds-dk}

A [new CDS lint rule](/tools/cds-lint/rules/valid-csv-header) validates header lines of CSV files for whether the columns match to CDS entities.  In addition, quick fixes suggest the correct names in VS Code:

![CDS lint result for CSV file](assets/dec21/lint-csv-header.png){}

> To get the VS Code integration for this rule, run [`cds add lint`](../../../tools/cds-lint/#cds-lint-vscode) once in your project.

[Learn more about CDS Lint.](../../../tools/cds-lint/){ .learn-more}

## Hybrid Testing: K8s and Java

You can [bind to Kubernetes service bindings and secrets](../../../advanced/hybrid-testing#services-on-kubernetes) and [run your CAP Java applications with bindings](../../../advanced/hybrid-testing#run-cap-java-apps-with-service-bindings) using [`cds bind --exec`](../../../advanced/hybrid-testing#cds-bind-exec) now. [Examples for important use cases](../../../advanced/hybrid-testing#use-cases) have been added to the [hybrid testing guide](../../../advanced/hybrid-testing).

## CDS Editor Performance Optimizations

> The following applies to CDS editors in SAP Business Application Studio and Visual Studio Code.

The editor is now faster at startup and requires less memory.

Progress is now indicated when configuration was changed, and during references and workspace symbols.

![](./assets/dec21/references_progress.gif){ class="ignore-dark"}

<div id="secondary-file">releases/archive/2021/dec21.fragment.md</div>


# August 2021


## Multitenancy { #mtx}

### Handlers for Asynchronous Subscription

Tenant creation and deletion are now called via CDS service `TenantPersistenceService`, that applications can add handlers for:

```cds
@protocol:'rest'
service TenantPersistenceService {
    type JSON {
        // any json
    }

    action createTenant(tenantId: UUID, subscriptionData: JSON) returns String;
    action deleteTenant(tenantId: UUID);
}
```

[Learn more about the handler for **asynchronous provisioning**.](../../../guides/multitenancy/old-mtx-apis#event-handlers-for-cds-mtx-provisioning){ .learn-more}

### Correlation IDs for Tenant Operations

The propagation of correlation IDs to asynchronous tenant operations is now fixed. The correlation IDs in the log entries of asynchronous tenant operations now correctly match the correlation IDs of the request that triggered the operation.

<span id="aftercoridfortenant" />
<Fragment target="#aftercoridfortenant">

### Configuration of Subscription URL <Beta />

The tenant-specific URL returned to the `saas-registry` can now be specified via 2 environment variables `SUBSCRIPTION_URL` and `SUBSCRIPTION_URL_REPLACEMENT_RULES`.<br>
The following example uses the MTX application URL and turns it into the UI application URL by replacing the application name suffix:

```yaml
 SUBSCRIPTION_URL: ${protocol}://\${tenant_subdomain}-${default-uri}
 SUBSCRIPTION_URL_REPLACEMENT_RULES: [['srv', 'app']]
```

`\${tenant_subdomain}` is replaced by the domain of the subscribed tenant. Note that it's escaped ('\') to not be replaced by the MTA build.

</Fragment>

## New Capire Docs { #capire}

- [CAP Release Schedule](../../schedule) &rarr; This schedule gives a reliable basis for planning adoption accordingly.

    New **major versions** of CAP will be released **every 12 months**, in April 2021, 2022, and so forth. Active CAP-based projects are strongly recommended to adopt new majors as soon as possible, as **former releases will receive critical bug fixes only**.
    ![This screenshot is explained in the accompanying text.](assets/aug21/image-20210708235244622.png)

<span id="aftercapire" />
<Fragment target="#aftercapire">

- [Audit Logging for Node.js](../../../guides/data-privacy/audit-logging) &rarr; Learn more about Audit Logging for the Node.js runtime.

</Fragment>

- [Minimalistic Logging Facade <Beta /> for Node.js](../../../node.js/cds-log) &rarr; Learn more about out-of-the-box log formatting.

- [Best Practices for Node.js - Error Handling](../../../node.js/best-practices#error-handling) &rarr; This section gives a brief overview of common best practices.

- [Media Type Processing for CAP Java](../../../java/cds-data#mediatypeprocessing) &rarr; This section describes how to process media streams in a custom event handler.

- [Testing CAP Java applications](../../../java/developing-applications/testing#testing-cap-java-applications) &rarr; This section describes some best practices and recommendations for testing CAP Java applications.

- [Observability for CAP Java](../../../java/operating-applications/observability) &rarr; Presents a set of recommended tools that help to understand the current status of running CAP services.

## Node.js Runtime { #cds-js}

This release focuses on quality and incremental steps towards larger feature packages. See the [changelog](../../releases/changelog/) for more details.

### Important Changes ❗️ { #changes-in-node-js .important }

> You should take notice of the following changes, which **may** affect your project:

- Computed values are preserved during draft activate. That is, the values of properties that are annotated with `@Core.Computed` do not need to be recalculated when activating a draft, but are copied from the draft persistence to the active persistence. This change can be deactivated during a two-month grace period through compatibility feature flag `cds.env.features.preserve_computed = false`.

<div id="afterchangesinnodejs" />
<Fragment target="#afterchangesinnodejs">

- Messaging topics are strictly used as provided. The previous topic generation algorithm based on the rules of SAP Event Mesh lead to unwanted side effects in some cases. Hence, the automatic topic manipulation was replaced by an opt-in approach.
- In [multitenant `enterprise-messaging`](../../../node.js/messaging#multitenancy-event-mesh) scenarios, the tenant onboarding hook `onSubscription` must be declared asynchronous, otherwise the SaaS provisioning service will run into timeouts.

::: tip
See [cds.MessagingService](../../../node.js/messaging) for more details.
:::

</Fragment>

### Minor Additions

- Support for passing arguments for [action and function implementations](../../../node.js/core-services) as objects.
- Support for [OData's omit-values](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358877) preference in `prefer` header.
- Support for [OData's ReadByKeyRestrictions annotation](https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.Capabilities.V1.md#readbykeyrestrictionstype-readrestrictionsbase).

## CDS Editors Speedup

> The following applies to CDS editors in SAP Business Application Studio and Visual Studio Code.

### New Default Validation Mode: _ActiveEditorOnly_

SAP Business Application Studio and VS Code have a new default CDS validation mode, _ActiveEditorsOnly_.

It further reduces necessary compilations to improve responsiveness. The new mode only keeps track of the active editor in focus. Other files, even open visible ones (split tabs), are first revalidated once they get focus again.

The new mode needs special client support, thus for other IDEs the default remains _OpenEditorsOnly_.

[Learn more about this and other editor settings.](../../../tools/cds-editors#settings){ .learn-more}

### Graphical Dependency Analysis

A new command _Visualize CDS file dependencies_ is available in SAP Business Application Studio and VS Code to get a better understanding of large models, for example, with hundreds of model files. Hovering over a node will show the number of files involved and the combined size of all involved files to get a rough understanding about the complexity and the compilation speed.

![The graphic is explained in the accompanying text.](assets/aug21/8b8cd300-efa0-11eb-8a8e-90215dcda0c9.png)

Use the command from the context menu on a folder or CDS file.

[Learn more about this and other commands from the editor.](../../../tools/cds-editors#commands){ .learn-more}

## CDS Language & Compiler { #cds}

### Extend Array-Like Annotation Values

Usually annotations in an `extend` overwrite already existing annotation values.
If an existing annotation has an array-like value, use the new ellipsis syntax to **add** values into the array:

```cds
extend Books with @UI.LineItem: [
  ...,  //> represents the existing array entires
  { Value: ISBN },
  { Value: pages }
] {
  ISBN : String;
  pages : Integer;
}
```

[Learn more about **Extend Array Annotations**.](../../../cds/cdl#extend-array-annotations){ .learn-more}

### Doc Comments Are Translated to SAP HANA COMMENT

When generating output for deployment to SAP HANA, any entity's doc comments

```cds
/**
 * I am the description for "Employee"
 */
entity Employees { ... }
```

are now translated to the HANA `COMMENT` feature:

```sql
CREATE TABLE Employees (...) COMMENT 'I am the description for "Employee"'
```

[Learn more about **Doc Comments**.](../../../cds/cdl#doc-comment){ .learn-more}

## Java SDK { #cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

#### CDS Compiler v2 Enabled by Default

As of version 1.18.0, the CAP Java SDK uses the _cds-dk 4_ and the _CDS Compiler v2_. This applies for newly generated projects but also for existing projects that do not use a fixed version of the _cds-dk_ in their _pom.xml_.

[Learn more about using a specific cds-dk version.](../../../java/developing-applications/building#cds-maven-plugin){  .learn-more}

[Learn more about upgrading to Compiler v2.](../../../cds/compiler/v2){  .learn-more}

<span id="aftercompilerv2default" />
<Fragment target="#aftercompilerv2default">

### Receiving Events with Multitenancy <Internal />

The CAP Java SDK now supports receiving events in multitenancy mode.

</Fragment>

<span id="beforeconvenientdebug" />
<Fragment target="#beforeconvenientdebug">

### Asynchronous Audit Logging <Beta />

The CAP Java SDK now provides an API that applications can use to write logs to an audit log service programmatically:

```java
@Autowired
AuditLogService audit;

...

Access dataAccess = Access.create();
// Fill in data accesses
audit.logDataAccess(dataAccess);
```

By default, writing audit logs to the application log is supported. In addition, when you add the dependency `cds-feature-auditlog-v2` to your application and bind a `auditlog` service instance, audit log messages are automatically sent to the [SAP Audit Log service](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/f92c86ab11f6474ea5579d839051c334.html).

[Learn more about how to use the audit logging API.](../../../java/auditlog){  .learn-more}


</Fragment>

### Convenient Debug Logging with Spring Log Groups

The CAP Java SDK now defines [Spring Boot Log Groups](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.logging.log-groups) with logical names that you can use to turn on debug logging for certain areas of the CAP runtime. For example, to turn all logs regarding generated SQL statements, configure:

```yaml
logging.level.com.sap.cds.persistence.sql: DEBUG
```

in your application configuration.

[Learn more about the available logger groups and how to toggle loggers dynamically in **Java Observability**.](../../../java/operating-applications/observability){  .learn-more}

### H2 Database by Default

Newly created projects now use the [H2 database](../../../java/cqn-services/persistence-services#h2) by default. H2 is the default database used in Spring Boot and thus requires very little configuration.

### Returning Multiple Error Messages

The CAP Java SDK now collects all error messages for automatic [input validation](../../../guides/providing-services#input-validation) using the Messages API and does no longer abort the request processing on the first validation error. Applications can contribute additional errors using the [Messages API](../../../java/event-handlers/indicating-errors#messages) in the `Before` phase and are no longer required to explicitly call [`throwIfError()`](../../../java/event-handlers/indicating-errors#throwing-a-serviceexception-from-messages) in that case.

### Session Context Variables in ON-conditions

You can now use session context variables such as `$user.id`, `$user.locale`, and `$now` in ON-conditions of associations.

### Updatable Views

Insert and update operations now also work on views having literals in the projection.

### Structured Elements

Simple insert and select operations are now supported on structured elements.

<div id="secondary-file">releases/archive/2021/aug21.fragment.md</div>

# July 2021


<span id="afterstarttop" />
<Fragment target="#afterstarttop">

### Async Audit Logging Out of the Box <Beta />

This release features the first version of the new [AuditLogService](../../../guides/data-privacy/audit-logging) in Node.js; Java follows soon.

In this first version, the audit log is written only *after* the respective transaction was committed in a fire-and-forget fashion. In future versions, the logs will be included in the atomic unit of work of the respective transaction via the *persistent outbox*.

Usage example:

```js
const AuditLogService = await cds.connect.to('audit-log')
// .emit: log sent after tx committed
await AuditLogService.emit('<event>', { <data> })
// .send: log sent immediately (for example, if rollback on error required)
await AuditLogService.send('<event>', { <data> })
```

The supported events of the first version are `dataAccessLog`, `dataModificationLog`, `configChangeLog`, and `securityLog`. See the _AuditLogService.cds_ for details on events and payloads. Event names, etc., can change for the final version!

Further, out-of-the-box audit logging for modification of personal data and access to sensitive personal data (excl. *attachments*) can be enabled via `cds.env.features.audit_personal_data`. Note that out-of-the-box support for draft-enabled entities may be limited.


</Fragment>

<span id="beforetypescript" />
<Fragment target="#beforetypescript">

## CDS Feature Toggles <Alpha />

It's now possible to consume an early-adopter version of CDS feature toggles in Java; Node.js follows soon.
See the [Java sample application](https://github.wdf.sap.corp/cds-runtime/bookshop-java-v2) to get started!



</Fragment>

## On-the-fly TypeScript with `cds-ts`

Use the `cds-ts` CLI command instead of `cds` to avoid having to precompile TypeScript files to JavaScript each time and speed up development.

```sh
cds-ts serve world.cds
```

```sh
cds-ts watch
```

[Learn more about using TypeScript.](../../../node.js/typescript){ .learn-more}

## Swagger UI Made Easier

For Node.js apps, less code is now needed to serve [exported OpenAPI definitions](/advanced/publishing-apis/openapi) in Swagger UI.  Just install the new [`cds-swagger-ui-express`](https://www.npmjs.com/package/cds-swagger-ui-express) package:

```sh
npm add --save-dev cds-swagger-ui-express
```

And add a [`server.js`](../../../node.js/cds-serve#custom-server-js) file:

```js
const cds = require ('@sap/cds')
module.exports = cds.server

if (process.env.NODE_ENV !== 'production') {
  const cds_swagger = require ('cds-swagger-ui-express')
  cds.on ('bootstrap', app => app.use (cds_swagger()) )
}
```

Follow the _Open API preview_ links on the index page and see your API definitions in action:
![Swagger UI](assets/july21/cds-swagger-ui.png){}

[Learn more about OpenAPI publishing.](/advanced/publishing-apis/openapi){ .learn-more}

## New CAP/SAP Fiori Sample

SFLIGHT is a new sample app for the travel reference scenario, built with CAP and SAP Fiori elements.

The purpose of this sample app is to demonstrate SAP Fiori annotations, compare SAP Fiori features on various stacks (CAP Node.js, CAP Java SDK, ABAP) and run UI test suites on various stacks.

Currently the app is only available for the CAP Node.js runtime. A version for CAP Java SDK will follow soon.

![SFLIGHT App](assets/july21/sflight.png)

[Try out the **SFLIGHT app**.](https://github.com/SAP-samples/cap-sflight){ .learn-more}


## Command Line / Toolkit { #cds-dk}

### Best Guess for Unknown Commands

The command line interface (CLI) of `@sap/cds-dk` offers you a best guess in case a command can't be found or if your input is ambiguous, for example, due to a typing mistake.

The following screenshot shows `cds` output for the unknown command **logu**.

![CDS message for unknown command](./assets/july21/cds_unknown_cmd.png)

### Importer Improvements

##### OData V4 Support

In much the same way as with OData v2, `cds import` now supports input documents for OData V4.

##### Preserved Documentation

If your imported EDMX documents contain tags like `<Documentation><Summary>`, `<LongDescription>` (OData V2), or `Core.Description/LongDescription` annotations (OData V4), these are now preserved in the resulting _.csn_ file.

To carry this documentation over to your provided services, generate EDMX files with the respective `Core.Description` annotations:

```sh
cds compile --to edmx --docs
```

## CDS Editors Speedup

> The following applies to CDS editors in SAP Business Application Studio and Visual Studio Code.

More and more users create models with hundreds of files. With this release, we introduce some settings to improve the editor performance and also changed some defaults.
Notable settings:

| Setting                                     | Description                      |
|---------------------------------------------|----------------------------------|
| _Cds: Workspace Validation Mode_          | New default: _OpenEditorsOnly_ |
| _Cds > Workspace: ScanCsn_                | New setting. Default: _off_    |
| _Cds > Quickfix: ImportArtifact_          | New setting. Default: _off_    |
| _Cds > Contributions > Enablement: Odata_ | New setting. Default: _on_     |

Best performance is achieved with default CDS settings, except for the last one in the list above &rarr; Switch it _off_ to speed up compilation, if you can do without Editor support for Fiori annotations.

Additionally, you may want to adjust some non-CDS settings to further increase performance:

| Setting                                                  | Description                                                                |
|----------------------------------------------------------|----------------------------------------------------------------------------|
| _Editor > Goto Location: Alternative Definition Command_ | Don't use _goToReferences_ to avoid unnecessary recompilations.          |
| _Workbench > Editor > Limit: Value_                      | Limit the number of recompilations in related editors (`using` statements) |
| _Workbench > Editor > Limit: Enabled_                    | Enable the _Limit: Value_ setting.                                       |

## CDS Language & Compiler { #cds}

### Dynamic Expressions in SAP Fiori Annotations

In particular, when writing annotations for SAP Fiori UIs, you may want to make use of
dynamic expressions in annotation values. They are evaluated in the front end and can,
for example, be used to avoid status mapping in the backend.

Provide an expression in the _EDM JSON representation_, like:

```cds
@UI.Hidden: {$edmJson: {$If: [{$Eq: [{$Path: 'status'}, 'visible']}, false, true]}}
```

and the compiler will translate it to the corresponding XML:

```xml
<Annotation Term="UI.Hidden">
  <If>
    <Eq>
      <Path>status</Path>
      <String>visible</String>
    </Eq>
    <Bool>false</Bool>
    <Bool>true</Bool>
  </If>
</Annotation>
```

[Learn more about Dynamic Expressions.](../../../advanced/odata#dynamic-expressions){ .learn-more}

### Define Views with the Exists Predicate

Use the [Exists Predicate](../../../cds/cql#exists-predicate) with path expressions and infix filters as a simplified way to define
views with correlated _exists_ subqueries:

```sql
SELECT from Authors where exists books[year=2000]
```

unfolds to:

```sql
SELECT name FROM Authors AS a WHERE EXISTS (
  SELECT 1 FROM Books AS b WHERE b.author_id = a.id AND b.year = 2000
)
```

[Learn more about the Exists Predicate in CQL.](../../../cds/cql#exists-predicate){ .learn-more}

## Node.js Runtime { #cds-js}


This release focuses on quality and incremental steps towards larger feature packages. See the [changelog](../../releases/changelog/) for more details.

### Merged Runtime Packages ❗️ { #changes-in-nodejs .important }

We merged the former package `@sap/cds-runtime` into `@sap/cds`.

As `@sap/cds-runtime` was always an internal package, this should not affect you.
Yet, if, for any reason, you had `@sap/cds-runtime` in your list of dependencies, you should remove it.

### Important Changes ❗️ { #changes-in-node-js .important }

> The following changes affect undocumented internal implementations, and hence **shouldn't** affect CAP-based projects. Nevertheless, they're listed here for your reference.

- Cascade delete order reverted from leaves to root &rarr; Fixes an issue in cascading delete where a child entity has more than one parent, for example, Books and Restaurants both have a composition of many Reviews

- Always use flag `u` during input validation via `@assert.format`

### Kibana-Ready Logging Out of the Box <Beta />

We now provide a Kibana-friendly log formatter to use with [cds.log()](../../../node.js/cds-log). Currently, the formatter must be activated via `cds.env.features.kibana_formatter = true` (additional to `NODE_ENV === 'production'`), but it will become the default in the future.
::: tip
Note that the formatter is in beta state and feedback is welcome!
:::

<span id="beforeodatareturn" />
<Fragment target="#beforeodatareturn">

### Improved Search Performance on SAP HANA <Beta />

The following two performance optimizations in the context of `$search` on SAP HANA can be activated via `cds.env.features.optimized_search`:

- Resolve localized texts for `$search` queries at runtime (instead of using convenience views based on `COALESCE`)
- Optimize `$search` queries using `CONTAINS` instead of `LIKE`
::: warning
Note that this mode is considered as *experimental*.
:::


</Fragment>

### OData Return Formats

The Node.js runtime now supports the prefer header `return` with values `minimal` and `representation`. The default value for the server is configurable at `cds.env.odata.prefer.return`. If not configured, the default is `representation`.

Further, annotation `@Core.ContentDisposition.Filename` is now supported. See
[Serving Media Data](../../../guides/providing-services#serving-media-data) for more details.

## Java SDK { #cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

#### Spring Boot 2.5 Support

- Update the CAP Java SDK to version 1.17.0 if you want to use Spring Boot 2.5. This Spring Boot version came with [incompatible changes](https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.5-Release-Notes) that were adopted by the CAP Java SDK.
- Note that CAP Java 1.17.0 now _requires_ Spring Boot 2.5. Therefore, please update your Spring Boot dependency if you adopt this CAP Java version!

### Enhanced Media Streaming Support

You can now use the [@Core.ContentDisposition.Filename](../../../guides/providing-services#serving-media-data) annotation to enable web browsers to handle the media data as an attachment download.

### Enhanced Remote Service Consumption

You can now use aliases in projections you define on entities used in [remote OData queries](../../../java/cqn-services/remote-services), for example:

```cds
entity Addresses as projection on external.A_BusinessPartnerAddress {
  key AddressID as ID,
  key BusinessPartner as businessPartner,
  CityName as city,
  StreetName as street,
  HouseNumber as houseNumber
}
```

These projections can then be used to retrieve data from a Remote Service:

```java
bupa.run(Select.from("Addresses")).stream().map(a -> a.get("city"));
```

In addition, the `IN` operator is now supported in remote OData queries. In OData V2, which doesn't natively support `IN` the query is transformed into multiple comparisons concatenated by `OR`.

### Alter Single Entity Properties

You can read and modify a property of an entity directly by sending `GET`, `POST`, `PUT`, and `DELETE` requests to the properties URL, for example `POST .../odata/v4/Person/name`. Primitive and complex collections are also supported.

### Reliable Implicit Sorting

[Implicit Sorting](../../../guides/providing-services#implicit-sorting) now works reliably when aggregation functions are used in queries. Also, queries that don't use a limit (top/skip, for example when [Implicit Pagination](../../../guides/providing-services#implicit-pagination) is disabled) are not implicitly sorted anymore to improve performance.

### Improved Development Turnaround Times

The [CDS Maven Plugin](../../../java/developing-applications/building#cds-maven-plugin) helps improving development roundtrips:

<div id="afterimproveddevelopmentturnaroundtimes" />
<Fragment target="#afterimproveddevelopmentturnaroundtimes">

- A new goal [cds:watch](../../../java/developing-applications/running#local-development-support) provides faster turnaround times during development. It automatically detects changes to the CDS model, triggers a CDS build, and restarts the CAP Java application locally for you to test you new feature. Note that this feature is still beta and doesn't work on Windows, yet.

</Fragment>

- It automatically creates JavaDoc for the generated [Data Accessor](../../../java/cds-data#generated-accessor-interfaces) interfaces based on doc comments in the CDS model.
- A new goal `cds:build` combines the existing goals `cds:cds` and `cds:generate`.

### Path Expressions on Outer References in EXISTS

You can now use path expressions based on `outer` referenced in an `exists` subquery.
This query selects all books where the publisher's city is the same as the author's city of birth:

```java
Select.from(BOOKS).where(b -> b.exists(outer ->
   Select.from(AUTHOR).where(a -> outer.publisher().city().eq(a.cityOfBirth()))));
```

### Support Doc Comments in Code Generation

Doc comments in CDS are now converted to Javadoc comments in generated Java artifacts:

```cds
/**
 * A medium for recording information in the form of writing
 */
entity Books {
  key id : GUID;

  /**
   * A name for the book which is usually chosen by the author
   */
  title : String;
}
```

&rarr; produces this Java output:

```java
/**
 * A medium for recording information in the form of writing
 */
interface Books {
  String getID();

  /**
   * A name for the book which is usually chosen by the author
   */
  String getTitle();
}
```

### Miscellaneous

- Virtual elements can now be set by client requests. See section [Virtual Elements](../../../cds/cdl#virtual-elements) for more details.
- The interface [EventContext](../../../java/event-handlers/#eventcontext) now exposes the `keySet()` method to iterate over all event parameter keys.
- Support SAP proprietary local `3Q` (`en-US-x-saprigi`)

<div id="secondary-file">releases/archive/2021/july21.fragment.md</div>

# March 2021


## Important Changes {  #important-changes .important }

##### CDS Compiler v2

[CDS compiler version 2](#cds) (cv2) brings numerous improvements, which allow us to greatly streamline model processing and memory consumption going forward. All projects are recommended to **upgrade as soon as possible**, as the former version will only receive critical fixes after v2 is released. Find a guide on how to upgrade at [**_CDS > Compiler v2_**](../../../cds/compiler/v2).



##### Consolidated Node.js APIs

In the course of finishing compiler v2 we also consolidated a few Node.js APIs for model processing. Those changes mostly affect private, undocumented APIs, so you should not encounter any adoption efforts if you sticked to the public APIs, Nevertheless find some things mentioned in the following [_Node.js_](#cds-js) section.

## Capire Docs & Samples

##### New and Overhauled docs for `cds.compile` and `cds.reflect` APIs

In the course of finishing compiler v2, we also consolidated the APIs for parsing, compiling, and reflecting models.
In response to feedback received, we also returned these docs back to the <a href="//node.js#toc" data-proofer-ignore>Node.js API reference docs</a>.
Find the updated docs at [**_Node.js > cds.compile_**](../../../node.js/cds-compile) and [**_> cds.reflect_**](../../../node.js/cds-reflect).

![image-20210406150526972](assets/mar21/capire-cds.reflect.png)

##### New and Overhauled docs for `cds.ql` APIs

We filled in many gaps in the Node.js `cds.ql` reference docs. This also includes docs for the newly introduced [tagged template string support](#node-tts). Find the updated docs at [**_Node.js > cds.ql_**](../../../node.js/cds-ql).

![image-20210406150258168](assets/mar21/capire-cds.ql.png)

##### Guide re Publishing to OpenAPI

Moved the formerly hidden information on CAP support for OpenAPI to a top-level guide at [**_Advanced > OpenAPI_**](/advanced/publishing-apis/openapi).

![image-20210406150756592](assets/mar21/capire-openapi.png)

##### Guided Tour in _cap/samples_ for Java

Take a guided tour in VS Code through our [CAP Java samples](https://github.com/SAP-samples/cloud-cap-samples-java) and learn which CAP features are showcased by the different parts of the repository. Just install the [CodeTour](https://marketplace.visualstudio.com/items?itemName=vsls-contrib.codetour) extension for VS Code.

## Command Line / Toolkit { #cds-dk}

### Live Reload with `cds watch`

In addition to restarting the server, `cds watch` now automatically reloads your browser page after a change in a CAP project. You can stay focused in the editor while the effect of your change is visible immediately.

### Adding SAP HANA Support with `cds add hana`

To prepare your project for SAP HANA, it is no longer necessary to modify your _package.json_. Instead, use `cds add hana` to enhance your project configuration. See section [Enhance Project Configuration for SAP HANA Cloud](../../../guides/databases-hana) for more details.

### Adding Cloud Foundry Native Deployment Support with `cds add cf-manifest`

As an alternative to MTA-based deployment, you can now easily create the manifest files with `cds add cf-manifest`. This replaces the CDS build base approach, but is currently limited to single tenant applications. See section [Deploy Using Manifest Files](../../../guides/deployment/to-cf) for more details.

### Linting CDS Models with `cds lint` <Beta />

You can now use [CDS Linter](../../../tools/cds-lint/) in your CAP project. See section [Setup & Usage](../../../tools/cds-lint/#usage-lint-cli) for more details how to enable and use it.

## CDS Editors & Tools

> The following features are available for all editors
> based on our language server implementation for CDS in
> SAP Business Application Studio, Visual Studio Code, and Eclipse.
> The plugins are available for download for Visual Studio Code at [Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=SAPSE.vscode-cds#overview) and for Eclipse at [SAP Development Tools](https://tools.hana.ondemand.com/#cloud-vscodecds).

### Support for CDS Compiler v2

The latest version of the editor supports both, CDS compiler v1 and v2.

As before, the editor picks up the compiler installed in the workspace if available, else from a globally installed `@sap/cds-dk` if available, else the embedded compiler, which now is CDS compiler v2.

### Support for Semantic Highlighting

Semantic highlighting adds additional coloring/styling on top of the existing syntax highlighting. It visualizes semantic information
like the type of identifiers, for example, (namespace/context/service, entity/view/aspect, type, element, annotation) or
modifiers, for example, if types are definitions, built-in, delivered with `@sap/cds/common.cds`, or abstract.

Standard syntax highlighting:

![](./assets/mar21/semanticHL_off.png){}

Additional semantic highlighting (see following example configuration):

![](./assets/mar21/semanticHL_on.png){}

Semantic highlighting is disabled by default. It requires extra calculation. For large models, there might be a noticeable delay between typing and updated highlighting.

#### Enablement

Enable semantic highlighting for CDS source files:

1. Open _Settings_.
2. Restrict selection to `semantic`.
3. Ensure that `Editor > Semantic Highlighting: Enabled` is set to `true` or `configuredByTheme`.
4. Enable specific CDS semantic highlighting by setting `Cds > Semantic Highlighting: Enabled` to `true`.

![](./assets/mar21/semanticHL_enable.png){}

#### Configuration

Configure colors and font styles based on the additional information from semantic highlighting.

1. Open _Settings_.
2. Navigate to `Editor: Semantic Token Color Customizations`.
3. Follow the link `Edit in settings.json`.

![](./assets/mar21/semanticHL_configure.png){}
::: tip
If you have `Editor > Semantic Highlighting: Enabled` set to `configuredByTheme`, add the theme name as an extra node between `editor.semanticTokenColorCustomizations` and `rules` (use code completion support)
:::

The underlying language server protocol defines a set of predefined constants for token types and modifiers. As there are no specific constants for entity-relation languages, use the following mapping:

Token types:

* `namespace/context/service` **&rarr;** **`"namespace"`**
* `entity/view/aspect` **&rarr;** **`"class"`**
* `element` **&rarr;** **`"property"`**
* `type` **&rarr;** **`"type"`**
* `annotation` **&rarr;** **`"typeParameter"`**

Modifiers:

* built-in types **&rarr;** **`"*.static"`**
* types from `@sap/cds/common.cds` **&rarr;** **`"*.defaultLibrary"`**
* aspects/abstract entities **&rarr;** **`"*.abstract"`**
* definitions **&rarr;** **`"*.definition"`**
::: tip
Some themes in the Marketplace already contain specific configuration for semantic highlighting information.
:::

## CDS Language & Compiler { #cds}

### Compiler v2 — A Major Step Forward {}

[CDS compiler version 2](#cds) (cv2) brings numerous improvements, many of which behind the scenes, which allow us to greatly streamline model processing and memory consumption going forward.

We recommend **upgrading as soon as possible**, as the former version will only receive critical fixes after v2 is released.

![image-20210406151536290](assets/mar21/upgrade-to-cv2.png)

*Minimized Breaking Changes* — Even though this is a major version update – actually the first in life for [@sap/cds-compiler](https://www.npmjs.com/package/@sap/cds-compiler) – we tried to minimize breaking changes to a minimum. Most changes should not affect you at all, as long as you sticked to public and documented APIs (which you always should!).

Nevertheless, we prepared a dedicated guide for you to ease upgrading at:<br> [_**CDS > Upgrade to Compiler v2**_](../../../cds/compiler/v2).

### Fixed  Temporal Data {}

Former releases had a major glitch, which made it literaly impossible to send _as-of-now_ queries or _time-travel_ queries; for example:

```http
GET .../Books(ID=201) HTTP/1.1
```

... would be rejected by OData libs, asking you to specify the full compound key.

Reason for that was, we erroneously included `validFrom` in the OData `<PrimaryKey>`. But frequently you would not know the value of that. We've fixed that now by omitting `validFrom` from the OData primary key, as documented in a [corrected version of the Temporal Data guide](../../../guides/temporal-data#primary-keys-of-time-slices).

Consequences:

* _As-of-now_ and _time-travel_ queries work now as they were thought to. In the unlikely case, you did own workarounds, adding `validFrom` to single-object requests as above, you'd need to remove that.
* _Time-series_ queries with `sap-valid-from/sap-valid-to` also continue to work, even though result sets may now have entries with duplicate keys, that is, same `ID` with different `validFrom` → OData specification disallows that, but most OData libs fortunately don't care.

In case you encounter issues, for example, using an OData library, that rejects duplicate keys, reach out to us. We do have a solution also for that, which we would share then.

### Compiler Messages Explained

We added a guide to explain selected `cds` compiler messages, with information how to fix them to [**_CDS > Compiler Messages_**](../../../cds/compiler/messages).

![image-20210406150658119](assets/mar21/capire-cdsc-messages.png)

### Scoped Definitions

You can now define an object `Foo.Bar` even if there is a definition for `Foo` that is not a context or a service.
You can, for example, define entities `Orders` and `Orders.Items`.

![image-20210406152600474](assets/mar21/cds-scoped-defs.png)

[Learn more in the **CDS Definition Language Reference**.](../../../cds/cdl#scoped-names){ .learn-more}

The compiler internally makes use of this, for example, for localized entities: the text entity for entity `Foo` is now called
`Foo.texts`. See section [Fix refs to Foo_texts](../../../cds/compiler/v2#fix-refs-to-foo-texts) for more details.

### Simplified Syntax for Annotated OData Annotations

Almost all annotation assignments can now be written without delimited identifiers: the use of `.`, `@`, and `#` is fine
for annotation names, property names of structures, and in references used as annotation values. For example, you can now write:

```cds
@Common.Text: {
  @UI.TextArrangement: #TextOnly,
  ...
}
```

### Sorting SQL Statements

The compiler now sorts SQL statements in the order in which they have to be executed for deploying the model to a database.

## Node.js Runtime { #cds-js}

### Major Version Update to v5 { #changes-in-node-js}

As a consequence of the major version upgrade of `@sap/cds-compiler^2`, also the Node.js runtime package `@sap/cds` received a major version update to **v5** →  _npm update_ your project to receive that.

##### No Breaking Changes

* There are no breaking changes to public APIs.

##### Noteworthy Changes

> You should take notice of the following changes, which **may** affect your project:

* Dropped support for Node.js v10 --› v12 is minimum required now; recommended: [v14 (LTS)](https://nodejs.org/).
* `@sap/cds^5` requires `@sap/cds-compiler^2`.
* `cds.features.snapi = false` has been removed now
* `req.timestamp` now returns [`Date` objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date), before it was a [`Date.now()` integer](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now). <br>Although a public API, this change should be transparent for custom code.

##### Changes to Implementation

> Following are changes to undocumented internal implementations, hence **shouldn't** affect CAP-based projects. Nevertheless, they're listed here for your reference:

* Removed methods `cds.compile.to.hdbtabledata` and `.to.hdbmigration` .
* Removed support for deprecated `@sap/xssec^2` --› use `xssec^3` instead.

### Tagged Template Strings for `CDL`, `CQL`, and `CXL` { #node-tts}

We enhanced `cds.parse` with new functions `CDL`, `CQL`, and `CXL` accepting [tagged template string literals](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals).
These are made available by the `cds` facade as global functions, so you can easily use them as follows:

### Tagged Template Strings with `cds.ql` { #node-tts2}

We also extended this support of tagged template strings to `cds.ql`, as well as the Querying API functions of `cds.Service`, with great effects on readability of code:

### Performance Optimizations

`@sap/cds` version 5 comes with several performance optimizations, many happened on a detailed implementation level. A few stand out however, and should be understood and taken into account by you:

1. **Outbound payload validation switched off** by default — In former releases the OData library always validated outgoing data; we switched that off now by default, as it comes with a high overhead and minimal value. You can re-enable it with `cds.env.odata.skipValidation = false`, for example for debugging reasons during development.

2. **Locale-specific sorting is skipped** if there is no _order by_ clause if there's no `String` column in it. Background: on SAP HANA this requires using the SAP HANA-specific `with parameters` clause, which has certain performance issues today.

3. **Streamlined authorization checks** — Authorization for draft-enabled entities via `@restrict` was streamlined in accordance to the [Authorization cookbook](../../../guides/security/authorization). First, grants of `@restrict` are now restricted to _CRUD_ (former redundant support for _NEW_ and _EDIT_ got removed). Second, redundant checks for bound actions are skipped, as they are anyways covered by the _"locked by user"_ check.

### Tailored Search with `@cds.search`

Node.js runtime now supports entity-level annotation `@cds.search` to control deep generic search capability: Just annotate those elements, which shall be searched, and which not. All elements typed `String` are searchable by default. Reduce these to increase performance.

[Learn more in **Cookbook > Generic Providers > Search Capabilities**.](../../../guides/providing-services#searching-data){ .learn-more}

> Note 1: In previous versions, we also included all `UUID`-typed elements by default, which we don't do anymore, due to performance reasons.

> Note 2: Deep search still remains unsupported at the moment. Hence, path expressions in `@cds.search` are currently ignored.

> Note 3: The element-level annotation `@Search.defaultSearchElement` is deprecated and will be removed in future versions. In the meantime, `@cds.search` supersedes those, that is, if both are defined, `@cds.search` wins.

### Scalable Multitenant Messaging Using Webhooks <Beta />

The Node.js runtime now ships with full out-of-the-box support for outbound and inbound messaging in multitenant SaaS scenarios. To ensure scalability we avoid open connections.

On the inbound side, we use [webhooks](https://wikipedia.org/wiki/Webhook) to achieve that. Instead of transferring incoming messages through a permanent AMQP connection, they are delivered through HTTP using webhooks.

[Learn more in _**Node.js > Messaging**_ reference docs.](../../../node.js/messaging#sap-event-mesh){ .learn-more}

## Java SDK { #cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

#### Virtual Elements

The behaviour of virtual elements has been changed to align it with how virtual elements are [treated by the CDS Compiler v2](../../../cds/compiler/v2#removed-virtual-elements-as-calculated-fields). Although virtual elements are present in the domain model, they are
no longer reflected in the generated database view. They still can be used in queries but with some limitations. They are:

* ignored on the select list, order by and group by
* not returned by select *
* ignored in input data of insert, update, and upsert
* rejected when used in filters, where or having

### Support for H2 Database

With CDS Compiler v2, SQL statements are [sorted properly](#sorting-sql-statements) so that a generated [`schema.sql`](../../../java/cqn-services/persistence-services#in-memory-storage) file can be deployed without post-processing. This allows to smoothly use [H2](../../../java/cqn-services/persistence-services#h2-database) for local development and Continuous Integration. In order to generate SQL for H2, the sql dialect in _.cdsrc.json_ has to be set to "plain":

```json
"sql": {
    "dialect": "plain"
}
```

![image-20210407222647359](assets/mar21/image-20210407222647359.png)

### Compiler v2 Support

The new `@sap/cds-dk@^4` including `@sap/cds-compiler@^2` is supported by the CAP Java SDK.
This release also maintains compatibility with `@sap/cds-dk@^3` including `@sap/cds-compiler@^1`.

See section [Upgrade to Compiler v2](../../../cds/compiler/v2#impact-on-java-code) for more details on the new compiler version and how it might affect your CAP Java project.

To use the new major version, you can update the `@sap/cds-dk` version in your `pom.xml` file, by setting the `version` property of the `cds:install-cdsdk` Maven goal.

[Learn more about the `cds:install-cdsdk` Maven goal.](../../../java/assets/cds-maven-plugin-site/install-cdsdk-mojo.html){ .learn-more target="_blank"}

### Indicating Errors

The method `throwIfError()` has been added to the Messages interface.
It simplifies throwing a ServiceException and aborting the request after collecting multiple error messages.

[Learn more about `throwIfError()` and Messages.](../../../java/event-handlers/indicating-errors#messages){ .learn-more}

### Updated Java Samples

We have revamped our [CAP Java Sample application](https://github.com/sap-samples/cloud-cap-samples-java). Some highlights include:

* Updated SAP Fiori UIs and improved Vue.js UI
* Added ability to add reviews to books
* Showcased instance-based authorizations

You can now also take a guided tour in VS Code through our [CAP Java sample application](https://github.com/sap-samples/cloud-cap-samples-java) and learn which CAP features are showcased by the different parts of the repository. Just install the [CodeTour](https://marketplace.visualstudio.com/items?itemName=vsls-contrib.codetour) extension for VS Code.

### Support for Simple Projections in Remote Services <Beta />

You can now use CQN queries targeting your own projections on entities from external services with Remote Services.
Currently only simple projections are supported, which reduce the list of selected items without renaming them:

```cds
entity SimpleBooks as projection on Books { ID, title, descr };
entity SimpleAuthors as projection on Authors excluding { placeOfBirth, placeOfDeath };
```

[Learn more about Remote Services.](../../../java/cqn-services/remote-services){ .learn-more}

### Services Accepting CQN Queries

The interfaces `ApplicationService`, `PersistenceService`, and `RemoteService` now all implement the common interface `CqnService`, which will gradually replace the former `CdsService` interface.
Consider adapting your code to use `CqnService` over `CdsService`, as it captures the intent better and avoids name clashes with `CdsService` from the [Model Reflection API](../../../java/reflection-api).

[Learn more about these three service types and their differences.](../../../java/cqn-services/#cdsservices){ .learn-more}

### Compositions of Aspects

Using [compositions of aspects](../../../cds/cdl#managed-compositions) is now fully supported in CAP Java. Also accessor and model interfaces are generated accordingly. For example:

```cds
entity Orders {
  key ID: Integer; //...
  Items : Composition of many OrderItems;
}

aspect OrderItems {
  key pos : Integer;
  product : Association to Products;
  quantity : Integer;
}
```

::: warning _❗ Warning_ 
Upgrading from CDS Compiler v1 to v2 will cause accessor and model interfaces for compositions of aspects to change. It is therefore recommended to firstly upgrade to CDS Compiler v2 before starting to use compositions of aspects.
:::

## Databases <Beta /> {#databases}

Support for [Schema Evolution](../../../guides/databases-hana#schema-evolution-native-db-clauses) on SAP HANA Cloud has been added as beta feature for non-productive usage and trial.



# February 2021


## Docs and Samples

### Real-Time Search Improvements

The search ranking algorithm has been improved to show more accurate results. Additionally, capire can now be searched in real-time.

Full-text search results are automatically highlighted and the scroll position is adjusted to display the first result.

### Guided Tours in cap/samples

Take a guided tour in VS Code through our [CAP samples](https://github.com/SAP-samples/cloud-cap-samples) and learn which CAP features are showcased by the different parts of the repository. Just install the [CodeTour](https://marketplace.visualstudio.com/items?itemName=vsls-contrib.codetour) extension for VS Code.

![](./assets/feb21/codetour.gif)

We'll add more code tours in the future. Stay tuned!

### Using SQLite and SAP HANA Functions

CAP samples demonstrate how you can use [native database functions of SQLite and SAP HANA](https://github.com/SAP-samples/cloud-cap-samples/commit/65c8c82f745e0097fab6ca8164a2ede8400da803) in one code base. There is also a [code tour](https://github.com/SAP-samples/cloud-cap-samples#code-tours) available for it.

## CDS Language & Compiler { #cds}

### Resolving Ambiguities for Auto-Redirection of Associations

If there are several equally suited potential targets for the auto-redirection of an association, you can now resolve the ambiguity with the annotation `@cds.redirection.target`. Use the value `true` to make an entity a preferred redirection target, or `false` to exclude an entity as target for auto-redirection. See section [Auto-Redirected Associations](../../../guides/providing-services#redirected-associations) for a detailed example.

## Node.js Runtime { #cds-js}

### Important Changes ❗️ { #changes-in-node-js .important }

The following changes can affect your project. See the respective sections for details and potentially necessary actions.

- The default implementation of a messaging service with kind `enterprise-messaging` is now multitenant aware. The old, shared variant is available through kind `enterprise-messaging-shared`.
- `.after` handlers are consistently called with a result with a type based on the respective request.
- Managed properties of a containing entity are updated if any composition target is updated.

### Authorization Enhancements

If not explicitly contained in the service definition, composite entities that are auto-exposed by the CDS Compiler can't be accessed directly, and associated entities that are auto-exposed by means of `@cds.autoexpose` are read-only. Additionally, implicitly autoexposed entities inherit the authorization restrictions of their containing entity when accessed via navigation.

Instance-based `@restrict.where` clauses are ignored during `CREATE` requests. Previously, the respective requests were rejected as there are no `WHERE` clauses in `INSERT` statements. This change allows to specify instance-based restrictions with grant type `WRITE` (cf. [Control Access with @restrict](../../../guides/security/authorization#restrict-annotation)). It can be deactivated during a two-month grace period through compatible feature flag `cds.env.features.skip_restrict_where = false`.

Finally, trying to modify an entity without the necessary authorization results in an error response with HTTP status code `403` (instead of previously `404`).

<span id="beforedatainafter" />
<Fragment target="#beforedatainafter">

### Tenant-Aware `emit` in AMQP Messaging <Beta />

The new implementation for kind `enterprise-messaging` is enabled for multitenancy. Currently, only the `emit` functionality is implemented, consuming messages will be added at a later stage. To use the single-tenant implementation (for example, for communicating between apps in the provider account), use kind `enterprise-messaging-shared`.

</Fragment>

### Data in `.after` Handlers

[`.after` Handlers](../../../node.js/core-services#srv-after-request) are consistently called with a result with a type based on the respective request, for example an array for a collection and an object for a single entity. Previously, after handler for read requests were always called with an arrayed result. This change can be deactivated during a two-month grace period through compatible feature flag `cds.env.features.arrayed_after = true`.

### Managed Properties in Composition Trees

Managed properties of a containing entity are updated if any composition target is updated. For example, on a deep update to `OrderHeaders` with payload `{ items: [...] }`, `OrderHeaders.modifiedAt` will be updated if `items` contains changes. This change can be deactivated during a two-month grace period through compatible feature flag `cds.env.features.update_header_item = false`.

### Error Response Targets

The target of error responses now adheres to the OData path syntax. This allows, for example, the UI to correctly highlight the respective input and display the i18n name of the respective property even in case of name clashes.

Example:

```cds
POST /Headers
{
  ID: 1,
  items: [{
    ID: 1,
    description: null, //> a mandatory property
  }]
}


Error Response:
{
  code: '400',
  message: 'Value is required',
  target: 'items(ID=1)/description' //> fully qualified path
}
```

### OData Metadata

OData responses now contain ETags for nested entities, that is, on READs with $expand and on deep CREATEs/ UPDATEs. Only the ETag of the header item is compared to the `If-(None-)Match` header.

Further, the Node.js runtime now supports responding with absolute context URLs. See section [Absolute Context URL](../../../advanced/odata#absolute-context-url) for more details.

## Java SDK { #cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

#### Changed

- The Maven build now enforces a minimum `@sap/cds-dk` version of 3.0.0.
- In case property `cds.security.openUnrestrictedEndpoints` is not configured explicitly, the Spring security configuration in the runtime authenticates all endpoints in multitenant scenario. In single tenant mode, the endpoints are still authenticated according to the restrictions in the CDS model.
- Elements with type UUID aren't [searched](../../../guides/providing-services#searching-data) by default any longer.
- Entities that have associations annotated with [cascade](../../../java/working-with-cql/query-execution#cascading-over-associations), don't cascade insert, update, and delete operations anymore when they're in draft mode.

#### Fixed

- Service entity `DraftAdministrativeData` is now read-only and can't be accessed directly any more. Read requests using navigation to this entity (for example, */\<Service\>/\<Entity\>(id)/DraftAdministrativeData*) are allowed for authorized users.
- The signature of the error messages 400002, 400012, 400015, 400018, 400019, 409006 and 428002 was changed to not expose request data in error messages.

### OData V2 Endpoints on Index Page

The index page of CAP Java application now displays links to OData V2 endpoints as well.

![](./assets/feb21/java-index-page.jpg)

### OData V4 Protocol Adapter Enhancements

OData V4 `$expand` now supports using **inner** `$top` and `$skip` query options. Restriction: The result for `$count` is not considered, yet, when using these options in combination.

[Learn more about OData features supported in CAP.](../../../advanced/odata#overview){ .learn-more}

### Remote Services <Beta />

You can now configure Remote Services, which are CQN-based clients to remote OData V2/V4 APIs.

[Learn more about Remote Services.](../../../java/cqn-services/remote-services){ .learn-more}

### Performance Improvements

- The performance of cascading delete operations has been improved on acyclic delete graphs.
- The performance of upserts has been improved by using batch delete.

### CDS.ql

- CDS.ql update and delete statements support now path expressions in the *entity* resp. *from* clause.
- `CQL.matching` allows to build a [query-by-example](../../../java/working-with-cql/query-api#using-matching) style predicate, which can be used in infix filters and where clauses.

### Remove Values From Data Maps

You can now also use the `CDSDataProcessor` [converters](../../../java/cds-data#cds-data-processor) to remove values from data maps.

<div id="secondary-file">releases/archive/2021/feb21.fragment.md</div>

# January 2021


### New and Revised Guides

- New guide [Project-Specific Configurations](../../../node.js/cds-env) for the Node.js runtime has been created, which also apply for `@cds-compiler` and `@sap/cds`.

- Documentation for [`cds build` configuration](../../../guides/deployment/custom-builds#build-config) is now available.  This is useful for projects that deviate from the standard folder layout.

### Improved Navigation

We take feedback seriously and therefore we've improved the navigation in our documentation. The section you're currently in will be now highlighted in the navigation on the left-hand side.

### Real-Time Search

The search ranking algorithm has been updated to show more accurate results. Additionally, capire can now be searched in real-time.

Full-text search results will be automatically highlighted and the scroll position is adjusted to display the first result.

## Command Line / Toolkit { #cds-dk}

### Important Changes❗️ { #changes-in-toolkit .important }

Both, preview for SAP Fiori and the `--with-mocks` option of `cds run`, are now disabled if `NODE_ENV` environment variable is set to `production`.  These features are meant to help you during development and should not be used in productive applications.

You can still enable them with `cds.features.fiori_preview: true` and `cds.features.mocked_bindings: true`, respectively.  As an example, this is how can you configure them in your project's _package.json_:

```json
"cds": {
  "features": {
    "fiori_preview": true,
    "mocked_bindings": true
  }
}
```

### Create Projects with Multitenancy Support <Beta />

With `cds init --add mtx`, you can now create projects that are configured for multitenancy right from the start.  This includes both, runtime and deploy configuration.<br>
In a future version, we'll also allow augmenting existing projects with `cds add mtx`.

## CDS Editors & Tools

> The following features are available for all editors
> based on our language server implementation for CDS in
> SAP Business Application Studio, Visual Studio Code, and Eclipse.
> The plugins are available for download for Visual Studio Code at [Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=SAPSE.vscode-cds#overview) and for Eclipse at [https://tools.hana.ondemand.com](https://tools.hana.ondemand.com/#cloud-vscodecds).

### Renaming VS Code Extension for CDS Language

The extension _SAP Cloud Platform core data services plug-in for Visual Studio Code_ was renamed to _SAP CDS Language Support_.

![](./assets/jan21/Marketplace.png){}

Learn more about the [features and commands](../../../tools/cds-editors) in the documentation and watch this short [video](https://www.youtube.com/watch?v=eY7BTzch8w0).

 

## Node.js Runtime { #cds-js}

### Important Changes ❗️ { #changes-in-node-js .important }

The following changes affect undocumented internal implementations, and hence shouldn't affect CAP-based projects. Nevertheless, they're listed here for your reference.

- Support for deprecated config `cds.auth.passport` was removed. Use `cds.requires.auth` instead.
- `@sap/cds-reflect` is no longer maintained. Use the reflection API of [`@sap/cds`](https://www.npmjs.com/package/@sap/cds) instead.

The following private APIs and configuration options are deprecated and will be removed in the future. Make sure you remove their usage.

- `req.run(...)`: use `cds.db.tx(req).run(...)` instead
- `cds.runtime.skipIntegrity`: use `cds.env.features.assert_integrity = false` instead or add annotation `@assert.integrity: false` at the respective service, entity, or association
- `cds.runtime.skipWithParameters`: use `cds.env.features.with_parameters = false` instead

### Logging <Beta />

`cds.log()` is used throughout the Node.js stack, including the inherited `@sap/odata-server`. This results in some changes to the log format. In general, more information is available in the logs. See section [cds.log()](../../../node.js/cds-log) for more details.

Further, text keys are replaced by their language-independent texts before logging, for example, the message "MULTIPLE_ERRORS" will be replaced by the text in the language-independent text bundle with the key `MULTIPLE_ERRORS`, for example, "Multiple errors occurred. See the details for more information.".

### Protecting OData Metadata by Default

OData metadata endpoints -- that means, the service root `/` and the metadata endpoint `/$metadata` -- are protected by default if the respective service is protected through annotation `@requires`. This default protection can be deactivated through `cds.env.odata.protectMetadata = false`.

### SAP HANA

We've improved the robustness and observability of our SAP HANA usage, respectively its drivers:

- When using `hdb` (CAP's preferred option), the client is additional validated based on its error history. In turn, the automatic reconnect was removed as it can cause more harm in certain situations, which can't be safely determined in the application layer.
- Improved error login case of a timeout with a [service unavailable error](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503) being returned to the client indicating it shall retry.
- The effective pool configuration is logged with level `info`.

Further, it's now possible to skip SAP HANA's localization feature (`WITH PARAMETERS ('LOCALE' = '<locale>')`) through `cds.env.features.with_parameters = false`. As this is a rather costly feature, we recommend doing so if it isn't needed.

### Generic Providers

The generic input validation was extended to include the typed parameters of actions and functions, excluding `array of` constructs.

Runtime-based integrity checks can now be deactivated through annotation `@assert.integrity: false` on entity and service level (additional to on association level) or global config `cds.env.features.assert_integrity = false`.

With regards to the draft choreography for SAP Fiori UIs, the Node.js runtime now supports the scenario "all active", that means, reading all active versions even of those entities where a draft exists. Further, the result of a draft activation is no longer expanded by default.

##### Miscellaneous

- ETag added for expanded entities
- Upsert target of to-one containment with foreign key in parent during deep update
- Server-side pagination when serving to REST

### Service Consumption

On an HTTP error (that means, status code 4xx) during remote service consumption, the error gets logged and a [bad gateway error](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502) is returned to the client. This helps identifying that the error originates in a remote app. Further, the details of the original error may disclose information that shall not reach the client.

##### Miscellaneous

- Support for filter on `null` values in service consumption
- The default query option `$format` was removed for `GET` requests to remote OData services

## Java SDK { #cds-java}

### Important Changes ❗️ { .important #important-changes-in-java}

#### Fixed

- Composite entities that are auto-exposed by the CDS Compiler can't be accessed directly by a request, if they aren't explicitly contained in the service definition.
- Associated entities that are auto-exposed by means of `@cds.autoexpose` are now read-only, if they aren't explicitly contained in the service definition.
- Draft administrative data is now created only _once_ per deep draft document. Thus, changes in child entities are reflected directly in the common draft administrative data.

#### Deprecated

- The error messages for constraint violations have been improved by distinguishing not null constraint violations from unique constraint violations. With that, the previous general error code `409001` (`CONSTRAINT_VIOLATED`) has been deprecated and is replaced by the more specific error codes `409003` (`VALUE_REQUIRED`) and `409006` (`UNIQUE_CONSTRAINT_VIOLATED`).
- Renamed the configuration property `cds.datasource.serviceName` to `cds.datasource.binding` (previous name is deprecated, but still available).
- Renamed the configuration property `cds.security.xsuaa.serviceName` to `cds.security.xsuaa.binding` (previous name is deprecated, but still available).
- Added a new API to retrieve authentication information, for example the JWT token of the current user. It can be accessed by means of `CdsRuntime.getProvidedAuthenticationInfo()`. The new API replaces the former internal `AuthenticatedUserClaimProvider`.

### Native OData V2 Adapter GA

The native OData V2 is now generally available and can be used productively. We added the following features in this version:

- Support read requests with [Parameterized Views](../../../advanced/hana#views-with-parameters).
- Support path expressions in `$filter` conditions. This allows filtering expanded deep documents based on conditions for properties in child entities. Note that the filter applies to the entire document in this case.
- Support multiple expands within a single query.
- OData V2 now provides `__deferred` links for unexpanded navigation properties.

Also, the [cds-services-archetype](../../../java/developing-applications/building#the-maven-archetype) now supports creating new CAP Java projects with OData V2 support.

### Keys Contained in Data Accessor Objects

Key values contained in an OData `PATCH` or `PUT` request can now be accessed by means of the [data accessor objects](../../../java/cds-data#generated-accessor-interfaces) passed to event handlers.

Previously, you had to use the following code to extract the keys of the entity that is updated:

```java
@Before(event = CdsService.EVENT_UPDATE)
public void updateOrderItem(CdsUpdateEventContext context, OrderItems orderItem) {
    // access ID of orderItem
    String orderItemId = (String) CqnAnalyzer.create(context.getModel()).analyze(context.getCqn()).targetKeys().get(OrderItems.ID);
    // use it...
}
```

Now, you can achieve this much easier:

```java
@Before(event = CdsService.EVENT_UPDATE)
public void updateOrderItem(OrderItems orderItem) {
    // access ID of orderItem
    String orderItemId = orderItem.getId();
    // use it...
}
```

### Maven Build Improvements

- The goal `install-cdsdk` of the [cds-maven-plugin](../../../java/developing-applications/building#cds-maven-plugin) provides a new command line argument:

  ```yaml
  cds.install-cdsdk.force=true
  ```

  to enable updating the _cds-dk_ (see also [Maven Build Options](../../../java/developing-applications/building#maven-build-options)
- The [cds-maven-plugin](../../../java/developing-applications/building#cds-maven-plugin) now validates the installed version of _cds-dk_ and reports an error for outdated installations.

### Messaging Foundation <Beta />

It's now possible to use technical [messaging services](../../../java/messaging) with `cds.java@1.13.0`.

### CDS.ql Runtime

- The [CDS Data Processor API](../../../java/cds-data#cds-data-processor) <Beta /> allows to validate, convert, and generate CDS data.
- [Indexed parameters](../../../java/working-with-cql/query-execution#parameterized-execution) are introduced as replacement for the deprecated positional parameters.
- The new [@cds.java.name](../../../java/cds-data#renaming-elements-in-java) annotation allows to define custom names for elements to be used when generating Java interfaces.
- Improve performance of deep update.
- Improve performance of search on SAP HANA: The SQL rendering for search on SQL backends has been changed for localized elements, besides in the user's language texts are now additionally searched in the default language. This optimization requires the `localized` association to the texts entity in the CDS model. See section [Behind the Scenes](../../../guides/localized-data#behind-the-scenes) for more details.
- Draft: Deletion isn't cascaded anymore to the `DraftAdministrativeData` of a non-root draft entity, because one deep draft document shares a single `DraftAdministrativeData` entity now.

### CDS Reflection API

- Support for Events referencing other Events, Entities, and Structured Types
- Support for Aspects

### Bug Fixes

- Fix projection resolvement of aliased to-many associations
- Fix SQL exception on updates having only key values as data
- Fix NoSuchElementException when using binary elements in where condition



# All of 2020



<br>
<IndexList :pages='pages' />




# November 2020


### Revamped _cap/samples_

Our **[cap/samples](https://github.com/sap-samples/cloud-cap-samples)** received another cleanup and overhaul. Things added include:

- Authorization enabled by default now, also showcased in [@capire/reviews](https://github.com/sap-samples/cloud-cap-samples/tree/main/reviews)
- Additional Fiori app in [@capire/orders](https://github.com/sap-samples/cloud-cap-samples/tree/main/orders) (moved there from [@capire/fiori](https://github.com/sap-samples/cloud-cap-samples))
- Additional Vue.js apps in [@capire/orders](https://github.com/sap-samples/cloud-cap-samples/tree/main/orders) and [@capire/reviews](https://github.com/sap-samples/cloud-cap-samples/tree/main/reviews)
- Messaging between [@capire/bookshop](https://github.com/sap-samples/cloud-cap-samples/tree/main/bookshop), [@capire/orders](https://github.com/sap-samples/cloud-cap-samples/tree/main/orders), and [@capire/reviews](https://github.com/sap-samples/cloud-cap-samples/tree/main/reviews)
- Reuse & Compose / mashups showcased in [@capire/fiori](https://github.com/sap-samples/cloud-cap-samples/tree/main/fiori)



[Learn more in the new **_Reuse & Compose_** guide](../../../guides/extensibility/composition){ .learn-more}

### New and Revised Guides

- The guide [Domain Modeling with CDS](../../../guides/domain-modeling) received a major overhaul with several additions, also about things added in latest releases. &rarr; worthwhile a revisit, in particular the sections about aspects, which were missing before.

- New guide [Providing & Consuming Services](../../../guides/providing-services) has been created from merged, revised, and complemented content of the former separate guides on _Providing Services_ and _Consuming Services_.

- The guide [Using Generic Providers](../../../guides/providing-services) was taken out from the former _Providing Services_ guide and promoted to a top-level cookbook guide.

- New guide [Reuse & Compose](../../../guides/extensibility/composition) introduces how to compose enhanced, verticalized solutions by reusing content from other projects, and adapt it to your needs by adding extensions or projections.

- The guide on [Managing Dependencies](../../../node.js/best-practices#dependencies) moved from the _Getting Started_ sections to _Node.js Best Practices_.

### Provide Feedback for the Documentation

You can now provide feedback or report issues regarding the documentation directly from capire. Just click on the envelope icon on the right-hand side and follow the link to SAP Q&A. Give us as much information as possible in the pre-filled SAP Q&A form to enable better processing of your feedback.

## Command Line / Toolkit { #cds-dk}

### Export to OpenAPI

You can now convert CDS models to the [OpenAPI Specification](https://www.openapis.org), a widely adopted API description standard.
For example, this is how you convert all services in `srv/` and store the API files in the `docs/` folder:

```sh
cds compile srv --service all -o docs --to openapi
```

[Learn more about the export to OpenAPI.](/advanced/publishing-apis/openapi){ .learn-more}

### CAP Jupyter Notebooks

You can now add a **CAP Jupyter Notebook** to your CAP project.

A **CAP Jupyter Notebook** is a [Jupyter Notebook](https://jupyter.org) that serves as a guide on how to create, navigate and monitor CAP projects.

With this, we want to encourage the CAP community to work with CAP in the same explorative manner that scientists work with their data by:

- Visually interacting with their code
- Playing with REPL-type inputs (notebook input cells)
- Storing persistent code (notebook output cells)

The cell inputs/outputs are especially useful at later points in time when the project's details have long been forgotten. In addition, notebooks are a good way to share, compare and also reproduce projects.

![](./assets/cap-jupyter-notebooks.gif){}
<em>Opening and interacting with a **CAP Jupyter Notebook** in Visual Studio Code</em>

### Start with Different Ports on Node.js

By default, Node.js apps started with `cds run` or `cds watch` use port 4004, which might be occupied if other app instances are still running.  In this case, `cds watch` now asks you if it should pick a different port.

<pre class="log">
$ cds watch
...
[cds] - serving CatalogService ...

<em>EADDRINUSE - port 4004 is already in use. Restart with new port? (Y/n)</em>
> y
restart
...
[cds] - server listening on { url: 'http://localhost:<em>4005</em>' }
</pre>

Ports can be explicitly set with the `PORT` environment variable or the `--port` argument.  See `cds help run` for more.



## CDS Editors & Tools

> The following features are available for all editors
> based on our language server implementation for CDS in
> SAP Business Application Studio, Visual Studio Code, and Eclipse.
> The plugins are available for download for Visual Studio Code at [Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=SAPSE.vscode-cds#overview) and for Eclipse at [https://tools.hana.ondemand.com](https://tools.hana.ondemand.com/#cloud-vscodecds).

### Native Submenus (Visual Studio Code only)

With VS Code 1.50, the editor supports native submenus. The CDS preview commands can now be accessed directly in the editor for an open CDS file.

![](./assets/nativeSubmenu.gif){}

In SAP Business Application Studio you can access the submenu entries by using menu `View` / `Find Command...` and then type `cds preview` to narrow the search to the applicable commands.

![](./assets/previewCommandsBAS.png){}

### Quickfixes for Deprecated Identifiers

Compiler warnings for deprecated identifiers wrapped in double quotes now show a quickfix to convert those into the modern form wrapped in `![...]`.

### Framework Support for Quickfixes in Annotation Handler

Annotation handler can now contribute quickfixes.

## Node.js Runtime { #cds-js}

### Important Changes ❗️{ #changes-in-node-js }

- CREATE and UPDATE requests that aren't allowed due to `@restrict.where` are rejected with `403` instead of `404`
- Internal `req.run()` is deprecated and will be removed. Use `cds.db.tx(req).run()` instead.
- Internal `req._model` is deprecated and will be removed. Use `tx.model` instead.
- Internal `req.statements` was removed. Use `cds.ql` instead.

<br><br>
The following features, marked with _Experimental:_ are brand new, more comprehensive documentation will follow:

### Experimental: `cds.context` <Beta />

- `cds.context` always allows access to the current request context when running in Node v12.18 and higher. It uses [Node.js' `async_hooks` API for so-called continuation-local storage](https://nodejs.org/api/async_hooks.html), and supercedes the need for `srv.tx(req)` in custom handlers (can be used with Node.js 12.18 or later).

### Experimental: `cds.log` <Beta />

- `cds.log` is a minimalistic logging framework, by default using `console`, which we'll use in all parts of CAP runtime, and which allows to plug in other logging framework like Winston, Bunyan, Morgan or other.

### Experimental: Convenience API on `cds.Service`

For actions and functions (unbound and bound), a convenience function is added to the respective instance of `cds.Service` / `cds.Service` subclass (if the name doesn't clash).

For example, if you have a remote service with an unbound action `cancelOrder(ID: UUID)`, you can invoke it like this:

```js
const remote = await cds.connect.to('remote')
await remote.cancelOrder('<the order ID>')
```

_Note_{ .tip-title}
The implementation has to take care of returning the correct response format, for example, an integer, an array of a type, etc.
{ .tip}

### Tracing Database Statements with Dynatrace

The Node.js runtime supports tracing database statements with Dynatrace (n/a for SQLite).

### Custom Aggregates in OData

[_Custom aggregates_](../../../advanced/odata#custom-aggregates) can be used in `$apply`.

### Correlation ID Header Are Propagated to Subrequests

If an incoming HTTP request has header `x-correlation-id`, all resulting subrequests provide access to the ID via `req.headers['x-correlation-id']`.

### Miscellaneous

- New helper function `cds.utils.uuid()` to generate UUIDs
- Service consumption: Cloud SDK logs are only printed in debug mode
- Draft: Lock active entity on edit action to prevent duplicate drafts

## Java SDK { #cds-java}

### Important Changes ❗️{ #important-changes-in-java}

The OData comparison operators `eq` and `ne` are now mapped to the CQL [comparison operators](../../../java/working-with-cql/query-api#comparison-operators) `CqnComparisonPredicate.IS` and `IS_NOT`, respectively, providing two-valued comparison semantics. If a query is [introspected](../../../java/working-with-cql/query-introspection) with the `CqnAnalyzer`, this change is automatically taken into account.

### OData V2 (RC1)

The [OData V2 adapter](../../../java/migration#v2adapter) is now available as a first release candidate. Features that were added in this version are:

- You're now able to return messages that are shown in Fiori UIs by means of the CDS Messages interface as already available for OData V4, see [Indicating Errors](../../../java/event-handlers/indicating-errors) for more details.
- You can now use actions, so called "Service Operations", with complex return types.

### OData V4 Analytics

We made large progress with adding more analytics features for OData V4:

- OData V4 $apply now supports the transformations [skip, top, and orderby](../../../advanced/odata#transformations).
- OData V4 $apply now supports the transformation [concat](../../../advanced/odata#transformations) (not to be combined with other system query options).
- OData V4 $apply now supports [custom aggregates](../../../advanced/odata#custom-aggregates) with aggregation methods declared by `@Aggregation.default`.

### Logging and Tracing

The CAP Java SDK now logs single queries contained in an OData batch request separately. This feature enables fine-grained debugging but could cause increased log output. Therefore, you can disable this feature by setting the log level to "Warning" on the following log components:

```yaml
com.sap.cds.adapter.odata.v2.BatchAccess=WARN
com.sap.cds.adapter.odata.v4.BatchAccess=WARN
```

### Datasource and Environment Configuration

You can now configure the connection pools of datasources, which are auto-configured by CAP Java SDK based for bound services using the following property in _application.yaml_:

```yaml
cds.dataSource.<service-name>.hikari.<hikari-property>=...
```

In addition, you can configure a dedicated _default-env.json_ file for each Spring profile with:

```yaml
cds.environment.local.defaultEnvPath=...
```

This enables using different service bindings / credentials for services for each Spring profile.

### Multitenancy: Fast Unsubscribe and Resubscribe

It's now possible to unsubscribe a tenant and resubscribe without delay. This feature enables stress testing of your tenant subscription logic.

### CDS.ql

- The [comparison operators](../../../java/working-with-cql/query-api#comparison-operators) `IS` and `IS NOT` now allow to compare any two values for [in]equality. NULL values are treated as any other value in the comparison, in contrast to the `EQ` and `NE` operators, where NULL values might be treated as unknown depending on the underlying datastore. Corresponding builder methods `is(Value other)` and `isNot(Value other)` are added to the Value interface.

- Initial support for [arrayed elements](july20#arrayed-elements) with simple and structured types.

### Bug Fixes

- Projection Resolvement: Support aliased elements in infix filters and filtered updates
- Fix `isPredicate` and `asPredicate` methods of `CqnPredicate`
- Fix using `isNull` on elements of associated entities



# September 2020



## Command Line / Toolkit{ #cds-dk}


### Interactive Commands in `cds watch`

After `cds watch` has started, you can type commands like:
- `<enter>` or `rs` to restart the application
- `ps` to show a simple list of the involved processes with their IDs
- `debug` to enter debug mode (see below)
- `bye` or <kbd>Ctrl</kbd> + <kbd>C</kbd> to stop watching


### Debug Handler Code with `cds watch`

Start `cds watch` and enter `debug`. This restarts the application in debug mode. Similarly, `debug-brk` will start debug mode, but pause the application at the first line, so that you can debug bootstrap code.

If you do this in VS Code's integrated terminal with the 'Auto Attach' feature enabled, debugging starts right away:
![Debug with cds watch](./assets/debug-with-cds-watch.gif){}

If you executed `cds watch` on a standalone terminal, you can still attach a Node.js debugger to the process.

For example:
- In VS Code, use the _Debug: Attach to Node Process_ command.
- In Chrome browser, just open [chrome://inspect](chrome://inspect) and click _Inspect_.


## CDS Editors & Tools

### Editing OData Annotations

There is a new plugin for the editor, which helps you add and edit OData annotations in CDS syntax. The OData annotation plugin supports the following features:
- [Code completion](../../../advanced/fiori#code-completion) for annotations applied to entities and entity elements]
- [Validation against](../../../advanced/fiori#diagnostics) the OData vocabularies and project metadata
- [Navigation](../../../advanced/fiori#navigation-to-referenced-annotations) to the referenced annotations
- [Quick view](../../../advanced/fiori#documentation-quick-info) of vocabulary information
- [Internationalization (i18n) support](../../../advanced/fiori#documentation-quick-info) for language dependent strings

<br />
The following features are available for all editors
based on our language server implementation for CDS in
SAP Business Application Studio, Visual Studio Code, and Eclipse.
The plugins are available for download for Visual Studio Code at [Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=SAPSE.vscode-cds#overview) and for Eclipse at [https://tools.hana.ondemand.com](https://tools.hana.ondemand.com/#cloud-vscodecds).


### Plugin Support for Domain-Specific Annotation Handlers

The editor now contains a plugin framework for semantical annotation editing. A first plugin for OData annotations will be available in the coming weeks and installed automatically.

All features are additional to the existing ones but provide semantical refinements. Among the features are:

  - Diagnostics (semantical markers like errors, warning etc.)

      ![](./assets/anno_diags.png){}

  - Code completion for the supported annotation domain, including details where available.

      ![](./assets/anno_completion.png){}

  - Hover information

      ![](./assets/anno_hover.png){}

  - Go to definition of certain annotation keys or values.

      ![](./assets/anno_goto_opt.gif){}

  - _Quickfix_ to convert a simple text value into a translation key and create a corresponding translation pair in the translation file.

    ![](./assets/anno_quickfix_opt.gif){}


Plugins to this framework are automatically installed.
Updates to plugins will be fetched in the background and are in place after restart.
Use a user setting, to override the default npm registry from which you get the plugins, for example in private cloud environments.

Inside annotation values code completion is also triggered using `/` character, next to `.`, and `@`.


### Formatting of Code Snippets

Snippets applied using code completion are now formatted according to the user defined formatting settings.

![](./assets/snippet_format_opt.gif){}


### Quickfixes in _Problems_ View

Quickfixes are now accessible in diagnostic popups and in the _Problems_ view.
![](./assets/anno_qf_problems.png){}

Some quickfixes are now _preferred_, allowing an even quicker access using specific keyboard shortcut.

![](./assets/anno_qf_pref.png){}


### More Code Navigations

Code navigation to go to the definition or find references are now available for `action`s, `function`s, and their parameters.


### Release Notes in VS Code
The release notes are now displayed when a new version is available on ../../../releases/.


### Command to Check and Install @sap/cds-dk Globally in VS Code
The command __install CDS Development Kit (@sap/cds-dk) globally__ is now available to check for updates and install __@sap/cds-dk__ globally on your machine.


## CDS Language & Compiler { #cds}

### Simplified type references

When referencing types of elements, the `type of` keyword was mandatory - this is no longer the case.
Previously, only the following was valid:

```cds
entity Foo {
  key id: Integer;
}

entity Bar {
  key id: type of Foo:id;
}
```

`Bar` can now be rewritten like this:
```cds
entity Bar {
  key id: Foo:id;
}
```

See [CDL > Type References](../../../cds/cdl#type-references) for more details.

### cast(element as Type)

The compiler now supports the `cast(element as Type)` function in queries. Using this function will also result in a `CAST` SQL function call.
The `element as alias: Type` syntax is still supported, but will not result in SQL `CAST` calls.

In CDL, the cast looks like this:

```cds
view V as select from E {
  cast( element as String ) as castedElement,
  element as cdlCastedElement: String
};
```

In CSN, it looks like this:

```JSON
"columns": [
    {
      "xpr": [
        {
          "ref": [
            "element"
          ],
          "cast": {
            "type": "cds.String"
          }
        }
      ],
      "as": "castedElement"
    },
    {
      "ref": [
        "element"
      ],
      "as": "cdlCastedElement",
      "cast": {
        "type": "cds.String"
      }
    }
  ]
```

Which will ultimately result in the following SQL:

```SQL
CREATE VIEW V AS SELECT
  CAST(E_0.element AS NVARCHAR(5000)) AS castedElement,
  E_0.element AS cdlCastedElement
FROM E AS E_0;
```

## Node.js Runtime { #cds-js}

### Important Changes ❗️{ #changes-in-node-js }


### Structured Elements in OData V4 for APIs

The Node.js runtime now offers native support for structured elements in OData. Entities modelled as structured in CDS can now be queried with OData without using the 'underscore notation'  and the result returned will be a structured object instead of the previously flattened result. To enable structured mode the [`odata.flavor = x4` flag](../../../node.js/cds-env#project-settings) needs to be set.

Structured:

```http
GET /Books?$filter=author/ID eq 5
```

```JSON
{
    author : {
      ID: 5
    },
    ...
}
```

Unstructured:

```http
GET /Books?$filter=author_ID eq 5
```

```JSON
{
    author_ID: 5,
    ...
}
```

Supported features included:
   - Structured elements in `$orderby`, `$filter`, and `$select` queries
   - Assertions in structured data
   - Navigating to association to-one in structured


### Miscellaneous

- Generic input validation also apply to actions and functions.
- Support for `@assert.notNull: false`
- Support for annotation `@Capabilities.ReadRestrictions.Readable`
- Messaging: An ID is automatically generated for each message (`headers.id`).
- Support for custom timezone offset in OData queries (2020-09-27T22:07:00Z and 2020-09-27T21:07:00+01:00).



## Java Runtime { #cds-java}

### Important Changes ❗️{ #important-changes-in-java}

The module `cds-services-impl` isn't a compile time dependency anymore. This prevents application developers from using internal APIs. Applications that already use methods and classes from `cds-services-impl` will experience compile time errors like `error: cannot find symbol`. Thus, application developers need to switch to public APIs only provided by module `cds-services-api`.


### Native OData V2 Adapter (Beta)

The CAP Java runtime now supports OData V2 natively. Despite not yet GA, this feature is ready to be tested by early adopters. In order to use the OData V2 adapter, add the following dependency to your *pom.xml* file:

```xml
<dependencies>
    <dependency>
        <groupId>com.sap.cds</groupId>
        <artifactId>cds-starter-spring-boot</artifactId>
    </dependency>

    <dependency>
        <groupId>com.sap.cds</groupId>
        <artifactId>cds-adapter-odata-v2</artifactId>
    </dependency>

    ...

</dependencies>
```

Note, that currently you can't use the OData V2 and OData V4 adapter at the same time. We'll support this in an upcoming CAP Java release. Therefore, remove the following dependency from your project:

```xml
    <dependency>
        <groupId>com.sap.cds</groupId>
        <artifactId>cds-starter-spring-boot-odata</artifactId>
    </dependency>
```

In addition, make sure to change the OData version of your CDS build configuration to `v2` in _.cdsrc.json_ or _package.json_, so that the correct EDMX is generated for the OData V2 adapter.


### SAP Fiori Drafts with Timeouts

By default, SAP Fiori drafts that aren't activated or updated are now automatically garbage collected after a timeout of 30 days. For example, this is useful when users that have created inactive draft entities don't exist anymore.

The timeout is configurable by application configuration. The following example extends the timeout to 8 weeks:

```yaml
cds.drafts.deletionTimeout: 8w
```

This feature can be also turned off completely by setting the application configuration:

```yaml
cds.drafts.gc.enabled: false
```

See [Java > Garbage Collecting Drafts](../../../java/fiori-drafts#draft-gc) for more details.


### OData V4 Lambda Operators

The OData V4 adapter supports [OData Lambda operators](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31361024) `all` and `any`:

```http
http://host/service/Authors?$filter=books/any(b:b/year eq 2000)
```

### Export Default Error Messages

It's now possible to export the default error messages thrown by the CAP Java runtime to a resource bundle file for further processing (for example, to customize or to translate error messages). See [Java > Indicating Errors](../../../java/event-handlers/indicating-errors) for more details.

### AllMatch/anyMatch Predicates

Allow to [filter by values](../../../java/working-with-cql/query-api#any-match) of elements in an associated collection through the Builder API methods `.anyMatch(<predicate>)` and `.allMatch(<predicate>)`. For example this query selects authors that have written _any_ book in the year 2000:

```java
Select.from(AUTHORS).where(a -> a.books().anyMatch(b -> b.year().eq(2000)));
```

### Entity References from Query Result

Simplify writing queries on the source entity of another query's result using [entity references](../../../java/working-with-cql/query-execution#entity-refs) that can be obtained through the result row's `ref()` method:

```java
CqnSelect query = Select.from(AUTHOR).byId(101);
Author authorData = service.run(query).single(Author.class);

// Author[101]
Author_ author = authorData.ref();

// SELECT from Author[101].books where year = 2000
Select.from(author.books()).where(b -> b.year().eq(2000));
```

### Updatable Views

Execute deep insert/upsert operations through [updatable views](../../../java/working-with-cql/query-execution#updatable-views).

### Miscellaneous

- Support search by UUID
- The Reflection API now allows to check if a `CdsElement` is localized through the new `isLocalized` method.



# August 2020


## New and Revised Guides

- **[Java > Multitenancy]( ../../../java/multitenancy)**


## CDS Editors & Tools

> The following features are available for all editors
> based on our language server implementation for CDS in
> SAP Business Application Studio, Visual Studio Code, and Eclipse.
> The plugins are available for download for Visual Studio Code at [Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=SAPSE.vscode-cds#overview) and for Eclipse at [https://tools.hana.ondemand.com](https://tools.hana.ondemand.com/#cloud-vscodecds).

### Preview Commands (currently not in Eclipse)

The VS Code extension for the core data services (CDS) language now features a set of commands to generate a quick preview for a given `cds` file. By using this preview, you can get a quick glance at the code the `cds compiler` will generate.

![The graphic is explained in the accompanying text.](./assets/PreviewCommands.gif)

### Code Completion Proposes Global Identifiers

The editor includes proposals of identifiers found in the workspace that aren't yet imported in the current file.
    ![The graphic is explained in the accompanying text.](./assets/GlobalProposalsWithGeneratedUsing.gif){}

Enable global proposals:
    ![In your VS Code setting, set Cds > Completion > Workspace Symbols > Max Proposals to -1 and Cds > Completion > Workspace Symbols > Min Prefix Length to 0.](./assets/GlobalProposalsSettings.png){}

## CDS Language & Compiler{ #cds}

### Join Cardinality

CQL now allows to specify a join cardinality. Allowed are any combinations of
`{ [ EXACT ] ONE | MANY } TO { [ EXACT ] ONE | MANY }` for
`{ INNER | { LEFT | RIGHT | FULL } [ OUTER ] }` joins.
The cardinality is added in for SAP HANA generated CREATE VIEW statements.


### Unique Constraints

Support the creation of unique constraints by assigning `@assert.unique.<constraintName>` to non-query entities or query entities annotated with `@cds.persistence.table`. The value of the annotation is an array of paths referring to elements in the entity. The path leaf may be an element of a scalar, structured or managed association type. Individual foreign keys or unmanaged associations can't be accessed. In case the path points to a structured element, the unique constraint will contain all columns stemming from the structured type. In case the path points to a managed association, the unique constraint will contain all foreign key columns stemming from this managed association.

### Extended Projection Support


Projections columns can now use expressions like select items, both for `entity … as projection on` and `extend projection … with`.


### OData V4: array of `<structured>`

`array of <structure>` or `many <structure>` is now allowed in OData V4, flat format.

### Foreign Key Access and Association to Join Translation

The association to join transformation treats foreign key accesses with priority. If a foreign key of a managed association can be accessed without joins, no joins are generated. The priority handling can be turned of with option `joinfk`.

Before:

```sql
CREATE VIEW V AS SELECT
  managedAssociation_1.foreignKey
FROM (Source AS Source_0 LEFT JOIN Source AS managedAssociation_1 ON (Source_0.managedAssociation_foreignKey = managedAssociation_1.foreignKey));
```

After:

```sql
CREATE VIEW V AS SELECT
  Source_0.managedAssociation_foreignKey AS foreignKey
FROM Source AS Source_0;
```

### Extended Event Support

An event payload type can now be defined with a type/entity reference or a projection (instead of providing the elements directly).
Furthermore, aspects can now be included when specifying the elements of an event payload type, as it's known for type, entity and aspect definitions.
The directly provided elements of an event payload are now represented as `elements` in the CSN.

## Node.js Runtime{ #cds-js}

### Setting Headers for Remote Services

Headers can be set with `tx.emit` on remote HTTP services:

```js
const tx = service.transaction()
const resultUsingHeaders = await tx.emit({
    query: SELECT.from('Entity'),
    headers: { header1: 'content'}
})
```

See [Node.js > Core Service API]( ../../../node.js/core-services#srv-emit-event) for more details.

### Support for Privileged Users

With `cds.User.Privileged`, it's possible to bypass authorization checks while [consuming a local service]( ../../../node.js/core-services).
See [Node.js > Authentication]( ../../../node.js/authentication#privileged-user) for more details.


### Miscellaneous

- Support for `@sap/xssec^3`
- Support for `expand` with `*` in Query Language API


## Java Runtime { #cds-java}

### Important Changes ❗️{}

#### `UPSERT` event isn't used anymore!

Previously, OData V4 `PUT` requests triggered an `UPSERT` event on the corresponding CAP services. By default, the `UPSERT` event implements a `CqnUpsert` statement, which first triggers a cascading delete followed by a deep insert. This doesn't exactly match the semantics of a `PUT`.

Now, the OData V4 `PUT` follows the same pattern as `PATCH`, by:

1. First triggering an `UPDATE` event
2. Following a `CREATE` event if the entity didn't yet exist.

As the `UPDATE` event in CAP supports updating sparse data, the `PUT` operation also ensures to fill up unspecified values with `null` or their default values, as long as they can't be determined through a foreign key relation. In addition, a `PUT` request no longer affects the full composition tree of an entity, but only those parts of the entity that the `PUT` was sent to and those that are specified in the entity data.

**Action required:** If your application has been using `PUT` requests and therefore registering event handlers for `UPSERT`, you need to register event handlers for `CREATE` and `UPDATE` events instead! Note however, that an `UPSERT` event can still be triggered through the [local service consumption API]( ../../../java/services).

#### System User

- The name of the XSUAA system user (JWT with client credential flow) is now set to `system`.

### SAP Fiori Drafts

You can now use OData V4 `PATCH` and `PUT` requests to update and create active entities by specifying the key property `IsActiveEntity=true` in your OData URI. This skips the need to create an inactive draft entity first, which is useful when updating or creating an entity through technical APIs instead of SAP Fiori UIs. See [Java > Bypassing Fiori Draft Flow]( ../../../java/fiori-drafts#bypassing-draft-flow) for more details.

### SaaS Multitenancy

It's now possible to develop multitenant CAP Java applications with MTX Sidecar and Service Manager, see [Java > Multitenancy]( ../../../java/multitenancy).

### OData V4

The OData V4 protocol adapter now additionally supports applying a [_compute_](https://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016588){ target="blank"} transformation on the result of the _groupby_ or _aggregate_ transformations of $apply. Note: navigation properties aren't supported when using compute.

### Privileged User

A new option `privilegedUser()` can be leveraged when [defining]( ../../../java/event-handlers/request-contexts#defining-requestcontext) your own `RequestContext`. Adding this introduces a user, which passes all authorization restrictions. This is useful for scenarios, where a restricted service should be called through the [local service consumption API]( ../../../java/services) either in a request thread regardless of the original user's authorizations or in a background thread.

### Remote OData V2 / V4 Service Consumption (alpha)

CAP's [service consumption APIs]( ../../../java/services) are based on the protocol-agnostic CQN query language. So far, The CAP Java runtime only supported to run CQN queries against SQL databases out-of-the-box. By adding the newly introduced Maven dependency `cds-feature-remote-odata` to your CAP Java project, you can now enable CQN queries against remote OData V2 and V4 services. SAP Cloud SDK is used to execute the OData requests, which are compiled from the CQN query definition. In the current state only `CqnSelect` queries (`GET` requests) are supported.

You can enable a CDS service from your model as a local representation of a remote OData service, by simply adding a destination configuration to it:

```yaml
cds:
  services:
  - name: API_BUSINESS_PARTNER # name of the service in the CDS model
    destination:
      name: "s4-business-partner-api" # the destination, retrieved from SAP Cloud SDKs DestinationAccessor
      suffix: "/sap/opu/odata/sap" # an optional suffix appended to the destination's URL
      type: "odata-v2" # or odata-v4
```

> You can learn more about destinations in the [SAP Cloud SDK documentation](https://sap.github.io/cloud-sdk/docs/java/features/connectivity/sdk-connectivity-destination-service){ target="blank"}.

Afterwards, you can interact with the service like with any other database-backend service. See [Service Consumption API](../../../java/services) documentation for more details.

### Reflection API

- Support parsing the query definition of views with joins

### CDS Data Store

- Support select from subquery. Note: expand isn't supported in subqueries

### Bug Fixes

- The `cds-maven-plugin` doesn't use npm/npx from local installation cache anymore, if goal `install-node` is skipped or not configured. In this case, a globally installed npm/npx is required and used.
- Fixed a bug that caused a `NullPointerException` when calling an action or function, which returned a contained entity. With this fix, the OData V4 context URL for actions or functions returning an entity is now built based on entity types instead of entity sets.
- Fixed a bug that caused the `cds-maven-plugin` to determine a null working directory, in case the Maven project used an "external" parent project, not part of it's own source tree.
- Fixed a bug that caused an incorrect encoding of non-ASCII characters in `sap-messages` header
- Generate builder interfaces for services containing only actions/functions
- Fixed typed data access for arrayed types



# July 2020


## Important News and Changes❗️{  #important-changes }

### Streamlined Compiler Switched on by Default

The streamlined compiler implementation is switched on by default.
[Learn more in the **Compiler section** below](#cds){ .learn-more}

### Refactored Node.js Runtime --- Version 4

Behind the scenes of stable APIs the Node.js runtime implementation has been improved and refactored substantially.

[Learn more in the **Node.js section** below](#cds-js){ .learn-more}

### CLI Commands moved to `@sap/cds-dk`

To minimize the footprint of the Node.js runtime, close to all CLI commands have been moved out of `@sap/cds` and into `@sap/cds-dk` now.

[Learn more in the **CLI section** below](#cds-dk){ .learn-more}

### OData V2 Officially Supported

From now on, CAP officially supports OData V2 and SAP Fiori Elements UIs based on V2. In the beginning, we use the OData V2 proxy, which we'll integrate intrinsically in the long run to reduce TCO.

[Find details in the **Serving UIs guide**](../../../advanced/odata#v2-support){ .learn-more}

### SAP HANA Cloud Edition Supported Out-of-the-Box

Already since May, CAP provides out-of-the-box support for SAP HANA Cloud Edition.
No changes are required to models or code, only a single configuration is to be added [&rarr; see details in the **Databases** guide](../../../guides/databases-hana).

## New and Revised Guides

- **[About CAP](../../../about/)** &rarr; received another major overhaul
- **[Features Overview](../../../about/features)** &rarr; adjusted to latest additions
- **[Cookbook > Authorization and Access Control](../../../guides/security/authorization)**
- **[Java > Event Handlers](../../../java/event-handlers/)**
- **[Java > Application Services > Result Builder](../../../java/cqn-services/application-services#result-builder)**
- **[CDS > Node.js APIs](../../../node.js/cds-compile)** has been moved here from Node.js reference docs
- **[Cookbook > Extensibility](../../../guides/extensibility/)** has been moved here from _Advanced_

## Command Line / Toolkit { #cds-dk}

### CLI Commands Moved to `@sap/cds-dk`❗️ {}

As already started with the introduction of `@sap/cds-dk` in 2019, we now moved all CLI commands to the `-dk` packages, except for `run` and `serve`, which are used to launch Node.js runtime servers.
> Background: We want to drastically strip down runtimes to minimum footprint.

If you already followed the recommendations to install `cds-dk` globally and use that in your setups accordingly, this shouldn't affect you at all. Yet, in case you didn't, ensure to follow these steps to avoid pitfalls:

- **In Java projects**, use the new [cds-maven-plugin](../../../java/developing-applications/building#cds-maven-plugin); no other changes are necessary, as this plugin uses `@sap/cds-dk` out of the box.

- **In Node.js projects** with existing _mta.yaml_ files, replace all occurrences of `npx cds` with `npx -p @sap/cds-dk cds` in those files.

- **In freestyle CI setups**, either **(A)** install `cds-dk` prior to the execution of build commands, that is `npm i @sap/cds-dk && npm run ...`, or **(B)** add a dev dependency to your project, for example: `npm i @sap/cds-dk --save-dev`. <br/>
**Note:** (B) increases the installation time for every `npm install` call for every developer, so rather prefer option (A).

### Streamlined and Modularized `cds build`

Builds for Node.js and SAP HANA have been optimized for better performance. In addition, we renovated our build infrastructure to allow flexible customization using respective CLI options.

For example:

<pre class="log">
<i># choose specific build task</i>
<em>cds build</em> --for hana
<i># override task-specific options/defaults:</i>
<em>cds build</em> --for hana --opts model=[db,srv,schema.cds]
<i># build with production profile:</i>
<em>cds build</em> --production
<i># ...which is a shell-independent equivalent to:</i>
<b>NODE_ENV</b><i>=</i>production <em>cds build</em>
<i># Learn more with:</i>
<em>cds build</em> --help
</pre>

[See also how database configuration uses profiles.](../../../guides/databases-hana){ .learn-more}
[Learn more about Node.js configuration in general.](../../../node.js/cds-env){ .learn-more}

#### Deprecated/Obsolete

- `cds build/all` &rarr; simply use `cds build` instead.
- `cds build --clean` &rarr; is the default now.

### Using `await` in `cds repl`

We now support using `await` directly on `cds repl` prompt inputs.
For example:

<pre class="log">
[demo] cds repl
<em>Welcome to cds repl v4.1.5</em>
> m = <b>await</b> cds.load('*')
</pre>

[This feature is provided through Node.js _--experimental-repl-await_ option.](https://nodejs.org/api/repl.html#repl_await_keyword){ .learn-more}

## CDS Editors & Tools

> The following features are available for all editors
> based on our language server implementation for CDS in
> SAP Business Application Studio, Visual Studio Code, and Eclipse.
> The plugin for Eclipse is available for
> download at [https://tools.hana.ondemand.com](https://tools.hana.ondemand.com/#cloud-vscodecds).

### We Are on VS Code Marketplace --- Finally

Finally, the VS Code extension for the core data services (CDS) language can be installed now from the [Visual Studio Marketplace](https://marketplace.visualstudio.com/items?itemName=SAPSE.vscode-cds#overview). See [Getting Started > Tools](../../../tools/cds-editors#install-vscode) for more details. If the extension is already installed and enabled in VS Code, it will be updated automatically.

![The graphic is explained in the accompanying text.](./assets/Marketplace.png){}

### Welcome Page in VS Code

![The graphic is explained in the accompanying text.](./assets/WelcomePage.png){}

The VS Code extension now comes with a welcome page, which shows latest information about CAP. It starts automatically once whenever an update arrives for the extension. Later, you can open the page through the command `CDS: Show CAP Release Notes`.

### Issue Reporting in VS Code

![The graphic is explained in the accompanying text.](./assets/ReportIssue.gif){}

You can now ask questions or report issues directly from VS Code. Just open the `Report Issue` dialog, select the VS Code extension, and follow the link to [SAP Q&A](https://answers.sap.com/). Give us as much information as possible in the pre-filled SAP Q&A form to enable better processing of your report.

### Editor Support for _doc comments_ (`/** ... */`)

Hovering over a definition now displays _doc comments_, if available:

![The graphic is explained in the accompanying text.](./assets/MarkdownHover.png){}

As well as details for code completion:

![The graphic is explained in the accompanying text.](./assets/CompletionDetails.png){}

Use the `doc...` snippet to create a _doc comment_.
You can use _markdown_ to structure a _doc comment_.
Formatting also beautifies _doc comments_.

![The graphic is explained in the accompanying text.](./assets/MarkdownBeautify.gif){}

An _information hint_ informs you about deprecation of the `@cds.doc` annotation.
A _quick fix_ allows you to convert a _@cds.doc_ annotation into a _doc comment_.

![The graphic is explained in the accompanying text.](./assets/DocCommentQuickFix.gif){}

You can specify the maximum line length of _doc comments_ using the command `CDS: Show Formatting Option Configuration`. On the _Other_ tab, edit the option _Max doc comment line length_.

![The graphic is explained in the accompanying text.](./assets/MaxDocCommentLineOption.gif){}

For better visibility _doc comments_ are highlighted differently than standard block comments.

### QuickFix to Generate `using` Statements

You can now type an existing artifact name that isn't yet imported (through a `using` statement). A _quick fix_ for the error marker suggests possible artifacts from the workspace. Select the corresponding one to generate the `using` statement.
The new import is inserted or merged among existing `using` statements, sorted alphabetically. The `using` statement is formatted.

![The graphic is explained in the accompanying text.](./assets/ImportQuickFix.gif){}

### More CDS Editor Improvements

- **Semantic Code Completion** --- Code completion now also suggests identifiers for elements, enums, actions, and parameters in `annotate` and `extend` within `annotate` and `extend` statements.

- **Syntax highlighting for identifiers** --- Until now identifiers, including variants delimited with `\![...]`, haven't been classified so themes couldn't color them.

- **Related Info in Messages**:
![The graphic is explained in the accompanying text.](./assets/RelatedInfo.png){}

## CDS Language & Compiler { #cds}

### Streamlined Compiler by Default ❗️{ #snapi-default}

The [already mentioned](feb20#snapi) streamlined compiler implementation is now used by default. This new implementation brings significantly improved performance in compilation and bootstrapping servers, as well as reduced memory consumption at runtime.

In the unlikely case that the new default causes problems in your project, you can switch back as follows in your _package.json_ or _.cdsrc.json_:

```json
  "cds": {
    "features": { "snapi": false }
  }
```

> **Note:** This fallback option will be offered **only for a limited grace period**. Make sure to switch to snapi as soon as possible.

### Managed Compositions for Improved Domain Modeling

We deliver a major improvement to [keep your domain models **concise** and **comprehensible**](../../../guides/domain-modeling#keep-it-simple-stupid). Use [Managed Compositions](../../../cds/cdl#managed-compositions) to nicely reflect document structures, without the need for separate entities, reverse associations, and unmanaged `on` conditions. For example:

```cds
entity Orders { ...
  Items : Composition of many { ...
    product : Association to Products;
    quantity : Integer;
  }
}
```

Managed Compositions are especially handy for many-to-many relationships:

```cds
entity Teams { ...
  members : Composition of many { key user: Association to Users; }
}
entity Users { ... }
```

And here's an example of an attributed many-to-many relationship:

```cds
entity Teams { ...
  members : Composition of many {
    key user : Association to Users;
    role : String enum { Lead; Member; Collaborator; }
  }
}
entity Users { ... }
```

[Learn more in the CDS Reference Documentations](../../../cds/cdl#managed-compositions){ .learn-more}

> **IMPORTANT: CSN not stable yet**. --- Means: While you can safely use Managed Compositions as shown above, don't rely on the current CSN output of for example, `cds compile` for managed compositions, as that may change. {}

### Arrayed Elements in Entities to Avoid Joins { #arrayed-elements}

You can now declare arrayed elements in entities using keywords `many` or `array of`:

```cds
entity User { ...
  emails: many { kind:String; address:String }
}
```

Arrayed elements are stored as JSON-stringified values in single NCLOB columns in relational tables.
[Node.js runtime already supports this generically](#node-js-arrayed-elements); Java will follow.

**Performance Benefits** ---
On the one hand, this removes a lot of clutter from your models. On the other hand, and even more important, it greatly improves performance during data access. This results from eliminating a lot of joins to separate entities.

[See also: Feature Matrix](../../../about/features#providing-services){ .learn-more}
[See also: Avoid Overly Normalized Models in the Domain Modeling Guide](../../../guides/domain-modeling#use-custom-types-reasonably){ .learn-more}
[Learn more in the CDS Reference Documentations](../../../cds/cdl#arrayed-types){ .learn-more}

### Structs and Associations in `on` Conditions

We now allow comparing struct elements and managed(!) associations in on conditions of other associations.
Have a look at the following example, which is only possible since this release:

```cds
entity Project { ...
  teams : Association to many Teams
    on teams.country = $self.country
    and teams.validity = $self.validity;
  country : Association to Country;
  validity : Validity;
}
entity Teams { ...
  country : Association to Country;
  validity : Validity;
}
type Validity : { _from:Date; to:Date }
```

> Both operands must be structurally compatible, that is both structures must be expandable to an identical set of leaf paths. Each leaf path must terminate on a builtin CDS scalar type. The original relational term of the form `s1 op s2` is replaced by the resulting expression `s1.leafpath_0 op s2.leafpath_0 (AND s1.leafpath_i op s2.leafpath_i)*` with i < n leaf paths.

### Enhanced Projection Clauses

You likely noticed already that [`as projection on`](../../../cds/cdl#as-projection-on) and [`as select from`](../../../cds/cdl#as-select-from) are mostly interchangeable alternatives, however the former should be preferred over the latter whenever you don't need the full power of SQL.

This is especially true when defining projections on entities from remote services in service consumption scenarios.
However, while in the past the following clauses weren't allowed, they're now:

- `where`
- `having`
- `group by`
- `order by`
- `limit`

For example, provided content of these clauses will be translated to respective query options in OData in [Service Consumption Scenarios](../../../guides/using-services).

[Learn more in the CDS Reference Documentations](../../../cds/cdl#as-projection-on){ .learn-more}





### Not Null for Parameters and Return Types

Parameters and return types can now also be declared to be `(not) null`.

## Node.js Runtime Version 4 ❗️ { #cds-js}

**Behind the scenes of given APIs** this release provides a broad range of major improvements. We removed inconsistencies, closed gaps and fixed several little glitches. In effect, release 4 is the basis for us to add new features and qualities faster than before, and at the same time gives you **more stable and more future-proof APIs**.

While **public, documented APIs weren't affected**, you might nevertheless have written code, which relied on internal interfaces and behaviors, which you should correct accordingly. &rarr; see [_Important Changes_](#node-important-changes) below.

We strongly recommend doing so, and to **upgrade as soon as possible**, as former releases will receive only critical bug fixes from now on.

### Important Changes ❗️{ #node-important-changes}

The following changes mostly affect **undocumented, internal interfaces**.

Eliminated `Promise` Voodoo
: Former versions did quite some magic, meant to ease [Promise Hell](https://medium.com/@pyrolistical/how-to-get-out-of-promise-hell-8c20e0ab0513){ target="blank"}. With broad availability of `async/await` this became useless overhead, removed in release 4.
Now, always call `cds.connect.to` with `await`:

```js
const srv = await cds.connect.to('some-service')
```

Eliminated `next()` Voodoo
: Before, the framework called `next()` implicitly if an `.on` handler returned `undefined`. Now, always call `next()` explicitly, either with `await`, or with `return`:

```js
this.on(..., async (req,next)=>{ /* ... */ await next(); /* ... */ })
this.on(..., (req,next)=>{ /* ... */ return next() })
```

[See revised docs for `.on` handlers](../../../node.js/core-services#srv-on-request){ .learn-more}
> **Fallback:** Set config `cds.features.implicit_next:true` to restore former behavior, but correct your handlers, as soon as possible.

#### Deprecated and Removed

- `req.user.has(<roles>)` &rarr; use [`req.user.is(<role>)`](../../../node.js/authentication#user-is) instead
- `req.user.<attr>` &rarr; use [`req.user.attr.<attr>`](../../../node.js/authentication#user-attr) instead
- `in-process-messaging` kind &rarr; in-process messaging is always enabled.
- `db.run(()=>{})` &rarr; use [`cds.run([...multiple queries])` instead.](../../../node.js/cds-ql#select)
- **init.js** variant `(db)=>{...}` &rarr; use `db.run([...multiple queries])` instead.
- **cds.ql**`.where('x',1)` or `.where('x','=',1)` &rarr; use [documented variants](../../../node.js/cds-ql#where) only

#### Important Fixes

- [`$user.<attr>` === `undefined`](../../../guides/security/authorization#user-attrs) erroneously evaluated to `true` &rarr; now it's `false`
- `$metadata` requests erroneously got authorization-checked &rarr; not anymore
- `@restrict` did permit all operations not mentioned, for example, the following annotation allowed all other operations, like _UPDATE_ or _DELETE_, for every user:

```cds
@restrict:[ {grant:'READ',to:'some-role'} ]
```

- `GET /Foo(1)/bar` erroneously translated to semi joins &rarr; now correctly yields:

```js
{SELECT:{from:{ref:[ { id:'Foo', where:[{val:1}] }, 'bar' ]}}
```

### Refactored and Enhanced [Core Services API](../../../node.js/core-services)

These enhancements are the main effects of the refactorings. They close many API gaps and glitches, and provides us with a clean core, for the things to come...

#### Classes `cds.Service`, `cds.Request`, and `cds.Event`

- [`cds.Service` is the common base class for all connected or provided services.](../../../node.js/core-services)
- [Instances of `cds.Request` represent synchronous requests.](../../../node.js/events#cds-request)
- [Instances of `cds.Event` represent asynchronous event messages.](../../../node.js/events#cds-event)

#### New Service and Request Methods

- [`cds.emit` for both, synchronous requests, and asynchronous event messages.](../../../node.js/core-services#srv-emit-event)
- [`req.warn,info,notify` allow to return messages with different severity](../../../node.js/events#cds-event-context)
- [_HTTP-style convenience methods_](../../../node.js/core-services#srv-send-request) complementing the [_CRUD-style ones_](../../../node.js/core-services#srv-run-query).

[Learn more about the refactored **Core Services APIs**](../../../node.js/core-services){ .learn-more}

### Streamlined, Extensible Bootstrapping by `cds.server`

The bootstrapping process has been greatly optimized, in particular by loading only one consolidated effective model, instead of many per service independently. In effect, both, **bootstrapping times**, as well as **memory consumption improve by magnitudes**, especially with larger projects.

In addition, the built-in `server.js` implementation has been redesigned, and allows to plug-in custom logic, without loosing the convenience of `cds watch` et al:

```js
// custom server.js
const cds = require('@sap/cds')
cds.on('bootstrap', (app)=>{ /* add your own middleware */ })
cds.on('served', ()=>{ /* add more middleware */ })
module.exports = cds.server //> delegate to default server.js
```

[Learn more about `cds.server`-based bootstrapping](../../../node.js/cds-serve#cds-server){ .learn-more}

> **IMPORTANT:** In case you're using own `server.js` implementations, we strongly recommend revisiting these and considering refactoring them to extend the built-in one, as documented in [custom `server.js`](../../../node.js/cds-serve#custom-server-js). This ensures you benefit from the mentioned and future optimizations.

### Custom `cds.Service` Subclasses

Besides providing [impl functions](../../../node.js/core-services#implementing-services), service implementations can now provide [specific subclasses of `cds.Service`](../../../node.js/core-services#how-to-provide-custom-service-implementations), as shown below:

```js
// srv/cat-service.js
const cds = require('@sap/cds')
class CatalogService extends cds.ApplicationService {
  async init(){
    this.on ('UPDATE','Books', (req)=>{...})
    await super.init()
    this.before ('CREATE','Books', (req)=>{...})
  }
}
module.exports = CatalogService
```

Common Service Factory
: This is one of many more effects of the **new service factory**, commonly used by `cds.serve` and `cds.connect` now. This applies the same consistent ways to register new implementations via [`cds.requires`](../../../node.js/cds-connect#cds-env-requires) options, model [annotations `@impl` and `@kind`](../../../node.js/core-services#specified-by-impl-annotation-or-impl-configuration), or the well-known _.cds_/_.js_ sibling files mechanism.

[Learn more about new ways of **Providing Service Implementations**](../../../node.js/core-services#implementing-services){ .learn-more}
[Learn more about new ways of **Configuring Required Services**](../../../node.js/cds-connect#cds-env-requires){ .learn-more}

### Custom Handlers on _`cds.connect`ed_ Services

As a CAP Node.js developer, you're used to add event handlers to provided services to add custom-specific implementations to the service. Starting with this release, you can also do the same from the consumer side to services you connected to, such as Database Services or Remote Services:

```js
const db = await cds.connect('db')
db.prepend (()=>{
  db.on ('INSERT','Orders', req => {...})
  db.after ('READ','*', each => {...})
})
```

[Learn more about **Adding Handlers to `cds.connect`ed Services**](../../../node.js/core-services#cds-service){ .learn-more}

For example, you could use that to fix gaps in our generic support, by providing your own generic handlers to our built-in database services for SQLite and HANA.

With this, we make these statements in the [_About CAP_](../../../about/) page even more true:

- Every active thing in CAP is a service, that is a `cds.Service`, and...
- Everything happens in response to [events](../../../node.js/events#cds-event), that is in [_Event Handlers_](../../../node.js/core-services#cds-service).

All service implementations essentially are just a bunch of registered event handlers. There's actually no difference between handlers added from provider side, or from consumer side. There's also no difference between the handlers we add to provide all the [generic framework features of CAP](../../../guides/providing-services), or the handlers you add. At the end of the day, **we all eat the same dog food** --- with this release more than ever before.

### Custom and Dummy Authentication Strategies

New Dummy Authentication Strategy
: The [dummy strategy](../../../node.js/authentication#dummy) creates a dummy user that passes all authorization checks. It's meant for temporarily disabling the `@requires` and `@restrict` annotations at development time.

Custom Authentication Middleware
: In case the supported authentication strategies don't fulfill the necessary requirements, developers can provide a [custom express middleware](../../../node.js/authentication#custom) for authentication.

[Learn more about the **revamped Authentication framework**](../../../node.js/authentication){ .learn-more}

### INSERT Queries Return Generated Keys

[INSERT queries](../../../node.js/cds-ql#insert) now return iterables, similar to results from SELECT queries, which allow to reflect on (generated) keys of the inserted entities, as shown in this snippet.

```js
const [ Emily, Charlotte ] = await INSERT.into (Authors,[
   {name:'Emily Brontë'},
   {name:'Charlotte Brontë'},
])
INSERT.into(Books).columns('title','author_ID').rows(
   [ 'Wuthering Heights', Emily.ID ],
   [ 'Jayne Eyre', Charlotte.ID ],
)
```

[Find details in the updated **API docs of `cds.run`**](../../../node.js/core-services#srv-run-query){ .learn-more}

### Generic Support for Arrayed Elements { #node-js-arrayed-elements}

[See Arrayed Elements in the CDS Language section](#arrayed-elements){ .learn-more}

### Localized Messages / i18n

Application developers can now use [localized error messages](../../../node.js/cds-i18n).
For example:

```properties
# i18n/messages_en.properties
ORDER_EXCEEDS_STOCK=The order of {0} books exceeds the stock by {1}
```

```js
req.reject( 400, 'ORDER_EXCEEDS_STOCK', [
   order.quantity,
   order.quantity - book.stock
])
```

[Learn more about **Localized Messages**](../../../node.js/cds-i18n){ .learn-more}

### Miscellaneous

- **New `srv.after('each', row => ...)`** &mdash; the former technique to register per-row handlers `srv.after('READ', each => ...)` broke when code was minified. The new method using pseudo event `'each'` is minifier-safe.

- **New `srv.prepend(srv => ...)`** &mdash; use `srv.prepend(...)` to register event handlers to be executed _before_ the already registered handlers. For example, extensions of reused implementations sometimes need to use this.

- **New [`req.user.tenant`](../../../node.js/events#user)** to access the current user's tenant ID.

- **Reflect `srv.events`** &mdash; base class `cds.Service` provides a new getter `srv.events` to reflect on declared events in the service definition, similar to the already existing `srv.entities`, `srv.types`, and `srv.operations`.

- **Experimental `cds.ql(req)`** &mdash; event handlers can now use the like of `const {SELECT} = cds.ql(req)` to ensure transaction-managed and tenant-isolated execution of queries, instead of `srv.tx(req)`. **Note** though, that this is an **experimental** feature, which might change or be removed in future versions.

- **Switch on debug logs** by setting the environmental variable `DEBUG` to `y` if you want to show more detailed log output.

### More to Come Soon

As stated above, this major version update was just the start, setting the stage for new features with a greatly cleaned up implementations of [our Node.js runtime's core](/node.js/core-services).

In the documentation, you already find outlines, of not-yet documented or rarely filled-in guides and APIs, such as:

- [Application Services](/node.js/app-services)
- [Remote Services](/node.js/remote-services)
- [Messaging](/node.js/messaging)
- [Databases](/node.js/databases)
- [Protocols](/node.js/cds-serve#cds-protocols)

We didn't document and release these APIs right now, as we want to give them some more polishing before general availability.

**Stay tuned** for more to come in there.

## Java Runtime { #cds-java}

### Important Changes for Former Java Stack ❗️{ #important-changes-in-java}

A minimum version `1.40.6` of the former CAP Java runtime is required.<br>
Check your project's `pom.xml` and bump [projects-parent-odatav2](https://search.maven.org/artifact/com.sap.cloud.servicesdk.prov/projects-parent-odatav2){ target="blank"} or [projects-parent](https://search.maven.org/artifact/com.sap.cloud.servicesdk.prov/projects-parent){ target="blank"} to the latest version.
We recommend doing this regularly.

Also, to benefit from new features, see our [migration guide](../../../java/migration) for the new CAP Java SDK.

### Important Changes ❗️{}

- The API `CdsRuntime.runInRequestContext()` has been deprecated and replaced by `CdsRuntime.requestContext().run()`.
- The API `CdsRuntime.runInChangeSetContext()` has been deprecated and replaced by `CdsRuntime.changeSetContext().run()`.
- Some error codes were incorrect and have been corrected: The codes ranging from `40008` to `40017` have been changed to `400008` to `400017` respectively, to prevent conflicts in error codes in the future.
- The method `ServiceException.getLocalizedMessage()` can't be used anymore for non-OData requests. Hence, if no active `RequestContext` object exists, use the new method `ServiceException.getLocalizedMessage(Locale)` to explicitly set a locale. The requests locale can be obtained from the CdsRuntime using `runtime.getProvidedParameterInfo().getLocale()`.
- XSUAA user names aren't normalized to lower case by default anymore (property `cds.security.xsuaa.normalizeUserNames`) because XSUAA delivers stable case-sensitive user names as of now.

### Modeling

- Support managed associations that don't target `key` elements
  - Support using `$now` in `on` conditions of unmanaged associations

### Code Generation

- `EventContext` interfaces for events
- `create` method for consumption interfaces for structured types

### CDS Data Store

- [Managed Data](../../../guides/domain-modeling#managed-data)
  - handle [`@cds.on.insert`\|`update`](../../../cds/common#aspect-managed) annotations on data store level to set the values of current user (`$user.id`), session timestamp (`$now`) or a literal value
  - support managed data also upon [deep insert](../../../java/working-with-cql/query-api#deep-insert) or [deep update](../../../java/working-with-cql/query-api#deep-update)
- support using the session context variable `$now`, `$at.from`, `$at.to`, `$user.id`, and `$user.locale` in filters

### New RequestContext API

A new [RequestContext API](../../../java/event-handlers/request-contexts) enables accessing and modifying request metadata like user information, query parameters, and HTTP headers.

In addition, a new Provider API enables applications to control how user or request parameter information is derived from the request.

### Parametrized Views

Read requests on [Parameterized views](../../../advanced/hana#views-with-parameters) are now supported in OData V4. See section [CDS > Definition Language > Exposed Entities](../../../cds/cdl#exposed-entities) for more details.

### OData Features

The following new OData V4 features have been added:

- Updates on OData singletons and navigations from singletons to other entities are now supported.
- The expression `not` is now supported in `$filter` requests
- The `$metadata` endpoint now supports proper browser caching by setting the http header `Cache-Control: max-age=0`.
  - Data Aggregation (`$apply`)
  - support for one level of data aggregation
  - using transformations `groupby`, `aggregate`, `filter`, `search` and `identity`
  - using the standard aggregation methods `sum`, `min`, `max`, `average` and `countdistinct`
  - ordering by aggregated values
  - using `$count=true` together with

### Fiori Drafts

You can now use field from draft enabled entities in `orderBy` clauses.

### Miscellaneous

- Event handler methods can now use the types  `CdsData`, `List<CdsData>`, or `Stream<CdsData>` for method arguments.
- Support multiple bound XSUAA service instances --- The application configuration property `cds.security.xsuaa.serviceName` now controls which XSUAA service binding is chosen for authorization.

### Bug Fixes

- For an OData query with `$count` option, the inline count must be specified in the result. In the previous version, if no inline count was contained in the result, the row count was used, which could have resulted in wrong data.
- Fixed a bug that caused queries using `COUNT(*)`, for example, OData's `/$count` to fail on SAP HANA databases.
- Fixed a bug that caused PUT requests and actions to fail on Etag-enabled entities on SAP HANA.
- Fields annotated with `@cds.on.insert` are now preserved in the draft when editing a draft enabled entity.

### Performance

- Improved performance when querying a draft enabled entity.
- Suppress additional query for inline count if possible
- Reduce number of queries when expanding to-one associations

## Multitenancy

### Building Multitenant SaaS Applications with CAP

Create cost-efficient SaaS applications with CAP and SAP HANA Cloud by leveraging the [multitenancy concepts of SAP Cloud Platform](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/5e8a2b74e4f2442b8257c850ed912f48.html) and the new [Service Management instance management capabilities](https://help.sap.com/docs/SERVICEMANAGEMENT/09cc82baadc542a688176dce601398de/3a27b85a47fc4dff99184dd5bf181e14.html).<br>
The `cds-mtx` library offers you out-of-the-box support to switch your single tenant scenario to multitenant persistency with tenant data separation using HDI containers and to integrate it with the SAP Cloud Platform SaaS Manager. See [Multitenancy] for more details.



# April 2020


## Docs and Samples

### Tests Added to cap/samples

We added a few tests to [cap/samples](https://github.com/SAP-samples/cloud-cap-samples/tree/master/test), which we use to qualify our content in there. In addition, you may take these as blueprints and best practices how to add tests to your projects, as well as samples in itself how to use certain CAP features, such as [`cds.ql` in Node.js](https://github.com/SAP-samples/cloud-cap-samples/tree/master/test/cds.ql.test.js). Just a few notes about these tests:

- They use [`chai`](https://www.chaijs.com) as an assertions library.
- They run with both, [Mocha](https://mochajs.org) and [Jest](https://jestjs.io) as test runners.
- You can run the tests using the provided npm scripts:

```sh
npm run jest  # or...
npm run mocha test/<individual test file>.js
```

> Setup: We leave the choice of Mocha or Jest to you. Install them globally in order to run the tests, for example: `npm i -g mocha`.
> Note: In contrast to Jest, Mocha doesn't isolate tests, so you can't run them all at once but may need to run them individually.


### New and Revised Sections and Guides

New Guides and Sections:

- **[Cookbook > Providing Services > Implicit Pagination](../../../guides/providing-services#implicit-pagination)**
- **[Cookbook > Providing Services > Input Validation](../../../guides/providing-services#input-validation)**
- **[CDS > Schema Notation > Imports](../../../cds/csn#imports)**
- **[Java > Executing CQN Queries > Pessimistic Locking](../../../java/working-with-cql/query-execution#pessimistic-locking)**
- **[Java > Query Builder API > Select > Ordering and Pagination > Write Lock](../../../java/working-with-cql/query-api#write-lock)**
- **[Node.js > ETag](../../../guides/providing-services#etag)**
- **[Advanced > Deploying to Cloud > Deploy using MTA](../../../guides/deployment/to-cf)**


### Improvements

Introducing badges in **[CAP Service SDK Java Reference Documentation](../../../java/)** to show the latest supported version and linking to the API documentation:

<span class="badges">
[![cds-services](https://javadoc.io/badge2/com.sap.cds/cds-services-api/cds--services.svg)](https://javadoc.io/doc/com.sap.cds/cds-services-api/latest/overview-summary.html)
[![cds4j](https://javadoc.io/badge2/com.sap.cds/cds4j-api/cds4j.svg)](https://javadoc.io/doc/com.sap.cds/cds4j-api/latest/com/sap/cds/ql/package-summary.html)
</span>


## Command Line

New Node.js method `cds.compile.cdl()` allows compiling CDS sources in-process.

### cds watch `<package name>`

Use package names as arguments with `cds watch`/`run`/`serve`, for example:

```sh
cds watch @capire/bookshop
```

### cds version `-ls`

 Use `cds version --npm-list` (or `cds v -ls` for short) to print an `npm ls` subtree, for example:

<pre class="log">
$ cds version -ls
npm ls --depth 11 | grep @sap/cds
├─┬ <b>@sap/cds</b> <em>3.33.4</em> <i>-> ~/cap/cds</i>
│ ├── <b>@sap/cds-compiler</b> <em>1.26.1</em> <i>-> ~/cap/compiler</i> deduped
│ ├── <b>@sap/cds-foss</b> <em>1.2.0</em> <i>-> ~/cap/foss</i> deduped
│ ├── <b>@sap/cds-reflect</b> <em>2.10.2</em> <i>-> ~/cap/core</i> deduped
│ └── <b>@sap/cds-runtime</b> <em>1.0.5</em> <i>-> ~/cap/runtime</i> deduped
├─┬ <b>@sap/cds-compiler</b> <em>1.26.1</em> <i>-> ~/cap/compiler</i>
├─┬ <b>@sap/cds-dk</b> <em>1.8.1</em> <i>-> ~/cap/cds-dk</i>
│ ├── <b>@sap/cds</b> <em>3.33.4</em> <i>-> ~/cap/cds</i> deduped
│ ├── <b>@sap/cds-foss</b> <em>1.2.0</em> <i>-> ~/cap/foss</i> deduped
├─┬ <b>@sap/cds-foss</b> <em>1.2.0</em> <i>-> ~/cap/foss</i>
├─┬ <b>@sap/cds-mtx</b> <em>1.0.13</em> <i>-> ~/cap/mtx/mtx-agent</i>
├── <b>@sap/cds-reflect</b> <em>2.10.2</em> <i>-> ~/cap/core</i>
├─┬ <b>@sap/cds-runtime</b> <em>1.0.5</em> <i>-> ~/cap/runtime</i>
│ ├── <b>@sap/cds-foss</b> <em>1.2.0</em> <i>-> ~/cap/foss</i> deduped
├─┬ <b>@sap/cds-test</b> <em>0.0.2</em> <i>-> ~/cap/tests</i>
│ │ │ ├── <b>@sap/cds</b> <em>3.33.4</em> <i>-> ~/cap/cds</i> deduped
│ │ │ ├── <b>@sap/cds</b> <em>3.33.4</em> <i>-> ~/cap/cds</i> deduped
│ │ │ ├── <b>@sap/cds</b> <em>3.33.4</em> <i>-> ~/cap/cds</i> deduped
│ ├── <b>@sap/cds</b> <em>3.33.4</em> <i>-> ~/cap/cds</i> deduped
</pre>

### cds build `--log-level`

With `cds build --log-level` and `cds compile --log-level`, you define which messages you want to see.


## CDS Language & Compiler

### Arrayed Types

Introduced keyword `many` as a substitute for `array of`. Furthermore, such arrayed types are now also supported on the database side - they're represented as elements of type `cds.LargeString`.

[Learn more in CDS > Definition Language > Arrayed Types](../../../cds/cdl#arrayed-types){ .learn-more}

### Parsed-only Output

The `cds compile` option `--parse` provides minimal, parsed-only CSN output. Minimal meaning as close to the CDL source as possible, that means no generation of fields or entities, no resolving of imports, no applying extensions, no annotation propagation, etc. Consequently, many integrity checks are also not run because they require one of the steps above.

The following example illustrates this nicely:

```cds
using Bar from './bar';
namespace parsecdl;

entity Foo as select from Bar:toBar { *,
  unchecked
};

extend Bar with {
  add: Integer;
  not_expanded: localized String;
}
```

The CDL from above, compiled with `--parse` yields the following CSN:

```json
{
  "namespace": "parsecdl",
  "requires": [ "./bar" ],
  "definitions": {
    "parsecdl.Foo": {
      "kind": "entity",
      "query": {
        "SELECT": {"from": {"ref":["Bar","toBar"]},
          "columns": [ "*", {"ref":["unchecked"]} ]
        }
      }
    }
  },
  "extensions": [
    { "extend": "Bar",
      "elements": {
        "add": { "type":"cds.Integer" },
        "not_expanded": { "localized":true, "type":"cds.String" }
      }
    }
  ]
}
```

As you've seen in the sample, `localized` isn't processed, imports aren't resolved, the view isn't validated (`Bar` might not have a field `unchecked`), and more.

### UI Annotations for Draft Administrative Data

All elements of `DraftAdministrativeData` are now annotated with `@Common.Label` and a translated text.  In addition, the elements `DraftUUID`, `DraftIsCreatedByMe`, and `DraftIsProcessedByMe` are annotated with `@UI.Hidden`.


## Node.js Runtime

### Important Changes❗️{ #changes-in-node-js }

If a [SELECT query](../../../node.js/cds-ql#select-from) contains columns or column aliases with the same name, the query is rejected.

In a [SELECT query](../../../node.js/cds-ql#select-from), that uses the object notation in `.where` statements, functions aren't allowed anymore.

The result of an OData `GET` request is now ordered by the keys of the returned entities by default if the client doesn't request a specific sorting (for example, through `$orderby`, `@cds.default.order`, or `@odata.default.order`).


### Value Range Annotations for OData

The [value range annotations](../../../guides/providing-services#input-validation) [`@assert.format`](../../../guides/providing-services#assert-format) and [`@assert.range`](../../../guides/providing-services#assert-range) are now implemented for the OData protocol. The usage of `@assert.enum` is deprecated. Switch to `@assert.range enum`.

### @assert.integrity

Associations _to-one_, annotated with [`@assert.integrity: false`](../../../guides/providing-services#assert-target), are ignored on integrity checks.

### Implicit Pagination

The results of READ requests are automatically truncated at 1000 records. With server-side pagination, you can configure the default and max page size globally, on service, and on entity level.

[For more details, see Providing Services > Implicit Pagination.](../../../guides/providing-services#implicit-pagination){ .learn-more target="_blank"}

### Changed Draft Locks Timeout

Draft locks now expire after a default timeout of 15 minutes. The locked entity can be reclaimed by other users after that timeout. The timeout duration is configurable via the application configuration property `cds.drafts.cancellationTimeout`.

### Miscellaneous

If there's no custom handler implemented for entities annotated with `@cds.persistence.skip` requests to it fail with HTTP code 501.

## Java Runtime

### Important Changes ❗️{ #changes-in-java }

- Saving a draft now triggers an UPDATE event instead of an UPSERT event that was used in previous versions. Applications need to adopt this new behavior, see following section [Fiori Drafts](#fiori-drafts) below for more information.
- OData system query parameter `$count` now generates a CQN query using the [inlineCount](#cds-query-builder) option in CQL. Unlike before, a single `READ` event is now emitted. Previously, `$count` triggered invocation of two event handlers, as an additional CQL query was executed.

### Customizing Error Messages

Customize and translate error messages that are thrown by the CAP Java runtime in several ways:

- Use the following application configuration property to prevent that the technical error message is transferred to the application frontend:

  ```yaml
  cds.errors.stackMessages.enabled: false
  ```

  This setting doesn't affect application logging.
- Use the following application configuration property to log more details when the CAP Java runtime throws exceptions, such as parameters contained in the EventContext:

  ```yaml
  cds.errors.extended: true
  ```

- Each error now has a dedicated error status, refer to the following enum to get a full list of possible errors:

  ```yaml
  com.sap.cds.services.utils.CdsErrorStatuses
  ```

- Like with customer error messages, error messages thrown by the stack can be localized by means of so called _message bundles_. See [Java > Indicating Errors > Formatting and Localization](../../../java/event-handlers/indicating-errors#formatting-and-localization) for more details. For example, to translate the text for the error message with error code 400002 (which is an invalid request) to German, you could define:

  ```txt
  400002=Der Wert '{}' ist ungültig
  ```

### Concurrency Control Using ETags

Optimistic concurrency control is now supported by means of ETags. See [Cookbook > Providing Services > Concurrency Control](../../../guides/providing-services#etag) for more details.


### Fiori Drafts {  #fiori-drafts}

#### Changes in Draft Orchestration

When saving a draft, this triggers now an UPDATE event. Previously, an UPSERT event was used that isn't able to perform sparse updates and maintain the `created-at` timestamp correctly. Applications need to adapt the new behavior as follows:

All event handlers reacting when a draft is saved and need to be registered on the UPDATE event, for example:

Before:

```java
@Before(event = { CdsService.EVENT_CREATE, CdsService.EVENT_UPSERT })
public void validateOrders(Stream<Orders> orders) {
   ...
}
```

After:

```java
@Before(event = { CdsService.EVENT_CREATE, CdsService.EVENT_UPSERT, CdsService.EVENT_UPDATE })
public void validateOrders(Stream<Orders> orders) {
    ...
}
```

If your event handler signature contains a `CdsUpsertEventContext` type signature, change that type to `CdsUpdateEventContext` or simply `EventContext`.

In addition, verify that no other event handlers are registered on the UPDATE event to make sure that they aren't triggered unintentionally. See [Java > Service Provisioning API > Implementing Event Handlers > Draft Event Flow](../../../java/fiori-drafts#draftevents) for more details.


#### Changed Draft Locks Timeout

Draft locks now expire after a default timeout of 15 minutes. The locked entity can be reclaimed by other users after that timeout. The timeout duration is configurable via the application configuration property `cds.drafts.cancellationTimeout`.

#### New DRAFT_CREATE Event

Introduced a new DRAFT_CREATE event, which is triggered when creating either an empty draft or a draft from an existing entity. This way it's possible to step in and validate data before the draft entity is created.

### Accessing XSUAA JWT Token Properties

It's now possible to conveniently access properties of JWT tokens issued by XSUAA using `cds-feature-xsuaa`, for example:

```java
import com.sap.cds.feature.xsuaa.XsuaaUserInfo;

@Autowired
private XsuaaUserInfo xsuaaToken;

@Before(...)
public void eventHandler(EventContext event) {
	logger.info("Request user: {} {} email: {}",
			xsuaaToken.getGivenName(),
			xsuaaToken.getFamilyName(),
			xsuaaToken.getEmail() );
}
```

### CDS Query Builder

- Inline counts are now supported when defining CQN queries. For example, `Result result = dataStore.execute(Select.from(BOOK).limit(2).inlineCount());` will deliver two book entries and additionally the number of all books. The `CqnSelect.hasInlineCount()` method indicates if an inline count will be returned.
- An `exists` subquery predicate can now be used `Select.from(EMPLOYEE).columns(c -> c.id(), c -> c.name()) .where(e -> e.exists(outer -> Select.from(CAR).where(c -> c.owner().id().eq(outer.id()).and(c.licensePlate().eq("XYZ123")))))` in filters of CQL queries. See [Java > Query Builder API > Predicates](../../../java/working-with-cql/query-api#predicates), for more details.
- Write locks can be initiated by using pessimistic locking, for example, `Select.from("bookshop.Books").where(b -> b.get("ID").eq(1)).lock(5);` a lock timeout can be defined (otherwise DB specific). For more details, see [Java > Query Builder API > Select > Ordering and Pagination > Write Lock](../../../java/working-with-cql/query-api#write-lock) and [Java > Consumption API > Pessimistic Locking](../../../java/working-with-cql/query-execution#pessimistic-locking).

### Miscellaneous

- Support for `$select` and `$expand` on actions and functions in OData V4, ensuring compatibility with SAP UI5 >= 1.75.0
- A Spring property metadata file is now part of the `cds-framework-spring-boot` JAR. This enables code completion and suggestions of cds properties in Spring configuration files, if corresponding IDE plugins are installed. See [Spring Tools](https://spring.io/tools) for more details.
- Patterns in `.gitignore` generated by the archetype, now use `**/` as `glob` statement prefix, to ensure compatibility with other tools interpreting the `.gitignore` file (for example, npm publish). See [glob (programming)](https://en.wikipedia.org/w/index.php?title=Glob_(programming)&oldid=952319799) (Wikipedia) for more details.
- Error messages listed in the details section of an error response now have the fields `@Common.numericSeverity` and optionally `@Common.longtextUrl`. This ensures that Fiori displays these messages correctly and also renders the target correctly.

### Bug Fixes

- Fixed handling of `CqnUpdate` statements with more than one data entry.
- Fixed handling of `CqnUpdate` statements with empty data entry.
- Fixed handling of mandatory associations to draft-enabled entities.
- Update data is only returned when amount of updated rows is higher than 0. Returned data is enriched by default values.



# March 2020



## Important Changes❗️{  #important-changes }

### `cds build` Uses New Build System

The `cds build` command now delegates to the new build system by default (known as `cds build/all`).

The new build system is compatible, but supports additional features, for example:
+ Staging build
+ SAP HANA Cloud Edition support
+ Populating initial data from `.csv` by generating `.hdbtabledata` files



## Docs and Samples

Find below a list of changes and improvements to the capire docs and to cap/samples. These are another major steps in our quality focus early 2020. There's much more to come &rarr; stay tuned...

### Revamped and Reloaded _cap/samples_

- **cap/samples** received a comprehensive cleanup and overhaul, including simplified monorepo setup, improved organization of sub projects, a bookshop with a Vue.js app, and much more...


### Revised Getting Started & Resources

- **[Resources](../../../resources/)** &rarr; consolidated and relocated
- **[About > Feature Matrix](../../../about/features)** &rarr; consolidated and updated
- **[Getting Started > in a Nutshell](../../../get-started/in-a-nutshell)** &rarr; greatly revised and improved

### New and Revised Guides in Cookbook

- **[Cookbook > Generic Providers](../../../guides/providing-services)** &rarr; merged into [_Providing Services_](../../../guides/providing-services)
- **[Cookbook > Adding Custom Logic](../../../guides/providing-services#event-handlers)** &rarr; merged into [_Providing Services_](../../../guides/providing-services)
- **[Cookbook > Providing Services](../../../guides/providing-services)** &rarr; consolidated and improved

- **[Cookbook > Adding/Serving UIs](../../../advanced/fiori)** &rarr; newly written and released

### New Reference Docs

- **[CDS > Common Annotations](../../../cds/annotations)**
- **[CDS > OData Annotations](../../../advanced/odata#annotations)**


## Command Line

### _Integrate_ and _Mashup_ with `cds watch`
{ #cds-watch}

As a bonus, `cds watch` detects whenever you add an `.edmx` file to your project in whatever place and automatically triggers `cds import` to convert them to CSN.

Get an `.edmx` file from the [SAP API Business Hub](https://api.sap.com/), in the *Details* tab of an API description, to test it.

![](./assets/edmxDownload.gif){}

Drag-and-drop the `.edmx` file to your Visual Studio Code window.

![](./assets/DropedmxinVSCode.gif){}


### Start Service in Watch Mode

Use the option `--watch` on a specific service with command `cds serve` to start that specific service in nodeman watch mode.

### List All Dependencies of Your Local _package.json_

Use `cds version --all` to list all dependencies of your local _package.json_. See the CLI command help for more information.


## CDS Editors & Tools

The following features are available for all editors based on our Visual Studio Code extension for CDS in SAP Business Application Studio and Visual Studio Code. The extension for Visual Studio Code is available for download at the [SAP Development Tools](https://tools.hana.ondemand.com/#cloud-vscodecds) page.

### Installation of CDS Development Kit

The Visual Studio Code extension for CDS detects missing or outdated installation of CDS development kit.

Select to install the CDS Development Kit:
    ![](./assets/InstallDk.gif){}

Select to update the CDS Development Kit:
    ![](./assets/UpdateDk.png){}

Enable Installation Check:
    ![](./assets/EnableDk.png){}


## CDS Language & Compiler

### Documentation Comments

If comments of the form `/**...*/` appear at positions where annotation assignments are allowed, use option `--docs` in `cds compile` to preserve them.

Documentation comments are propagated like annotations until an empty comment `/***/` disrupts the propagation. The documentation comments appear as `doc` properties in the CSN and in the OData/EDMX, it appears as a value for the annotation `@Core.Description`.

```cds
/** This is an example for a doc comment */
entity Foo { key ID:UUID; ... }
```

```json
{
  "definitions": {
    "Foo": { "kind": "entity", "doc": "This is an example for a doc comment", ... }
  }
}
```

### DISTINCT and ALL

The compiler supports function calls like `count( distinct ... )` and `count( all ... )`.

### New Option `--clean`

Use `cds compile --clean` to return a CSN, which reflects only what was found in a _.cds_ source. The compiler doesn't add any derived information.

## Node.js Runtime

### Important Changes❗️{ #changes-in-node-js }

On SAP HANA with multitenancy enabled (`multiTenant: true`), the users are being authenticated regardless of whether authorization annotations (`@requires/@restrict`) are used. The reason is that the user's identity zone is required to determine the respective HDI container. In production mode, this requirement is now enforced. In development mode, the developer needs to make sure to fulfill this requirement.

In previous versions, `$count=true` triggered handlers to be executed twice. This led, for example, to `WHERE` conditions from security annotations being appended twice. Now, the usage of `$count=true` triggers handlers only once, so custom handlers that accommodated this behavior might have to be adapted. The resulting array of the original query has a new property `$count`. Make sure that this property is not lost when you return the result in your custom handlers.


The [`req.user` object](../../../node.js/events#user) represents the currently logged in user.


The annotations `@FieldControl.Mandatory`, `@Common.FieldControl.Mandatory`, and `@mandatory` now enforce that empty strings and strings with only whitespaces are rejected as input. Previously only `null` and `undefined` were checked.

### Convenient Access to express Request Object

The [`req._` object](../../../node.js/events#cds-request) contains the original `req` and `res` objects as obtained from express.js. This is now also the case for `$batch` requests.

### Localized Data - Access to Default Values

It's now possible to prevent automatic redirection to the localized views for localized entities with the [`@cds.localized:false` annotation](../../../guides/localized-data#serving-localized-data).

### Ordered OData Singletons

In the CDS model, it's now possible to order OData Singletons: `... as select from <entity> order by <property>`.

### Miscellaneous

- Enhanced Fiori draft support, see [Fiori Support](#fiori-support)
- The [pool acquire timeout](../../../node.js/cds-connect) is now set to a default (5,000ms on SQLite and 10,000ms on SAP HANA) and can be configured in the pool options with `acquireTimeoutMillis`.

- Functions and properties are now allowed as second parameter in `contains`, `startswith`, and `endswith`.

- OData requests using $count on navigation-to-many are now supported.

- OData requests using $count on parameterized views are now supported.

- [INSERT.entries](../../../node.js/cds-ql#insert-entries) now supports different columns combinations.

- Support for `count` in [SELECT CQN](../../../cds/cqn#select).

- `@cds.persistence.skip` is now also evaluated for deep operations to annotated child entities.

## Java Runtime

### Important Changes❗️{ }

`@mandatory` annotated elements of type `String` now also reject any trimmed empty strings.

Entities annotated with `@cds.autoexpose` are now read-only if referenced as root entity in a CQN statement. This policy doesn't apply if the entity is draft-enabled or explicitly mentioned in the service definition.


### Build Improvements

- Save time and [use a globally installed cds-dk](../../../java/getting-started#build-and-run) when building your application by using the `cdsdk-global` profile:

  ```bash
  mvn spring-boot:run -P cdsdk-global
  ```

- When creating new projects with the CAP Java Maven archetype, the `cds-starter-cloudfoundry` dependency is automatically added.

- `EventContext` interfaces for types used in OData actions and functions, which make accessing input and output parameters much more convenient. Newly generated projects now support `EventContext` interfaces by default. Add this feature to your existing project manually by adding the following to your CDS4J maven plugin configuration:

  ```xml
  <eventContext>true</eventContext>
  ```

  For example, consider the action `review` defined in the following CDS model:

  ```cds
  entity Books {
    ...
    action review(stars: Integer) returns Reviews;
    ...
  }

  entity Reviews {
      book : Association to Books;
      stars: Integer;
  }
  ```

  You can now use type names that you defined in the CDS model directly in your custom code. Hence, the generated type `ReviewContext` allows you accessing the input value via `getStars()`. In addition, you can use the generated type `Reviews` to set the result:

  ```java
  @On(entity = Books_.CDS_NAME)
  public void review(ReviewContext context) {
      int stars = context.getStars();
      ...
      Reviews review = [...]
      context.setResult(review)
  }
  ```

### Deep Update

Allows to update a single entity including its associated entities. In contrast to a deep upsert (replace), deep update has patch semantics. Elements that aren't contained in the update data keep their old value.

For to-many compositions or associations, the provided list of entities has to be complete, entities that aren't in the list will be removed and in case of compositions also deleted. See also [Java > Query Builder API > Deep Update](../../../java/working-with-cql/query-api#deep-update).

### Spring Framework Integration

- Use Spring health-check actuators with multitenancy turned on. At each call, the health of each connected HANA database is checked.
- We now support a Spring actuator returning CDS-related debugging information. Get, for example, version, registered event handlers, and service instances at endpoint `<basepath>/actuator/cds`. Activate this endpoint by adding the value `cds` to the property `management.endpoints.web.exposure.include` in your application configuration, for example:

  ```yaml
  management.endpoints.web.exposure.include: info,health,cds
  ```

### OData V4

- We added a configuration switch `cds.odatav4.contextAbsoluteUrl`. This switch controls if the URL in the @context field of OData V4 responses contains a relative or an absolute path. The default of this property is `false` (relative path).
- We improved the startup performance. OData vocabulary files used for validation purposes aren't loaded during startup anymore.

### Miscellaneous

- Enhanced Fiori draft support, see [Fiori Support](#fiori-support)
- The [whitelist for normalized locales](../../../guides/i18n#normalized-locales) is now configurable by means of the property `cds.locales.normalization` in the application configuration, for example:
  ```yaml
  cds.locales.normalization:
    defaults: true  # Keep default whitelist as documented in capire
    whiteList:      # These locales are added to the default whitelist
      - "zh_CN"
      - "zh_HK"
  ```
- .csv files (for example, configuration data) are loaded during startup from either `db/data` or `db/csv` folders. To load `.csv` files is enabled by default for the in-memory SQLite database.

  You can control this behavior further by setting `cds.datasource.csv-initialization-mode` in your application configuration to either `always` or `never` load data. `always` enables loading of the CSVs regardless of the database type. `never` turns it off completely.

- Reactivated tests integrating PostgreSQL DB, nevertheless CAP won't support PostgreSQL out of the box. More details when setting up PostgreSQL for own purposes are collected in section [PostgreSQL](../../../java/cqn-services/persistence-services#postgresql).

### Bug Fixes

- The locales `1Q` and `2Q` are now handled correctly.
- `$search` doesn't lead to duplicate search results anymore.
- Fixed a malformed OData response, containing an incorrect `@context` property instead of `@odata.context`.
- XSUAA user names are now normalized by converting them to lower case when persisting. This behavior can be turned off by specifying `cds.security.xsuaa.normalizeUserNames: false` in the application configuration.
- Batch request the Authorization header is now propagated from the parent batch request to child requests. This only affects the visibility of the Authorization header through the ParameterInfo interface.
- Fixed a bug the prevented to use SAP UI5 versions greater or equal than 1.75.0 by returning the complete structured entity when saving a draft.

## Fiori Support

### Draft for Localized Data

The compiler supports draft-enabling entities with localized elements.

To make the generated `_texts`-entities draftable, additionally annotate the source entity with `@fiori.draft.enabled` - more details on the usage and the implications can be found in [Advanced > Serving Fiori UIs](../../../advanced/fiori#draft-for-localized-data).


### Fiori Drafts with Locks

Edited draft data is now restricted to the user who created the draft. This also applies to delete and cancelling drafts.



# Resources and Support



## If you are new to CAP

[**Visit our official SAP Community page**](https://pages.community.sap.com/topics/cloud-application-programming) to get an overview of the most relevant sources of information, including introduction, blog posts, tutorials, and events.

## Public Resources

<div id="resources">

[![](./assets/community.png) **CAP Community at GitHub**](https://github.com/cap-js-community)

[![](./assets/Logo_TFE.drawio.svg) **Explore our sample applications**](/get-started/learning-sources)



[![](./assets/navi.png) **Try out CAP Tutorials**](https://developers.sap.com/tutorial-navigator.html?tag=software-product-function%3Asap-cloud-application-programming-model&tag=tutorial%3Atype%2Fmission)

[![](./assets/blogs.png) **Read Blog Posts**](https://blogs.sap.com/tags/9f13aee1-834c-4105-8e43-ee442775e5ce/)

[![](./assets/questions.png) **Ask Questions**](https://answers.sap.com/tags/9f13aee1-834c-4105-8e43-ee442775e5ce)
&rarr; [file new one](./ask-question-vscode)

[![](./assets/issues.png) **Report Issues** &rarr; see below](#support-channels)

[![](./assets/features.png) **Request Features**](https://influence.sap.com/sap/ino/#/campaign/2280)

</div>

<span id="more-resources" />
<Fragment target="#more-resources">

## Internal Resources <Internal />

<div id="resources">

[![x](./assets/roadmap.png) **CAP Roadmap** &rarr; see what we're working on](https://github.tools.sap/cap/dev/projects/1)

[![x](./assets/docs.png) **CAP Slide Deck** &rarr; for intros and rollout](https://sap.sharepoint.com/:p:/t/CAPSharing/EffMkSMDYMpJjo6wIkuElsIBXw__H9QE7E4UxD0uWHb8xQ?e=8arChy)

[![x](./assets/list.png) **Projects using CAP**](https://wiki.one.int.sap/wiki/display/CAP/Stakeholders) &rarr; please register

[![x](./assets/stack.svg) **Find Answers** in Stack@SAP](https://sap.stackenterprise.co/posts/tagged/1838)

[![x](./assets/issues.png) **Report Issues** in cap/issues](https://github.tools.sap/cap/issues/issues). [Note our **_Code of Conduct_**.](https://github.tools.sap/cap/issues/blob/main/README.md)

[![x](./assets/analytics.png) **CAPtics** &rarr; Insights on cap/issues](https://captics.c-36c5653.stage.kyma.ondemand.com)

[![x](./assets/questions.png) Join our **Consulting Hours**](#consulting-hours)

</div>

### CAP Product Day <Internal />

Shortly after every release, we conduct a product day to show the most interesting topics in a hands-on fashion.

- [Mail _Michael Hellenschmidt_](mailto:michael.hellenschmidt@sap.com?subject=Please%20invite%20me%20to%20the%20CAP%20Product%20Day) for invites

### Consulting Hours <Internal />

Together with SAP Fiori colleagues, we conduct a [weekly consulting hours](https://wiki.one.int.sap/wiki/display/CAP/Consulting+Hour) every Wednesday, 10:00 am CET
or Wednesday 5:00 pm CET in a bi-weekly manner. Visit our wiki to download the meeting request or

- [Mail _Michael Hellenschmidt_](mailto:michael.hellenschmidt@sap.com?subject=Please%20invite%20me%20to%20the%20CAP%20consulting%20hour) for invites

### Contacts <Internal />

See the [CAP development teams](team.md)

**Contacts from other areas**

| Area                            | Contact                                                              |
|---------------------------------|:---------------------------------------------------------------------|
| SAP Business Application Studio | Yuval Anafi <br> Liat Borenshtein                                    |
| SAP Fiori & UIs                 | Katja Zoch                                                           |

</Fragment>




## Support Channels

<span id="issues" />
<Fragment target="#issues">

::: warning Internal Reporting <Internal />
❗ Internal projects please report issues in [**cap/issues**](https://github.tools.sap/cap/issues).
:::

</Fragment>

As registered SAP customers, report issues by creating incidents in [**_SAP Support Portal_**](https://support.sap.com/en/index.html), using these components to reach us:

- **BC-XS-CDX-COR** for CDS and Compiler
- **BC-XS-CDX-JAV** for CAP Java SDK
- **BC-XS-CDX-NJS** for Node.js Runtime
- **BC-XS-CDX-TLS** for Tools, IDEs, Build, Deployment

See also [Getting Support](https://help.sap.com/products/BTP/65de2977205c403bbc107264b8eccf4b/5dd739823b824b539eee47b7860a00be.html) in the SAP BTP documentation.



## References

These are selected customers, including SAP's own applications and products, that use CAP in their projects:

- [Rizing LLC](https://www.sap.com/documents/2021/11/9ec87681-047e-0010-bca6-c68f7e60039b.html)
- [Emmi Group](https://www.sap.com/documents/2021/10/666ec92e-007e-0010-bca6-c68f7e60039b.html)
- [Heidelberg University Hospital](https://www.sap.com/idea-place/sap-innovation-awards/submission-details-2021.html?idea_id=2089)
- [Hamburg Ministry of Finance](https://www.sap.com/idea-place/sap-innovation-awards/submission-details-2022.html?idea_id=2891)
- [SAP S/4HANA for Advanced Financial Closing](https://www.sap.com/products/financial-management/advanced-financial-closing.html)
- [SAP S/4HANA Cloud for Projects](https://help.sap.com/docs/PPRM_OD)
- [SAP Risk and Assurance Management](https://www.sap.com/products/financial-management/financial-compliance-management.html)
- [SAP Privacy Governance](https://www.sap.com/products/financial-management/privacy-governance.html)
- [SAP Cloud Application Lifecycle Management](https://support.sap.com/en/alm/sap-cloud-alm.html)
- [SAP Cloud for Utilities](https://pages.community.sap.com/topics/utilities/cloud-for-utilities)
- [SAP Graph](https://navigator.graph.sap/)

<div id="more-references" />
<Fragment target="#more-references">

- [Emmi Group @ _The BTP Effect_](https://sap.sharepoint.com/sites/126813/SitePages/Emmi.aspx) <Internal />

</Fragment>


## Legal Notices

Learn about open source usage in CAP.

- [Java stack (active major version v9/4)](https://support.sap.com/content/dam/launchpad/en_us/osln/osln/73555000100900008701_20250516083028.pdf)

- [Java stack (previous and maintenance version/3)](https://support.sap.com/content/dam/launchpad/en_us/osln/osln/73555000100900007869_20240720064731.pdf)

- [Node.js stack (active major version v9)](https://support.sap.com/content/dam/launchpad/en_us/osln/osln/73555000100900008665_20250525072046.pdf)

- [Node.js stack (previous and maintenance version v8)](https://support.sap.com/content/dam/launchpad/en_us/osln/osln/73555000100900007870_20240720064747.pdf)

- [Privacy Policy](./privacy.md)

- [Cookie Statement](./cookies.md)



<div id="secondary-file">resources/index.fragment.md</div>


# CAP Events Overview

All available information on past and future CAP events.



## Customer Roundtables ![](./assets/Roundtable.png){}

### June 2025 {  #roundtable06-25}


- [Information](https://community.sap.com/t5/technology-blog-posts-by-sap/sap-cloud-application-programming-model-cap-customer-roundtable-june-2025/ba-p/14103224#M181461)
- [Slides](https://cap.cloud.sap/resources/events/SAP_CAP_Roundtable_June_2025.pdf)
- **Recording:**

  <iframe id="kmsembed-1_bec6g1u7" height="200" src="https://video.sap.com/embed/secure/iframe/entryId/1_bec6g1u7/uiConfId/54310412/st/0" class="kmsembed" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" referrerPolicy="no-referrer-when-downgrade" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="CAP Customer Roundtable | June 4th, 2025"></iframe>

### December 2024 {  #roundtable12-24}

- [Information](https://community.sap.com/t5/technology-blogs-by-sap/sap-cloud-application-programming-model-eighth-customer-roundtable/ba-p/13951006)
- [Slides](https://cap.cloud.sap/resources/events/SAP_CAP_Roundtable_December_2024.pdf)

### March 2024 {  #roundtable03-24}

- [Information](https://community.sap.com/t5/technology-blogs-by-sap/sap-cloud-application-programming-model-seventh-customer-roundtable/ba-p/13622672)
- [Slides](https://cap.cloud.sap/resources/events/SAP_CAP_Roundtable_March_2024.pdf)

### October 2023 {#roundtable10-23}

- [Information](https://blogs.sap.com/2023/10/10/sap-cloud-application-programming-model-sixth-customer-roundtable/)
- [Slides](https://cap.cloud.sap/resources/events/SAP_CAP_Roundtable_October_2023.pdf)

### April 2023 {  #roundtable04-23}

- [Information](https://blogs.sap.com/2023/03/17/sap-cloud-application-programming-model-fifth-customer-roundtable/)
- [Slides](https://cap.cloud.sap/resources/events/April_2023.pdf)

### January 2023 {  #roundtable01-23}

- [Information](https://blogs.sap.com/2022/12/20/sap-cloud-application-programming-model-fourth-customer-roundtable/)
- [Slides](https://cap.cloud.sap/resources/events/SAP_CAP_Roundtable_January_2023.pdf)

### October 2022 {  #roundtable10-22}

- [Information](https://blogs.sap.com/2022/09/01/sap-cloud-application-programming-model-third-customer-roundtable/)
- [Slides](https://cap.cloud.sap/resources/events/SAP_CAP_Roundtable_October_2022.pdf)

### July 2022 {  #roundtable07-22}

- [Information](https://blogs.sap.com/2022/06/29/sap-cloud-application-programming-model-second-customer-roundtable/)
- [Slides](https://cap.cloud.sap/resources/events/SAP_CAP_Roundtable_July_2022.pdf)

### April 2022 {  #roundtable02-22}

- [Information](https://blogs.sap.com/2022/03/18/sap-cloud-application-programming-model-customer-roundtable)
- [Slides](https://cap.cloud.sap/resources/events/SAP_CAP_Roundtable_April_2022.pdf)

## re&#8829;cap ![](./assets/recap2023.svg){}

### re&#8829;cap 25 {#recap2025}

- [Recording Main Track (Yellow Room)](https://broadcast.sap.com/replay/250709_recap)
- [Recording Side Track (Blue Room)](https://www.youtube.com/playlist?list=PLJDFklpD_2cTjReIS8xQ2L0HnfjoxPUxd)

### re&#8829;cap 24 {#recap2024}

- [Recordings](https://www.youtube.com/playlist?list=PLJDFklpD_2cQtnAF22FKky5gmujxDd4AY)

### re&#8829;cap 23 {#recap2023}

- [Recordings](https://www.js-soft.com/recordings-of-recap-2023/)

### re&#8829;cap 22 {#recap2022}

- [Recordings](https://www.js-soft.com/recordings-of-recap-online-2022)

### re&#8829;cap 21 {#recap2021}

- [Recordings](https://blog.js-soft.com/blog/recap2021_recordings)

### re&#8829;cap 20 {#recap2020}

- [Recordings](https://www.js-soft.com/recordings-of-recap-online-2020/)

{  #teched22}
## CAP at SAP TechEd 2022

- [Information](https://blogs.sap.com/2022/11/15/whats-new-in-sap-cloud-application-programming-model-teched-2022-edition./)
- [Recording](https://go3.events.sap.com/sapteched/hybrid/2022/reg/flow/sap/saptech2022/sapteched2022catalog/page/catalog/session/1661202714774001CAb1)

{#webinar-opensource}
## Webinar: Open Sourcing CAP

- [Find the recording in this collection of webinar replays.](https://webinars.sap.com/ospo-webinar-series/en/webinar-replays)
- [Slides](https://dam.sap.com/mac/app/p/pdf/asset/preview/4nU3QLx?ltr=a&rc=10)

## Community Call February 2022

- [Replay on YouTube](https://www.youtube.com/watch?v=OQVUkCs7mzY)
- [Slides](https://d.dam.sap.com/a/cKKne4Z/CAP_Call_20220224.pdf?rc=10)



# CAP License



## Where can I find the new CAP license?

Find here the [license text for the _SAP Developer License 3.2 CAP_.](https://cap.cloud.sap/resources/license/developer-license-3_2_CAP.txt)

> [!note] Quote
> “I am pleased that SAP has clarified the previous ambiguities in its license agreement. This enables us as SAP Partners to concentrate on the development of CAP-based SaaS and customer-specific applications without the need to engage in lengthy discussions regarding license agreements. Simultaneously, it provides our joint customers with the assurance that they will receive support when utilizing CAP as the engine for their customer-specific developments.”
>
>_Martin Stenzig, CEO, AlphaOak_

## tl;dr - Main Benefits and Changes

<div class="cols-2">

- [Productive Usage](#what-is-a-customer-productive-application)
- [Official SAP Support](#can-i-get-support-if-i-have-issues-with-cap)
- [Broader Platform Scope (incl. On-Premise)](#why-are-we-making-this-change)
- [No Impact on CAP's Open Source Strategy](#what-are-the-implications-on-the-cap-open-source-strategy)

<br>

- [Third-Party/Partner Enablement](#what-do-you-and-your-customer-mean)
- [Greater Interoperability](#what-are-the-implications-of-this-change-for-users-of-cap)
- [Continued Security Patching](#will-sap-provide-security-patches-to-previous-releases-under-the-original-sap-developer-license-3-1-3-2)
- [Clearer Guidance for Productive vs. Non-Productive Use](#what-is-a-customer-productive-application)


</div>

# FAQs

## What did we announce with CAP v9?

SAP SE announced a transition from the [_SAP Developer License 3.1_](https://tools.hana.ondemand.com/developer-license-3_1.txt) and [_SAP Developer License 3.2_](https://tools.hana.ondemand.com/developer-license-3_2.txt) to the [_SAP Developer License 3.2 CAP_](https://cap.cloud.sap/resources/license/developer-license-3_2_CAP.txt) for all releases of all CAP libraries that are not under the Apache License 2.0. The change applies from CAP v9 (released May 2025) and all subsequent releases.



## Why are we making this change?

The formerly used _SAP Developer License 3.1 / 3.2_ imposed strict rules on CAP users with respect to usage and customer support. By shifting to the _SAP Developer License 3.2 CAP_, SAP allows customers of SAP Business Technology Platform (BTP) or any other SAP platform to use CAP applications productively and to request support in line with their existing licensing agreement with SAP.



## Which parts of CAP are affected?

The updated license applies for all CAP components which are not published with an Open-Source license. The license applies to both CAP Java and CAP Node.js.

## What are the implications of this change for users of CAP?

Customers and partners and external developers in general are granted to create custom applications for productive use that are operated on BTP or any other platform licensed from SAP. In the _SAP Developer License 3.2 CAP_ those applications are called “Customer Productive Applications”. In setups that deviate from this, CAP shall only be used for testing purposes and/or non-productive use (called “Customer Test Applications”).

While the former _SAP Developer License 3.1 / 3.2_ limits mass data extraction from an SAP product to a non-SAP product, including use, modification, saving or other processing of such data in the non-SAP product, the new _SAP Developer License 3.2 CAP_ is defining an exception to the extent that the extraction is solely used for and required for interoperability with an SAP product. Allowing this, applications for e.g. product extensions are supported and interoperability of applications is enhanced.



## Who is impacted by this change?

All users of CAP are affected starting with CAP v9.

## What are the implications on the CAP Open Source strategy?

The change of CAP’s license model has **no implications on the CAP Open Source strategy**. Many CAP components and CAP plugins are already open source (mostly with Apache License 2.0) and the number will continue to grow.



## What is a _Customer Productive Application_?

The _SAP Developer License 3.2 CAP_ defines “Customer Applications”. These are in general applications developed using the CAP application programming interfaces, documentations, plugins, templates, scripts, sample code or tools. “Customer Test Applications” are for testing and non-productive use. Only if deployed and operated on BTP or any other platform licensed from SAP, productive usage is allowed and supported. These are the mentioned “Customer Productive Applications”.



## What do _You_ and _Your Customer_ mean?

Some places in the _SAP Developer License 3.2 CAP_ mention CAP users and their customers (“You and Your customers”) which should emphasize that we encourage third parties / partners to implement CAP applications for their customers as Customer Productive Applications (see [What is a Customer Productive Application](#what-is-a-customer-productive-application)).



## Can I get support if I have issues with CAP?

We offer support for Customer Productive Applications that are developed and made available by You in accordance with the _SAP Developer License 3.2 CAP_. You and third parties may request support in line with Your licensing agreement for SAP. All other users are referred to what is made available on the SAP Community Website by SAP at its sole discretion and by SAP Community members. For Open-Source CAP components under Apache License 2.0, the official GitHub support channels (GitHub issues) are available.



## Can I continue to use previous versions of CAP that were provided under the original _SAP Developer License 3.1 / 3.2_?

The license change is not retroactive. This means, all source code and releases prior to the change remain under the _SAP Developer License 3.1 / 3.2_. For using CAP applications in productive environments, we strongly recommend to upgrade though. Support for older CAP versions is limited to the CAP release and support strategy that is described in [CAP Release Schedule](../releases/schedule).



## Will SAP provide security patches to previous releases under the original _SAP Developer License 3.1 / 3.2_?

SAP will continue to patch critical security patches, as available, to existing versions under the _SAP Developer License 3.1 / 3.2_ for one year, as outlined in the [CAP Release Schedule](../releases/schedule). Any patches after that date will be provided under the new license only, because older CAP versions will fall out of maintenance then.


