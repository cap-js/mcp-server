import { test } from 'node:test'
import assert from 'node:assert'
import calculateEmbeddings from '../lib/embedding-lib.js'

test('compare calculateEmbeddings with HuggingFace on code-snippets.json', async () => {
  // Load HuggingFace pipeline
  const { pipeline } = await import('@huggingface/transformers')
  const hfPipeline = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2', {
    pooling: 'mean',
    normalize: true
  })

  // Code snippets embedded directly
  const codeSnippets = [
    {
      labels: ['installation', 'cds toolkit', 'npm', 'Node.js', 'CLI'],
      code: 'npm add -g @sap/cds-dk',
      type: 'shell',
      summary:
        "This command installs the @sap/cds-dk toolkit globally using npm. The toolkit provides the 'cds' command line interface required for SAP Cloud Application Programming Model (CAP) development.",
      source: ' Getting Started > Initial Setup > Installation'
    },
    {
      labels: ['installation', 'verify', 'cds CLI'],
      code: 'cds',
      type: 'shell',
      summary:
        "Running this command verifies that the 'cds' command line interface has been installed successfully. The output displays usage information and available commands for CAP projects.",
      source: ' Getting Started > Initial Setup > Installation'
    },
    {
      labels: ['init', 'project setup', 'cds CLI'],
      code: 'cds init bookshop',
      type: 'shell',
      summary:
        "Initializes a new CAP project named 'bookshop' with the required directory structure and configuration files. This is the entry point for starting CAP-based projects.",
      source: ' Getting Started > Starting Projects'
    },
    {
      labels: ['editor', 'VS Code', 'project open'],
      code: 'code bookshop',
      type: 'shell',
      summary:
        "Opens the newly initialized 'bookshop' CAP project in Visual Studio Code. Assumes you have set up the 'code' command for VS Code.",
      source: ' Getting Started > Starting Projects'
    },
    {
      labels: ['project structure', 'scaffolding'],
      code: "bookshop/        # Your project's root folder\n├─ app/          # UI-related content\n├─ srv/          # Service-related content\n├─ db/           # Domain models and database-related content\n├─ package.json  # Configuration for cds + cds-dk\n└─ readme.md     # A readme placeholder",
      type: 'shell',
      summary:
        "Shows the default folder structure of a CAP project generated by 'cds init'. Directories include app, srv, db, and configuration files like package.json and readme.md.",
      source: ' Getting Started > Project Structure'
    },
    {
      labels: ['configuration', 'package.json', 'custom project layout'],
      code: '{ ...\n  "cds": {\n    "folders": {\n       "db": "database/",\n       "srv": "services/",\n       "app": "uis/"\n    }\n  }\n}',
      type: 'json',
      summary:
        "This JSON snippet demonstrates how to override the default CAP project folder layout by specifying custom directories for db, srv, and app through the 'cds.folders' property in package.json.",
      source: ' Getting Started > Project Structure'
    },
    {
      labels: ['cds CLI', 'environment', 'defaults', 'list'],
      code: 'cds env ls defaults',
      type: 'shell',
      summary:
        'Lists the default environment configurations and directory structure used by cds in the current CAP project. Useful for exploring and understanding CAP project conventions.',
      source: ' Getting Started > Project Structure'
    },
    {
      labels: ['CLI', 'cds CLI', 'init', 'project setup', 'verify'],
      code: 'cds init\ncds watch',
      type: 'shell',
      summary:
        "These two shell commands are used to rapidly initialize and start a new CAP (Cloud Application Programming Model) project. 'cds init' scaffolds a minimalistic new project with default configuration, while 'cds watch' starts a server with live reload for fast development. Used to jumpstart CAP development by following the convention over configuration principle.",
      source: 'Jumpstart & Grow As You Go... > Jumpstarting Projects'
    },
    {
      labels: ['CLI', 'cds CLI', 'add', 'project setup', 'configuration', 'environment'],
      code: 'cds add hana,redis,mta,helm,mtx,multitenancy,extensibility...',
      type: 'shell',
      summary:
        'This shell command allows you to add features or integrations to a CAP project only as needed. Common options include database adapters (hana, redis), deployed artifact types (mta, helm), and capabilities like multitenancy or extensibility. This approach supports incremental project evolution and iterative workflow in CAP projects, avoiding premature decisions.',
      source: 'Jumpstart & Grow As You Go... > Growing as You Go...'
    },
    {
      labels: [
        'service definition',
        'srv/catalog-service.cds',
        'Books',
        'Orders',
        'projection',
        'authorization',
        'entities',
        'projection',
        'readonly',
        'insertonly'
      ],
      code: "using { my.domain as my } from './db/schema';\n\n/** Serves end users browsing books and place orders */\nservice CatalogService {\n  @readonly entity Books as select from my.Books {\n    ID, title, author.name as author\n  };\n  @requires: 'authenticated-user'\n  @insertonly entity Orders as projection on my.Orders;\n}",
      type: 'cds',
      summary:
        'Defines a CatalogService for browsing books and placing orders. The Books entity is exposed as readonly with selected fields, while Orders is exposed as insertonly for authenticated users. Each entity is projected from the domain model.',
      source: ' Best Practices > Single-Purposed Services > DO: One Service Per Use Case'
    },
    {
      labels: [
        'service definition',
        'srv/users-service.cds',
        'Orders',
        'projection',
        'authorization',
        'actions',
        'restrict',
        'readonly'
      ],
      code: "/** Serves registered users managing their account and their orders */\n@requires: 'authenticated-user'\nservice UsersService {\n  @restrict: [{ grant: 'READ', where: 'buyer = $user' }] // limit to own ones\n  @readonly entity Orders as projection on my.Orders;\n  action cancelOrder ( ID:Orders.ID, reason:String );\n}",
      type: 'cds',
      summary:
        "Defines a UsersService for registered users to manage their own orders. Only orders belonging to the authenticated user can be read, and an action 'cancelOrder' is provided to allow users to cancel their orders.",
      source: ' Best Practices > Single-Purposed Services > DO: One Service Per Use Case'
    },
    {
      labels: [
        'service definition',
        'srv/admin-service.cds',
        'Books',
        'Authors',
        'Orders',
        'projection',
        'authorization'
      ],
      code: "/** Serves administrators managing everything */\n@requires: 'authenticated-user'\nservice AdminService {\n  entity Books   as projection on my.Books;\n  entity Authors as projection on my.Authors;\n  entity Orders  as projection on my.Orders;\n}",
      type: 'cds',
      summary:
        'Defines an AdminService for administrators to manage all aspects of the application. The service exposes Books, Authors, and Orders entities as projections for full administrative access, restricted to authenticated users.',
      source: ' Best Practices > Single-Purposed Services > DO: One Service Per Use Case'
    },
    {
      labels: ['automatic transactions', 'db.read', 'Service-managed Transactions', 'cds CLI', 'SQL'],
      code: "await db.read('Books')",
      type: 'js',
      summary:
        "Example of an automatic transaction using CAP's db.read API in JavaScript. The CAP framework manages transaction boundaries automatically, including connection acquisition and release, so no explicit transaction code is needed.",
      source: ' Transaction Management > Automatic Transactions'
    },
    {
      labels: ['automatic transactions', 'SQL', 'connection pool'],
      code: '-- ACQUIRE connection from pool\nCONNECT; -- if no pooled one\nBEGIN;\nSELECT * from Books;\nCOMMIT;\n-- RELEASE connection to pool',
      type: 'sql',
      summary:
        "SQL-level representation of a transaction managed automatically by CAP when executing a db.read('Books') operation. Illustrates connection pooling, transaction begin/commit, and release.",
      source: ' Transaction Management > Automatic Transactions'
    },
    {
      labels: ['event handler', 'nested transactions', 'service-to-service calls'],
      code: "const log = cds.connect.to('log')\nconst db = cds.connect.to('db')\n\nBankingService.on ('transfer', req => {\n  let { from, to, amount } = req.data\n  await db.update('BankAccount',from).set('balance -=', amount),\n  await db.update('BankAccount',to).set('balance +=', amount),\n  await log.insert ({ kind:'Transfer', from, to, amount })\n})",
      type: 'js',
      summary:
        'Shows handling of nested transactions inside an event handler for a bank transfer scenario. CAP runtime manages a root transaction for the event and nested ones for DB and log service interactions.',
      source: ' Transaction Management > Nested Transactions'
    },
    {
      labels: ['manual transactions', 'cds.tx', 'transaction handling'],
      code: "cds.tx (async ()=>{\n  const [ Emily ] = await db.insert (Authors, {name:'Emily Brontë'})\n  await db.insert (Books, { title: 'Wuthering Heights', author: Emily })\n})",
      type: 'js',
      summary:
        'Manually starting and committing a transaction using cds.tx() to insert an author and a book in a single transactional context. CAP will handle commit/rollback for all operations within the supplied function.',
      source: ' Transaction Management > Manual Transactions'
    },
    {
      labels: ['background jobs', 'cds.spawn', 'async operations'],
      code: "cds.spawn ({ user: cds.User.privileged, every: 1000 /* ms */ }, async ()=>{\n  const mails = await SELECT.from('Outbox')\n  await MailServer.send(mails)\n  await DELETE.from('Outbox').where (`ID in ${mails.map(m => m.ID)}`)\n})",
      type: 'js',
      summary:
        'Creates a background job using cds.spawn() to process outbox mails periodically under a privileged user. Each run executes in a fresh transaction, independent of the main event context.',
      source: ' Transaction Management > Background Jobs'
    },
    {
      labels: ['context', 'cds.context', 'user', 'tenant'],
      code: "const { user } = cds.context\nif (user.is('admin')) ...",
      type: 'js',
      summary:
        'Accesses the current user from cds.context to check for admin role. Demonstrates accessing runtime event context for authorization and logic branching.',
      source: ' Transaction Management > cds. context {event-contexts .property} > Accessing Context'
    },
    {
      labels: ['context', 'cds.context', 'http', 'request', 'response'],
      code: "const { req, res } = cds.context.http\nif (!req.is('application/json')) res.send(415)",
      type: 'js',
      summary:
        'Shows how to access HTTP request and response objects from cds.context in CAP. Can be used for content negotiation and protocol-level handling within service operations or handlers.',
      source: ' Transaction Management > cds. context {event-contexts .property} > Accessing Context'
    },
    {
      labels: ['context', 'cds.context', 'middleware', 'custom authentication'],
      code: "app.use ((req, res, next) => {\n  const { 'x-tenant':tenant, 'x-user-id':user } = req.headers\n  cds.context = { tenant, user } // Setting cds.context\n  next()\n})",
      type: 'js',
      summary:
        'Example of custom Express middleware that sets cds.context based on incoming HTTP headers for tenant and user. Used for custom authentication or context propagation in CAP applications.',
      source: ' Transaction Management > cds. context {event-contexts .property} > Setting Contexts'
    },
    {
      labels: ['context propagation', 'transaction context', 'cds.tx', 'user', 'tenant'],
      code: "cds.context = { tenant:'t1', user:'u1' }\ncds.context.user.id === 'u1'          //> true\nlet tx = cds.tx({ user:'u2' })\ntx.context !== cds.context            //> true\ntx.context.tenant === 't1'            //> true\ntx.context.user.id === 'u2'           //> true\ntx.context.user !== cds.context.user  //> true\ncds.context.user.id === 'u1'          //> true",
      type: 'js',
      summary:
        'Illustrates how a new transaction context inherits properties from cds.context, and how you can override some (like user) while maintaining others (like tenant). Shows transaction and context independence.',
      source: ' Transaction Management > cds. context {event-contexts .property} > Context Propagation'
    },
    {
      labels: ['cds.tx', 'srv.tx', 'method signature', 'service', 'transaction'],
      code: 'function srv.tx ( ctx?, fn? : tx<srv> => {...} ) => Promise\nfunction srv.tx ( ctx? ) => tx<srv>\nvar ctx : { tenant, user, locale }',
      type: 'ts',
      summary:
        "TypeScript signatures for CAP's srv.tx method showing function overloads for starting transactions manually and optionally providing a context and/or a function to execute transactional code.",
      source: ' Transaction Management > cds/srv. tx() {srv-tx .method}'
    },
    {
      labels: ['srv.tx', 'manual transaction', 'transaction object', 'commit', 'rollback'],
      code: 'const tx = srv.tx()\ntry {\n  let exists = await tx.run ( SELECT(1).from(Books,201).forUpdate() )\n  if (exists) await tx.update (Books,201).with(data)\n  else await tx.create (Books,{ ID:201,...data })\n  await tx.commit()\n} catch(e) {\n  await tx.rollback(e)\n}',
      type: 'js',
      summary:
        'Manual transaction management with srv.tx(): creates a transaction object used to run several queries, with explicit commit/rollback handling.',
      source: ' Transaction Management > cds/srv. tx() {srv-tx .method}'
    },
    {
      labels: ['srv.tx', 'db.tx', 'manual transaction', 'commit', 'rollback', 'Service API'],
      code: "let db = await cds.connect.to('db')\nlet tx = db.tx()\ntry {\n  await tx.run (SELECT.from(Foo))\n  await tx.create (Foo, {...})\n  await tx.read (Foo)\n  await tx.commit()\n} catch(e) {\n  await tx.rollback(e)\n}",
      type: 'js',
      summary:
        'Starts a manual transaction on a database service, executes multiple operations, and manages commit/rollback explicitly. Demonstrates proper lifecycle management for transactions outside of event handlers.',
      source: ' Transaction Management > cds/srv. tx() {srv-tx .method} > srv.tx  <i>  (context?, fn?) → tx<srv> </i>'
    },
    {
      labels: ['srv.tx', 'context', 'user', 'tenant'],
      code: "let tx = db.tx ({ tenant:'t1' user:'u2' })",
      type: 'js',
      summary:
        'Creates a new transaction (tx) on the database service with a specific tenant and user context, overriding any ambient context.',
      source:
        ' Transaction Management > cds/srv. tx() {srv-tx .method} > srv.tx  <i>  ({ tenant?, user?, ... }) → tx<srv> </i> {srv-tx-ctx}'
    },
    {
      labels: ['srv.tx', 'function callback', 'auto commit', 'auto rollback'],
      code: 'await db.tx (async tx => {\n  await tx.run (SELECT.from(Foo))\n  await tx.create (Foo, {...})\n  await tx.read (Foo)\n})',
      type: 'js',
      summary:
        "Runs a transaction using db.tx with an async function argument: automatically commits if the function completes, or rolls back if there's an error.",
      source:
        ' Transaction Management > cds/srv. tx() {srv-tx .method} > srv.tx  <i>  ((tx)=>{...}) → tx<srv> </i> {srv-tx-fn}'
    },
    {
      labels: ['srv.tx', 'manual transaction', 'commit', 'rollback'],
      code: 'let tx = db.tx()\ntry {\n  await tx.run (SELECT.from(Foo))\n  await tx.create (Foo, {...})\n  await tx.read (Foo)\n  await tx.commit()\n} catch(e) {\n  await tx.rollback(e)\n}',
      type: 'js',
      summary:
        'Equivalent manual transaction management using db.tx: explicit try/catch with commit/rollback, functionally similar to the auto-commit variant but with more control over error handling.',
      source:
        ' Transaction Management > cds/srv. tx() {srv-tx .method} > srv.tx  <i>  ((tx)=>{...}) → tx<srv> </i> {srv-tx-fn}'
    },
    {
      labels: ['cds.tx', 'context', 'nested transaction', 'root transaction'],
      code: "cds.context = { tenant:'t1', user:'u2' }\nconst tx = cds.tx (cds.context)\n//> tx is a new root transaction",
      type: 'js',
      summary:
        'Creates a new root transaction with CDS, inheriting context properties from cds.context. Useful for performing work under explicit context.',
      source:
        ' Transaction Management > cds/srv. tx() {srv-tx .method} > srv.tx  <i>  (ctx) → tx<srv> </i> {srv-tx-context}'
    },
    {
      labels: ['cds.tx', 'nested transaction', 'context propagation'],
      code: "const tx = cds.context = cds.tx ({ tenant:'t1', user:'u2' })\nconst tx1 = cds.tx (cds.context)\n//> tx1 is a new nested transaction to tx",
      type: 'js',
      summary:
        'Demonstrates creating a nested transaction with explicit event context. Shows how nested transactions are created and how context is handled.',
      source:
        ' Transaction Management > cds/srv. tx() {srv-tx .method} > srv.tx  <i>  (ctx) → tx<srv> </i> {srv-tx-context}'
    },
    {
      labels: ['transaction object', 'commit', 'rollback', 'promise chaining'],
      code: 'let tx = cds.tx()\ntx.run(...) .then (tx.commit, tx.rollback)',
      type: 'js',
      summary:
        'Shows use of promise chaining for commit and rollback methods on a transaction object (tx), which are both bound to the transaction instance and return or propagate their argument.',
      source:
        ' Transaction Management > cds/srv. tx() {srv-tx .method} > _↳_ <span>tx</span>.commit  <i>  (res?) ⇢ res </i> {commit }'
    }
  ]

  // Pre-warm our embeddings model
  await calculateEmbeddings('initialization test')

  // Test all 30 snippets
  const sampleSnippets = codeSnippets

  const similarities = []

  for (const snippet of sampleSnippets) {
    // Format the snippet text
    const text = `${snippet.source}\n${snippet.labels.join(', ')}\n${snippet.summary}\n\n\`\`\`${snippet.type}\n${snippet.code}\n\`\`\`\n`

    // Get embeddings from both implementations
    const ourEmbedding = await calculateEmbeddings(text)
    const hfResult = await hfPipeline(text, { pooling: 'mean', normalize: true })

    // Extract HuggingFace embedding
    let hfEmbedding = hfResult
    if (hfResult && typeof hfResult.data !== 'undefined') {
      hfEmbedding = hfResult.data
    } else if (Array.isArray(hfResult)) {
      hfEmbedding = Array.isArray(hfResult[0]) ? hfResult[0] : hfResult
    }

    // Verify dimensions match
    assert.strictEqual(ourEmbedding.length, hfEmbedding.length, 'Embedding dimensions should match')
    assert.strictEqual(ourEmbedding.length, 384, 'Should be 384-dimensional')

    // Calculate cosine similarity
    let similarity = 0
    for (let i = 0; i < ourEmbedding.length; i++) {
      similarity += ourEmbedding[i] * hfEmbedding[i]
    }

    similarities.push(similarity)
  }

  // Calculate average similarity
  const avgSimilarity = similarities.reduce((sum, s) => sum + s, 0) / similarities.length

  // Assert reasonable similarity (should be > 0.9 since they're the same model)
  assert(avgSimilarity > 0.9, `Average similarity should be > 0.9, got ${avgSimilarity.toFixed(4)}`)

  // Assert all similarities are in valid range (allow slight floating point error)
  for (const sim of similarities) {
    assert(sim >= -1.001 && sim <= 1.001, `Similarity should be in range [-1, 1], got ${sim}`)
  }
})
